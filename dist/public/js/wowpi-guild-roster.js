/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/datatables.net/js/jquery.dataTables.js":
/*!*************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.22
 * Â©2008-2020 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.22
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2020 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */

/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
(function (factory) {
  "use strict";

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
      return factory($, window, document);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($, window, document, undefined) {
  "use strict";
  /**
   * DataTables is a plug-in for the jQuery Javascript library. It is a highly
   * flexible tool, based upon the foundations of progressive enhancement,
   * which will add advanced interaction controls to any HTML table. For a
   * full list of features please refer to
   * [DataTables.net](href="http://datatables.net).
   *
   * Note that the `DataTable` object is not a global variable but is aliased
   * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
   * be  accessed.
   *
   *  @class
   *  @param {object} [init={}] Configuration object for DataTables. Options
   *    are defined by {@link DataTable.defaults}
   *  @requires jQuery 1.7+
   *
   *  @example
   *    // Basic initialisation
   *    $(document).ready( function {
   *      $('#example').dataTable();
   *    } );
   *
   *  @example
   *    // Initialisation with configuration options - in this case, disable
   *    // pagination and sorting.
   *    $(document).ready( function {
   *      $('#example').dataTable( {
   *        "paginate": false,
   *        "sort": false
   *      } );
   *    } );
   */

  var DataTable = function (options) {
    /**
     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
     * return the resulting jQuery object.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     *    criterion ("applied") or all TR elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {object} jQuery object, filtered by the given selector.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Highlight every second row
     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to rows with 'Webkit' in them, add a background colour and then
     *      // remove the filter, thus highlighting the 'Webkit' rows only.
     *      oTable.fnFilter('Webkit');
     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
     *      oTable.fnFilter('');
     *    } );
     */
    this.$ = function (sSelector, oOpts) {
      return this.api(true).$(sSelector, oOpts);
    };
    /**
     * Almost identical to $ in operation, but in this case returns the data for the matched
     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
     * rather than any descendants, so the data can be obtained for the row/cell. If matching
     * rows are found, the data returned is the original data array/object that was used to
     * create the row (or a generated array if from a DOM source).
     *
     * This method is often useful in-combination with $ where both functions are given the
     * same parameters and the array indexes will match identically.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
     *    criterion ("applied") or all elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {array} Data for the matched elements. If any elements, as a result of the
     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
     *    entry in the array.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the data from the first row in the table
     *      var data = oTable._('tr:first');
     *
     *      // Do something useful with the data
     *      alert( "First cell is: "+data[0] );
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to 'Webkit' and get all data for
     *      oTable.fnFilter('Webkit');
     *      var data = oTable._('tr', {"search": "applied"});
     *
     *      // Do something with the data
     *      alert( data.length+" rows matched the search" );
     *    } );
     */


    this._ = function (sSelector, oOpts) {
      return this.api(true).rows(sSelector, oOpts).data();
    };
    /**
     * Create a DataTables Api instance, with the currently selected tables for
     * the Api's context.
     * @param {boolean} [traditional=false] Set the API instance's context to be
     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
     *   or if all tables captured in the jQuery object should be used.
     * @return {DataTables.Api}
     */


    this.api = function (traditional) {
      return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this);
    };
    /**
     * Add a single new row or multiple rows of data to the table. Please note
     * that this is suitable for client-side processing only - if you are using
     * server-side processing (i.e. "bServerSide": true), then to add data, you
     * must add it to the data source, i.e. the server-side, through an Ajax call.
     *  @param {array|object} data The data to be added to the table. This can be:
     *    <ul>
     *      <li>1D array of data - add a single row with the data provided</li>
     *      <li>2D array of arrays - add multiple rows in a single call</li>
     *      <li>object - data object when using <i>mData</i></li>
     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
     *    </ul>
     *  @param {bool} [redraw=true] redraw the table or not
     *  @returns {array} An array of integers, representing the list of indexes in
     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
     *    the table.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Global var for counter
     *    var giCount = 2;
     *
     *    $(document).ready(function() {
     *      $('#example').dataTable();
     *    } );
     *
     *    function fnClickAddRow() {
     *      $('#example').dataTable().fnAddData( [
     *        giCount+".1",
     *        giCount+".2",
     *        giCount+".3",
     *        giCount+".4" ]
     *      );
     *
     *      giCount++;
     *    }
     */


    this.fnAddData = function (data, redraw) {
      var api = this.api(true);
      /* Check if we want to add multiple rows or not */

      var rows = Array.isArray(data) && (Array.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);

      if (redraw === undefined || redraw) {
        api.draw();
      }

      return rows.flatten().toArray();
    };
    /**
     * This function will make DataTables recalculate the column sizes, based on the data
     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
     * through the sWidth parameter). This can be useful when the width of the table's
     * parent element changes (for example a window resize).
     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable( {
     *        "sScrollY": "200px",
     *        "bPaginate": false
     *      } );
     *
     *      $(window).on('resize', function () {
     *        oTable.fnAdjustColumnSizing();
     *      } );
     *    } );
     */


    this.fnAdjustColumnSizing = function (bRedraw) {
      var api = this.api(true).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;

      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      } else if (scroll.sX !== "" || scroll.sY !== "") {
        /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
        _fnScrollDraw(settings);
      }
    };
    /**
     * Quickly and simply clear a table
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
     *      oTable.fnClearTable();
     *    } );
     */


    this.fnClearTable = function (bRedraw) {
      var api = this.api(true).clear();

      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }
    };
    /**
     * The exact opposite of 'opening' a row, this function will close any rows which
     * are currently 'open'.
     *  @param {node} nTr the table row to 'close'
     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnClose = function (nTr) {
      this.api(true).row(nTr).child.hide();
    };
    /**
     * Remove a row for the table
     *  @param {mixed} target The index of the row from aoData to be deleted, or
     *    the TR element you want to delete
     *  @param {function|null} [callBack] Callback function
     *  @param {bool} [redraw=true] Redraw the table or not
     *  @returns {array} The row that was deleted
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately remove the first row
     *      oTable.fnDeleteRow( 0 );
     *    } );
     */


    this.fnDeleteRow = function (target, callback, redraw) {
      var api = this.api(true);
      var rows = api.rows(target);
      var settings = rows.settings()[0];
      var data = settings.aoData[rows[0][0]];
      rows.remove();

      if (callback) {
        callback.call(this, settings, data);
      }

      if (redraw === undefined || redraw) {
        api.draw();
      }

      return data;
    };
    /**
     * Restore the table to it's original state in the DOM by removing all of DataTables
     * enhancements, alterations to the DOM structure of the table and event listeners.
     *  @param {boolean} [remove=false] Completely remove the table from the DOM
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
     *      var oTable = $('#example').dataTable();
     *      oTable.fnDestroy();
     *    } );
     */


    this.fnDestroy = function (remove) {
      this.api(true).destroy(remove);
    };
    /**
     * Redraw the table
     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
     *      oTable.fnDraw();
     *    } );
     */


    this.fnDraw = function (complete) {
      // Note that this isn't an exact match to the old call to _fnDraw - it takes
      // into account the new data, but can hold position.
      this.api(true).draw(complete);
    };
    /**
     * Filter the input based on data
     *  @param {string} sInput String to filter the table on
     *  @param {int|null} [iColumn] Column to limit filtering to
     *  @param {bool} [bRegex=false] Treat as regular expression or not
     *  @param {bool} [bSmart=true] Perform smart filtering or not
     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sometime later - filter...
     *      oTable.fnFilter( 'test string' );
     *    } );
     */


    this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
      var api = this.api(true);

      if (iColumn === null || iColumn === undefined) {
        api.search(sInput, bRegex, bSmart, bCaseInsensitive);
      } else {
        api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
      }

      api.draw();
    };
    /**
     * Get the data for the whole table, an individual row or an individual cell based on the
     * provided parameters.
     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
     *    a TR node then the data source for the whole row will be returned. If given as a
     *    TD/TH cell node then iCol will be automatically calculated and the data for the
     *    cell returned. If given as an integer, then this is treated as the aoData internal
     *    data index for the row (see fnGetPosition) and the data for that row used.
     *  @param {int} [col] Optional column index that you want the data of.
     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
     *    returned. If mRow is defined, just data for that row, and is iCol is
     *    defined, only data for the designated cell is returned.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Row data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('tr').click( function () {
     *        var data = oTable.fnGetData( this );
     *        // ... do something with the array / object of data for the row
     *      } );
     *    } );
     *
     *  @example
     *    // Individual cell data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('td').click( function () {
     *        var sData = oTable.fnGetData( this );
     *        alert( 'The cell clicked on had the value of '+sData );
     *      } );
     *    } );
     */


    this.fnGetData = function (src, col) {
      var api = this.api(true);

      if (src !== undefined) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : '';
        return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
      }

      return api.data().toArray();
    };
    /**
     * Get an array of the TR nodes that are used in the table's body. Note that you will
     * typically want to use the '$' API method in preference to this as it is more
     * flexible.
     *  @param {int} [iRow] Optional row index for the TR element you want
     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
     *    in the table's body, or iRow is defined, just the TR element requested.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the nodes from the table
     *      var nNodes = oTable.fnGetNodes( );
     *    } );
     */


    this.fnGetNodes = function (iRow) {
      var api = this.api(true);
      return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
    };
    /**
     * Get the array indexes of a particular cell from it's DOM element
     * and column index including hidden columns
     *  @param {node} node this can either be a TR, TD or TH in the table's body
     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
     *    if given as a cell, an array of [row index, column index (visible),
     *    column index (all)] is given.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      $('#example tbody td').click( function () {
     *        // Get the position of the current data from the node
     *        var aPos = oTable.fnGetPosition( this );
     *
     *        // Get the data array for this row
     *        var aData = oTable.fnGetData( aPos[0] );
     *
     *        // Update the data array and return the value
     *        aData[ aPos[1] ] = 'clicked';
     *        this.innerHTML = 'clicked';
     *      } );
     *
     *      // Init DataTables
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnGetPosition = function (node) {
      var api = this.api(true);
      var nodeName = node.nodeName.toUpperCase();

      if (nodeName == 'TR') {
        return api.row(node).index();
      } else if (nodeName == 'TD' || nodeName == 'TH') {
        var cell = api.cell(node).index();
        return [cell.row, cell.columnVisible, cell.column];
      }

      return null;
    };
    /**
     * Check to see if a row is 'open' or not.
     *  @param {node} nTr the table row to check
     *  @returns {boolean} true if the row is currently open, false otherwise
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnIsOpen = function (nTr) {
      return this.api(true).row(nTr).child.isShown();
    };
    /**
     * This function will place a new row directly after a row which is currently
     * on display on the page, with the HTML contents that is passed into the
     * function. This can be used, for example, to ask for confirmation that a
     * particular record should be deleted.
     *  @param {node} nTr The table row to 'open'
     *  @param {string|node|jQuery} mHtml The HTML to put into the row
     *  @param {string} sClass Class to give the new TD cell
     *  @returns {node} The row opened. Note that if the table row passed in as the
     *    first parameter, is not found in the table, this method will silently
     *    return.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnOpen = function (nTr, mHtml, sClass) {
      return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
    };
    /**
     * Change the pagination - provides the internal logic for pagination in a simple API
     * function. With this function you can have a DataTables table go to the next,
     * previous, first or last pages.
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer), note that page 0 is the first page.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnPageChange( 'next' );
     *    } );
     */


    this.fnPageChange = function (mAction, bRedraw) {
      var api = this.api(true).page(mAction);

      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      }
    };
    /**
     * Show a particular column
     *  @param {int} iCol The column whose display should be changed
     *  @param {bool} bShow Show (true) or hide (false) the column
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Hide the second column after initialisation
     *      oTable.fnSetColumnVis( 1, false );
     *    } );
     */


    this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
      var api = this.api(true).column(iCol).visible(bShow);

      if (bRedraw === undefined || bRedraw) {
        api.columns.adjust().draw();
      }
    };
    /**
     * Get the settings for a particular table for external manipulation
     *  @returns {object} DataTables settings object. See
     *    {@link DataTable.models.oSettings}
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      var oSettings = oTable.fnSettings();
     *
     *      // Show an example parameter from the settings
     *      alert( oSettings._iDisplayStart );
     *    } );
     */


    this.fnSettings = function () {
      return _fnSettingsFromNode(this[_ext.iApiIndex]);
    };
    /**
     * Sort the table by a particular column
     *  @param {int} iCol the data index to sort on. Note that this will not match the
     *    'display index' if you have hidden data entries
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort immediately with columns 0 and 1
     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
     *    } );
     */


    this.fnSort = function (aaSort) {
      this.api(true).order(aaSort).draw();
    };
    /**
     * Attach a sort listener to an element for a given column
     *  @param {node} nNode the element to attach the sort listener to
     *  @param {int} iColumn the column that a click on this node will sort on
     *  @param {function} [fnCallback] callback function when sort is run
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort on column 1, when 'sorter' is clicked on
     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
     *    } );
     */


    this.fnSortListener = function (nNode, iColumn, fnCallback) {
      this.api(true).order.listener(nNode, iColumn, fnCallback);
    };
    /**
     * Update a table cell or row - this method will accept either a single value to
     * update the cell with, an array of values with one element for each column or
     * an object in the same format as the original data source. The function is
     * self-referencing in order to make the multi column updates easier.
     *  @param {object|array|string} mData Data to update the cell/row with
     *  @param {node|int} mRow TR element you want to update or the aoData index
     *  @param {int} [iColumn] The column to update, give as null or undefined to
     *    update a whole row.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @param {bool} [bAction=true] Perform pre-draw actions or not
     *  @returns {int} 0 on success, 1 on error
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
     *    } );
     */


    this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
      var api = this.api(true);

      if (iColumn === undefined || iColumn === null) {
        api.row(mRow).data(mData);
      } else {
        api.cell(mRow, iColumn).data(mData);
      }

      if (bAction === undefined || bAction) {
        api.columns.adjust();
      }

      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }

      return 0;
    };
    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @method
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
     *    } );
     */


    this.fnVersionCheck = _ext.fnVersionCheck;

    var _that = this;

    var emptyInit = options === undefined;
    var len = this.length;

    if (emptyInit) {
      options = {};
    }

    this.oApi = this.internal = _ext.internal; // Extend with old style plug-in API methods

    for (var fn in DataTable.ext.internal) {
      if (fn) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }

    this.each(function () {
      // For each initialisation we want to give it a clean initialisation
      // object that can be bashed around
      var o = {};
      var oInit = len > 1 ? // optimisation for single table case
      _fnExtend(o, options, true) : options;
      /*global oInit,_that,emptyInit*/

      var i = 0,
          iLen,
          j,
          jLen,
          k,
          kLen;
      var sId = this.getAttribute('id');
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $(this);
      /* Sanity check */

      if (this.nodeName.toLowerCase() != 'table') {
        _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);

        return;
      }
      /* Backwards compatibility for the defaults */


      _fnCompatOpts(defaults);

      _fnCompatCols(defaults.column);
      /* Convert the camel-case defaults to Hungarian */


      _fnCamelToHungarian(defaults, defaults, true);

      _fnCamelToHungarian(defaults.column, defaults.column, true);
      /* Setting up the initialisation object */


      _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()), true);
      /* Check to see if we are re-initialising a table */


      var allSettings = DataTable.settings;

      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        /* Base check on table node */

        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            s.oInstance.fnDestroy();
            break;
          } else {
            _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);

            return;
          }
        }
        /* If the element we are initialising has the same ID as a table which was previously
         * initialised, but the table nodes don't match (from before) then we destroy the old
         * instance by simply deleting it. This is under the assumption that the table has been
         * destroyed by other methods. Anyone using non-id selectors will need to do this manually
         */


        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      /* Ensure the table has an ID - required for accessibility */


      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      /* Create the settings object for this table and set some of the default parameters */


      var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId
      });
      oSettings.nTable = this;
      oSettings.oApi = _that.internal;
      oSettings.oInit = oInit;
      allSettings.push(oSettings); // Need to add the instance after the instance after the settings object has been added
      // to the settings array, so we can self reference the table instance if more than one

      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable(); // Backwards compatibility, before we apply all the defaults

      _fnCompatOpts(oInit);

      _fnLanguageCompat(oInit.oLanguage); // If the length menu is given, but the init display length is not, use the length menu


      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      } // Apply the defaults and init options to make a single init object will all
      // options defined from defaults and instance options.


      oInit = _fnExtend($.extend(true, {}, defaults), oInit); // Map the initialisation options onto the settings object

      _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);

      _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"], // backwards compat
      ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"]]);

      _fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);

      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      /* Callback functions which are array driven */


      _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');

      _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');

      _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');

      _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');

      _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');

      _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');

      _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');

      _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      /* Browser support detection */

      _fnBrowserDetect(oSettings);

      var oClasses = oSettings.oClasses;
      $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.sTable);

      if (oSettings.iInitDisplayStart === undefined) {
        /* Display start point, taking into account the save saving */
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }

      if (oInit.iDeferLoading !== null) {
        oSettings.bDeferLoading = true;
        var tmp = Array.isArray(oInit.iDeferLoading);
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      /* Language definitions */


      var oLanguage = oSettings.oLanguage;
      $.extend(true, oLanguage, oInit.oLanguage);

      if (oLanguage.sUrl) {
        /* Get the language definitions from a file - because this Ajax call makes the language
         * get async to the remainder of this function we use bInitHandedOff to indicate that
         * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
         */
        $.ajax({
          dataType: 'json',
          url: oLanguage.sUrl,
          success: function (json) {
            _fnLanguageCompat(json);

            _fnCamelToHungarian(defaults.oLanguage, json);

            $.extend(true, oLanguage, json);

            _fnInitialise(oSettings);
          },
          error: function () {
            // Error occurred loading language file, continue on as best we can
            _fnInitialise(oSettings);
          }
        });
        bInitHandedOff = true;
      }
      /*
       * Stripes
       */


      if (oInit.asStripeClasses === null) {
        oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
      }
      /* Remove row stripe classes if they are already on the table row */


      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children('tbody').find('tr').eq(0);

      if ($.inArray(true, $.map(stripeClasses, function (el, i) {
        return rowOne.hasClass(el);
      })) !== -1) {
        $('tbody tr', this).removeClass(stripeClasses.join(' '));
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      /*
       * Columns
       * See if we should load columns automatically or use defined ones
       */


      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName('thead');

      if (nThead.length !== 0) {
        _fnDetectHeader(oSettings.aoHeader, nThead[0]);

        anThs = _fnGetUniqueThs(oSettings);
      }
      /* If not given a column array, generate one with nulls */


      if (oInit.aoColumns === null) {
        aoColumnsInit = [];

        for (i = 0, iLen = anThs.length; i < iLen; i++) {
          aoColumnsInit.push(null);
        }
      } else {
        aoColumnsInit = oInit.aoColumns;
      }
      /* Add the columns */


      for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
        _fnAddColumn(oSettings, anThs ? anThs[i] : null);
      }
      /* Apply the column definitions */


      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      /* HTML5 attribute detection - build an mData object automatically if the
       * attributes are found
       */


      if (rowOne.length) {
        var a = function (cell, name) {
          return cell.getAttribute('data-' + name) !== null ? name : null;
        };

        $(rowOne[0]).children('th, td').each(function (i, cell) {
          var col = oSettings.aoColumns[i];

          if (col.mData === i) {
            var sort = a(cell, 'sort') || a(cell, 'order');
            var filter = a(cell, 'filter') || a(cell, 'search');

            if (sort !== null || filter !== null) {
              col.mData = {
                _: i + '.display',
                sort: sort !== null ? i + '.@data-' + sort : undefined,
                type: sort !== null ? i + '.@data-' + sort : undefined,
                filter: filter !== null ? i + '.@data-' + filter : undefined
              };

              _fnColumnOptions(oSettings, i);
            }
          }
        });
      }

      var features = oSettings.oFeatures;

      var loadedInit = function () {
        /*
         * Sorting
         * @todo For modularisation (1.11) this needs to do into a sort start up handler
         */
        // If aaSorting is not defined, then we use the first indicator in asSorting
        // in case that has been altered, so the default sort reflects that option
        if (oInit.aaSorting === undefined) {
          var sorting = oSettings.aaSorting;

          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        /* Do a first pass on the sorting classes (allows any size changes to be taken into
         * account, and also will apply sorting disabled classes if disabled
         */


        _fnSortingClasses(oSettings);

        if (features.bSort) {
          _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);

              var sortedColumns = {};
              $.each(aSort, function (i, val) {
                sortedColumns[val.src] = val.dir;
              });

              _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);

              _fnSortAria(oSettings);
            }
          });
        }

        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
          if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, 'sc');
        /*
         * Final init
         * Cache the header, body and footer as required, creating them if needed
         */
        // Work around for Webkit bug 83867 - store the caption-side before removing from doc


        var captions = $this.children('caption').each(function () {
          this._captionSide = $(this).css('caption-side');
        });
        var thead = $this.children('thead');

        if (thead.length === 0) {
          thead = $('<thead/>').appendTo($this);
        }

        oSettings.nTHead = thead[0];
        var tbody = $this.children('tbody');

        if (tbody.length === 0) {
          tbody = $('<tbody/>').appendTo($this);
        }

        oSettings.nTBody = tbody[0];
        var tfoot = $this.children('tfoot');

        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
          // If we are a scrolling table, and no footer has been given, then we need to create
          // a tfoot element for the caption element to be appended to
          tfoot = $('<tfoot/>').appendTo($this);
        }

        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];

          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        /* Check if there is data passing into the constructor */


        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData(oSettings, oInit.aaData[i]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
          /* Grab the data from the page - only do this when deferred loading or no Ajax
           * source since there is no point in reading the DOM data if we are then going
           * to replace it with Ajax data
           */
          _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
        }
        /* Copy the data index array */


        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        /* Initialisation complete - table can be drawn */

        oSettings.bInitialised = true;
        /* Check if we need to initialise the table (it might not have been handed off to the
         * language processor)
         */

        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      };
      /* Must be done after everything which can be overridden by the state saving! */


      if (oInit.bStateSave) {
        features.bStateSave = true;

        _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');

        _fnLoadState(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  /*
   * It is useful to have variables which are scoped locally so only the
   * DataTables functions can access them and they don't leak into global space.
   * At the same time these functions are often useful over multiple files in the
   * core and API, so we list, or at least document, all variables which are used
   * by DataTables as private variables here. This also ensures that there is no
   * clashing of variable names and that they can easily referenced for reuse.
   */
  // Defined else where
  //  _selector_run
  //  _selector_opts
  //  _selector_first
  //  _selector_row_indexes


  var _ext; // DataTable.ext


  var _Api; // DataTable.Api


  var _api_register; // DataTable.Api.register


  var _api_registerPlural; // DataTable.Api.registerPlural


  var _re_dic = {};
  var _re_new_lines = /[\r\n\u2028]/g;
  var _re_html = /<.*?>/g; // This is not strict ISO8601 - Date.parse() is quite lax, although
  // implementations differ between browsers.

  var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/; // Escape regular expression special characters

  var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g'); // http://en.wikipedia.org/wiki/Foreign_exchange_market
  // - \u20BD - Russian ruble.
  // - \u20a9 - South Korean Won
  // - \u20BA - Turkish Lira
  // - \u20B9 - Indian Rupee
  // - R - Brazil (R$) and South Africa
  // - fr - Swiss Franc
  // - kr - Swedish krona, Norwegian krone and Danish krone
  // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
  // - É - Bitcoin
  // - Î - Ethereum
  //   standards as thousands separators.


  var _re_formatted_numeric = /['\u00A0,$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfkÉÎ]/gi;

  var _empty = function (d) {
    return !d || d === true || d === '-' ? true : false;
  };

  var _intVal = function (s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  }; // Convert from a formatted number with characters other than `.` as the
  // decimal place, to a Javascript number


  var _numToDecimal = function (num, decimalPoint) {
    // Cache created regular expressions for speed as this function is called often
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
    }

    return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
  };

  var _isNumber = function (d, decimalPoint, formatted) {
    var strType = typeof d === 'string'; // If empty return immediately so there must be a number if it is a
    // formatted string (this stops the string "k", or "kr", etc being detected
    // as a formatted number for currency

    if (_empty(d)) {
      return true;
    }

    if (decimalPoint && strType) {
      d = _numToDecimal(d, decimalPoint);
    }

    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric, '');
    }

    return !isNaN(parseFloat(d)) && isFinite(d);
  }; // A string without HTML in it can be considered to be HTML still


  var _isHtml = function (d) {
    return _empty(d) || typeof d === 'string';
  };

  var _htmlNumeric = function (d, decimalPoint, formatted) {
    if (_empty(d)) {
      return true;
    }

    var html = _isHtml(d);

    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
  };

  var _pluck = function (a, prop, prop2) {
    var out = [];
    var i = 0,
        ien = a.length; // Could have the test in the loop for slightly smaller code, but speed
    // is essential here

    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }

    return out;
  }; // Basically the same as _pluck, but rather than looping over `a` we use `order`
  // as the indexes to pick from `a`


  var _pluck_order = function (a, order, prop, prop2) {
    var out = [];
    var i = 0,
        ien = order.length; // Could have the test in the loop for slightly smaller code, but speed
    // is essential here

    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        out.push(a[order[i]][prop]);
      }
    }

    return out;
  };

  var _range = function (len, start) {
    var out = [];
    var end;

    if (start === undefined) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }

    for (var i = start; i < end; i++) {
      out.push(i);
    }

    return out;
  };

  var _removeEmpty = function (a) {
    var out = [];

    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        // careful - will remove all falsy values!
        out.push(a[i]);
      }
    }

    return out;
  };

  var _stripHtml = function (d) {
    return d.replace(_re_html, '');
  };
  /**
   * Determine if all values in the array are unique. This means we can short
   * cut the _unique method at the cost of a single loop. A sorted array is used
   * to easily check the values.
   *
   * @param  {array} src Source array
   * @return {boolean} true if all unique, false otherwise
   * @ignore
   */


  var _areAllUnique = function (src) {
    if (src.length < 2) {
      return true;
    }

    var sorted = src.slice().sort();
    var last = sorted[0];

    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }

      last = sorted[i];
    }

    return true;
  };
  /**
   * Find the unique elements in a source array.
   *
   * @param  {array} src Source array
   * @return {array} Array of unique items
   * @ignore
   */


  var _unique = function (src) {
    if (_areAllUnique(src)) {
      return src.slice();
    } // A faster unique method is to use object keys to identify used values,
    // but this doesn't work with arrays or objects, which we must also
    // consider. See jsperf.com/compare-array-unique-versions/4 for more
    // information.


    var out = [],
        val,
        i,
        ien = src.length,
        j,
        k = 0;

    again: for (i = 0; i < ien; i++) {
      val = src[i];

      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }

      out.push(val);
      k++;
    }

    return out;
  }; // Surprisingly this is faster than [].concat.apply
  // https://jsperf.com/flatten-an-array-loop-vs-reduce/2


  var _flatten = function (out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten(out, val[i]);
      }
    } else {
      out.push(val);
    }

    return out;
  }; // Array.isArray polyfill.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray


  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  } // .trim() polyfill
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim


  if (!String.prototype.trim) {
    String.prototype.trim = function () {
      return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
  }
  /**
   * DataTables utility methods
   * 
   * This namespace provides helper methods that DataTables uses internally to
   * create a DataTable, but which are not exclusively used only for DataTables.
   * These methods can be used by extension authors to save the duplication of
   * code.
   *
   *  @namespace
   */


  DataTable.util = {
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function (fn, freq) {
      var frequency = freq !== undefined ? freq : 200,
          last,
          timer;
      return function () {
        var that = this,
            now = +new Date(),
            args = arguments;

        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function () {
            last = undefined;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },

    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function (val) {
      return val.replace(_re_escape_regex, '\\$1');
    }
  };
  /**
   * Create a mapping object that allows camel case parameters to be looked up
   * for their Hungarian counterparts. The mapping is stored in a private
   * parameter called `_hungarianMap` which can be accessed on the source object.
   *  @param {object} o
   *  @memberof DataTable#oApi
   */

  function _fnHungarianMap(o) {
    var hungarian = 'a aa ai ao as b fn i m o s ',
        match,
        newKey,
        map = {};
    $.each(o, function (key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);

      if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map[newKey] = key;

        if (match[1] === 'o') {
          _fnHungarianMap(o[key]);
        }
      }
    });
    o._hungarianMap = map;
  }
  /**
   * Convert from camel case parameters to Hungarian, based on a Hungarian map
   * created by _fnHungarianMap.
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   *  @memberof DataTable#oApi
   */


  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }

    var hungarianKey;
    $.each(user, function (key, val) {
      hungarianKey = src._hungarianMap[key];

      if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
        // For objects, we need to buzz down into the object to copy parameters
        if (hungarianKey.charAt(0) === 'o') {
          // Copy the camelCase options over to the hungarian
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }

          $.extend(true, user[hungarianKey], user[key]);

          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  /**
   * Language compatibility - when certain options are given, and others aren't, we
   * need to duplicate the values over, in order to provide backwards compatibility
   * with older language files.
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnLanguageCompat(lang) {
    // Note the use of the Hungarian notation for the parameters in this method as
    // this is called after the mapping of camelCase to Hungarian
    var defaults = DataTable.defaults.oLanguage; // Default mapping

    var defaultDecimal = defaults.sDecimal;

    if (defaultDecimal) {
      _addNumericSort(defaultDecimal);
    }

    if (lang) {
      var zeroRecords = lang.sZeroRecords; // Backwards compatibility - if there is no sEmptyTable given, then use the same as
      // sZeroRecords - assuming that is given.

      if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
        _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
      } // Likewise with loading records


      if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
        _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
      } // Old parameter name of the thousands separator mapped onto the new


      if (lang.sInfoThousands) {
        lang.sThousands = lang.sInfoThousands;
      }

      var decimal = lang.sDecimal;

      if (decimal && defaultDecimal !== decimal) {
        _addNumericSort(decimal);
      }
    }
  }
  /**
   * Map one parameter onto another
   *  @param {object} o Object to map
   *  @param {*} knew The new parameter name
   *  @param {*} old The old parameter name
   */


  var _fnCompatMap = function (o, knew, old) {
    if (o[knew] !== undefined) {
      o[old] = o[knew];
    }
  };
  /**
   * Provide backwards compatibility for the main DT options. Note that the new
   * options are mapped onto the old parameters, so this is an external interface
   * change only.
   *  @param {object} init Object to map
   */


  function _fnCompatOpts(init) {
    _fnCompatMap(init, 'ordering', 'bSort');

    _fnCompatMap(init, 'orderMulti', 'bSortMulti');

    _fnCompatMap(init, 'orderClasses', 'bSortClasses');

    _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');

    _fnCompatMap(init, 'order', 'aaSorting');

    _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');

    _fnCompatMap(init, 'paging', 'bPaginate');

    _fnCompatMap(init, 'pagingType', 'sPaginationType');

    _fnCompatMap(init, 'pageLength', 'iDisplayLength');

    _fnCompatMap(init, 'searching', 'bFilter'); // Boolean initialisation of x-scrolling


    if (typeof init.sScrollX === 'boolean') {
      init.sScrollX = init.sScrollX ? '100%' : '';
    }

    if (typeof init.scrollX === 'boolean') {
      init.scrollX = init.scrollX ? '100%' : '';
    } // Column search objects are in an array, so it needs to be converted
    // element by element


    var searchCols = init.aoSearchCols;

    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
        }
      }
    }
  }
  /**
   * Provide backwards compatibility for column options. Note that the new options
   * are mapped onto the old parameters, so this is an external interface change
   * only.
   *  @param {object} init Object to map
   */


  function _fnCompatCols(init) {
    _fnCompatMap(init, 'orderable', 'bSortable');

    _fnCompatMap(init, 'orderData', 'aDataSort');

    _fnCompatMap(init, 'orderSequence', 'asSorting');

    _fnCompatMap(init, 'orderDataType', 'sortDataType'); // orderData can be given as an integer


    var dataSort = init.aDataSort;

    if (typeof dataSort === 'number' && !Array.isArray(dataSort)) {
      init.aDataSort = [dataSort];
    }
  }
  /**
   * Browser feature detection for capabilities, quirks
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnBrowserDetect(settings) {
    // We don't need to do this every time DataTables is constructed, the values
    // calculated are specific to the browser and OS configuration which we
    // don't expect to change between initialisations
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser; // Scrolling feature / quirks detection

      var n = $('<div/>').css({
        position: 'fixed',
        top: 0,
        left: $(window).scrollLeft() * -1,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: 'hidden'
      }).append($('<div/>').css({
        position: 'absolute',
        top: 1,
        left: 1,
        width: 100,
        overflow: 'scroll'
      }).append($('<div/>').css({
        width: '100%',
        height: 10
      }))).appendTo('body');
      var outer = n.children();
      var inner = outer.children(); // Numbers below, in order, are:
      // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
      //
      // IE6 XP:                           100 100 100  83
      // IE7 Vista:                        100 100 100  83
      // IE 8+ Windows:                     83  83 100  83
      // Evergreen Windows:                 83  83 100  83
      // Evergreen Mac with scrollbars:     85  85 100  85
      // Evergreen Mac without scrollbars: 100 100 100 100
      // Get scrollbar width

      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth; // IE6/7 will oversize a width 100% element inside a scrolling element, to
      // include the width of the scrollbar, while other browsers ensure the inner
      // element is contained without forcing scrolling

      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100; // In rtl text layout, some browsers (most, but not all) will place the
      // scrollbar on the left, rather than the right.

      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1; // IE8- don't provide height and width for getBoundingClientRect

      browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
      n.remove();
    }

    $.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  /**
   * Array.prototype reduce[Right] method, used for browsers which don't support
   * JS 1.6. Done this way to reduce code size, since we iterate either way
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnReduce(that, fn, init, start, end, inc) {
    var i = start,
        value,
        isSet = false;

    if (init !== undefined) {
      value = init;
      isSet = true;
    }

    while (i !== end) {
      if (!that.hasOwnProperty(i)) {
        continue;
      }

      value = isSet ? fn(value, that[i], i, that) : that[i];
      isSet = true;
      i += inc;
    }

    return value;
  }
  /**
   * Add a column to the list used for the table with default values
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nTh The th element for this column
   *  @memberof DataTable#oApi
   */


  function _fnAddColumn(oSettings, nTh) {
    // Add column to aoColumns array
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement('th'),
      "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    });
    oSettings.aoColumns.push(oCol); // Add search object for column specific search. Note that the `searchCols[ iCol ]`
    // passed into extend can be undefined. This allows the user to give a default
    // with only some of the parameters defined, and also not give a default

    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]); // Use the default column options function to initialise classes etc

    _fnColumnOptions(oSettings, iCol, $(nTh).data());
  }
  /**
   * Apply options for a column
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iCol column index to consider
   *  @param {object} oOptions object with sType, bVisible and bSearchable etc
   *  @memberof DataTable#oApi
   */


  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    var oClasses = oSettings.oClasses;
    var th = $(oCol.nTh); // Try to get width information from the DOM. We can't get it from CSS
    // as we'd need to parse the CSS stylesheet. `width` option can override

    if (!oCol.sWidthOrig) {
      // Width attribute
      oCol.sWidthOrig = th.attr('width') || null; // Style attribute

      var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);

      if (t) {
        oCol.sWidthOrig = t[1];
      }
    }
    /* User specified column options */


    if (oOptions !== undefined && oOptions !== null) {
      // Backwards compatibility
      _fnCompatCols(oOptions); // Map camel case parameters to their Hungarian counterparts


      _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
      /* Backwards compatibility for mDataProp */


      if (oOptions.mDataProp !== undefined && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }

      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      } // `class` is a reserved word in Javascript, so we need to provide
      // the ability to use a valid name for the camel case input


      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }

      if (oOptions.sClass) {
        th.addClass(oOptions.sClass);
      }

      $.extend(oCol, oOptions);

      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      /* iDataSort to be applied (backwards compatibility), but aDataSort will take
       * priority if defined
       */


      if (oOptions.iDataSort !== undefined) {
        oCol.aDataSort = [oOptions.iDataSort];
      }

      _fnMap(oCol, oOptions, "aDataSort");
    }
    /* Cache the data get and set functions for speed */


    var mDataSrc = oCol.mData;

    var mData = _fnGetObjectDataFn(mDataSrc);

    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

    var attrTest = function (src) {
      return typeof src === 'string' && src.indexOf('@') !== -1;
    };

    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;

    oCol.fnGetData = function (rowData, type, meta) {
      var innerData = mData(rowData, type, undefined, meta);
      return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
    };

    oCol.fnSetData = function (rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    }; // Indicate if DataTables should read DOM data as an object or array
    // Used in _fnGetRowElements


    if (typeof mDataSrc !== 'number') {
      oSettings._rowReadObject = true;
    }
    /* Feature sorting overrides column specific when off */


    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
      th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
    }
    /* Check that the class assignment is correct for sorting */


    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;

    if (!oCol.bSortable || !bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    } else if (bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    } else if (!bAsc && bDesc) {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    } else {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }
  /**
   * Adjust the table column widths for new data. Note: you would probably want to
   * do a redraw after calling this function!
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnAdjustColumnSizing(settings) {
    /* Not interested in doing column width calculation if auto-width is disabled */
    if (settings.oFeatures.bAutoWidth !== false) {
      var columns = settings.aoColumns;

      _fnCalculateColumnWidths(settings);

      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }

    var scroll = settings.oScroll;

    if (scroll.sY !== '' || scroll.sX !== '') {
      _fnScrollDraw(settings);
    }

    _fnCallbackFire(settings, null, 'column-sizing', [settings]);
  }
  /**
   * Covert the index of a visible column to the index in the data array (take account
   * of hidden columns)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iMatch Visible column index to lookup
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */


  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, 'bVisible');

    return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
  }
  /**
   * Covert the index of an index in the data array and convert it to the visible
   *   column index (take account of hidden columns)
   *  @param {int} iMatch Column index to lookup
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */


  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, 'bVisible');

    var iPos = $.inArray(iMatch, aiVis);
    return iPos !== -1 ? iPos : null;
  }
  /**
   * Get the number of visible columns
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the number of visible columns
   *  @memberof DataTable#oApi
   */


  function _fnVisbleColumns(oSettings) {
    var vis = 0; // No reduce in IE8, use a loop for now

    $.each(oSettings.aoColumns, function (i, col) {
      if (col.bVisible && $(col.nTh).css('display') !== 'none') {
        vis++;
      }
    });
    return vis;
  }
  /**
   * Get an array of column indexes that match a given property
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sParam Parameter in aoColumns to look for - typically
   *    bVisible or bSearchable
   *  @returns {array} Array of indexes with matched properties
   *  @memberof DataTable#oApi
   */


  function _fnGetColumns(oSettings, sParam) {
    var a = [];
    $.map(oSettings.aoColumns, function (val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  /**
   * Calculate the 'type' of a column
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache; // For each column, spin over the 

    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];

      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            // Use a cache array so we only need to get the type data
            // from the formatter once (when using multiple detectors)
            if (cache[k] === undefined) {
              cache[k] = _fnGetCellData(settings, k, i, 'type');
            }

            detectedType = types[j](cache[k], settings); // If null, then this type can't apply to this column, so
            // rather than testing all cells, break out. There is an
            // exception for the last type which is `html`. We need to
            // scan all rows since it is possible to mix string and HTML
            // types

            if (!detectedType && j !== types.length - 1) {
              break;
            } // Only a single match is needed for html type since it is
            // bottom of the pile and very similar to string


            if (detectedType === 'html') {
              break;
            }
          } // Type is valid for all data points in the column - use this
          // type


          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        } // Fall back - if no type was detected, always use string


        if (!col.sType) {
          col.sType = 'string';
        }
      }
    }
  }
  /**
   * Take the column definitions and static columns arrays and calculate how
   * they relate to column indexes. The callback function will then apply the
   * definition found for a column to a suitable configuration object.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
   *  @param {array} aoCols The aoColumns array that defines columns individually
   *  @param {function} fn Callback function - takes two parameters, the calculated
   *    column index and the definition for that column.
   *  @memberof DataTable#oApi
   */


  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns; // Column definitions with aTargets

    if (aoColDefs) {
      /* Loop over the definitions array - loop in reverse so first instance has priority */
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        /* Each definition can target multiple columns, as it is an array */

        var aTargets = def.targets !== undefined ? def.targets : def.aTargets;

        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }

        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
            /* Add columns that we don't yet know about */
            while (columns.length <= aTargets[j]) {
              _fnAddColumn(oSettings);
            }
            /* Integer, basic index */


            fn(aTargets[j], def);
          } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
            /* Negative integer, right to left column counting */
            fn(columns.length + aTargets[j], def);
          } else if (typeof aTargets[j] === 'string') {
            /* Class name matching on TH element */
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
                fn(k, def);
              }
            }
          }
        }
      }
    } // Statically defined columns array


    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  /**
   * Add a data array to the table, creating DOM node etc. This is the parallel to
   * _fnGatherData, but for adding rows from a Javascript source, rather than a
   * DOM source.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aData data array to be added
   *  @param {node} [nTr] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
   *  @memberof DataTable#oApi
   */


  function _fnAddData(oSettings, aDataIn, nTr, anTds) {
    /* Create the object for storing information about this new row */
    var iRow = oSettings.aoData.length;
    var oData = $.extend(true, {}, DataTable.models.oRow, {
      src: nTr ? 'dom' : 'data',
      idx: iRow
    });
    oData._aData = aDataIn;
    oSettings.aoData.push(oData);
    /* Create the cells */

    var nTd, sThisType;
    var columns = oSettings.aoColumns; // Invalidate the column types as the new data needs to be revalidated

    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    /* Add to the display array */


    oSettings.aiDisplayMaster.push(iRow);
    var id = oSettings.rowIdFn(aDataIn);

    if (id !== undefined) {
      oSettings.aIds[id] = oData;
    }
    /* Create the DOM information, or register it if already present */


    if (nTr || !oSettings.oFeatures.bDeferRender) {
      _fnCreateTr(oSettings, iRow, nTr, anTds);
    }

    return iRow;
  }
  /**
   * Add one or more TR elements to the table. Generally we'd expect to
   * use this for reading data from a DOM sourced table, but it could be
   * used for an TR element. Note that if a TR is given, it is used (i.e.
   * it is not cloned).
   *  @param {object} settings dataTables settings object
   *  @param {array|node|jQuery} trs The TR element(s) to add to the table
   *  @returns {array} Array of indexes for the added rows
   *  @memberof DataTable#oApi
   */


  function _fnAddTr(settings, trs) {
    var row; // Allow an individual node to be passed in

    if (!(trs instanceof $)) {
      trs = $(trs);
    }

    return trs.map(function (i, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  /**
   * Take a TR element and convert it to an index in aoData
   *  @param {object} oSettings dataTables settings object
   *  @param {node} n the TR element to find
   *  @returns {int} index if the node is found, null if not
   *  @memberof DataTable#oApi
   */


  function _fnNodeToDataIndex(oSettings, n) {
    return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
  }
  /**
   * Take a TD element and convert it into a column data index (not the visible index)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow The row number the TD/TH can be found in
   *  @param {node} n The TD/TH element to find
   *  @returns {int} index if the node is found, -1 if not
   *  @memberof DataTable#oApi
   */


  function _fnNodeToColumnIndex(oSettings, iRow, n) {
    return $.inArray(n, oSettings.aoData[iRow].anCells);
  }
  /**
   * Get the data for a given cell from the internal cache, taking into account data mapping
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
   *  @returns {*} Cell data
   *  @memberof DataTable#oApi
   */


  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings: settings,
      row: rowIdx,
      col: colIdx
    });

    if (cellData === undefined) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);

        settings.iDrawError = draw;
      }

      return defaultContent;
    } // When the data source is null and a specific data type is requested (i.e.
    // not the original data), we can use default column data


    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
      cellData = defaultContent;
    } else if (typeof cellData === 'function') {
      // If the data source is a function, then we run it and use the return,
      // executing in the scope of the data object (for instances)
      return cellData.call(rowData);
    }

    if (cellData === null && type == 'display') {
      return '';
    }

    return cellData;
  }
  /**
   * Set the value for a specific cell, into the internal data cache
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {*} val Value to set
   *  @memberof DataTable#oApi
   */


  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings: settings,
      row: rowIdx,
      col: colIdx
    });
  } // Private variable that is used to match action syntax in the data property object


  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  /**
   * Split string on periods, taking into account escaped periods
   * @param  {string} str String to split
   * @return {array} Split string
   */

  function _fnSplitObjNotation(str) {
    return $.map(str.match(/(\\.|[^\.])+/g) || [''], function (s) {
      return s.replace(/\\\./g, '.');
    });
  }
  /**
   * Return a function that can be used to get data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data get function
   *  @memberof DataTable#oApi
   */


  function _fnGetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      /* Build an object of get functions, and wrap them in a single call */
      var o = {};
      $.each(mSource, function (key, val) {
        if (val) {
          o[key] = _fnGetObjectDataFn(val);
        }
      });
      return function (data, type, row, meta) {
        var t = o[type] || o._;
        return t !== undefined ? t(data, type, row, meta) : data;
      };
    } else if (mSource === null) {
      /* Give an empty string for rendering / sorting etc */
      return function (data) {
        // type, row and meta also passed, but not used
        return data;
      };
    } else if (typeof mSource === 'function') {
      return function (data, type, row, meta) {
        return mSource(data, type, row, meta);
      };
    } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
      /* If there is a . in the source string then the data source is in a
       * nested object so we loop over the data for each level to get the next
       * level down. On each loop we test for undefined, and if found immediately
       * return. This allows entire objects to be missing and sDefaultContent to
       * be used if defined, rather than throwing an error
       */
      var fetchData = function (data, type, src) {
        var arrayNotation, funcNotation, out, innerSrc;

        if (src !== "") {
          var a = _fnSplitObjNotation(src);

          for (var i = 0, iLen = a.length; i < iLen; i++) {
            // Check if we are dealing with special notation
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);

            if (arrayNotation) {
              // Array notation
              a[i] = a[i].replace(__reArray, ''); // Condition allows simply [] to be passed in

              if (a[i] !== "") {
                data = data[a[i]];
              }

              out = []; // Get the remainder of the nested object to get

              a.splice(0, i + 1);
              innerSrc = a.join('.'); // Traverse each entry in the array getting the properties requested

              if (Array.isArray(data)) {
                for (var j = 0, jLen = data.length; j < jLen; j++) {
                  out.push(fetchData(data[j], type, innerSrc));
                }
              } // If a string is given in between the array notation indicators, that
              // is used to join the strings together, otherwise an array is returned


              var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
              data = join === "" ? out : out.join(join); // The inner call to fetchData has already traversed through the remainder
              // of the source requested, so we exit from the loop

              break;
            } else if (funcNotation) {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[a[i]]();
              continue;
            }

            if (data === null || data[a[i]] === undefined) {
              return undefined;
            }

            data = data[a[i]];
          }
        }

        return data;
      };

      return function (data, type) {
        // row and meta also passed, but not used
        return fetchData(data, type, mSource);
      };
    } else {
      /* Array or flat object mapping */
      return function (data, type) {
        // row and meta also passed, but not used
        return data[mSource];
      };
    }
  }
  /**
   * Return a function that can be used to set data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data set function
   *  @memberof DataTable#oApi
   */


  function _fnSetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      /* Unlike get, only the underscore (global) option is used for for
       * setting data since we don't know the type here. This is why an object
       * option is not documented for `mData` (which is read/write), but it is
       * for `mRender` which is read only.
       */
      return _fnSetObjectDataFn(mSource._);
    } else if (mSource === null) {
      /* Nothing to do when the data source is null */
      return function () {};
    } else if (typeof mSource === 'function') {
      return function (data, val, meta) {
        mSource(data, 'set', val, meta);
      };
    } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
      /* Like the get, we need to get data from a nested object */
      var setData = function (data, val, src) {
        var a = _fnSplitObjNotation(src),
            b;

        var aLast = a[a.length - 1];
        var arrayNotation, funcNotation, o, innerSrc;

        for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
          // Protect against prototype pollution
          if (a[i] === '__proto__') {
            throw new Error('Cannot set prototype values');
          } // Check if we are dealing with an array notation request


          arrayNotation = a[i].match(__reArray);
          funcNotation = a[i].match(__reFn);

          if (arrayNotation) {
            a[i] = a[i].replace(__reArray, '');
            data[a[i]] = []; // Get the remainder of the nested object to set so we can recurse

            b = a.slice();
            b.splice(0, i + 1);
            innerSrc = b.join('.'); // Traverse each entry in the array setting the properties requested

            if (Array.isArray(val)) {
              for (var j = 0, jLen = val.length; j < jLen; j++) {
                o = {};
                setData(o, val[j], innerSrc);
                data[a[i]].push(o);
              }
            } else {
              // We've been asked to save data to an array, but it
              // isn't array data to be saved. Best that can be done
              // is to just save the value.
              data[a[i]] = val;
            } // The inner call to setData has already traversed through the remainder
            // of the source and has set the data, thus we can exit here


            return;
          } else if (funcNotation) {
            // Function call
            a[i] = a[i].replace(__reFn, '');
            data = data[a[i]](val);
          } // If the nested object doesn't currently exist - since we are
          // trying to set the value - create it


          if (data[a[i]] === null || data[a[i]] === undefined) {
            data[a[i]] = {};
          }

          data = data[a[i]];
        } // Last item in the input - i.e, the actual set


        if (aLast.match(__reFn)) {
          // Function call
          data = data[aLast.replace(__reFn, '')](val);
        } else {
          // If array notation is used, we just want to strip it and use the property name
          // and assign the value. If it isn't used, then we get the result we want anyway
          data[aLast.replace(__reArray, '')] = val;
        }
      };

      return function (data, val) {
        // meta is also passed in, but not used
        return setData(data, val, mSource);
      };
    } else {
      /* Array or flat object mapping */
      return function (data, val) {
        // meta is also passed in, but not used
        data[mSource] = val;
      };
    }
  }
  /**
   * Return an array with the full table data
   *  @param {object} oSettings dataTables settings object
   *  @returns array {array} aData Master data array
   *  @memberof DataTable#oApi
   */


  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, '_aData');
  }
  /**
   * Nuke the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  /**
  * Take an array of integers (index array) and remove a target integer (value - not
  * the key!)
  *  @param {array} a Index array to target
  *  @param {int} iTarget value to find
  *  @memberof DataTable#oApi
  */


  function _fnDeleteIndex(a, iTarget, splice) {
    var iTargetIndex = -1;

    for (var i = 0, iLen = a.length; i < iLen; i++) {
      if (a[i] == iTarget) {
        iTargetIndex = i;
      } else if (a[i] > iTarget) {
        a[i]--;
      }
    }

    if (iTargetIndex != -1 && splice === undefined) {
      a.splice(iTargetIndex, 1);
    }
  }
  /**
   * Mark cached data as invalid such that a re-read of the data will occur when
   * the cached data is next requested. Also update from the data source object.
   *
   * @param {object} settings DataTables settings object
   * @param {int}    rowIdx   Row index to invalidate
   * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
   *     or 'data'
   * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
   *     row will be invalidated
   * @memberof DataTable#oApi
   *
   * @todo For the modularisation of v1.11 this will need to become a callback, so
   *   the sort and filter methods can subscribe to it. That will required
   *   initialisation options for sorting, which is why it is not already baked in
   */


  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;

    var cellWrite = function (cell, col) {
      // This is very frustrating, but in IE if you just write directly
      // to innerHTML, and elements that are overwritten are GC'ed,
      // even if there is a reference to them elsewhere
      while (cell.childNodes.length) {
        cell.removeChild(cell.firstChild);
      }

      cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
    }; // Are we reading last data from DOM or the data object?


    if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
      // Read the data from the DOM
      row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
    } else {
      // Reading from data object, update the DOM
      var cells = row.anCells;

      if (cells) {
        if (colIdx !== undefined) {
          cellWrite(cells[colIdx], colIdx);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            cellWrite(cells[i], i);
          }
        }
      }
    } // For both row and cell invalidation, the cached data for sorting and
    // filtering is nulled out


    row._aSortData = null;
    row._aFilterData = null; // Invalidate the type for a specific column (if given) or all columns since
    // the data might have changed

    var cols = settings.aoColumns;

    if (colIdx !== undefined) {
      cols[colIdx].sType = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
      } // Update DataTables special `DT_*` attributes for the row


      _fnRowAttributes(settings, row);
    }
  }
  /**
   * Build a data source object from an HTML row, reading the contents of the
   * cells that are in the row.
   *
   * @param {object} settings DataTables settings object
   * @param {node|object} TR element from which to read data or existing row
   *   object from which to re-read the data from the cells
   * @param {int} [colIdx] Optional column index
   * @param {array|object} [d] Data source object. If `colIdx` is given then this
   *   parameter should also be given and will be used to write the data into.
   *   Only the column in question will be written
   * @returns {object} Object with two parameters: `data` the data read, in
   *   document order, and `cells` and array of nodes (they can be useful to the
   *   caller, so rather than needing a second traversal to get them, just return
   *   them from here).
   * @memberof DataTable#oApi
   */


  function _fnGetRowElements(settings, row, colIdx, d) {
    var tds = [],
        td = row.firstChild,
        name,
        col,
        o,
        i = 0,
        contents,
        columns = settings.aoColumns,
        objectRead = settings._rowReadObject; // Allow the data object to be passed in, or construct

    d = d !== undefined ? d : objectRead ? {} : [];

    var attr = function (str, td) {
      if (typeof str === 'string') {
        var idx = str.indexOf('@');

        if (idx !== -1) {
          var attr = str.substring(idx + 1);

          var setter = _fnSetObjectDataFn(str);

          setter(d, td.getAttribute(attr));
        }
      }
    }; // Read data from a cell and store into the data object


    var cellProcess = function (cell) {
      if (colIdx === undefined || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();

        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);

          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          // Depending on the `data` option for the columns the data can
          // be read to either an object or an array.
          if (objectRead) {
            if (!col._setter) {
              // Cache the setter function
              col._setter = _fnSetObjectDataFn(col.mData);
            }

            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }

      i++;
    };

    if (td) {
      // `tr` element was passed in
      while (td) {
        name = td.nodeName.toUpperCase();

        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }

        td = td.nextSibling;
      }
    } else {
      // Existing row object passed in
      tds = row.anCells;

      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    } // Read the ID from the DOM if present


    var rowNode = row.firstChild ? row : row.nTr;

    if (rowNode) {
      var id = rowNode.getAttribute('id');

      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d, id);
      }
    }

    return {
      data: d,
      cells: tds
    };
  }
  /**
   * Create a new TR element (and it's TD children) for a row
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow Row to consider
   *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @memberof DataTable#oApi
   */


  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow],
        rowData = row._aData,
        cells = [],
        nTr,
        nTd,
        oCol,
        i,
        iLen,
        create;

    if (row.nTr === null) {
      nTr = nTrIn || document.createElement('tr');
      row.nTr = nTr;
      row.anCells = cells;
      /* Use a private property on the node to allow reserve mapping from the node
       * to the aoData array for fast look up
       */

      nTr._DT_RowIndex = iRow;
      /* Special parameters can be given by the data source to be used on the row */

      _fnRowAttributes(oSettings, row);
      /* Process each column */


      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd); // Need to create the HTML if new, or if a rendering function is defined

        if (create || (!nTrIn || oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')) {
          nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
        }
        /* Add user defined class */


        if (oCol.sClass) {
          nTd.className += ' ' + oCol.sClass;
        } // Visibility - add or remove as required


        if (oCol.bVisible && !nTrIn) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && nTrIn) {
          nTd.parentNode.removeChild(nTd);
        }

        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
        }
      }

      _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells]);
    } // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
    // and deployed


    row.nTr.setAttribute('role', 'row');
  }
  /**
   * Add attributes to a row based on the special `DT_*` parameters in a data
   * source object.
   *  @param {object} settings DataTables settings object
   *  @param {object} DataTables row object for the row to be modified
   *  @memberof DataTable#oApi
   */


  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;

    if (tr) {
      var id = settings.rowIdFn(data);

      if (id) {
        tr.id = id;
      }

      if (data.DT_RowClass) {
        // Remove any classes added by DT_RowClass before
        var a = data.DT_RowClass.split(' ');
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
        $(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
      }

      if (data.DT_RowAttr) {
        $(tr).attr(data.DT_RowAttr);
      }

      if (data.DT_RowData) {
        $(tr).data(data.DT_RowData);
      }
    }
  }
  /**
   * Create the HTML header for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnBuildHead(oSettings) {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $('th, td', thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;

    if (createHeader) {
      row = $('<tr/>').appendTo(thead);
    }

    for (i = 0, ien = columns.length; i < ien; i++) {
      column = columns[i];
      cell = $(column.nTh).addClass(column.sClass);

      if (createHeader) {
        cell.appendTo(row);
      } // 1.11 move into sorting


      if (oSettings.oFeatures.bSort) {
        cell.addClass(column.sSortingClass);

        if (column.bSortable !== false) {
          cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);

          _fnSortAttachListener(oSettings, column.nTh, i);
        }
      }

      if (column.sTitle != cell[0].innerHTML) {
        cell.html(column.sTitle);
      }

      _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
    }

    if (createHeader) {
      _fnDetectHeader(oSettings.aoHeader, thead);
    }
    /* ARIA role for the rows */


    $(thead).children('tr').attr('role', 'row');
    /* Deal with the footer - add classes if required */

    $(thead).children('tr').children('th, td').addClass(classes.sHeaderTH);
    $(tfoot).children('tr').children('th, td').addClass(classes.sFooterTH); // Cache the footer cells. Note that we only take the cells from the first
    // row in the footer. If there is more than one row the user wants to
    // interact with, they need to use the table().foot() method. Note also this
    // allows cells to be used for multiple columns using colspan

    if (tfoot !== null) {
      var cells = oSettings.aoFooter[0];

      for (i = 0, ien = cells.length; i < ien; i++) {
        column = columns[i];
        column.nTf = cells[i].cell;

        if (column.sClass) {
          $(column.nTf).addClass(column.sClass);
        }
      }
    }
  }
  /**
   * Draw the header (or footer) element based on the column visibility states. The
   * methodology here is to use the layout array from _fnDetectHeader, modified for
   * the instantaneous column visibility, to construct the new layout. The grid is
   * traversed over cell at a time in a rows x columns grid fashion, although each
   * cell insert can cover multiple elements in the grid - which is tracks using the
   * aApplied array. Cell inserts in the grid will only occur where there isn't
   * already a cell in that position.
   *  @param {object} oSettings dataTables settings object
   *  @param array {objects} aoSource Layout array from _fnDetectHeader
   *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
   *  @memberof DataTable#oApi
   */


  function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;

    if (!aoSource) {
      return;
    }

    if (bIncludeHidden === undefined) {
      bIncludeHidden = false;
    }
    /* Make a copy of the master layout array, but without the visible columns in it */


    for (i = 0, iLen = aoSource.length; i < iLen; i++) {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;
      /* Remove any columns which are currently hidden */

      for (j = iColumns - 1; j >= 0; j--) {
        if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
          aoLocal[i].splice(j, 1);
        }
      }
      /* Prep the applied array - it needs an element for each row */


      aApplied.push([]);
    }

    for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
      nLocalTr = aoLocal[i].nTr;
      /* All cells are going to be replaced, so empty out the row */

      if (nLocalTr) {
        while (n = nLocalTr.firstChild) {
          nLocalTr.removeChild(n);
        }
      }

      for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
        iRowspan = 1;
        iColspan = 1;
        /* Check to see if there is already a cell (row/colspan) covering our target
         * insert point. If there is, then there is nothing to do.
         */

        if (aApplied[i][j] === undefined) {
          nLocalTr.appendChild(aoLocal[i][j].cell);
          aApplied[i][j] = 1;
          /* Expand the cell to cover as many rows as needed */

          while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
            aApplied[i + iRowspan][j] = 1;
            iRowspan++;
          }
          /* Expand the cell to cover as many columns as needed */


          while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
            /* Must update the applied array over the rows for the columns */
            for (k = 0; k < iRowspan; k++) {
              aApplied[i + k][j + iColspan] = 1;
            }

            iColspan++;
          }
          /* Do the actual expansion in the DOM */


          $(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
        }
      }
    }
  }
  /**
   * Insert the required TR nodes into the table for display
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnDraw(oSettings) {
    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
    var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);

    if ($.inArray(false, aPreDraw) !== -1) {
      _fnProcessingDisplay(oSettings, false);

      return;
    }

    var i, iLen, n;
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var iOpenRows = oSettings.aoOpenRows.length;
    var oLang = oSettings.oLanguage;
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    var bServerSide = _fnDataSource(oSettings) == 'ssp';
    var aiDisplay = oSettings.aiDisplay;
    oSettings.bDrawing = true;
    /* Check and see if we have an initial draw position from state saving */

    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }

    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    /* Server-side processing draw intercept */

    if (oSettings.bDeferLoading) {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;

      _fnProcessingDisplay(oSettings, false);
    } else if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
      return;
    }

    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];

        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }

        var nRow = aoData.nTr;
        /* Remove the old striping classes and then add the new one */

        if (iStripes !== 0) {
          var sStripe = asStripeClasses[iRowCount % iStripes];

          if (aoData._sRowStripe != sStripe) {
            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
            aoData._sRowStripe = sStripe;
          }
        } // Row callback functions - might want to manipulate the row
        // iRowCount and j are not currently documented. Are they at all
        // useful?


        _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j, iDataIndex]);

        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      /* Table is empty - create a row with an empty message in it */
      var sZero = oLang.sZeroRecords;

      if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
        sZero = oLang.sLoadingRecords;
      } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
        sZero = oLang.sEmptyTable;
      }

      anRows[0] = $('<tr/>', {
        'class': iStripes ? asStripeClasses[0] : ''
      }).append($('<td />', {
        'valign': 'top',
        'colSpan': _fnVisbleColumns(oSettings),
        'class': oSettings.oClasses.sRowEmpty
      }).html(sZero))[0];
    }
    /* Header and footer callbacks */


    _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

    _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

    var body = $(oSettings.nTBody);
    body.children().detach();
    body.append($(anRows));
    /* Call all required callback functions for the end of a draw */

    _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
    /* Draw is complete, sorting and filtering must be as well */


    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  /**
   * Redraw the table - taking account of the various features which are enabled
   *  @param {object} oSettings dataTables settings object
   *  @param {boolean} [holdPosition] Keep the current paging position. By default
   *    the paging is reset to the first page
   *  @memberof DataTable#oApi
   */


  function _fnReDraw(settings, holdPosition) {
    var features = settings.oFeatures,
        sort = features.bSort,
        filter = features.bFilter;

    if (sort) {
      _fnSort(settings);
    }

    if (filter) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      // No filtering, so we want to just use the display master
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }

    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    } // Let any modules know about the draw hold position state (used by
    // scrolling internally)


    settings._drawHold = holdPosition;

    _fnDraw(settings);

    settings._drawHold = false;
  }
  /**
   * Add the options to the page HTML for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnAddOptionsHtml(oSettings) {
    var classes = oSettings.oClasses;
    var table = $(oSettings.nTable);
    var holding = $('<div/>').insertBefore(table); // Holding element for speed

    var features = oSettings.oFeatures; // All DataTables are wrapped in a div

    var insert = $('<div/>', {
      id: oSettings.sTableId + '_wrapper',
      'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
    });
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
    /* Loop over the user set positioning and place the elements as needed */

    var aDom = oSettings.sDom.split('');
    var featureNode, cOption, nNewNode, cNext, sAttr, j;

    for (var i = 0; i < aDom.length; i++) {
      featureNode = null;
      cOption = aDom[i];

      if (cOption == '<') {
        /* New container div */
        nNewNode = $('<div/>')[0];
        /* Check to see if we should append an id and/or a class name to the container */

        cNext = aDom[i + 1];

        if (cNext == "'" || cNext == '"') {
          sAttr = "";
          j = 2;

          while (aDom[i + j] != cNext) {
            sAttr += aDom[i + j];
            j++;
          }
          /* Replace jQuery UI constants @todo depreciated */


          if (sAttr == "H") {
            sAttr = classes.sJUIHeader;
          } else if (sAttr == "F") {
            sAttr = classes.sJUIFooter;
          }
          /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
           * breaks the string into parts and applies them as needed
           */


          if (sAttr.indexOf('.') != -1) {
            var aSplit = sAttr.split('.');
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
            nNewNode.className = aSplit[1];
          } else if (sAttr.charAt(0) == "#") {
            nNewNode.id = sAttr.substr(1, sAttr.length - 1);
          } else {
            nNewNode.className = sAttr;
          }

          i += j;
          /* Move along the position array */
        }

        insert.append(nNewNode);
        insert = $(nNewNode);
      } else if (cOption == '>') {
        /* End container div */
        insert = insert.parent();
      } // @todo Move options into their own plugins?
      else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
          /* Length */
          featureNode = _fnFeatureHtmlLength(oSettings);
        } else if (cOption == 'f' && features.bFilter) {
          /* Filter */
          featureNode = _fnFeatureHtmlFilter(oSettings);
        } else if (cOption == 'r' && features.bProcessing) {
          /* pRocessing */
          featureNode = _fnFeatureHtmlProcessing(oSettings);
        } else if (cOption == 't') {
          /* Table */
          featureNode = _fnFeatureHtmlTable(oSettings);
        } else if (cOption == 'i' && features.bInfo) {
          /* Info */
          featureNode = _fnFeatureHtmlInfo(oSettings);
        } else if (cOption == 'p' && features.bPaginate) {
          /* Pagination */
          featureNode = _fnFeatureHtmlPaginate(oSettings);
        } else if (DataTable.ext.feature.length !== 0) {
          /* Plug-in features */
          var aoFeatures = DataTable.ext.feature;

          for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
            if (cOption == aoFeatures[k].cFeature) {
              featureNode = aoFeatures[k].fnInit(oSettings);
              break;
            }
          }
        }
      /* Add to the 2D features array */


      if (featureNode) {
        var aanFeatures = oSettings.aanFeatures;

        if (!aanFeatures[cOption]) {
          aanFeatures[cOption] = [];
        }

        aanFeatures[cOption].push(featureNode);
        insert.append(featureNode);
      }
    }
    /* Built our DOM structure - replace the holding div with what we want */


    holding.replaceWith(insert);
    oSettings.nHolding = null;
  }
  /**
   * Use the DOM source to create up an array of header cells. The idea here is to
   * create a layout grid (array) of rows x columns, which contains a reference
   * to the cell that that point in the grid (regardless of col/rowspan), such that
   * any column / row could be removed and the new grid constructed
   *  @param array {object} aLayout Array to store the calculated layout in
   *  @param {node} nThead The header/footer element for the table
   *  @memberof DataTable#oApi
   */


  function _fnDetectHeader(aLayout, nThead) {
    var nTrs = $(nThead).children('tr');
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;

    var fnShiftCol = function (a, i, j) {
      var k = a[i];

      while (k[j]) {
        j++;
      }

      return j;
    };

    aLayout.splice(0, aLayout.length);
    /* We know how many rows there are in the layout - so prep it */

    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      aLayout.push([]);
    }
    /* Calculate a layout array */


    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      nTr = nTrs[i];
      iColumn = 0;
      /* For every cell in the row... */

      nCell = nTr.firstChild;

      while (nCell) {
        if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
          /* Get the col and rowspan attributes from the DOM and sanitise them */
          iColspan = nCell.getAttribute('colspan') * 1;
          iRowspan = nCell.getAttribute('rowspan') * 1;
          iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
          iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
          /* There might be colspan cells already in this row, so shift our target
           * accordingly
           */

          iColShifted = fnShiftCol(aLayout, i, iColumn);
          /* Cache calculation for unique columns */

          bUnique = iColspan === 1 ? true : false;
          /* If there is col / rowspan, copy the information into the layout grid */

          for (l = 0; l < iColspan; l++) {
            for (k = 0; k < iRowspan; k++) {
              aLayout[i + k][iColShifted + l] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i + k].nTr = nTr;
            }
          }
        }

        nCell = nCell.nextSibling;
      }
    }
  }
  /**
   * Get an array of unique th elements, one for each column
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nHeader automatically detect the layout from this node - optional
   *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
   *  @returns array {node} aReturn list of unique th's
   *  @memberof DataTable#oApi
   */


  function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
    var aReturn = [];

    if (!aLayout) {
      aLayout = oSettings.aoHeader;

      if (nHeader) {
        aLayout = [];

        _fnDetectHeader(aLayout, nHeader);
      }
    }

    for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
      for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
        if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }

    return aReturn;
  }
  /**
   * Create an Ajax call based on the table's settings, taking into account that
   * parameters can have multiple forms, and backwards compatibility.
   *
   * @param {object} oSettings dataTables settings object
   * @param {array} data Data to send to the server, required by
   *     DataTables - may be augmented by developer callbacks
   * @param {function} fn Callback function to run when data is obtained
   */


  function _fnBuildAjax(oSettings, data, fn) {
    // Compatibility with 1.9-, allow fnServerData and event to manipulate
    _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]); // Convert to object based for 1.10+ if using the old array scheme which can
    // come from server-side processing or serverParams


    if (data && Array.isArray(data)) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
      $.each(data, function (key, val) {
        var match = val.name.match(rbracket);

        if (match) {
          // Support for arrays
          var name = match[0];

          if (!tmp[name]) {
            tmp[name] = [];
          }

          tmp[name].push(val.value);
        } else {
          tmp[val.name] = val.value;
        }
      });
      data = tmp;
    }

    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;

    var callback = function (json) {
      _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);

      fn(json);
    };

    if ($.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === 'function' ? ajaxData(data, oSettings) : // fn can manipulate data or return
      ajaxData; // an object object or array to merge
      // If the function returned something, use that alone

      data = typeof ajaxData === 'function' && newData ? newData : $.extend(true, data, newData); // Remove the data property as we've resolved it already and don't want
      // jQuery to do it again (it is restored at the end of the function)

      delete ajax.data;
    }

    var baseAjax = {
      "data": data,
      "success": function (json) {
        var error = json.error || json.sError;

        if (error) {
          _fnLog(oSettings, 0, error);
        }

        oSettings.json = json;
        callback(json);
      },
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function (xhr, error, thrown) {
        var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

        if ($.inArray(true, ret) === -1) {
          if (error == "parsererror") {
            _fnLog(oSettings, 0, 'Invalid JSON response', 1);
          } else if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, 'Ajax error', 7);
          }
        }

        _fnProcessingDisplay(oSettings, false);
      }
    }; // Store the data submitted for the API

    oSettings.oAjaxData = data; // Allow plug-ins and external processes to modify the data

    _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

    if (oSettings.fnServerData) {
      // DataTables 1.9- compatibility
      oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
        // Need to convert back to 1.9 trad format
        return {
          name: key,
          value: val
        };
      }), callback, oSettings);
    } else if (oSettings.sAjaxSource || typeof ajax === 'string') {
      // DataTables 1.9- compatibility
      oSettings.jqXHR = $.ajax($.extend(baseAjax, {
        url: ajax || oSettings.sAjaxSource
      }));
    } else if (typeof ajax === 'function') {
      // Is a function - let the caller define what needs to be done
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else {
      // Object to extend the base settings
      oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax)); // Restore for next time around

      ajax.data = ajaxData;
    }
  }
  /**
   * Update the table using an Ajax call
   *  @param {object} settings dataTables settings object
   *  @returns {boolean} Block the table drawing or not
   *  @memberof DataTable#oApi
   */


  function _fnAjaxUpdate(settings) {
    if (settings.bAjaxDataGet) {
      settings.iDraw++;

      _fnProcessingDisplay(settings, true);

      _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
        _fnAjaxUpdateDraw(settings, json);
      });

      return false;
    }

    return true;
  }
  /**
   * Build up the parameters in an object needed for a server-side processing
   * request. Note that this is basically done twice, is different ways - a modern
   * method which is used by default in DataTables 1.10 which uses objects and
   * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
   * the sAjaxSource option is used in the initialisation, or the legacyAjax
   * option is set.
   *  @param {object} oSettings dataTables settings object
   *  @returns {bool} block the table drawing or not
   *  @memberof DataTable#oApi
   */


  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns,
        columnCount = columns.length,
        features = settings.oFeatures,
        preSearch = settings.oPreviousSearch,
        preColSearch = settings.aoPreSearchCols,
        i,
        data = [],
        dataProp,
        column,
        columnSearch,
        sort = _fnSortFlatten(settings),
        displayStart = settings._iDisplayStart,
        displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;

    var param = function (name, value) {
      data.push({
        'name': name,
        'value': value
      });
    }; // DataTables 1.9- compatible method


    param('sEcho', settings.iDraw);
    param('iColumns', columnCount);
    param('sColumns', _pluck(columns, 'sName').join(','));
    param('iDisplayStart', displayStart);
    param('iDisplayLength', displayLength); // DataTables 1.10+ method

    var d = {
      draw: settings.iDraw,
      columns: [],
      order: [],
      start: displayStart,
      length: displayLength,
      search: {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };

    for (i = 0; i < columnCount; i++) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData == "function" ? 'function' : column.mData;
      d.columns.push({
        data: dataProp,
        name: column.sName,
        searchable: column.bSearchable,
        orderable: column.bSortable,
        search: {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      });
      param("mDataProp_" + i, dataProp);

      if (features.bFilter) {
        param('sSearch_' + i, columnSearch.sSearch);
        param('bRegex_' + i, columnSearch.bRegex);
        param('bSearchable_' + i, column.bSearchable);
      }

      if (features.bSort) {
        param('bSortable_' + i, column.bSortable);
      }
    }

    if (features.bFilter) {
      param('sSearch', preSearch.sSearch);
      param('bRegex', preSearch.bRegex);
    }

    if (features.bSort) {
      $.each(sort, function (i, val) {
        d.order.push({
          column: val.col,
          dir: val.dir
        });
        param('iSortCol_' + i, val.col);
        param('sSortDir_' + i, val.dir);
      });
      param('iSortingCols', sort.length);
    } // If the legacy.ajax parameter is null, then we automatically decide which
    // form to use, based on sAjaxSource


    var legacy = DataTable.ext.legacy.ajax;

    if (legacy === null) {
      return settings.sAjaxSource ? data : d;
    } // Otherwise, if legacy has been specified then we use that to decide on the
    // form


    return legacy ? data : d;
  }
  /**
   * Data the data from the server (nuking the old) and redraw the table
   *  @param {object} oSettings dataTables settings object
   *  @param {object} json json data return from the server.
   *  @param {string} json.sEcho Tracking flag for DataTables to match requests
   *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
   *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
   *  @param {array} json.aaData The data to display on this page
   *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
   *  @memberof DataTable#oApi
   */


  function _fnAjaxUpdateDraw(settings, json) {
    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
    // Support both
    var compat = function (old, modern) {
      return json[old] !== undefined ? json[old] : json[modern];
    };

    var data = _fnAjaxDataSrc(settings, json);

    var draw = compat('sEcho', 'draw');
    var recordsTotal = compat('iTotalRecords', 'recordsTotal');
    var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

    if (draw !== undefined) {
      // Protect against out of sequence returns
      if (draw * 1 < settings.iDraw) {
        return;
      }

      settings.iDraw = draw * 1;
    }

    _fnClearTable(settings);

    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData(settings, data[i]);
    }

    settings.aiDisplay = settings.aiDisplayMaster.slice();
    settings.bAjaxDataGet = false;

    _fnDraw(settings);

    if (!settings._bInitComplete) {
      _fnInitComplete(settings, json);
    }

    settings.bAjaxDataGet = true;

    _fnProcessingDisplay(settings, false);
  }
  /**
   * Get the data from the JSON data source to use for drawing a table. Using
   * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
   * source object, or from a processing function.
   *  @param {object} oSettings dataTables settings object
   *  @param  {object} json Data source object / array from the server
   *  @return {array} Array of data to use
   */


  function _fnAjaxDataSrc(oSettings, json) {
    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp; // Compatibility with 1.9-.
    // Compatibility with 1.9-. In order to read from aaData, check if the
    // default has been changed, if not, check for aaData

    if (dataSrc === 'data') {
      return json.aaData || json[dataSrc];
    }

    return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
  }
  /**
   * Generate the node required for filtering text
   *  @returns {node} Filter control element
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlFilter(settings) {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
    var str = language.sSearch;
    str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;
    var filter = $('<div/>', {
      'id': !features.f ? tableId + '_filter' : null,
      'class': classes.sFilter
    }).append($('<label/>').append(str));

    var searchFn = function () {
      /* Update all other filter input elements for the new display */
      var n = features.f;
      var val = !this.value ? "" : this.value; // mental IE8 fix :-(

      /* Now do the filter */

      if (val != previousSearch.sSearch) {
        _fnFilterComplete(settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart,
          "bCaseInsensitive": previousSearch.bCaseInsensitive
        }); // Need to redraw, without resorting


        settings._iDisplayStart = 0;

        _fnDraw(settings);
      }
    };

    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;
    var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).on('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).on('mouseup', function (e) {
      // Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
      // on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
      // checks the value to see if it has changed. In other browsers it won't have.
      setTimeout(function () {
        searchFn.call(jqFilter[0]);
      }, 10);
    }).on('keypress.DT', function (e) {
      /* Prevent form submission */
      if (e.keyCode == 13) {
        return false;
      }
    }).attr('aria-controls', tableId); // Update the input elements whenever the table is filtered

    $(settings.nTable).on('search.dt.DT', function (ev, s) {
      if (settings === s) {
        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame...
        try {
          if (jqFilter[0] !== document.activeElement) {
            jqFilter.val(previousSearch.sSearch);
          }
        } catch (e) {}
      }
    });
    return filter[0];
  }
  /**
   * Filter the table using both the global filter and column based filtering
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oSearch search information
   *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
   *  @memberof DataTable#oApi
   */


  function _fnFilterComplete(oSettings, oInput, iForce) {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;

    var fnSaveFilter = function (oFilter) {
      /* Save the filtering values */
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
    };

    var fnRegex = function (o) {
      // Backwards compatibility with the bEscapeRegex option
      return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
    }; // Resolve any column types that are unknown due to addition or invalidation
    // @todo As per sort - can this be moved into an event handler?


    _fnColumnTypes(oSettings);
    /* In server-side processing all filtering is done by the server, so no point hanging around here */


    if (_fnDataSource(oSettings) != 'ssp') {
      /* Global filter */
      _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);

      fnSaveFilter(oInput);
      /* Now do the individual column filter */

      for (var i = 0; i < aoPrevSearch.length; i++) {
        _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
      }
      /* Custom filtering */


      _fnFilterCustom(oSettings);
    } else {
      fnSaveFilter(oInput);
    }
    /* Tell the draw function we have been filtering */


    oSettings.bFiltered = true;

    _fnCallbackFire(oSettings, null, 'search', [oSettings]);
  }
  /**
   * Apply custom filtering functions
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;

    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = []; // Loop over each row and see if it should be included

      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];

        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      } // So the array reference doesn't break set the results into the
      // existing array


      displayRows.length = 0;
      $.merge(displayRows, rows);
    }
  }
  /**
   * Filter the table on a per-column basis
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sInput string to filter on
   *  @param {int} iColumn column to filter
   *  @param {bool} bRegex treat search string as a regular expression or not
   *  @param {bool} bSmart use smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */


  function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
    if (searchStr === '') {
      return;
    }

    var data;
    var out = [];
    var display = settings.aiDisplay;

    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

    for (var i = 0; i < display.length; i++) {
      data = settings.aoData[display[i]]._aFilterData[colIdx];

      if (rpSearch.test(data)) {
        out.push(display[i]);
      }
    }

    settings.aiDisplay = out;
  }
  /**
   * Filter the data table based on user input and draw the table
   *  @param {object} settings dataTables settings object
   *  @param {string} input string to filter on
   *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
   *  @param {bool} regex treat as a regular expression or not
   *  @param {bool} smart perform smart filtering or not
   *  @param {bool} caseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */


  function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);

    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
    var filtered = []; // Need to take account of custom filtering functions - always filter

    if (DataTable.ext.search.length !== 0) {
      force = true;
    } // Check if any of the rows were invalidated


    invalidated = _fnFilterData(settings); // If the input is blank - we just want the full data set

    if (input.length <= 0) {
      settings.aiDisplay = displayMaster.slice();
    } else {
      // New search - start from the master array
      if (invalidated || force || regex || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted // On resort, the display master needs to be
      // re-filtered since indexes will have changed
      ) {
          settings.aiDisplay = displayMaster.slice();
        } // Search the display array


      display = settings.aiDisplay;

      for (i = 0; i < display.length; i++) {
        if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
          filtered.push(display[i]);
        }
      }

      settings.aiDisplay = filtered;
    }
  }
  /**
   * Build a regular expression object suitable for searching a table
   *  @param {string} sSearch string to search for
   *  @param {bool} bRegex treat as a regular expression or not
   *  @param {bool} bSmart perform smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insensitive matching or not
   *  @returns {RegExp} constructed object
   *  @memberof DataTable#oApi
   */


  function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
    search = regex ? search : _fnEscapeRegex(search);

    if (smart) {
      /* For smart filtering we want to allow the search to work regardless of
       * word order. We also want double quoted text to be preserved, so word
       * order is important - a la google. So this is what we want to
       * generate:
       * 
       * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
       */
      var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
        if (word.charAt(0) === '"') {
          var m = word.match(/^"(.*)"$/);
          word = m ? m[1] : word;
        }

        return word.replace('"', '');
      });
      search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
    }

    return new RegExp(search, caseInsensitive ? 'i' : '');
  }
  /**
   * Escape a string such that it can be used in a regular expression
   *  @param {string} sVal string to escape
   *  @returns {string} escaped string
   *  @memberof DataTable#oApi
   */


  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $('<div>')[0];

  var __filter_div_textContent = __filter_div.textContent !== undefined; // Update the filtering data for each row if needed (by invalidation or first run)


  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var fomatters = DataTable.ext.type.search;
    var wasInvalidated = false;

    for (i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];

      if (!row._aFilterData) {
        filterData = [];

        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];

          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, i, j, 'filter');

            if (fomatters[column.sType]) {
              cellData = fomatters[column.sType](cellData);
            } // Search in DataTables 1.10 is string based. In 1.11 this
            // should be altered to also allow strict type checking.


            if (cellData === null) {
              cellData = '';
            }

            if (typeof cellData !== 'string' && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = '';
          } // If it looks like there is an HTML entity in the string,
          // attempt to decode it so sorting works as expected. Note that
          // we could use a single line of jQuery to do this, but the DOM
          // method used here is much faster http://jsperf.com/html-decode


          if (cellData.indexOf && cellData.indexOf('&') !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }

          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, '');
          }

          filterData.push(cellData);
        }

        row._aFilterData = filterData;
        row._sFilterRow = filterData.join('  ');
        wasInvalidated = true;
      }
    }

    return wasInvalidated;
  }
  /**
   * Convert from the internal Hungarian notation to camelCase for external
   * interaction
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */


  function _fnSearchToCamel(obj) {
    return {
      search: obj.sSearch,
      smart: obj.bSmart,
      regex: obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }
  /**
   * Convert from camelCase notation to the internal Hungarian. We could use the
   * Hungarian convert function here, but this is cleaner
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */


  function _fnSearchToHung(obj) {
    return {
      sSearch: obj.search,
      bSmart: obj.smart,
      bRegex: obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }
  /**
   * Generate the node required for the info display
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Information element
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlInfo(settings) {
    var tid = settings.sTableId,
        nodes = settings.aanFeatures.i,
        n = $('<div/>', {
      'class': settings.oClasses.sInfo,
      'id': !nodes ? tid + '_info' : null
    });

    if (!nodes) {
      // Update display on each draw
      settings.aoDrawCallback.push({
        "fn": _fnUpdateInfo,
        "sName": "information"
      });
      n.attr('role', 'status').attr('aria-live', 'polite'); // Table is described by our info div

      $(settings.nTable).attr('aria-describedby', tid + '_info');
    }

    return n[0];
  }
  /**
   * Update the information elements in the display
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnUpdateInfo(settings) {
    /* Show information about the table */
    var nodes = settings.aanFeatures.i;

    if (nodes.length === 0) {
      return;
    }

    var lang = settings.oLanguage,
        start = settings._iDisplayStart + 1,
        end = settings.fnDisplayEnd(),
        max = settings.fnRecordsTotal(),
        total = settings.fnRecordsDisplay(),
        out = total ? lang.sInfo : lang.sInfoEmpty;

    if (total !== max) {
      /* Record set after filtering */
      out += ' ' + lang.sInfoFiltered;
    } // Convert the macros


    out += lang.sInfoPostFix;
    out = _fnInfoMacros(settings, out);
    var callback = lang.fnInfoCallback;

    if (callback !== null) {
      out = callback.call(settings.oInstance, settings, start, end, max, total, out);
    }

    $(nodes).html(out);
  }

  function _fnInfoMacros(settings, str) {
    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
    // internally
    var formatter = settings.fnFormatNumber,
        start = settings._iDisplayStart + 1,
        len = settings._iDisplayLength,
        vis = settings.fnRecordsDisplay(),
        all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
  }
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnInitialise(settings) {
    var i,
        iLen,
        iAjaxStart = settings.iInitDisplayStart;
    var columns = settings.aoColumns,
        column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading; // value modified by the draw

    /* Ensure that the table data is fully initialised */

    if (!settings.bInitialised) {
      setTimeout(function () {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    /* Show the display HTML options */


    _fnAddOptionsHtml(settings);
    /* Build and draw the header / footer for the table */


    _fnBuildHead(settings);

    _fnDrawHead(settings, settings.aoHeader);

    _fnDrawHead(settings, settings.aoFooter);
    /* Okay to show that something is going on now */


    _fnProcessingDisplay(settings, true);
    /* Calculate sizes for columns */


    if (features.bAutoWidth) {
      _fnCalculateColumnWidths(settings);
    }

    for (i = 0, iLen = columns.length; i < iLen; i++) {
      column = columns[i];

      if (column.sWidth) {
        column.nTh.style.width = _fnStringToCss(column.sWidth);
      }
    }

    _fnCallbackFire(settings, null, 'preInit', [settings]); // If there is default sorting required - let's do it. The sort function
    // will do the drawing for us. Otherwise we draw the table regardless of the
    // Ajax source - this allows the table to look initialised for Ajax sourcing
    // data (show 'loading' message possibly)


    _fnReDraw(settings); // Server-side processing init complete is done by _fnAjaxUpdateDraw


    var dataSrc = _fnDataSource(settings);

    if (dataSrc != 'ssp' || deferLoading) {
      // if there is an ajax source load the data
      if (dataSrc == 'ajax') {
        _fnBuildAjax(settings, [], function (json) {
          var aData = _fnAjaxDataSrc(settings, json); // Got the data - add it to the table


          for (i = 0; i < aData.length; i++) {
            _fnAddData(settings, aData[i]);
          } // Reset the init display for cookie saving. We've already done
          // a filter, and therefore cleared it before. So we need to make
          // it appear 'fresh'


          settings.iInitDisplayStart = iAjaxStart;

          _fnReDraw(settings);

          _fnProcessingDisplay(settings, false);

          _fnInitComplete(settings, json);
        }, settings);
      } else {
        _fnProcessingDisplay(settings, false);

        _fnInitComplete(settings);
      }
    }
  }
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} oSettings dataTables settings object
   *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
   *    with client-side processing (optional)
   *  @memberof DataTable#oApi
   */


  function _fnInitComplete(settings, json) {
    settings._bInitComplete = true; // When data was added after the initialisation (data or Ajax) we need to
    // calculate the column sizing

    if (json || settings.oInit.aaData) {
      _fnAdjustColumnSizing(settings);
    }

    _fnCallbackFire(settings, null, 'plugin-init', [settings, json]);

    _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
  }

  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;

    _fnLengthOverflow(settings); // Fire length change event


    _fnCallbackFire(settings, null, 'length', [settings, len]);
  }
  /**
   * Generate the node required for user display length changing
   *  @param {object} settings dataTables settings object
   *  @returns {node} Display length feature node
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlLength(settings) {
    var classes = settings.oClasses,
        tableId = settings.sTableId,
        menu = settings.aLengthMenu,
        d2 = Array.isArray(menu[0]),
        lengths = d2 ? menu[0] : menu,
        language = d2 ? menu[1] : menu;
    var select = $('<select/>', {
      'name': tableId + '_length',
      'aria-controls': tableId,
      'class': classes.sLengthSelect
    });

    for (var i = 0, ien = lengths.length; i < ien; i++) {
      select[0][i] = new Option(typeof language[i] === 'number' ? settings.fnFormatNumber(language[i]) : language[i], lengths[i]);
    }

    var div = $('<div><label/></div>').addClass(classes.sLength);

    if (!settings.aanFeatures.l) {
      div[0].id = tableId + '_length';
    }

    div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)); // Can't use `select` variable as user might provide their own and the
    // reference is broken by the use of outerHTML

    $('select', div).val(settings._iDisplayLength).on('change.DT', function (e) {
      _fnLengthChange(settings, $(this).val());

      _fnDraw(settings);
    }); // Update node value whenever anything changes the table's length

    $(settings.nTable).on('length.dt.DT', function (e, s, len) {
      if (settings === s) {
        $('select', div).val(len);
      }
    });
    return div[0];
  }
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Note that most of the paging logic is done in
   * DataTable.ext.pager
   */

  /**
   * Generate the node required for default pagination
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Pagination feature node
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlPaginate(settings) {
    var type = settings.sPaginationType,
        plugin = DataTable.ext.pager[type],
        modern = typeof plugin === 'function',
        redraw = function (settings) {
      _fnDraw(settings);
    },
        node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
        features = settings.aanFeatures;

    if (!modern) {
      plugin.fnInit(settings, node, redraw);
    }
    /* Add a draw callback for the pagination on first instance, to update the paging display */


    if (!features.p) {
      node.id = settings.sTableId + '_paginate';
      settings.aoDrawCallback.push({
        "fn": function (settings) {
          if (modern) {
            var start = settings._iDisplayStart,
                len = settings._iDisplayLength,
                visRecords = settings.fnRecordsDisplay(),
                all = len === -1,
                page = all ? 0 : Math.ceil(start / len),
                pages = all ? 1 : Math.ceil(visRecords / len),
                buttons = plugin(page, pages),
                i,
                ien;

            for (i = 0, ien = features.p.length; i < ien; i++) {
              _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
            }
          } else {
            plugin.fnUpdate(settings, redraw);
          }
        },
        "sName": "pagination"
      });
    }

    return node;
  }
  /**
   * Alter the display settings to change the page
   *  @param {object} settings DataTables settings object
   *  @param {string|int} action Paging action to take: "first", "previous",
   *    "next" or "last" or page number to jump to (integer)
   *  @param [bool] redraw Automatically draw the update or not
   *  @returns {bool} true page has changed, false - no change
   *  @memberof DataTable#oApi
   */


  function _fnPageChange(settings, action, redraw) {
    var start = settings._iDisplayStart,
        len = settings._iDisplayLength,
        records = settings.fnRecordsDisplay();

    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;

      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;

      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else {
      _fnLog(settings, 0, "Unknown paging action: " + action, 5);
    }

    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;

    if (changed) {
      _fnCallbackFire(settings, null, 'page', [settings]);

      if (redraw) {
        _fnDraw(settings);
      }
    }

    return changed;
  }
  /**
   * Generate the node required for the processing node
   *  @param {object} settings dataTables settings object
   *  @returns {node} Processing element
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlProcessing(settings) {
    return $('<div/>', {
      'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
      'class': settings.oClasses.sProcessing
    }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
  }
  /**
   * Display or hide the processing indicator
   *  @param {object} settings dataTables settings object
   *  @param {bool} show Show the processing indicator (true) or not (false)
   *  @memberof DataTable#oApi
   */


  function _fnProcessingDisplay(settings, show) {
    if (settings.oFeatures.bProcessing) {
      $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
    }

    _fnCallbackFire(settings, null, 'processing', [settings, show]);
  }
  /**
   * Add any control elements for the table - specifically scrolling
   *  @param {object} settings dataTables settings object
   *  @returns {node} Node to add to the DOM
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlTable(settings) {
    var table = $(settings.nTable); // Add the ARIA grid role to the table

    table.attr('role', 'grid'); // Scrolling from here on in

    var scroll = settings.oScroll;

    if (scroll.sX === '' && scroll.sY === '') {
      return settings.nTable;
    }

    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children('caption');
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $(table[0].cloneNode(false));
    var footerClone = $(table[0].cloneNode(false));
    var footer = table.children('tfoot');
    var _div = '<div/>';

    var size = function (s) {
      return !s ? null : _fnStringToCss(s);
    };

    if (!footer.length) {
      footer = null;
    }
    /*
     * The HTML structure that we want to generate in this function is:
     *  div - scroller
     *    div - scroll head
     *      div - scroll head inner
     *        table - scroll head table
     *          thead - thead
     *    div - scroll body
     *      table - table (master table)
     *        thead - thead clone for sizing
     *        tbody - tbody
     *    div - scroll foot
     *      div - scroll foot inner
     *        table - scroll foot table
     *          tfoot - tfoot
     */


    var scroller = $(_div, {
      'class': classes.sScrollWrapper
    }).append($(_div, {
      'class': classes.sScrollHead
    }).css({
      overflow: 'hidden',
      position: 'relative',
      border: 0,
      width: scrollX ? size(scrollX) : '100%'
    }).append($(_div, {
      'class': classes.sScrollHeadInner
    }).css({
      'box-sizing': 'content-box',
      width: scroll.sXInner || '100%'
    }).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, {
      'class': classes.sScrollBody
    }).css({
      position: 'relative',
      overflow: 'auto',
      width: size(scrollX)
    }).append(table));

    if (footer) {
      scroller.append($(_div, {
        'class': classes.sScrollFoot
      }).css({
        overflow: 'hidden',
        border: 0,
        width: scrollX ? size(scrollX) : '100%'
      }).append($(_div, {
        'class': classes.sScrollFootInner
      }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
    }

    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null; // When the body is scrolled, then we also want to scroll the headers

    if (scrollX) {
      $(scrollBody).on('scroll.DT', function (e) {
        var scrollLeft = this.scrollLeft;
        scrollHead.scrollLeft = scrollLeft;

        if (footer) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      });
    }

    $(scrollBody).css('max-height', scrollY);

    if (!scroll.bCollapse) {
      $(scrollBody).css('height', scrollY);
    }

    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot; // On redraw - align columns

    settings.aoDrawCallback.push({
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    });
    return scroller[0];
  }
  /**
   * Update the header, footer and body tables for resizing - i.e. column
   * alignment.
   *
   * Welcome to the most horrible function DataTables. The process that this
   * function follows is basically:
   *   1. Re-create the table inside the scrolling div
   *   2. Take live measurements from the DOM
   *   3. Apply the measurements to align the columns
   *   4. Clean up
   *
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnScrollDraw(settings) {
    // Given that this is such a monster function, a lot of variables are use
    // to try and keep the minimised size as small as possible
    var scroll = settings.oScroll,
        scrollX = scroll.sX,
        scrollXInner = scroll.sXInner,
        scrollY = scroll.sY,
        barWidth = scroll.iBarWidth,
        divHeader = $(settings.nScrollHead),
        divHeaderStyle = divHeader[0].style,
        divHeaderInner = divHeader.children('div'),
        divHeaderInnerStyle = divHeaderInner[0].style,
        divHeaderTable = divHeaderInner.children('table'),
        divBodyEl = settings.nScrollBody,
        divBody = $(divBodyEl),
        divBodyStyle = divBodyEl.style,
        divFooter = $(settings.nScrollFoot),
        divFooterInner = divFooter.children('div'),
        divFooterTable = divFooterInner.children('table'),
        header = $(settings.nTHead),
        table = $(settings.nTable),
        tableEl = table[0],
        tableStyle = tableEl.style,
        footer = settings.nTFoot ? $(settings.nTFoot) : null,
        browser = settings.oBrowser,
        ie67 = browser.bScrollOversize,
        dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
        headerTrgEls,
        footerTrgEls,
        headerSrcEls,
        footerSrcEls,
        headerCopy,
        footerCopy,
        headerWidths = [],
        footerWidths = [],
        headerContent = [],
        footerContent = [],
        idx,
        correction,
        sanityWidth,
        zeroOut = function (nSizer) {
      var style = nSizer.style;
      style.paddingTop = "0";
      style.paddingBottom = "0";
      style.borderTopWidth = "0";
      style.borderBottomWidth = "0";
      style.height = 0;
    }; // If the scrollbar visibility has changed from the last draw, we need to
    // adjust the column sizes as the table width will have changed to account
    // for the scrollbar


    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
      settings.scrollBarVis = scrollBarVis;

      _fnAdjustColumnSizing(settings);

      return; // adjust column sizing will call this function again
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    /*
     * 1. Re-create the table inside the scrolling div
     */
    // Remove the old minimised thead and tfoot elements in the inner table


    table.children('thead, tfoot').remove();

    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized

      footerSrcEls = footerCopy.find('tr');
    } // Clone the current header and footer elements and then place it into the inner table


    headerCopy = header.clone().prependTo(table);
    headerTrgEls = header.find('tr'); // original header is in its own table

    headerSrcEls = headerCopy.find('tr');
    headerCopy.find('th, td').removeAttr('tabindex');
    /*
     * 2. Take live measurements from the DOM - do not alter the DOM itself!
     */
    // Remove old sizing and apply the calculated column widths
    // Get the unique column headers in the newly created (cloned) header. We want to apply the
    // calculated sizes to this header

    if (!scrollX) {
      divBodyStyle.width = '100%';
      divHeader[0].style.width = '100%';
    }

    $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
      idx = _fnVisibleToColumnIndex(settings, i);
      el.style.width = settings.aoColumns[idx].sWidth;
    });

    if (footer) {
      _fnApplyToChildren(function (n) {
        n.style.width = "";
      }, footerSrcEls);
    } // Size the table as a whole


    sanityWidth = table.outerWidth();

    if (scrollX === "") {
      // No x scrolling
      tableStyle.width = "100%"; // IE7 will make the width of the table when 100% include the scrollbar
      // - which is shouldn't. When there is a scrollbar we need to take this
      // into account.

      if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
        tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
      } // Recalculate the sanity width


      sanityWidth = table.outerWidth();
    } else if (scrollXInner !== "") {
      // legacy x scroll inner has been given - use it
      tableStyle.width = _fnStringToCss(scrollXInner); // Recalculate the sanity width

      sanityWidth = table.outerWidth();
    } // Hidden header should have zero height, so remove padding and borders. Then
    // set the width based on the real headers
    // Apply all styles in one pass


    _fnApplyToChildren(zeroOut, headerSrcEls); // Read all widths in next pass


    _fnApplyToChildren(function (nSizer) {
      headerContent.push(nSizer.innerHTML);
      headerWidths.push(_fnStringToCss($(nSizer).css('width')));
    }, headerSrcEls); // Apply all widths in final pass


    _fnApplyToChildren(function (nToSize, i) {
      // Only apply widths to the DataTables detected header cells - this
      // prevents complex headers from having contradictory sizes applied
      if ($.inArray(nToSize, dtHeaderCells) !== -1) {
        nToSize.style.width = headerWidths[i];
      }
    }, headerTrgEls);

    $(headerSrcEls).height(0);
    /* Same again with the footer if we have one */

    if (footer) {
      _fnApplyToChildren(zeroOut, footerSrcEls);

      _fnApplyToChildren(function (nSizer) {
        footerContent.push(nSizer.innerHTML);
        footerWidths.push(_fnStringToCss($(nSizer).css('width')));
      }, footerSrcEls);

      _fnApplyToChildren(function (nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls);

      $(footerSrcEls).height(0);
    }
    /*
     * 3. Apply the measurements
     */
    // "Hide" the header and footer that we used for the sizing. We need to keep
    // the content of the cell so that the width applied to the header and body
    // both match, but we want to hide it completely. We want to also fix their
    // width to what they currently are


    _fnApplyToChildren(function (nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i] + '</div>';
      nSizer.childNodes[0].style.height = "0";
      nSizer.childNodes[0].style.overflow = "hidden";
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls);

    if (footer) {
      _fnApplyToChildren(function (nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i] + '</div>';
        nSizer.childNodes[0].style.height = "0";
        nSizer.childNodes[0].style.overflow = "hidden";
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls);
    } // Sanity check that the table is of a sensible width. If not then we are going to get
    // misalignment - try to prevent this by not allowing the table to shrink below its min width


    if (table.outerWidth() < sanityWidth) {
      // The min width depends upon if we have a vertical scrollbar visible or not */
      correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll" ? sanityWidth + barWidth : sanityWidth; // IE6/7 are a law unto themselves...

      if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
        tableStyle.width = _fnStringToCss(correction - barWidth);
      } // And give the user a warning that we've stopped the table getting too small


      if (scrollX === "" || scrollXInner !== "") {
        _fnLog(settings, 1, 'Possible column misalignment', 6);
      }
    } else {
      correction = '100%';
    } // Apply to the container elements


    divBodyStyle.width = _fnStringToCss(correction);
    divHeaderStyle.width = _fnStringToCss(correction);

    if (footer) {
      settings.nScrollFoot.style.width = _fnStringToCss(correction);
    }
    /*
     * 4. Clean up
     */


    if (!scrollY) {
      /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
       * the scrollbar height from the visible display, rather than adding it on. We need to
       * set the height in order to sort this. Don't want to do it in any other browsers.
       */
      if (ie67) {
        divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
      }
    }
    /* Finally set the width's of the header and footer tables */


    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth); // Figure out if there are scrollbar present - if so then we need a the header and footer to
    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)

    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

    if (footer) {
      divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
    } // Correct DOM ordering for colgroup - comes before the thead


    table.children('colgroup').insertBefore(table.children('thead'));
    /* Adjust the position of the header in case we loose the y-scrollbar */

    divBody.trigger('scroll'); // If sorting or filtering has occurred, jump the scrolling back to the top
    // only if we aren't holding the position

    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  /**
   * Apply a given function to the display child nodes of an element array (typically
   * TD children of TR rows
   *  @param {function} fn Method to apply to the objects
   *  @param array {nodes} an1 List of elements to look through for display children
   *  @param array {nodes} an2 Another list (identical structure to the first) - optional
   *  @memberof DataTable#oApi
   */


  function _fnApplyToChildren(fn, an1, an2) {
    var index = 0,
        i = 0,
        iLen = an1.length;
    var nNode1, nNode2;

    while (i < iLen) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;

      while (nNode1) {
        if (nNode1.nodeType === 1) {
          if (an2) {
            fn(nNode1, nNode2, index);
          } else {
            fn(nNode1, index);
          }

          index++;
        }

        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }

      i++;
    }
  }

  var __re_html_remove = /<.*?>/g;
  /**
   * Calculate the width of columns for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */

  function _fnCalculateColumnWidths(oSettings) {
    var table = oSettings.nTable,
        columns = oSettings.aoColumns,
        scroll = oSettings.oScroll,
        scrollY = scroll.sY,
        scrollX = scroll.sX,
        scrollXInner = scroll.sXInner,
        columnCount = columns.length,
        visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
        headerCells = $('th', oSettings.nTHead),
        tableWidthAttr = table.getAttribute('width'),
        // from DOM element
    tableContainer = table.parentNode,
        userInputs = false,
        i,
        column,
        columnIdx,
        width,
        outerWidth,
        browser = oSettings.oBrowser,
        ie67 = browser.bScrollOversize;

    var styleWidth = table.style.width;

    if (styleWidth && styleWidth.indexOf('%') !== -1) {
      tableWidthAttr = styleWidth;
    }
    /* Convert any user input sizes into pixel sizes */


    for (i = 0; i < visibleColumns.length; i++) {
      column = columns[visibleColumns[i]];

      if (column.sWidth !== null) {
        column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
        userInputs = true;
      }
    }
    /* If the number of columns in the DOM equals the number that we have to
     * process in DataTables, then we can use the offsets that are created by
     * the web- browser. No custom sizes can be set in order for this to happen,
     * nor scrolling used
     */


    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
      for (i = 0; i < columnCount; i++) {
        var colIdx = _fnVisibleToColumnIndex(oSettings, i);

        if (colIdx !== null) {
          columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      }
    } else {
      // Otherwise construct a single row, worst case, table with the widest
      // node in the data, assign any user defined widths, then insert it into
      // the DOM and allow the browser to do all the hard work of calculating
      // table widths
      var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
      .css('visibility', 'hidden').removeAttr('id'); // Clean up the table body

      tmpTable.find('tbody tr').remove();
      var tr = $('<tr/>').appendTo(tmpTable.find('tbody')); // Clone the table header and footer - we can't use the header / footer
      // from the cloned table, since if scrolling is active, the table's
      // real header and footer are contained in different table tags

      tmpTable.find('thead, tfoot').remove();
      tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone()); // Remove any assigned widths from the footer (from scrolling)

      tmpTable.find('tfoot th, tfoot td').css('width', ''); // Apply custom sizing to the cloned header

      headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];
        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''; // For scrollX we need to force the column width otherwise the
        // browser will collapse it. If this width is smaller than the
        // width the column requires, then it will have no effect

        if (column.sWidthOrig && scrollX) {
          $(headerCells[i]).append($('<div/>').css({
            width: column.sWidthOrig,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } // Find the widest cell for each column and put it into the table


      if (oSettings.aoData.length) {
        for (i = 0; i < visibleColumns.length; i++) {
          columnIdx = visibleColumns[i];
          column = columns[columnIdx];
          $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
        }
      } // Tidy the temporary table - remove name attributes so there aren't
      // duplicated in the dom (radio elements for example)


      $('[name]', tmpTable).removeAttr('name'); // Table has been built, attach to the document so we can work with it.
      // A holding element is used, positioned at the top of the container
      // with minimal height, so it has no effect on if the container scrolls
      // or not. Otherwise it might trigger scrolling when it actually isn't
      // needed

      var holder = $('<div/>').css(scrollX || scrollY ? {
        position: 'absolute',
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: 'hidden'
      } : {}).append(tmpTable).appendTo(tableContainer); // When scrolling (X or Y) we want to set the width of the table as 
      // appropriate. However, when not scrolling leave the table width as it
      // is. This results in slightly different, but I think correct behaviour

      if (scrollX && scrollXInner) {
        tmpTable.width(scrollXInner);
      } else if (scrollX) {
        tmpTable.css('width', 'auto');
        tmpTable.removeAttr('width'); // If there is no width attribute or style, then allow the table to
        // collapse

        if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
          tmpTable.width(tableContainer.clientWidth);
        }
      } else if (scrollY) {
        tmpTable.width(tableContainer.clientWidth);
      } else if (tableWidthAttr) {
        tmpTable.width(tableWidthAttr);
      } // Get the width of each column in the constructed table - we need to
      // know the inner width (so it can be assigned to the other table's
      // cells) and the outer width so we can calculate the full width of the
      // table. This is safe since DataTables requires a unique cell for each
      // column, but if ever a header can span multiple columns, this will
      // need to be modified.


      var total = 0;

      for (i = 0; i < visibleColumns.length; i++) {
        var cell = $(headerCells[i]);
        var border = cell.outerWidth() - cell.width(); // Use getBounding... where possible (not IE8-) because it can give
        // sub-pixel accuracy, which we then want to round up!

        var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth(); // Total is tracked to remove any sub-pixel errors as the outerWidth
        // of the table might not equal the total given here (IE!).

        total += bounding; // Width for each column to use

        columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
      }

      table.style.width = _fnStringToCss(total); // Finished with the table - ditch it

      holder.remove();
    } // If there is a width attr, we want to attach an event listener which
    // allows the table sizing to automatically adjust when the window is
    // resized. Use the width attr rather than CSS, since we can't know if the
    // CSS is a relative value or absolute - DOM read is always px.


    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }

    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
      var bindResize = function () {
        $(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
          _fnAdjustColumnSizing(oSettings);
        }));
      }; // IE6/7 will crash if we bind a resize event handler on page load.
      // To be removed in 1.11 which drops IE6/7 support


      if (ie67) {
        setTimeout(bindResize, 1000);
      } else {
        bindResize();
      }

      oSettings._reszEvt = true;
    }
  }
  /**
   * Throttle the calls to a function. Arguments and context are maintained for
   * the throttled function
   *  @param {function} fn Function to be called
   *  @param {int} [freq=200] call frequency in mS
   *  @returns {function} wrapped function
   *  @memberof DataTable#oApi
   */


  var _fnThrottle = DataTable.util.throttle;
  /**
   * Convert a CSS unit width to pixels (e.g. 2em)
   *  @param {string} width width to be converted
   *  @param {node} parent parent to get the with for (required for relative widths) - optional
   *  @returns {int} width in pixels
   *  @memberof DataTable#oApi
   */

  function _fnConvertToWidth(width, parent) {
    if (!width) {
      return 0;
    }

    var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);
    var val = n[0].offsetWidth;
    n.remove();
    return val;
  }
  /**
   * Get the widest node
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {node} widest table node
   *  @memberof DataTable#oApi
   */


  function _fnGetWidestNode(settings, colIdx) {
    var idx = _fnGetMaxLenString(settings, colIdx);

    if (idx < 0) {
      return null;
    }

    var data = settings.aoData[idx];
    return !data.nTr ? // Might not have been created when deferred rendering
    $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
  }
  /**
   * Get the maximum strlen for each data column
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {string} max string length for each column
   *  @memberof DataTable#oApi
   */


  function _fnGetMaxLenString(settings, colIdx) {
    var s,
        max = -1,
        maxIdx = -1;

    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      s = _fnGetCellData(settings, i, colIdx, 'display') + '';
      s = s.replace(__re_html_remove, '');
      s = s.replace(/&nbsp;/g, ' ');

      if (s.length > max) {
        max = s.length;
        maxIdx = i;
      }
    }

    return maxIdx;
  }
  /**
   * Append a CSS unit (only if required) to a string
   *  @param {string} value to css-ify
   *  @returns {string} value with css unit
   *  @memberof DataTable#oApi
   */


  function _fnStringToCss(s) {
    if (s === null) {
      return '0px';
    }

    if (typeof s == 'number') {
      return s < 0 ? '0px' : s + 'px';
    } // Check it has a unit character already


    return s.match(/\d$/) ? s + 'px' : s;
  }

  function _fnSortFlatten(settings) {
    var i,
        iLen,
        k,
        kLen,
        aSort = [],
        aiOrig = [],
        aoColumns = settings.aoColumns,
        aDataSort,
        iCol,
        sType,
        srcCol,
        fixed = settings.aaSortingFixed,
        fixedObj = $.isPlainObject(fixed),
        nestedSort = [],
        add = function (a) {
      if (a.length && !Array.isArray(a[0])) {
        // 1D array
        nestedSort.push(a);
      } else {
        // 2D array
        $.merge(nestedSort, a);
      }
    }; // Build the sort array, with pre-fix and post-fix options if they have been
    // specified


    if (Array.isArray(fixed)) {
      add(fixed);
    }

    if (fixedObj && fixed.pre) {
      add(fixed.pre);
    }

    add(settings.aaSorting);

    if (fixedObj && fixed.post) {
      add(fixed.post);
    }

    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[srcCol].aDataSort;

      for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
        iCol = aDataSort[k];
        sType = aoColumns[iCol].sType || 'string';

        if (nestedSort[i]._idx === undefined) {
          nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
        }

        aSort.push({
          src: srcCol,
          col: iCol,
          dir: nestedSort[i][1],
          index: nestedSort[i]._idx,
          type: sType,
          formatter: DataTable.ext.type.order[sType + "-pre"]
        });
      }
    }

    return aSort;
  }
  /**
   * Change the order of the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   *  @todo This really needs split up!
   */


  function _fnSort(oSettings) {
    var i,
        ien,
        iLen,
        j,
        jLen,
        k,
        kLen,
        sDataType,
        nTh,
        aiOrig = [],
        oExtSort = DataTable.ext.type.order,
        aoData = oSettings.aoData,
        aoColumns = oSettings.aoColumns,
        aDataSort,
        data,
        iCol,
        sType,
        oSort,
        formatters = 0,
        sortCol,
        displayMaster = oSettings.aiDisplayMaster,
        aSort; // Resolve any column types that are unknown due to addition or invalidation
    // @todo Can this be moved into a 'data-ready' handler which is called when
    //   data is going to be used in the table?

    _fnColumnTypes(oSettings);

    aSort = _fnSortFlatten(oSettings);

    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i]; // Track if we can use the fast sort algorithm

      if (sortCol.formatter) {
        formatters++;
      } // Load the data needed for the sort, for each cell


      _fnSortData(oSettings, sortCol.col);
    }
    /* No sorting required if server-side or no sorting array */


    if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
      // Create a value - key array of the current row positions such that we can use their
      // current position during the sort, if values match, in order to perform stable sorting
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[displayMaster[i]] = i;
      }
      /* Do the sort - here we want multi-column sorting based on a given data source (column)
       * and sorting function (from oSort) in a certain direction. It's reasonably complex to
       * follow on it's own, but this is what we want (example two column sorting):
       *  fnLocalSorting = function(a,b){
       *    var iTest;
       *    iTest = oSort['string-asc']('data11', 'data12');
       *      if (iTest !== 0)
       *        return iTest;
       *    iTest = oSort['numeric-desc']('data21', 'data22');
       *    if (iTest !== 0)
       *      return iTest;
       *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
       *  }
       * Basically we have a test for each sorting column, if the data in that column is equal,
       * test the next column. If all columns match, then we use a numeric sort on the row
       * positions in the original data array to provide a stable sort.
       *
       * Note - I know it seems excessive to have two sorting methods, but the first is around
       * 15% faster, so the second is only maintained for backwards compatibility with sorting
       * methods which do not have a pre-sort formatting function.
       */


      if (formatters === aSort.length) {
        // All sort types have formatting functions
        displayMaster.sort(function (a, b) {
          var x,
              y,
              k,
              test,
              sort,
              len = aSort.length,
              dataA = aoData[a]._aSortData,
              dataB = aoData[b]._aSortData;

          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            test = x < y ? -1 : x > y ? 1 : 0;

            if (test !== 0) {
              return sort.dir === 'asc' ? test : -test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      } else {
        // Depreciated - remove in 1.11 (providing a plug-in option)
        // Not all sort types have formatting methods, so we have to call their sorting
        // methods.
        displayMaster.sort(function (a, b) {
          var x,
              y,
              k,
              l,
              test,
              sort,
              fn,
              len = aSort.length,
              dataA = aoData[a]._aSortData,
              dataB = aoData[b]._aSortData;

          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
            test = fn(x, y);

            if (test !== 0) {
              return test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      }
    }
    /* Tell the draw function that we have sorted the data */


    oSettings.bSorted = true;
  }

  function _fnSortAria(settings) {
    var label;
    var nextSort;
    var columns = settings.aoColumns;

    var aSort = _fnSortFlatten(settings);

    var oAria = settings.oLanguage.oAria; // ARIA attributes - need to loop all columns, to update all (removing old
    // attributes as needed)

    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.sTitle.replace(/<.*?>/g, "");
      var th = col.nTh; // IE7 is throwing an error when setting these properties with jQuery's
      // attr() and removeAttr() methods...

      th.removeAttribute('aria-sort');
      /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */

      if (col.bSortable) {
        if (aSort.length > 0 && aSort[0].col == i) {
          th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
          nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
        } else {
          nextSort = asSorting[0];
        }

        label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
      } else {
        label = sTitle;
      }

      th.setAttribute('aria-label', label);
    }
  }
  /**
   * Function to run on user sort request
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {boolean} [append=false] Append the requested sort to the existing
   *    sort if true (i.e. multi-column sort)
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */


  function _fnSortListener(settings, colIdx, append, callback) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;

    var next = function (a, overflow) {
      var idx = a._idx;

      if (idx === undefined) {
        idx = $.inArray(a[1], asSorting);
      }

      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    }; // Convert to 2D array if needed


    if (typeof sorting[0] === 'number') {
      sorting = settings.aaSorting = [sorting];
    } // If appending the sort then we are multi-column sorting


    if (append && settings.oFeatures.bSortMulti) {
      // Are we already doing some kind of sort on this column?
      var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

      if (sortIdx !== -1) {
        // Yes, modify the sort
        nextSortIdx = next(sorting[sortIdx], true);

        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0; // can't remove sorting completely
        }

        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else {
        // No sort on this column yet
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      // Single column - already sorting on this column, modify the sort
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      // Single column - sort only on this column
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    } // Run the sort by calling a full redraw


    _fnReDraw(settings); // callback used for async user interaction


    if (typeof callback == 'function') {
      callback(settings);
    }
  }
  /**
   * Attach a sort handler (click) to a node
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */


  function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
    var col = settings.aoColumns[colIdx];

    _fnBindAction(attachTo, {}, function (e) {
      /* If the column is not sortable - don't to anything */
      if (col.bSortable === false) {
        return;
      } // If processing is enabled use a timeout to allow the processing
      // display to be shown - otherwise to it synchronously


      if (settings.oFeatures.bProcessing) {
        _fnProcessingDisplay(settings, true);

        setTimeout(function () {
          _fnSortListener(settings, colIdx, e.shiftKey, callback); // In server-side processing, the draw callback will remove the
          // processing display


          if (_fnDataSource(settings) !== 'ssp') {
            _fnProcessingDisplay(settings, false);
          }
        }, 0);
      } else {
        _fnSortListener(settings, colIdx, e.shiftKey, callback);
      }
    });
  }
  /**
   * Set the sorting classes on table's body, Note: it is safe to call this function
   * when bSort and bSortClasses are false
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;

    var sort = _fnSortFlatten(settings);

    var features = settings.oFeatures;
    var i, ien, colIdx;

    if (features.bSort && features.bSortClasses) {
      // Remove old sorting classes
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src; // Remove column sorting

        $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      } // Add new column sorting


      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }

    settings.aLastSort = sort;
  } // Get the data to sort a column, be it from cache, fresh (populating the
  // cache), or from a sort formatter


  function _fnSortData(settings, idx) {
    // Custom sorting function - provided by the sort data type
    var column = settings.aoColumns[idx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;

    if (customSort) {
      customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
    } // Use / populate cache


    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];

    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];

      if (!row._aSortData) {
        row._aSortData = [];
      }

      if (!row._aSortData[idx] || customSort) {
        cellData = customSort ? customData[i] : // If there was a custom sort function, use data from there
        _fnGetCellData(settings, i, idx, 'sort');
        row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
      }
    }
  }
  /**
   * Save the state of a table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnSaveState(settings) {
    if (!settings.oFeatures.bStateSave || settings.bDestroying) {
      return;
    }
    /* Store the interesting variables */


    var state = {
      time: +new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $.extend(true, [], settings.aaSorting),
      search: _fnSearchToCamel(settings.oPreviousSearch),
      columns: $.map(settings.aoColumns, function (col, i) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel(settings.aoPreSearchCols[i])
        };
      })
    };

    _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

    settings.oSavedState = state;
    settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
  }
  /**
   * Attempt to load a saved table state
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oInit DataTables init object so we can override settings
   *  @param {function} callback Callback to execute when the state has been loaded
   *  @memberof DataTable#oApi
   */


  function _fnLoadState(settings, oInit, callback) {
    var i, ien;
    var columns = settings.aoColumns;

    var loaded = function (s) {
      if (!s || !s.time) {
        callback();
        return;
      } // Allow custom and plug-in manipulation functions to alter the saved data set and
      // cancelling of loading by returning false


      var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);

      if ($.inArray(false, abStateLoad) !== -1) {
        callback();
        return;
      } // Reject old data


      var duration = settings.iStateDuration;

      if (duration > 0 && s.time < +new Date() - duration * 1000) {
        callback();
        return;
      } // Number of columns have changed - all bets are off, no restore of settings


      if (s.columns && columns.length !== s.columns.length) {
        callback();
        return;
      } // Store the saved state so it might be accessed at any time


      settings.oLoadedState = $.extend(true, {}, s); // Restore key features - todo - for 1.11 this needs to be done by
      // subscribed events

      if (s.start !== undefined) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      }

      if (s.length !== undefined) {
        settings._iDisplayLength = s.length;
      } // Order


      if (s.order !== undefined) {
        settings.aaSorting = [];
        $.each(s.order, function (i, col) {
          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
        });
      } // Search


      if (s.search !== undefined) {
        $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
      } // Columns
      //


      if (s.columns) {
        for (i = 0, ien = s.columns.length; i < ien; i++) {
          var col = s.columns[i]; // Visibility

          if (col.visible !== undefined) {
            columns[i].bVisible = col.visible;
          } // Search


          if (col.search !== undefined) {
            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
          }
        }
      }

      _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);

      callback();
    };

    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }

    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);

    if (state !== undefined) {
      loaded(state);
    } // otherwise, wait for the loaded callback to be executed

  }
  /**
   * Return the settings object for a particular table
   *  @param {node} table table we are using as a dataTable
   *  @returns {object} Settings object - or null if not found
   *  @memberof DataTable#oApi
   */


  function _fnSettingsFromNode(table) {
    var settings = DataTable.settings;
    var idx = $.inArray(table, _pluck(settings, 'nTable'));
    return idx !== -1 ? settings[idx] : null;
  }
  /**
   * Log an error message
   *  @param {object} settings dataTables settings object
   *  @param {int} level log error messages, or display them to the user
   *  @param {string} msg error message
   *  @param {int} tn Technical note id to get more information about the error.
   *  @memberof DataTable#oApi
   */


  function _fnLog(settings, level, msg, tn) {
    msg = 'DataTables warning: ' + (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

    if (tn) {
      msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
    }

    if (!level) {
      // Backwards compatibility pre 1.10
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;

      if (settings) {
        _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
      }

      if (type == 'alert') {
        alert(msg);
      } else if (type == 'throw') {
        throw new Error(msg);
      } else if (typeof type == 'function') {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  /**
   * See if a property is defined on one object, if so assign it to the other object
   *  @param {object} ret target object
   *  @param {object} src source object
   *  @param {string} name property
   *  @param {string} [mappedName] name to map too - optional, name used if not given
   *  @memberof DataTable#oApi
   */


  function _fnMap(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $.each(name, function (i, val) {
        if (Array.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }

    if (mappedName === undefined) {
      mappedName = name;
    }

    if (src[name] !== undefined) {
      ret[mappedName] = src[name];
    }
  }
  /**
   * Extend objects - very similar to jQuery.extend, but deep copy objects, and
   * shallow copy arrays. The reason we need to do this, is that we don't want to
   * deep copy array init values (such as aaSorting) since the dev wouldn't be
   * able to override them, but we do want to deep copy arrays.
   *  @param {object} out Object to extend
   *  @param {object} extender Object from which the properties will be applied to
   *      out
   *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
   *      independent copy with the exception of the `data` or `aaData` parameters
   *      if they are present. This is so you can pass in a collection to
   *      DataTables and have that used as your data source without breaking the
   *      references
   *  @returns {object} out Reference, just for convenience - out === the return.
   *  @memberof DataTable#oApi
   *  @todo This doesn't take account of arrays inside the deep copied objects.
   */


  function _fnExtend(out, extender, breakRefs) {
    var val;

    for (var prop in extender) {
      if (extender.hasOwnProperty(prop)) {
        val = extender[prop];

        if ($.isPlainObject(val)) {
          if (!$.isPlainObject(out[prop])) {
            out[prop] = {};
          }

          $.extend(true, out[prop], val);
        } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }

    return out;
  }
  /**
   * Bind an event handers to allow a click or return key to activate the callback.
   * This is good for accessibility since a return on the keyboard will have the
   * same effect as a click, if the element has focus.
   *  @param {element} n Element to bind the action to
   *  @param {object} oData Data object to pass to the triggered function
   *  @param {function} fn Callback function for when the event is triggered
   *  @memberof DataTable#oApi
   */


  function _fnBindAction(n, oData, fn) {
    $(n).on('click.DT', oData, function (e) {
      $(n).trigger('blur'); // Remove focus outline for mouse users

      fn(e);
    }).on('keypress.DT', oData, function (e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on('selectstart.DT', function () {
      /* Take the brutal approach to cancelling text selection */
      return false;
    });
  }
  /**
   * Register a callback function. Easily allows a callback function to be added to
   * an array store of callback functions that can then all be called together.
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sStore Name of the array storage for the callbacks in oSettings
   *  @param {function} fn Function to be called back
   *  @param {string} sName Identifying name for the callback (i.e. a label)
   *  @memberof DataTable#oApi
   */


  function _fnCallbackReg(oSettings, sStore, fn, sName) {
    if (fn) {
      oSettings[sStore].push({
        "fn": fn,
        "sName": sName
      });
    }
  }
  /**
   * Fire callback functions and trigger events. Note that the loop over the
   * callback array store is done backwards! Further note that you do not want to
   * fire off triggers in time sensitive applications (for example cell creation)
   * as its slow.
   *  @param {object} settings dataTables settings object
   *  @param {string} callbackArr Name of the array storage for the callbacks in
   *      oSettings
   *  @param {string} eventName Name of the jQuery custom event to trigger. If
   *      null no trigger is fired
   *  @param {array} args Array of arguments to pass to the callback function /
   *      trigger
   *  @memberof DataTable#oApi
   */


  function _fnCallbackFire(settings, callbackArr, eventName, args) {
    var ret = [];

    if (callbackArr) {
      ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
        return val.fn.apply(settings.oInstance, args);
      });
    }

    if (eventName !== null) {
      var e = $.Event(eventName + '.dt');
      $(settings.nTable).trigger(e, args);
      ret.push(e.result);
    }

    return ret;
  }

  function _fnLengthOverflow(settings) {
    var start = settings._iDisplayStart,
        end = settings.fnDisplayEnd(),
        len = settings._iDisplayLength;
    /* If we have space to show extra rows (backing up from the end point - then do so */

    if (start >= end) {
      start = end - len;
    } // Keep the start record on the current page


    start -= start % len;

    if (len === -1 || start < 0) {
      start = 0;
    }

    settings._iDisplayStart = start;
  }

  function _fnRenderer(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];

    if ($.isPlainObject(renderer) && renderer[type]) {
      // Specific renderer for this type. If available use it, otherwise use
      // the default.
      return host[renderer[type]] || host._;
    } else if (typeof renderer === 'string') {
      // Common renderer - if there is one available for this type use it,
      // otherwise use the default
      return host[renderer] || host._;
    } // Use the default


    return host._;
  }
  /**
   * Detect the data source being used for the table. Used to simplify the code
   * a little (ajax) and to make it compress a little smaller.
   *
   *  @param {object} settings dataTables settings object
   *  @returns {string} Data source
   *  @memberof DataTable#oApi
   */


  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return 'ssp';
    } else if (settings.ajax || settings.sAjaxSource) {
      return 'ajax';
    }

    return 'dom';
  }
  /**
   * Computed structure of the DataTables API, defined by the options passed to
   * `DataTable.Api.register()` when building the API.
   *
   * The structure is built in order to speed creation and extension of the Api
   * objects since the extensions are effectively pre-parsed.
   *
   * The array is an array of objects with the following structure, where this
   * base array represents the Api prototype base:
   *
   *     [
   *       {
   *         name:      'data'                -- string   - Property name
   *         val:       function () {},       -- function - Api method (or undefined if just an object
   *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
   *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
   *       },
   *       {
   *         name:     'row'
   *         val:       {},
   *         methodExt: [ ... ],
   *         propExt:   [
   *           {
   *             name:      'data'
   *             val:       function () {},
   *             methodExt: [ ... ],
   *             propExt:   [ ... ]
   *           },
   *           ...
   *         ]
   *       }
   *     ]
   *
   * @type {Array}
   * @ignore
   */


  var __apiStruct = [];
  /**
   * `Array.prototype` reference.
   *
   * @type object
   * @ignore
   */

  var __arrayProto = Array.prototype;
  /**
   * Abstraction for `context` parameter of the `Api` constructor to allow it to
   * take several different forms for ease of use.
   *
   * Each of the input parameter types will be converted to a DataTables settings
   * object where possible.
   *
   * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
   *   of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   *   * `DataTables.Api` - API instance
   * @return {array|null} Matching DataTables settings objects. `null` or
   *   `undefined` is returned if no matching DataTable is found.
   * @ignore
   */

  var _toSettings = function (mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $.map(settings, function (el, i) {
      return el.nTable;
    });

    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oApi) {
      // DataTables settings object
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
      // Table node
      idx = $.inArray(mixed, tables);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === 'function') {
      return mixed.settings().toArray();
    } else if (typeof mixed === 'string') {
      // jQuery selector
      jq = $(mixed);
    } else if (mixed instanceof $) {
      // jQuery object (also DataTables instance)
      jq = mixed;
    }

    if (jq) {
      return jq.map(function (i) {
        idx = $.inArray(this, tables);
        return idx !== -1 ? settings[idx] : null;
      }).toArray();
    }
  };
  /**
   * DataTables API class - used to control and interface with  one or more
   * DataTables enhanced tables.
   *
   * The API class is heavily based on jQuery, presenting a chainable interface
   * that you can use to interact with tables. Each instance of the API class has
   * a "context" - i.e. the tables that it will operate on. This could be a single
   * table, all tables on a page or a sub-set thereof.
   *
   * Additionally the API is designed to allow you to easily work with the data in
   * the tables, retrieving and manipulating it as required. This is done by
   * presenting the API class as an array like interface. The contents of the
   * array depend upon the actions requested by each method (for example
   * `rows().nodes()` will return an array of nodes, while `rows().data()` will
   * return an array of objects or arrays depending upon your table's
   * configuration). The API object has a number of array like methods (`push`,
   * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
   * `unique` etc) to assist your working with the data held in a table.
   *
   * Most methods (those which return an Api instance) are chainable, which means
   * the return from a method call also has all of the methods available that the
   * top level object had. For example, these two calls are equivalent:
   *
   *     // Not chained
   *     api.row.add( {...} );
   *     api.draw();
   *
   *     // Chained
   *     api.row.add( {...} ).draw();
   *
   * @class DataTable.Api
   * @param {array|object|string|jQuery} context DataTable identifier. This is
   *   used to define which DataTables enhanced tables this API will operate on.
   *   Can be one of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   * @param {array} [data] Data to initialise the Api instance with.
   *
   * @example
   *   // Direct initialisation during DataTables construction
   *   var api = $('#example').DataTable();
   *
   * @example
   *   // Initialisation using a DataTables jQuery object
   *   var api = $('#example').dataTable().api();
   *
   * @example
   *   // Initialisation as a constructor
   *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
   */


  _Api = function (context, data) {
    if (!(this instanceof _Api)) {
      return new _Api(context, data);
    }

    var settings = [];

    var ctxSettings = function (o) {
      var a = _toSettings(o);

      if (a) {
        settings.push.apply(settings, a);
      }
    };

    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    } // Remove duplicates


    this.context = _unique(settings); // Initial data

    if (data) {
      $.merge(this, data);
    } // selector


    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };

    _Api.extend(this, this, __apiStruct);
  };

  DataTable.Api = _Api; // Don't destroy the existing prototype, just extend it. Required for jQuery 2's
  // isPlainObject.

  $.extend(_Api.prototype, {
    any: function () {
      return this.count() !== 0;
    },
    concat: __arrayProto.concat,
    context: [],
    // array of table settings objects
    count: function () {
      return this.flatten().length;
    },
    each: function (fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }

      return this;
    },
    eq: function (idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
    },
    filter: function (fn) {
      var a = [];

      if (__arrayProto.filter) {
        a = __arrayProto.filter.call(this, fn, this);
      } else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for (var i = 0, ien = this.length; i < ien; i++) {
          if (fn.call(this, this[i], i, this)) {
            a.push(this[i]);
          }
        }
      }

      return new _Api(this.context, a);
    },
    flatten: function () {
      var a = [];
      return new _Api(this.context, a.concat.apply(a, this.toArray()));
    },
    join: __arrayProto.join,
    indexOf: __arrayProto.indexOf || function (obj, start) {
      for (var i = start || 0, ien = this.length; i < ien; i++) {
        if (this[i] === obj) {
          return i;
        }
      }

      return -1;
    },
    iterator: function (flatten, type, fn, alwaysNew) {
      var a = [],
          ret,
          i,
          ien,
          j,
          jen,
          context = this.context,
          rows,
          items,
          item,
          selector = this.selector; // Argument shifting

      if (typeof flatten === 'string') {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }

      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api(context[i]);

        if (type === 'table') {
          ret = fn.call(apiInst, context[i], i);

          if (ret !== undefined) {
            a.push(ret);
          }
        } else if (type === 'columns' || type === 'rows') {
          // this has same length as context - one entry for each table
          ret = fn.call(apiInst, context[i], this[i], i);

          if (ret !== undefined) {
            a.push(ret);
          }
        } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
          // columns and rows share the same structure.
          // 'this' is an array of column indexes for each context
          items = this[i];

          if (type === 'column-rows') {
            rows = _selector_row_indexes(context[i], selector.opts);
          }

          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];

            if (type === 'cell') {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }

            if (ret !== undefined) {
              a.push(ret);
            }
          }
        }
      }

      if (a.length || alwaysNew) {
        var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }

      return this;
    },
    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
      // Bit cheeky...
      return this.indexOf.apply(this.toArray.reverse(), arguments);
    },
    length: 0,
    map: function (fn) {
      var a = [];

      if (__arrayProto.map) {
        a = __arrayProto.map.call(this, fn, this);
      } else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for (var i = 0, ien = this.length; i < ien; i++) {
          a.push(fn.call(this, this[i], i));
        }
      }

      return new _Api(this.context, a);
    },
    pluck: function (prop) {
      return this.map(function (el) {
        return el[prop];
      });
    },
    pop: __arrayProto.pop,
    push: __arrayProto.push,
    // Does not return an API instance
    reduce: __arrayProto.reduce || function (fn, init) {
      return _fnReduce(this, fn, init, 0, this.length, 1);
    },
    reduceRight: __arrayProto.reduceRight || function (fn, init) {
      return _fnReduce(this, fn, init, this.length - 1, -1, -1);
    },
    reverse: __arrayProto.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto.shift,
    slice: function () {
      return new _Api(this.context, this);
    },
    sort: __arrayProto.sort,
    // ? name - order?
    splice: __arrayProto.splice,
    toArray: function () {
      return __arrayProto.slice.call(this);
    },
    to$: function () {
      return $(this);
    },
    toJQuery: function () {
      return $(this);
    },
    unique: function () {
      return new _Api(this.context, _unique(this));
    },
    unshift: __arrayProto.unshift
  });

  _Api.extend = function (scope, obj, ext) {
    // Only extend API instances and static properties of the API
    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
      return;
    }

    var i,
        ien,
        struct,
        methodScoping = function (scope, fn, struc) {
      return function () {
        var ret = fn.apply(scope, arguments); // Method extension

        _Api.extend(ret, ret, struc.methodExt);

        return ret;
      };
    };

    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i]; // Value

      obj[struct.name] = struct.type === 'function' ? methodScoping(scope, struct.val, struct) : struct.type === 'object' ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true; // Property extension

      _Api.extend(scope, obj[struct.name], struct.propExt);
    }
  }; // @todo - Is there need for an augment function?
  // _Api.augment = function ( inst, name )
  // {
  // 	// Find src object in the structure from the name
  // 	var parts = name.split('.');
  // 	_Api.extend( inst, obj );
  // };
  //     [
  //       {
  //         name:      'data'                -- string   - Property name
  //         val:       function () {},       -- function - Api method (or undefined if just an object
  //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
  //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  //       },
  //       {
  //         name:     'row'
  //         val:       {},
  //         methodExt: [ ... ],
  //         propExt:   [
  //           {
  //             name:      'data'
  //             val:       function () {},
  //             methodExt: [ ... ],
  //             propExt:   [ ... ]
  //           },
  //           ...
  //         ]
  //       }
  //     ]


  _Api.register = _api_register = function (name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api.register(name[j], val);
      }

      return;
    }

    var i,
        ien,
        heir = name.split('.'),
        struct = __apiStruct,
        key,
        method;

    var find = function (src, name) {
      for (var i = 0, ien = src.length; i < ien; i++) {
        if (src[i].name === name) {
          return src[i];
        }
      }

      return null;
    };

    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf('()') !== -1;
      key = method ? heir[i].replace('()', '') : heir[i];
      var src = find(struct, key);

      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: 'object'
        };
        struct.push(src);
      }

      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === 'function' ? 'function' : $.isPlainObject(val) ? 'object' : 'other';
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };

  _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {
    _Api.register(pluralName, val);

    _Api.register(singularName, function () {
      var ret = val.apply(this, arguments);

      if (ret === this) {
        // Returned item is the API instance that was passed in, return it
        return this;
      } else if (ret instanceof _Api) {
        // New API instance returned, want the value from the first item
        // in the returned array for the singular result.
        return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : // Array results are 'enhanced'
        ret[0] : undefined;
      } // Non-API return - just fire it back


      return ret;
    });
  };
  /**
   * Selector for HTML tables. Apply the given selector to the give array of
   * DataTables settings objects.
   *
   * @param {string|integer} [selector] jQuery selector string or integer
   * @param  {array} Array of DataTables settings objects to be filtered
   * @return {array}
   * @ignore
   */


  var __table_selector = function (selector, a) {
    if (Array.isArray(selector)) {
      return $.map(selector, function (item) {
        return __table_selector(item, a);
      });
    } // Integer is used to pick out a table by index


    if (typeof selector === 'number') {
      return [a[selector]];
    } // Perform a jQuery selector on the table nodes


    var nodes = $.map(a, function (el, i) {
      return el.nTable;
    });
    return $(nodes).filter(selector).map(function (i) {
      // Need to translate back from the table node to the settings
      var idx = $.inArray(this, nodes);
      return a[idx];
    }).toArray();
  };
  /**
   * Context selector for the API's context (i.e. the tables the API instance
   * refers to.
   *
   * @name    DataTable.Api#tables
   * @param {string|integer} [selector] Selector to pick which tables the iterator
   *   should operate on. If not given, all tables in the current context are
   *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
   *   select multiple tables or as an integer to select a single table.
   * @returns {DataTable.Api} Returns a new API instance if a selector is given.
   */


  _api_register('tables()', function (selector) {
    // A new instance is created if there was a selector specified
    return selector !== undefined && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;
  });

  _api_register('table()', function (selector) {
    var tables = this.tables(selector);
    var ctx = tables.context; // Truncate to the first matched table

    return ctx.length ? new _Api(ctx[0]) : tables;
  });

  _api_registerPlural('tables().nodes()', 'table().node()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTable;
    }, 1);
  });

  _api_registerPlural('tables().body()', 'table().body()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTBody;
    }, 1);
  });

  _api_registerPlural('tables().header()', 'table().header()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTHead;
    }, 1);
  });

  _api_registerPlural('tables().footer()', 'table().footer()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTFoot;
    }, 1);
  });

  _api_registerPlural('tables().containers()', 'table().container()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  /**
   * Redraw the tables in the current context.
   */


  _api_register('draw()', function (paging) {
    return this.iterator('table', function (settings) {
      if (paging === 'page') {
        _fnDraw(settings);
      } else {
        if (typeof paging === 'string') {
          paging = paging === 'full-hold' ? false : true;
        }

        _fnReDraw(settings, paging === false);
      }
    });
  });
  /**
   * Get the current page index.
   *
   * @return {integer} Current page index (zero based)
   */

  /**
  * Set the current page.
  *
  * Note that if you attempt to show a page which does not exist, DataTables will
  * not throw an error, but rather reset the paging.
  *
  * @param {integer|string} action The paging action to take. This can be one of:
  *  * `integer` - The page index to jump to
  *  * `string` - An action to take:
  *    * `first` - Jump to first page.
  *    * `next` - Jump to the next page
  *    * `previous` - Jump to previous page
  *    * `last` - Jump to the last page.
  * @returns {DataTables.Api} this
  */


  _api_register('page()', function (action) {
    if (action === undefined) {
      return this.page.info().page; // not an expensive call
    } // else, have an action to take on all tables


    return this.iterator('table', function (settings) {
      _fnPageChange(settings, action);
    });
  });
  /**
   * Paging information for the first table in the current context.
   *
   * If you require paging information for another table, use the `table()` method
   * with a suitable selector.
   *
   * @return {object} Object with the following properties set:
   *  * `page` - Current page index (zero based - i.e. the first page is `0`)
   *  * `pages` - Total number of pages
   *  * `start` - Display index for the first record shown on the current page
   *  * `end` - Display index for the last record shown on the current page
   *  * `length` - Display length (number of records). Note that generally `start
   *    + length = end`, but this is not always true, for example if there are
   *    only 2 records to show on the final page, with a length of 10.
   *  * `recordsTotal` - Full data set length
   *  * `recordsDisplay` - Data set length once the current filtering criterion
   *    are applied.
   */


  _api_register('page.info()', function (action) {
    if (this.context.length === 0) {
      return undefined;
    }

    var settings = this.context[0],
        start = settings._iDisplayStart,
        len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
        visRecords = settings.fnRecordsDisplay(),
        all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource(settings) === 'ssp'
    };
  });
  /**
   * Get the current page length.
   *
   * @return {integer} Current page length. Note `-1` indicates that all records
   *   are to be shown.
   */

  /**
  * Set the current page length.
  *
  * @param {integer} Page length to set. Use `-1` to show all records.
  * @returns {DataTables.Api} this
  */


  _api_register('page.len()', function (len) {
    // Note that we can't call this function 'length()' because `length`
    // is a Javascript property of functions which defines how many arguments
    // the function expects.
    if (len === undefined) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
    } // else, set the page length


    return this.iterator('table', function (settings) {
      _fnLengthChange(settings, len);
    });
  });

  var __reload = function (settings, holdPosition, callback) {
    // Use the draw event to trigger a callback
    if (callback) {
      var api = new _Api(settings);
      api.one('draw', function () {
        callback(api.ajax.json());
      });
    }

    if (_fnDataSource(settings) == 'ssp') {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true); // Cancel an existing request


      var xhr = settings.jqXHR;

      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      } // Trigger xhr


      _fnBuildAjax(settings, [], function (json) {
        _fnClearTable(settings);

        var data = _fnAjaxDataSrc(settings, json);

        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }

        _fnReDraw(settings, holdPosition);

        _fnProcessingDisplay(settings, false);
      });
    }
  };
  /**
   * Get the JSON response from the last Ajax request that DataTables made to the
   * server. Note that this returns the JSON from the first table in the current
   * context.
   *
   * @return {object} JSON received from the server.
   */


  _api_register('ajax.json()', function () {
    var ctx = this.context;

    if (ctx.length > 0) {
      return ctx[0].json;
    } // else return undefined;

  });
  /**
   * Get the data submitted in the last Ajax request
   */


  _api_register('ajax.params()', function () {
    var ctx = this.context;

    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    } // else return undefined;

  });
  /**
   * Reload tables from the Ajax data source. Note that this function will
   * automatically re-draw the table when the remote data has been loaded.
   *
   * @param {boolean} [reset=true] Reset (default) or hold the current paging
   *   position. A full re-sort and re-filter is performed when this method is
   *   called, which is why the pagination reset is the default action.
   * @returns {DataTables.Api} this
   */


  _api_register('ajax.reload()', function (callback, resetPaging) {
    return this.iterator('table', function (settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  /**
   * Get the current Ajax URL. Note that this returns the URL from the first
   * table in the current context.
   *
   * @return {string} Current Ajax source URL
   */

  /**
  * Set the Ajax URL. Note that this will set the URL for all tables in the
  * current context.
  *
  * @param {string} url URL to set.
  * @returns {DataTables.Api} this
  */


  _api_register('ajax.url()', function (url) {
    var ctx = this.context;

    if (url === undefined) {
      // get
      if (ctx.length === 0) {
        return undefined;
      }

      ctx = ctx[0];
      return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
    } // set


    return this.iterator('table', function (settings) {
      if ($.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      } // No need to consider sAjaxSource here since DataTables gives priority
      // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
      // value of `sAjaxSource` redundant.

    });
  });
  /**
   * Load data from the newly set Ajax URL. Note that this method is only
   * available when `ajax.url()` is used to set a URL. Additionally, this method
   * has the same effect as calling `ajax.reload()` but is provided for
   * convenience when setting a new URL. Like `ajax.reload()` it will
   * automatically redraw the table once the remote data has been loaded.
   *
   * @returns {DataTables.Api} this
   */


  _api_register('ajax.url().load()', function (callback, resetPaging) {
    // Same as a reload, but makes sense to present it for easy access after a
    // url change
    return this.iterator('table', function (ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });

  var _selector_run = function (type, selector, selectFn, settings, opts) {
    var out = [],
        res,
        a,
        i,
        ien,
        j,
        jen,
        selectorType = typeof selector; // Can't just check for isArray here, as an API or jQuery instance might be
    // given with their array like look

    if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
      selector = [selector];
    }

    for (i = 0, ien = selector.length; i < ien; i++) {
      // Only split on simple strings - complex expressions will be jQuery selectors
      a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(',') : [selector[i]];

      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === 'string' ? a[j].trim() : a[j]);

        if (res && res.length) {
          out = out.concat(res);
        }
      }
    } // selector extensions


    var ext = _ext.selector[type];

    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }

    return _unique(out);
  };

  var _selector_opts = function (opts) {
    if (!opts) {
      opts = {};
    } // Backwards compatibility for 1.9- which used the terminology filter rather
    // than search


    if (opts.filter && opts.search === undefined) {
      opts.search = opts.filter;
    }

    return $.extend({
      search: 'none',
      order: 'current',
      page: 'all'
    }, opts);
  };

  var _selector_first = function (inst) {
    // Reduce the API instance to the first item found
    for (var i = 0, ien = inst.length; i < ien; i++) {
      if (inst[i].length > 0) {
        // Assign the first element to the first item in the instance
        // and truncate the instance and context
        inst[0] = inst[i];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [inst.context[i]];
        return inst;
      }
    } // Not found - return an empty instance


    inst.length = 0;
    return inst;
  };

  var _selector_row_indexes = function (settings, opts) {
    var i,
        ien,
        tmp,
        a = [],
        displayFiltered = settings.aiDisplay,
        displayMaster = settings.aiDisplayMaster;
    var search = opts.search,
        // none, applied, removed
    order = opts.order,
        // applied, current, index (original - compatibility with 1.9)
    page = opts.page; // all, current

    if (_fnDataSource(settings) == 'ssp') {
      // In server-side processing mode, most options are irrelevant since
      // rows not shown don't exist and the index order is the applied order
      // Removed is a special case - for consistency just return an empty
      // array
      return search === 'removed' ? [] : _range(0, displayMaster.length);
    } else if (page == 'current') {
      // Current page implies that order=current and fitler=applied, since it is
      // fairly senseless otherwise, regardless of what order and search actually
      // are
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == 'current' || order == 'applied') {
      if (search == 'none') {
        a = displayMaster.slice();
      } else if (search == 'applied') {
        a = displayFiltered.slice();
      } else if (search == 'removed') {
        // O(n+m) solution by creating a hash map
        var displayFilteredMap = {};

        for (var i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }

        a = $.map(displayMaster, function (el) {
          return !displayFilteredMap.hasOwnProperty(el) ? el : null;
        });
      }
    } else if (order == 'index' || order == 'original') {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (search == 'none') {
          a.push(i);
        } else {
          // applied | removed
          tmp = $.inArray(i, displayFiltered);

          if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
            a.push(i);
          }
        }
      }
    }

    return a;
  };
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Rows
   *
   * {}          - no selector - use all available rows
   * {integer}   - row aoData index
   * {node}      - TR node
   * {string}    - jQuery selector to apply to the TR elements
   * {array}     - jQuery array of nodes, or simply an array of TR nodes
   *
   */


  var __row_selector = function (settings, selector, opts) {
    var rows;

    var run = function (sel) {
      var selInt = _intVal(sel);

      var i, ien;
      var aoData = settings.aoData; // Short cut - selector is a number and no options provided (default is
      // all records, so no need to check if the index is in there, since it
      // must be - dev error if the index doesn't exist).

      if (selInt !== null && !opts) {
        return [selInt];
      }

      if (!rows) {
        rows = _selector_row_indexes(settings, opts);
      }

      if (selInt !== null && $.inArray(selInt, rows) !== -1) {
        // Selector - integer
        return [selInt];
      } else if (sel === null || sel === undefined || sel === '') {
        // Selector - none
        return rows;
      } // Selector - function


      if (typeof sel === 'function') {
        return $.map(rows, function (idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      } // Selector - node


      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex; // Property added by DT for fast lookup

        var cellIdx = sel._DT_CellIndex;

        if (rowIdx !== undefined) {
          // Make sure that the row is actually still present in the table
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $(sel).closest('*[data-dt-row]');
          return host.length ? [host.data('dt-row')] : [];
        }
      } // ID selector. Want to always be able to select rows by id, regardless
      // of if the tr element has been created or not, so can't rely upon
      // jQuery here - hence a custom implementation. This does not match
      // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
      // but to select it using a CSS selector engine (like Sizzle or
      // querySelect) it would need to need to be escaped for some characters.
      // DataTables simplifies this for row selectors since you can select
      // only a row. A # indicates an id any anything that follows is the id -
      // unescaped.


      if (typeof sel === 'string' && sel.charAt(0) === '#') {
        // get row index from id
        var rowObj = settings.aIds[sel.replace(/^#/, '')];

        if (rowObj !== undefined) {
          return [rowObj.idx];
        } // need to fall through to jQuery in case there is DOM id that
        // matches

      } // Get nodes in the order from the `rows` array with null values removed


      var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr')); // Selector - jQuery selector string, array of nodes or jQuery object/
      // As jQuery's .filter() allows jQuery objects to be passed in filter,
      // it also allows arrays, so this will cope with all three options


      return $(nodes).filter(sel).map(function () {
        return this._DT_RowIndex;
      }).toArray();
    };

    return _selector_run('row', selector, run, settings, opts);
  };

  _api_register('rows()', function (selector, opts) {
    // argument shifting
    if (selector === undefined) {
      selector = '';
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts(opts);
    var inst = this.iterator('table', function (settings) {
      return __row_selector(settings, selector, opts);
    }, 1); // Want argument shifting here and in __row_selector?

    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });

  _api_register('rows().nodes()', function () {
    return this.iterator('row', function (settings, row) {
      return settings.aoData[row].nTr || undefined;
    }, 1);
  });

  _api_register('rows().data()', function () {
    return this.iterator(true, 'rows', function (settings, rows) {
      return _pluck_order(settings.aoData, rows, '_aData');
    }, 1);
  });

  _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
    return this.iterator('row', function (settings, row) {
      var r = settings.aoData[row];
      return type === 'search' ? r._aFilterData : r._aSortData;
    }, 1);
  });

  _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
    return this.iterator('row', function (settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });

  _api_registerPlural('rows().indexes()', 'row().index()', function () {
    return this.iterator('row', function (settings, row) {
      return row;
    }, 1);
  });

  _api_registerPlural('rows().ids()', 'row().id()', function (hash) {
    var a = [];
    var context = this.context; // `iterator` will drop undefined values, but in this case we want them

    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? '#' : '') + id);
      }
    }

    return new _Api(context, a);
  });

  _api_registerPlural('rows().remove()', 'row().remove()', function () {
    var that = this;
    this.iterator('row', function (settings, row, thatIdx) {
      var data = settings.aoData;
      var rowData = data[row];
      var i, ien, j, jen;
      var loopRow, loopCells;
      data.splice(row, 1); // Update the cached indexes

      for (i = 0, ien = data.length; i < ien; i++) {
        loopRow = data[i];
        loopCells = loopRow.anCells; // Rows

        if (loopRow.nTr !== null) {
          loopRow.nTr._DT_RowIndex = i;
        } // Cells


        if (loopCells !== null) {
          for (j = 0, jen = loopCells.length; j < jen; j++) {
            loopCells[j]._DT_CellIndex.row = i;
          }
        }
      } // Delete from the display arrays


      _fnDeleteIndex(settings.aiDisplayMaster, row);

      _fnDeleteIndex(settings.aiDisplay, row);

      _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes
      // For server-side processing tables - subtract the deleted row from the count


      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      } // Check for an 'overflow' they case for displaying the table


      _fnLengthOverflow(settings); // Remove the row's ID reference if there is one


      var id = settings.rowIdFn(rowData._aData);

      if (id !== undefined) {
        delete settings.aIds[id];
      }
    });
    this.iterator('table', function (settings) {
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        settings.aoData[i].idx = i;
      }
    });
    return this;
  });

  _api_register('rows.add()', function (rows) {
    var newRows = this.iterator('table', function (settings) {
      var row, i, ien;
      var out = [];

      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];

        if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }

      return out;
    }, 1); // Return an Api.rows() extended instance, so rows().nodes() etc can be used

    var modRows = this.rows(-1);
    modRows.pop();
    $.merge(modRows, newRows);
    return modRows;
  });
  /**
   *
   */


  _api_register('row()', function (selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });

  _api_register('row().data()', function (data) {
    var ctx = this.context;

    if (data === undefined) {
      // Get
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
    } // Set


    var row = ctx[0].aoData[this[0]];
    row._aData = data; // If the DOM has an id, and the data source is an array

    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
    } // Automatically invalidate


    _fnInvalidate(ctx[0], this[0], 'data');

    return this;
  });

  _api_register('row().node()', function () {
    var ctx = this.context;
    return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
  });

  _api_register('row.add()', function (row) {
    // Allow a jQuery object to be passed in - only a single row is added from
    // it though - the first element in the set
    if (row instanceof $ && row.length) {
      row = row[0];
    }

    var rows = this.iterator('table', function (settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
        return _fnAddTr(settings, row)[0];
      }

      return _fnAddData(settings, row);
    }); // Return an Api.rows() extended instance, with the newly added row selected

    return this.row(rows[0]);
  });

  var __details_add = function (ctx, row, data, klass) {
    // Convert to array of TR elements
    var rows = [];

    var addRow = function (r, k) {
      // Recursion to allow for arrays of jQuery objects
      if (Array.isArray(r) || r instanceof $) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }

        return;
      } // If we get a TR element, then just add it directly - up to the dev
      // to add the correct number of columns etc


      if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
        rows.push(r);
      } else {
        // Otherwise create a row with a wrapper
        var created = $('<tr><td></td></tr>').addClass(k);
        $('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };

    addRow(data, klass);

    if (row._details) {
      row._details.detach();
    }

    row._details = $(rows); // If the children were already shown, that state should be retained

    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };

  var __details_remove = function (api, idx) {
    var ctx = api.context;

    if (ctx.length) {
      var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

      if (row && row._details) {
        row._details.remove();

        row._detailsShow = undefined;
        row._details = undefined;
      }
    }
  };

  var __details_display = function (api, show) {
    var ctx = api.context;

    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];

      if (row._details) {
        row._detailsShow = show;

        if (show) {
          row._details.insertAfter(row.nTr);
        } else {
          row._details.detach();
        }

        __details_events(ctx[0]);
      }
    }
  };

  var __details_events = function (settings) {
    var api = new _Api(settings);
    var namespace = '.dt.DT_details';
    var drawEvent = 'draw' + namespace;
    var colvisEvent = 'column-visibility' + namespace;
    var destroyEvent = 'destroy' + namespace;
    var data = settings.aoData;
    api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

    if (_pluck(data, '_details').length > 0) {
      // On each draw, insert the required elements into the document
      api.on(drawEvent, function (e, ctx) {
        if (settings !== ctx) {
          return;
        }

        api.rows({
          page: 'current'
        }).eq(0).each(function (idx) {
          // Internal data grab
          var row = data[idx];

          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      }); // Column visibility change - update the colspan

      api.on(colvisEvent, function (e, ctx, idx, vis) {
        if (settings !== ctx) {
          return;
        } // Update the colspan for the details rows (note, only if it already has
        // a colspan)


        var row,
            visible = _fnVisbleColumns(ctx);

        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];

          if (row._details) {
            row._details.children('td[colspan]').attr('colspan', visible);
          }
        }
      }); // Table destroyed - nuke any child rows

      api.on(destroyEvent, function (e, ctx) {
        if (settings !== ctx) {
          return;
        }

        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i]._details) {
            __details_remove(api, i);
          }
        }
      });
    }
  }; // Strings for the method names to help minification


  var _emp = '';

  var _child_obj = _emp + 'row().child';

  var _child_mth = _child_obj + '()'; // data can be:
  //  tr
  //  string
  //  jQuery or array of any of the above


  _api_register(_child_mth, function (data, klass) {
    var ctx = this.context;

    if (data === undefined) {
      // get
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
    } else if (data === true) {
      // show
      this.child.show();
    } else if (data === false) {
      // remove
      __details_remove(this);
    } else if (ctx.length && this.length) {
      // set
      __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }

    return this;
  });

  _api_register([_child_obj + '.show()', _child_mth + '.show()' // only when `child()` was called with parameters (without
  ], function (show) {
    // it returns an object and this method is not executed)
    __details_display(this, true);

    return this;
  });

  _api_register([_child_obj + '.hide()', _child_mth + '.hide()' // only when `child()` was called with parameters (without
  ], function () {
    // it returns an object and this method is not executed)
    __details_display(this, false);

    return this;
  });

  _api_register([_child_obj + '.remove()', _child_mth + '.remove()' // only when `child()` was called with parameters (without
  ], function () {
    // it returns an object and this method is not executed)
    __details_remove(this);

    return this;
  });

  _api_register(_child_obj + '.isShown()', function () {
    var ctx = this.context;

    if (ctx.length && this.length) {
      // _detailsShown as false or undefined will fall through to return false
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }

    return false;
  });
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Columns
   *
   * {integer}           - column index (>=0 count from left, <0 count from right)
   * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
   * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
   * "{string}:name"     - column name
   * "{string}"          - jQuery selector on column header nodes
   *
   */
  // can be an array of these items, comma separated list, or an array of comma
  // separated lists


  var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/; // r1 and r2 are redundant - but it means that the parameters match for the
  // iterator callback in columns().data()

  var __columnData = function (settings, column, r1, r2, rows) {
    var a = [];

    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData(settings, rows[row], column));
    }

    return a;
  };

  var __column_selector = function (settings, selector, opts) {
    var columns = settings.aoColumns,
        names = _pluck(columns, 'sName'),
        nodes = _pluck(columns, 'nTh');

    var run = function (s) {
      var selInt = _intVal(s); // Selector - all


      if (s === '') {
        return _range(columns.length);
      } // Selector - index


      if (selInt !== null) {
        return [selInt >= 0 ? selInt : // Count from left
        columns.length + selInt // Count from right (+ because its a negative value)
        ];
      } // Selector = function


      if (typeof s === 'function') {
        var rows = _selector_row_indexes(settings, opts);

        return $.map(columns, function (col, idx) {
          return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
        });
      } // jQuery or string selector


      var match = typeof s === 'string' ? s.match(__re_column_selector) : '';

      if (match) {
        switch (match[2]) {
          case 'visIdx':
          case 'visible':
            var idx = parseInt(match[1], 10); // Visible index given, convert to column index

            if (idx < 0) {
              // Counting from the right
              var visColumns = $.map(columns, function (col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            } // Counting from the left


            return [_fnVisibleToColumnIndex(settings, idx)];

          case 'name':
            // match by name. `names` is column index complete and in order
            return $.map(names, function (name, i) {
              return name === match[1] ? i : null;
            });

          default:
            return [];
        }
      } // Cell in the table body


      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      } // jQuery selector on the TH elements for the columns


      var jqResult = $(nodes).filter(s).map(function () {
        return $.inArray(this, nodes); // `nodes` is column index complete and in order
      }).toArray();

      if (jqResult.length || !s.nodeName) {
        return jqResult;
      } // Otherwise a node which might have a `dt-column` data attribute, or be
      // a child or such an element


      var host = $(s).closest('*[data-dt-column]');
      return host.length ? [host.data('dt-column')] : [];
    };

    return _selector_run('column', selector, run, settings, opts);
  };

  var __setColumnVis = function (settings, column, vis) {
    var cols = settings.aoColumns,
        col = cols[column],
        data = settings.aoData,
        row,
        cells,
        i,
        ien,
        tr; // Get

    if (vis === undefined) {
      return col.bVisible;
    } // Set
    // No change


    if (col.bVisible === vis) {
      return;
    }

    if (vis) {
      // Insert column
      // Need to decide if we should use appendChild or insertBefore
      var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

      for (i = 0, ien = data.length; i < ien; i++) {
        tr = data[i].nTr;
        cells = data[i].anCells;

        if (tr) {
          // insertBefore can act like appendChild if 2nd arg is null
          tr.insertBefore(cells[column], cells[insertBefore] || null);
        }
      }
    } else {
      // Remove column
      $(_pluck(settings.aoData, 'anCells', column)).detach();
    } // Common actions


    col.bVisible = vis;
  };

  _api_register('columns()', function (selector, opts) {
    // argument shifting
    if (selector === undefined) {
      selector = '';
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts(opts);
    var inst = this.iterator('table', function (settings) {
      return __column_selector(settings, selector, opts);
    }, 1); // Want argument shifting here and in _row_selector?

    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });

  _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].nTh;
    }, 1);
  });

  _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].nTf;
    }, 1);
  });

  _api_registerPlural('columns().data()', 'column().data()', function () {
    return this.iterator('column-rows', __columnData, 1);
  });

  _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });

  _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
    return this.iterator('column-rows', function (settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
    }, 1);
  });

  _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
    return this.iterator('column-rows', function (settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, 'anCells', column);
    }, 1);
  });

  _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
    var that = this;
    var ret = this.iterator('column', function (settings, column) {
      if (vis === undefined) {
        return settings.aoColumns[column].bVisible;
      } // else


      __setColumnVis(settings, column, vis);
    }); // Group the column visibility changes

    if (vis !== undefined) {
      this.iterator('table', function (settings) {
        // Redraw the header after changes
        _fnDrawHead(settings, settings.aoHeader);

        _fnDrawHead(settings, settings.aoFooter); // Update colspan for no records display. Child rows and extensions will use their own
        // listeners to do this - only need to update the empty table item here


        if (!settings.aiDisplay.length) {
          $(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
        }

        _fnSaveState(settings); // Second loop once the first is done for events


        that.iterator('column', function (settings, column) {
          _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
        });

        if (calc === undefined || calc) {
          that.columns.adjust();
        }
      });
    }

    return ret;
  });

  _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
    return this.iterator('column', function (settings, column) {
      return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });

  _api_register('columns.adjust()', function () {
    return this.iterator('table', function (settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });

  _api_register('column.index()', function (type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];

      if (type === 'fromVisible' || type === 'toData') {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else if (type === 'fromData' || type === 'toVisible') {
        return _fnColumnIndexToVisible(ctx, idx);
      }
    }
  });

  _api_register('column()', function (selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });

  var __cell_selector = function (settings, selector, opts) {
    var data = settings.aoData;

    var rows = _selector_row_indexes(settings, opts);

    var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));

    var allCells = $(_flatten([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;

    var run = function (s) {
      var fnSelector = typeof s === 'function';

      if (s === null || s === undefined || fnSelector) {
        // All cells and function selectors
        a = [];

        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];

          for (j = 0; j < columns; j++) {
            o = {
              row: row,
              column: j
            };

            if (fnSelector) {
              // Selector - function
              host = data[row];

              if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              // Selector - all
              a.push(o);
            }
          }
        }

        return a;
      } // Selector - index


      if ($.isPlainObject(s)) {
        // Valid cell index and its in the array of selectable rows
        return s.column !== undefined && s.row !== undefined && $.inArray(s.row, rows) !== -1 ? [s] : [];
      } // Selector - jQuery filtered cells


      var jqResult = allCells.filter(s).map(function (i, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();

      if (jqResult.length || !s.nodeName) {
        return jqResult;
      } // Otherwise the selector is a node, and there is one last option - the
      // element might be a child of an element which has dt-row and dt-column
      // data attributes


      host = $(s).closest('*[data-dt-row]');
      return host.length ? [{
        row: host.data('dt-row'),
        column: host.data('dt-column')
      }] : [];
    };

    return _selector_run('cell', selector, run, settings, opts);
  };

  _api_register('cells()', function (rowSelector, columnSelector, opts) {
    // Argument shifting
    if ($.isPlainObject(rowSelector)) {
      // Indexes
      if (rowSelector.row === undefined) {
        // Selector options in first parameter
        opts = rowSelector;
        rowSelector = null;
      } else {
        // Cell index objects in first parameter
        opts = columnSelector;
        columnSelector = null;
      }
    }

    if ($.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    } // Cell selector


    if (columnSelector === null || columnSelector === undefined) {
      return this.iterator('table', function (settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    } // The default built in options need to apply to row and columns


    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {}; // Row + column selector

    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator('table', function (settings, idx) {
      var a = [];

      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }

      return a;
    }, 1); // There is currently only one extension which uses a cell selector extension
    // It is a _major_ performance drag to run this if it isn't needed, so this is
    // an extension specific check at the moment

    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts: opts
    });
    return cells;
  });

  _api_registerPlural('cells().nodes()', 'cell().node()', function () {
    return this.iterator('cell', function (settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : undefined;
    }, 1);
  });

  _api_register('cells().data()', function () {
    return this.iterator('cell', function (settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });

  _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
    type = type === 'search' ? '_aFilterData' : '_aSortData';
    return this.iterator('cell', function (settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });

  _api_registerPlural('cells().render()', 'cell().render()', function (type) {
    return this.iterator('cell', function (settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });

  _api_registerPlural('cells().indexes()', 'cell().index()', function () {
    return this.iterator('cell', function (settings, row, column) {
      return {
        row: row,
        column: column,
        columnVisible: _fnColumnIndexToVisible(settings, column)
      };
    }, 1);
  });

  _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
    return this.iterator('cell', function (settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });

  _api_register('cell()', function (rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });

  _api_register('cell().data()', function (data) {
    var ctx = this.context;
    var cell = this[0];

    if (data === undefined) {
      // Get
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
    } // Set


    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);

    _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

    return this;
  });
  /**
   * Get current ordering (sorting) that has been applied to the table.
   *
   * @returns {array} 2D array containing the sorting information for the first
   *   table in the current context. Each element in the parent array represents
   *   a column being sorted upon (i.e. multi-sorting with two columns would have
   *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
   *   the column index that the sorting condition applies to, the second is the
   *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
   *   index of the sorting order from the `column.sorting` initialisation array.
   */

  /**
  * Set the ordering for the table.
  *
  * @param {integer} order Column index to sort upon.
  * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
  * @returns {DataTables.Api} this
  */

  /**
  * Set the ordering for the table.
  *
  * @param {array} order 1D array of sorting information to be applied.
  * @param {array} [...] Optional additional sorting conditions
  * @returns {DataTables.Api} this
  */

  /**
  * Set the ordering for the table.
  *
  * @param {array} order 2D array of sorting information to be applied.
  * @returns {DataTables.Api} this
  */


  _api_register('order()', function (order, dir) {
    var ctx = this.context;

    if (order === undefined) {
      // get
      return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
    } // set


    if (typeof order === 'number') {
      // Simple column / direction passed in
      order = [[order, dir]];
    } else if (order.length && !Array.isArray(order[0])) {
      // Arguments passed in (list of 1D arrays)
      order = Array.prototype.slice.call(arguments);
    } // otherwise a 2D array was passed in


    return this.iterator('table', function (settings) {
      settings.aaSorting = order.slice();
    });
  });
  /**
   * Attach a sort listener to an element for a given column
   *
   * @param {node|jQuery|string} node Identifier for the element(s) to attach the
   *   listener to. This can take the form of a single DOM node, a jQuery
   *   collection of nodes or a jQuery selector which will identify the node(s).
   * @param {integer} column the column that a click on this node will sort on
   * @param {function} [callback] callback function when sort is run
   * @returns {DataTables.Api} this
   */


  _api_register('order.listener()', function (node, column, callback) {
    return this.iterator('table', function (settings) {
      _fnSortAttachListener(settings, node, column, callback);
    });
  });

  _api_register('order.fixed()', function (set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;
      return Array.isArray(fixed) ? {
        pre: fixed
      } : fixed;
    }

    return this.iterator('table', function (settings) {
      settings.aaSortingFixed = $.extend(true, {}, set);
    });
  }); // Order by the selected column(s)


  _api_register(['columns().order()', 'column().order()'], function (dir) {
    var that = this;
    return this.iterator('table', function (settings, i) {
      var sort = [];
      $.each(that[i], function (j, col) {
        sort.push([col, dir]);
      });
      settings.aaSorting = sort;
    });
  });

  _api_register('search()', function (input, regex, smart, caseInsen) {
    var ctx = this.context;

    if (input === undefined) {
      // get
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
    } // set


    return this.iterator('table', function (settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }

      _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      }), 1);
    });
  });

  _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
    return this.iterator('column', function (settings, column) {
      var preSearch = settings.aoPreSearchCols;

      if (input === undefined) {
        // get
        return preSearch[column].sSearch;
      } // set


      if (!settings.oFeatures.bFilter) {
        return;
      }

      $.extend(preSearch[column], {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      });

      _fnFilterComplete(settings, settings.oPreviousSearch, 1);
    });
  });
  /*
   * State API methods
   */


  _api_register('state()', function () {
    return this.context.length ? this.context[0].oSavedState : null;
  });

  _api_register('state.clear()', function () {
    return this.iterator('table', function (settings) {
      // Save an empty object
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });

  _api_register('state.loaded()', function () {
    return this.context.length ? this.context[0].oLoadedState : null;
  });

  _api_register('state.save()', function () {
    return this.iterator('table', function (settings) {
      _fnSaveState(settings);
    });
  });
  /**
   * Provide a common method for plug-ins to check the version of DataTables being
   * used, in order to ensure compatibility.
   *
   *  @param {string} version Version string to check for, in the format "X.Y.Z".
   *    Note that the formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to
   *    the required version, or false if this version of DataTales is not
   *    suitable
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
   */


  DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
    var aThis = DataTable.version.split('.');
    var aThat = version.split('.');
    var iThis, iThat;

    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0; // Parts are the same, keep comparing

      if (iThis === iThat) {
        continue;
      } // Parts are different, return immediately


      return iThis > iThat;
    }

    return true;
  };
  /**
   * Check if a `<table>` node is a DataTable table already or not.
   *
   *  @param {node|jquery|string} table Table node, jQuery object or jQuery
   *      selector for the table to test. Note that if more than more than one
   *      table is passed on, only the first will be checked
   *  @returns {boolean} true the table given is a DataTable, or false otherwise
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
   *      $('#example').dataTable();
   *    }
   */


  DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
    var t = $(table).get(0);
    var is = false;

    if (table instanceof DataTable.Api) {
      return true;
    }

    $.each(DataTable.settings, function (i, o) {
      var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  /**
   * Get all DataTable tables that have been initialised - optionally you can
   * select to get only currently visible tables.
   *
   *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
   *    or visible tables only.
   *  @returns {array} Array of `table` nodes (not DataTable instances) which are
   *    DataTables
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    $.each( $.fn.dataTable.tables(true), function () {
   *      $(table).DataTable().columns.adjust();
   *    } );
   */


  DataTable.tables = DataTable.fnTables = function (visible) {
    var api = false;

    if ($.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }

    var a = $.map(DataTable.settings, function (o) {
      if (!visible || visible && $(o.nTable).is(':visible')) {
        return o.nTable;
      }
    });
    return api ? new _Api(a) : a;
  };
  /**
   * Convert from camel case parameters to Hungarian notation. This is made public
   * for the extensions to provide the same ability as DataTables core to accept
   * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
   * parameters.
   *
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   */


  DataTable.camelToHungarian = _fnCamelToHungarian;
  /**
   *
   */

  _api_register('$()', function (selector, opts) {
    var rows = this.rows(opts).nodes(),
        // Get all rows
    jqRows = $(rows);
    return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
  }); // jQuery functions to operate on the tables


  $.each(['on', 'one', 'off'], function (i, key) {
    _api_register(key + '()', function ()
    /* event, handler */
    {
      var args = Array.prototype.slice.call(arguments); // Add the `dt` namespace automatically if it isn't already present

      args[0] = $.map(args[0].split(/\s/), function (e) {
        return !e.match(/\.dt\b/) ? e + '.dt' : e;
      }).join(' ');
      var inst = $(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });

  _api_register('clear()', function () {
    return this.iterator('table', function (settings) {
      _fnClearTable(settings);
    });
  });

  _api_register('settings()', function () {
    return new _Api(this.context, this.context);
  });

  _api_register('init()', function () {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });

  _api_register('data()', function () {
    return this.iterator('table', function (settings) {
      return _pluck(settings.aoData, '_aData');
    }).flatten();
  });

  _api_register('destroy()', function (remove) {
    remove = remove || false;
    return this.iterator('table', function (settings) {
      var orig = settings.nTableWrapper.parentNode;
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $(table);
      var jqTbody = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows = $.map(settings.aoData, function (r) {
        return r.nTr;
      });
      var i, ien; // Flag to note that the table is currently being destroyed - no action
      // should be taken

      settings.bDestroying = true; // Fire off the destroy callbacks for plug-ins etc

      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]); // If not being removed from the document, make all columns visible


      if (!remove) {
        new _Api(settings).columns().visible(true);
      } // Blitz all `DT` namespaced events (these are internal events, the
      // lowercase, `dt` events are user subscribed and they are responsible
      // for removing them


      jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
      $(window).off('.DT-' + settings.sInstance); // When scrolling we had to break the table up - restore it

      if (table != thead.parentNode) {
        jqTable.children('thead').detach();
        jqTable.append(thead);
      }

      if (tfoot && table != tfoot.parentNode) {
        jqTable.children('tfoot').detach();
        jqTable.append(tfoot);
      }

      settings.aaSorting = [];
      settings.aaSortingFixed = [];

      _fnSortingClasses(settings);

      $(rows).removeClass(settings.asStripeClasses.join(' '));
      $('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone); // Add the TR elements back into the table in their original order

      jqTbody.children().detach();
      jqTbody.append(rows); // Remove the DataTables generated nodes, events and classes

      var removedMethod = remove ? 'remove' : 'detach';
      jqTable[removedMethod]();
      jqWrapper[removedMethod](); // If we need to reattach the table to the document

      if (!remove && orig) {
        // insertBefore acts like appendChild if !arg[1]
        orig.insertBefore(table, settings.nTableReinsertBefore); // Restore the width of the original table - was read from the style property,
        // so we can restore directly to that

        jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable); // If the were originally stripe classes - then we add them back here.
        // Note this is not fool proof (for example if not all rows had stripe
        // classes - but it's a good effort without getting carried away

        ien = settings.asDestroyStripes.length;

        if (ien) {
          jqTbody.children().each(function (i) {
            $(this).addClass(settings.asDestroyStripes[i % ien]);
          });
        }
      }
      /* Remove the settings object from the settings array */


      var idx = $.inArray(settings, DataTable.settings);

      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  }); // Add the `every()` method for rows, columns and cells in a compact form


  $.each(['column', 'row', 'cell'], function (i, type) {
    _api_register(type + 's().every()', function (fn) {
      var opts = this.selector.opts;
      var api = this;
      return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {
        // Rows and columns:
        //  arg1 - index
        //  arg2 - table counter
        //  arg3 - loop counter
        //  arg4 - undefined
        // Cells:
        //  arg1 - row index
        //  arg2 - column index
        //  arg3 - table counter
        //  arg4 - loop counter
        fn.call(api[type](arg1, type === 'cell' ? arg2 : opts, type === 'cell' ? opts : undefined), arg1, arg2, arg3, arg4);
      });
    });
  }); // i18n method for extensions to be able to use the language object from the
  // DataTable

  _api_register('i18n()', function (token, def, plural) {
    var ctx = this.context[0];

    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

    if (resolved === undefined) {
      resolved = def;
    }

    if (plural !== undefined && $.isPlainObject(resolved)) {
      resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
    }

    return resolved.replace('%d', plural); // nb: plural might be undefined,
  });
  /**
   * Version string for plug-ins to check compatibility. Allowed format is
   * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
   * only for non-release builds. See http://semver.org/ for more information.
   *  @member
   *  @type string
   *  @default Version number
   */


  DataTable.version = "1.10.22";
  /**
   * Private data store, containing all of the settings objects that are
   * created for the tables on a given page.
   *
   * Note that the `DataTable.settings` object is aliased to
   * `jQuery.fn.dataTableExt` through which it may be accessed and
   * manipulated, or `jQuery.fn.dataTable.settings`.
   *  @member
   *  @type array
   *  @default []
   *  @private
   */

  DataTable.settings = [];
  /**
   * Object models container, for the various models that DataTables has
   * available to it. These models define the objects that are used to hold
   * the active state and configuration of the table.
   *  @namespace
   */

  DataTable.models = {};
  /**
   * Template object for the way in which DataTables holds information about
   * search information for the global filter and individual column filters.
   *  @namespace
   */

  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,

    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",

    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,

    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true
  };
  /**
   * Template object for the way in which DataTables holds information about
   * each individual row. This is the object format used for the settings
   * aoData array.
   *  @namespace
   */

  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,

    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,

    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],

    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,

    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,

    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,

    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",

    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null,

    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     *  @type integer
     *  @default -1
     *  @private
     */
    "idx": -1
  };
  /**
   * Template object for the column information object in DataTables. This object
   * is held in the settings aoColumns array and contains all the information that
   * DataTables needs about each individual column.
   *
   * Note that this object is related to {@link DataTable.defaults.column}
   * but this one is the internal data store for DataTables's cache of columns.
   * It should NOT be manipulated outside of DataTables. Any configuration should
   * be done through the initialisation options.
   *  @namespace
   */

  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,

    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,

    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,

    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,

    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,

    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,

    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,

    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,

    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,

    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,

    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,

    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,

    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,

    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,

    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,

    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,

    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": 'std',

    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,

    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,

    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,

    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,

    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,

    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };
  /*
   * Developer note: The properties of the object below are given in Hungarian
   * notation, that was used as the interface for DataTables prior to v1.10, however
   * from v1.10 onwards the primary interface is camel case. In order to avoid
   * breaking backwards compatibility utterly with this change, the Hungarian
   * version is still, internally the primary interface, but is is not documented
   * - hence the @name tags in each doc comment. This allows a Javascript function
   * to create a map from Hungarian notation to camel case (going the other direction
   * would require each property to be listed, which would add around 3K to the size
   * of DataTables, while this method is about a 0.5K hit).
   *
   * Ultimately this does pave the way for Hungarian notation to be dropped
   * completely, but that is a massive amount of work and will break current
   * installs (therefore is on-hold until v2).
   */

  /**
   * Initialisation options that can be given to DataTables at initialisation
   * time.
   *  @namespace
   */

  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,

    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0, 'asc']],

    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],

    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,

    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [10, 25, 50, 100],

    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,

    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,

    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],

    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,

    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,

    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,

    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,

    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,

    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,

    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,

    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,

    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,

    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,

    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,

    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,

    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,

    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,

    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,

    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,

    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,

    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,

    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,

    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,

    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function (toFormat) {
      return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
    },

    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,

    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,

    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,

    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,

    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,

    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} callback Callback that can be executed when done. It
     *    should be passed the loaded state object.
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings, callback) {
     *          $.ajax( {
     *            "url": "/state_load",
     *            "dataType": "json",
     *            "success": function (json) {
     *              callback( json );
     *            }
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function (settings) {
      try {
        return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
      } catch (e) {
        return {};
      }
    },

    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,

    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,

    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function (settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
      } catch (e) {}
    },

    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,

    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,

    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,

    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,

    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,

    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,

    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},

    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",

        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },

      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",

        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",

        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",

        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },

      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",

      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",

      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",

      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",

      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",

      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",

      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",

      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",

      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "Loading...",

      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *  @default Processing...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "Processing...",

      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",

      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",

      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",

      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "No matching records found"
    },

    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $.extend({}, DataTable.models.oSearch),

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,

    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",

    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     *  @type integer
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.searchDelay
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchDelay": 200
     *      } );
     *    } )
     */
    "searchDelay": null,

    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     *  
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",

    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",

    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",

    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",

    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null,

    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     *  @type string
     *  @default DT_RowId
     *
     *  @name DataTable.defaults.rowId
     */
    "rowId": "DT_RowId"
  };

  _fnHungarianMap(DataTable.defaults);
  /*
   * Developer note - See note in model.defaults.js about the use of Hungarian
   * notation and camel case.
   */

  /**
   * Column options that can be given to DataTables at initialisation time.
   *  @namespace
   */


  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,

    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": ['asc', 'desc'],

    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,

    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,

    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,

    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */

    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "details.0" },
     *          { "data": "details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed dislay and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,

    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,

    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",

    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,

    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",

    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",

    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,

    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,

    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };

  _fnHungarianMap(DataTable.defaults.column);
  /**
   * DataTables settings object - this holds all the information needed for a
   * given table, including configuration, data and current application of the
   * table options. DataTables does not have a single instance for each DataTable
   * with the settings attached to that instance, but rather instances of the
   * DataTable "class" are created on-the-fly as needed (typically by a
   * $().dataTable() call) and the settings object is then applied to that
   * instance.
   *
   * Note that this object is related to {@link DataTable.defaults} but this
   * one is the internal data store for DataTables's cache of columns. It should
   * NOT be manipulated outside of DataTables. Any configuration should be done
   * through the initialisation options.
   *  @namespace
   *  @todo Really should attach the settings object to individual instances so we
   *    don't need to create new instances on each $().dataTable() call (if the
   *    table already exists). It would also save passing oSettings around and
   *    into every single function. However, this is a very significant
   *    architecture change for DataTables and will almost certainly break
   *    backwards compatibility with older installations. This is something that
   *    will be done in 2.0.
   */


  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,

      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all fro DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,

      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,

      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,

      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,

      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,

      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,

      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,

      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,

      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,

      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,

      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },

    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,

      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,

      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,

      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,

      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },

    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },

    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,

      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false,

      /**
       * Flag for if `getBoundingClientRect` is fully supported or not
       *  @type boolean
       *  @default false
       */
      "bBounding": false,

      /**
       * Browser scrollbar width
       *  @type integer
       *  @default 0
       */
      "barWidth": 0
    },
    "ajax": null,

    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],

    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],

    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],

    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],

    /**
     * Map of row ids to data indexes
     *  @type object
     *  @default {}
     */
    "aIds": {},

    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],

    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],

    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],

    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},

    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],

    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,

    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],

    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,

    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],

    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,

    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],

    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],

    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],

    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],

    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],

    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],

    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],

    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],

    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],

    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],

    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",

    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,

    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,

    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,

    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,

    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,

    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,

    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,

    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],

    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,

    /**
     * Search delay (in mS)
     *  @type integer
     *  @default null
     */
    "searchDelay": null,

    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",

    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,

    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],

    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],

    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,

    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,

    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,

    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,

    /**
     * Note if draw should be blocked while getting data
     *  @type boolean
     *  @default true
     */
    "bAjaxDataGet": true,

    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,

    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": undefined,

    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": undefined,

    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,

    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],

    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,

    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,

    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,

    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,

    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,

    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,

    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,

    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,

    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,

    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,

    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,

    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,

    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,

    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],

    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function () {
      return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },

    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function () {
      return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },

    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function () {
      var len = this._iDisplayLength,
          start = this._iDisplayStart,
          calc = start + len,
          records = this.aiDisplay.length,
          features = this.oFeatures,
          paginate = features.bPaginate;

      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },

    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,

    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,

    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,

    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],

    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {},

    /**
     * Function used to get a row's id from the row's data
     *  @type function
     *  @default null
     */
    "rowIdFn": null,

    /**
     * Data location where to store a row's id
     *  @type string
     *  @default null
     */
    "rowId": null
  };
  /**
   * Extension object for DataTables that is used to provide all extension
   * options.
   *
   * Note that the `DataTable.ext` object is available through
   * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
   * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
   *  @namespace
   *  @extends DataTable.models.ext
   */

  /**
   * DataTables extensions
   * 
   * This namespace acts as a collection area for plug-ins that can be used to
   * extend DataTables capabilities. Indeed many of the build in methods
   * use this method to provide their own capabilities (sorting methods for
   * example).
   *
   * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
   * reasons
   *
   *  @namespace
   */

  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},

    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},

    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",

    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",

    /**
     * Feature plug-ins.
     * 
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     * 
     * Each feature plug-in is described by an object which must have the
     * following properties:
     * 
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     * 
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],

    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],

    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },

    /**
     * Internal functions, exposed for used in plug-ins.
     * 
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},

    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },

    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },

    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},

    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],

      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},

      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },

    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatiblity only.
    // The should not be used in new projects and will be removed in a future
    // version
    //

    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,

    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,

    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},

    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  }; //
  // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
  //

  $.extend(_ext, {
    afnFiltering: _ext.search,
    aTypes: _ext.type.detect,
    ofnSearch: _ext.type.search,
    oSort: _ext.type.order,
    afnSortData: _ext.order,
    aoFeatures: _ext.feature,
    oApi: _ext.internal,
    oStdClasses: _ext.classes,
    oPagination: _ext.pager
  });
  $.extend(DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",

    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",

    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",

    /* Empty row */
    "sRowEmpty": "dataTables_empty",

    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_",

    /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",

    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting",

    /* Sortable in both directions */
    "sSortableAsc": "sorting_asc_disabled",
    "sSortableDesc": "sorting_desc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_",

    /* Note that an int is postfixed for the sorting order */

    /* Filtering */
    "sFilterInput": "",

    /* Page length */
    "sLengthSelect": "",

    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",

    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",
    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  });
  var extPagination = DataTable.ext.pager;

  function _numbers(page, pages) {
    var numbers = [],
        buttons = extPagination.numbers_length,
        half = Math.floor(buttons / 2),
        i = 1;

    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else if (page <= half) {
      numbers = _range(0, buttons - 2);
      numbers.push('ellipsis');
      numbers.push(pages - 1);
    } else if (page >= pages - 1 - half) {
      numbers = _range(pages - (buttons - 2), pages);
      numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6

      numbers.splice(0, 0, 0);
    } else {
      numbers = _range(page - half + 2, page + half - 1);
      numbers.push('ellipsis');
      numbers.push(pages - 1);
      numbers.splice(0, 0, 'ellipsis');
      numbers.splice(0, 0, 0);
    }

    numbers.DT_el = 'span';
    return numbers;
  }

  $.extend(extPagination, {
    simple: function (page, pages) {
      return ['previous', 'next'];
    },
    full: function (page, pages) {
      return ['first', 'previous', 'next', 'last'];
    },
    numbers: function (page, pages) {
      return [_numbers(page, pages)];
    },
    simple_numbers: function (page, pages) {
      return ['previous', _numbers(page, pages), 'next'];
    },
    full_numbers: function (page, pages) {
      return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
    },
    first_last_numbers: function (page, pages) {
      return ['first', _numbers(page, pages), 'last'];
    },
    // For testing and plug-ins to use
    _numbers: _numbers,
    // Number of number buttons (including ellipsis) to show. _Must be odd!_
    numbers_length: 7
  });
  $.extend(true, DataTable.ext.renderer, {
    pageButton: {
      _: function (settings, host, idx, buttons, page, pages) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay,
            btnClass,
            counter = 0;

        var attach = function (container, buttons) {
          var i, ien, node, button, tabIndex;
          var disabledClass = classes.sPageButtonDisabled;

          var clickHandler = function (e) {
            _fnPageChange(settings, e.data.action, true);
          };

          for (i = 0, ien = buttons.length; i < ien; i++) {
            button = buttons[i];

            if (Array.isArray(button)) {
              var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
              attach(inner, button);
            } else {
              btnDisplay = null;
              btnClass = button;
              tabIndex = settings.iTabIndex;

              switch (button) {
                case 'ellipsis':
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;

                case 'first':
                  btnDisplay = lang.sFirst;

                  if (page === 0) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                case 'previous':
                  btnDisplay = lang.sPrevious;

                  if (page === 0) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                case 'next':
                  btnDisplay = lang.sNext;

                  if (pages === 0 || page === pages - 1) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                case 'last':
                  btnDisplay = lang.sLast;

                  if (pages === 0 || page === pages - 1) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                default:
                  btnDisplay = settings.fnFormatNumber(button + 1);
                  btnClass = page === button ? classes.sPageButtonActive : '';
                  break;
              }

              if (btnDisplay !== null) {
                node = $('<a>', {
                  'class': classes.sPageButton + ' ' + btnClass,
                  'aria-controls': settings.sTableId,
                  'aria-label': aria[button],
                  'data-dt-idx': counter,
                  'tabindex': tabIndex,
                  'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                }).html(btnDisplay).appendTo(container);

                _fnBindAction(node, {
                  action: button
                }, clickHandler);

                counter++;
              }
            }
          }
        }; // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame. Try / catch the error. Not good for
        // accessibility, but neither are frames.


        var activeEl;

        try {
          // Because this approach is destroying and recreating the paging
          // elements, focus is lost on the select button which is bad for
          // accessibility. So we want to restore focus once the draw has
          // completed
          activeEl = $(host).find(document.activeElement).data('dt-idx');
        } catch (e) {}

        attach($(host).empty(), buttons);

        if (activeEl !== undefined) {
          $(host).find('[data-dt-idx=' + activeEl + ']').trigger('focus');
        }
      }
    }
  }); // Built in type detection. See model.ext.aTypes for information about
  // what is required from this methods.

  $.extend(DataTable.ext.type.detect, [// Plain numbers - first since V8 detects some plain numbers as dates
  // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal) ? 'num' + decimal : null;
  }, // Dates (only those recognised by the browser's Date.parse)
  function (d, settings) {
    // V8 tries _very_ hard to make a string passed into `Date.parse()`
    // valid, so we need to use a regex to restrict date formats. Use a
    // plug-in for anything other than ISO8601 style strings
    if (d && !(d instanceof Date) && !_re_date.test(d)) {
      return null;
    }

    var parsed = Date.parse(d);
    return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
  }, // Formatted numbers
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
  }, // HTML numeric
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
  }, // HTML numeric, formatted
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
  }, // HTML (this is strict checking - there must be html)
  function (d, settings) {
    return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
  }]); // Filter formatting functions. See model.ext.ofnSearch for information about
  // what is required from these methods.
  // 
  // Note that additional search methods are added for the html numbers and
  // html formatted numbers by `_addNumericSort()` when we know what the decimal
  // place is

  $.extend(DataTable.ext.type.search, {
    html: function (data) {
      return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ").replace(_re_html, "") : '';
    },
    string: function (data) {
      return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ") : data;
    }
  });

  var __numericReplace = function (d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === '-')) {
      return -Infinity;
    } // If a decimal place other than `.` is used, it needs to be given to the
    // function so we can detect it and replace with a `.` which is the only
    // decimal place Javascript recognises - it is not locale aware.


    if (decimalPlace) {
      d = _numToDecimal(d, decimalPlace);
    }

    if (d.replace) {
      if (re1) {
        d = d.replace(re1, '');
      }

      if (re2) {
        d = d.replace(re2, '');
      }
    }

    return d * 1;
  }; // Add the numeric 'deformatting' functions for sorting and search. This is done
  // in a function to provide an easy ability for the language options to add
  // additional methods if a non-period decimal place is used.


  function _addNumericSort(decimalPlace) {
    $.each({
      // Plain numbers
      "num": function (d) {
        return __numericReplace(d, decimalPlace);
      },
      // Formatted numbers
      "num-fmt": function (d) {
        return __numericReplace(d, decimalPlace, _re_formatted_numeric);
      },
      // HTML numeric
      "html-num": function (d) {
        return __numericReplace(d, decimalPlace, _re_html);
      },
      // HTML numeric, formatted
      "html-num-fmt": function (d) {
        return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
      }
    }, function (key, fn) {
      // Add the ordering method
      _ext.type.order[key + decimalPlace + '-pre'] = fn; // For HTML types add a search formatter that will strip the HTML

      if (key.match(/^html\-/)) {
        _ext.type.search[key + decimalPlace] = _ext.type.search.html;
      }
    });
  } // Default sort methods


  $.extend(_ext.type.order, {
    // Dates
    "date-pre": function (d) {
      var ts = Date.parse(d);
      return isNaN(ts) ? -Infinity : ts;
    },
    // html
    "html-pre": function (a) {
      return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + '';
    },
    // string
    "string-pre": function (a) {
      // This is a little complex, but faster than always calling toString,
      // http://jsperf.com/tostring-v-check
      return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
    },
    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function (x, y) {
      return x < y ? -1 : x > y ? 1 : 0;
    },
    "string-desc": function (x, y) {
      return x < y ? 1 : x > y ? -1 : 0;
    }
  }); // Numeric sorting types - order doesn't matter here

  _addNumericSort('');

  $.extend(true, DataTable.ext.renderer, {
    header: {
      _: function (settings, cell, column, classes) {
        // No additional mark-up required
        // Attach a sort listener to update on sort - note that using the
        // `DT` namespace will allow the event to be removed automatically
        // on destroy, while the `dt` namespaced event is the one we are
        // listening for
        $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
          if (settings !== ctx) {
            // need to check this this is the host
            return; // table, not a nested one
          }

          var colIdx = column.idx;
          cell.removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
        });
      },
      jqueryui: function (settings, cell, column, classes) {
        $('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell); // Attach a sort listener to update on sort

        $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }

          var colIdx = column.idx;
          cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
          cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
        });
      }
    }
  });
  /*
   * Public helper functions. These aren't used internally by DataTables, or
   * called by any of the options passed into DataTables, but they can be used
   * externally by developers working with DataTables. They are helper functions
   * to make working with DataTables a little bit easier.
   */

  var __htmlEscapeEntities = function (d) {
    return typeof d === 'string' ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') : d;
  };
  /**
   * Helpers for `columns.render`.
   *
   * The options defined here can be used with the `columns.render` initialisation
   * option to provide a display renderer. The following functions are defined:
   *
   * * `number` - Will format numeric data (defined by `columns.data`) for
   *   display, retaining the original unformatted data for sorting and filtering.
   *   It takes 5 parameters:
   *   * `string` - Thousands grouping separator
   *   * `string` - Decimal point indicator
   *   * `integer` - Number of decimal points to show
   *   * `string` (optional) - Prefix.
   *   * `string` (optional) - Postfix (/suffix).
   * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
   *   parameters.
   *
   * @example
   *   // Column definition using the number renderer
   *   {
   *     data: "salary",
   *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
   *   }
   *
   * @namespace
   */


  DataTable.render = {
    number: function (thousands, decimal, precision, prefix, postfix) {
      return {
        display: function (d) {
          if (typeof d !== 'number' && typeof d !== 'string') {
            return d;
          }

          var negative = d < 0 ? '-' : '';
          var flo = parseFloat(d); // If NaN then there isn't much formatting that we can do - just
          // return immediately, escaping any HTML (this was supposed to
          // be a number after all)

          if (isNaN(flo)) {
            return __htmlEscapeEntities(d);
          }

          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';
          return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || '');
        }
      };
    },
    text: function () {
      return {
        display: __htmlEscapeEntities,
        filter: __htmlEscapeEntities
      };
    }
  };
  /*
   * This is really a good bit rubbish this method of exposing the internal methods
   * publicly... - To be fixed in 2.0 using methods on the prototype
   */

  /**
   * Create a wrapper function for exporting an internal functions to an external API.
   *  @param {string} fn API function name
   *  @returns {function} wrapped function
   *  @memberof DataTable#internal
   */

  function _fnExternApiFunc(fn) {
    return function () {
      var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
      return DataTable.ext.internal[fn].apply(this, args);
    };
  }
  /**
   * Reference to internal functions for use by plug-in developers. Note that
   * these methods are references to internal functions and are considered to be
   * private. If you use these methods, be aware that they are liable to change
   * between versions.
   *  @namespace
   */


  $.extend(DataTable.ext.internal, {
    _fnExternApiFunc: _fnExternApiFunc,
    _fnBuildAjax: _fnBuildAjax,
    _fnAjaxUpdate: _fnAjaxUpdate,
    _fnAjaxParameters: _fnAjaxParameters,
    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
    _fnAjaxDataSrc: _fnAjaxDataSrc,
    _fnAddColumn: _fnAddColumn,
    _fnColumnOptions: _fnColumnOptions,
    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
    _fnVisbleColumns: _fnVisbleColumns,
    _fnGetColumns: _fnGetColumns,
    _fnColumnTypes: _fnColumnTypes,
    _fnApplyColumnDefs: _fnApplyColumnDefs,
    _fnHungarianMap: _fnHungarianMap,
    _fnCamelToHungarian: _fnCamelToHungarian,
    _fnLanguageCompat: _fnLanguageCompat,
    _fnBrowserDetect: _fnBrowserDetect,
    _fnAddData: _fnAddData,
    _fnAddTr: _fnAddTr,
    _fnNodeToDataIndex: _fnNodeToDataIndex,
    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
    _fnGetCellData: _fnGetCellData,
    _fnSetCellData: _fnSetCellData,
    _fnSplitObjNotation: _fnSplitObjNotation,
    _fnGetObjectDataFn: _fnGetObjectDataFn,
    _fnSetObjectDataFn: _fnSetObjectDataFn,
    _fnGetDataMaster: _fnGetDataMaster,
    _fnClearTable: _fnClearTable,
    _fnDeleteIndex: _fnDeleteIndex,
    _fnInvalidate: _fnInvalidate,
    _fnGetRowElements: _fnGetRowElements,
    _fnCreateTr: _fnCreateTr,
    _fnBuildHead: _fnBuildHead,
    _fnDrawHead: _fnDrawHead,
    _fnDraw: _fnDraw,
    _fnReDraw: _fnReDraw,
    _fnAddOptionsHtml: _fnAddOptionsHtml,
    _fnDetectHeader: _fnDetectHeader,
    _fnGetUniqueThs: _fnGetUniqueThs,
    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
    _fnFilterComplete: _fnFilterComplete,
    _fnFilterCustom: _fnFilterCustom,
    _fnFilterColumn: _fnFilterColumn,
    _fnFilter: _fnFilter,
    _fnFilterCreateSearch: _fnFilterCreateSearch,
    _fnEscapeRegex: _fnEscapeRegex,
    _fnFilterData: _fnFilterData,
    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
    _fnUpdateInfo: _fnUpdateInfo,
    _fnInfoMacros: _fnInfoMacros,
    _fnInitialise: _fnInitialise,
    _fnInitComplete: _fnInitComplete,
    _fnLengthChange: _fnLengthChange,
    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
    _fnPageChange: _fnPageChange,
    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
    _fnProcessingDisplay: _fnProcessingDisplay,
    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
    _fnScrollDraw: _fnScrollDraw,
    _fnApplyToChildren: _fnApplyToChildren,
    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
    _fnThrottle: _fnThrottle,
    _fnConvertToWidth: _fnConvertToWidth,
    _fnGetWidestNode: _fnGetWidestNode,
    _fnGetMaxLenString: _fnGetMaxLenString,
    _fnStringToCss: _fnStringToCss,
    _fnSortFlatten: _fnSortFlatten,
    _fnSort: _fnSort,
    _fnSortAria: _fnSortAria,
    _fnSortListener: _fnSortListener,
    _fnSortAttachListener: _fnSortAttachListener,
    _fnSortingClasses: _fnSortingClasses,
    _fnSortData: _fnSortData,
    _fnSaveState: _fnSaveState,
    _fnLoadState: _fnLoadState,
    _fnSettingsFromNode: _fnSettingsFromNode,
    _fnLog: _fnLog,
    _fnMap: _fnMap,
    _fnBindAction: _fnBindAction,
    _fnCallbackReg: _fnCallbackReg,
    _fnCallbackFire: _fnCallbackFire,
    _fnLengthOverflow: _fnLengthOverflow,
    _fnRenderer: _fnRenderer,
    _fnDataSource: _fnDataSource,
    _fnRowAttributes: _fnRowAttributes,
    _fnExtend: _fnExtend,
    _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
    // in 1.10, so this dead-end function is
    // added to prevent errors

  }); // jQuery access

  $.fn.dataTable = DataTable; // Provide access to the host jQuery object (circular reference)

  DataTable.$ = $; // Legacy aliases

  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext; // With a capital `D` we return a DataTables API instance rather than a
  // jQuery object

  $.fn.DataTable = function (opts) {
    return $(this).dataTable(opts).api();
  }; // All properties that are available to $.fn.dataTable should also be
  // available on $.fn.DataTable


  $.each(DataTable, function (prop, val) {
    $.fn.DataTable[prop] = val;
  }); // Information about events fired by DataTables - for documentation.

  /**
   * Draw event, fired whenever the table is redrawn on the page, at the same
   * point as fnDrawCallback. This may be useful for binding events or
   * performing calculations when the table is altered at all.
   *  @name DataTable#draw.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Search event, fired when the searching applied to the table (using the
   * built-in global search, or column filters) is altered.
   *  @name DataTable#search.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page change event, fired when the paging of the table is altered.
   *  @name DataTable#page.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Order event, fired when the ordering applied to the table is altered.
   *  @name DataTable#order.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * DataTables initialisation complete event, fired when the table is fully
   * drawn, including Ajax data loaded, if Ajax data is required.
   *  @name DataTable#init.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used</li></ol>
   */

  /**
   * State save event, fired when the table has changed state a new state save
   * is required. This event allows modification of the state saving object
   * prior to actually doing the save, including addition or other state
   * properties (for plug-ins) or modification of a DataTables core property.
   *  @name DataTable#stateSaveParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The state information to be saved
   */

  /**
   * State load event, fired when the table is loading state from the stored
   * data, but prior to the settings object being modified by the saved state
   * - allowing modification of the saved state is required or loading of
   * state for a plug-in.
   *  @name DataTable#stateLoadParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * State loaded event, fired when state has been loaded from stored data and
   * the settings object has been modified by the loaded data.
   *  @name DataTable#stateLoaded.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * Processing event, fired when DataTables is doing some kind of processing
   * (be it, order, search or anything else). It can be used to indicate to
   * the end user that there is something happening, or that something has
   * finished.
   *  @name DataTable#processing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {boolean} bShow Flag for if DataTables is doing processing or not
   */

  /**
   * Ajax (XHR) event, fired whenever an Ajax request is completed from a
   * request to made to the server for new data. This event is called before
   * DataTables processed the returned data, so it can also be used to pre-
   * process the data returned from the server, if needed.
   *
   * Note that this trigger is called in `fnServerData`, if you override
   * `fnServerData` and which to use this event, you need to trigger it in you
   * success function.
   *  @name DataTable#xhr.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {object} json JSON returned from the server
   *
   *  @example
   *     // Use a custom property returned from the server in another DOM element
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       $('#status').html( json.status );
   *     } );
   *
   *  @example
   *     // Pre-process the data returned from the server
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
   *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
   *       }
   *       // Note no return - manipulate the data directly in the JSON object.
   *     } );
   */

  /**
   * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
   * or passing the bDestroy:true parameter in the initialisation object. This
   * can be used to remove bound events, added DOM nodes, etc.
   *  @name DataTable#destroy.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page length change event, fired when number of records to show on each
   * page (the length) is changed.
   *  @name DataTable#length.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {integer} len New length
   */

  /**
   * Column sizing has changed.
   *  @name DataTable#column-sizing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Column visibility has changed.
   *  @name DataTable#column-visibility.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {int} column Column index
   *  @param {bool} vis `false` if column now hidden, or `true` if visible
   */

  return $.fn.dataTable;
});

/***/ }),

/***/ "./src/public/js/wowpi-guild-roster.js":
/*!*********************************************!*\
  !*** ./src/public/js/wowpi-guild-roster.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(datatables_net__WEBPACK_IMPORTED_MODULE_1__);


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#' + wowpiRosterAjax.datatable_id).DataTable({
    "processing": true,
    "serverSide": true,
    "ajax": wowpiRosterAjax.ajaxurl,
    "paging": false,
    //"length": parseInt(wowpiRosterAjax.datatable_length),
    "columns": [{
      'data': 'name',
      'sortable': true
    }, {
      'data': 'race',
      'render': function render(data, type, row) {
        return '<div class="icon"><img src="/wp-content/plugins/wowpi-guild/assets/icon/' + data.icon + '" alt="' + data.name + '" /></div>';
      },
      'sortable': false
    }, {
      'data': 'class',
      'render': function render(data, type, row) {
        return '<div class="icon"><img src="/wp-content/plugins/wowpi-guild/assets/icon/' + data.icon + '" alt="' + data.name + '" /></div>';
      },
      'sortable': false
    }, {
      'data': 'role',
      'render': function render(data, type, row) {
        return '<div class="icon"><img src="/wp-content/plugins/wowpi-guild/assets/icon/role_' + data.type + '.png" alt="' + data.name + '" /></div>';
      },
      'sortable': false
    }, {
      'data': 'level',
      'sortable': true
    }, {
      'data': 'rank',
      'sortable': false
    }]
  });
});

/***/ }),

/***/ 1:
/*!***************************************************!*\
  !*** multi ./src/public/js/wowpi-guild-roster.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\laragon\www\wowpi\wp-content\plugins\wowpi-guild\src\public\js\wowpi-guild-roster.js */"./src/public/js/wowpi-guild-roster.js");


/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0L2pzL2pxdWVyeS5kYXRhVGFibGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9wdWJsaWMvanMvd293cGktZ3VpbGQtcm9zdGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJkZWZpbmUiLCIkIiwid2luZG93IiwiZG9jdW1lbnQiLCJ1bmRlZmluZWQiLCJEYXRhVGFibGUiLCJvcHRpb25zIiwic1NlbGVjdG9yIiwib09wdHMiLCJhcGkiLCJfIiwicm93cyIsImRhdGEiLCJ0cmFkaXRpb25hbCIsIl9BcGkiLCJfZm5TZXR0aW5nc0Zyb21Ob2RlIiwiX2V4dCIsImlBcGlJbmRleCIsImZuQWRkRGF0YSIsInJlZHJhdyIsIkFycmF5IiwiaXNBcnJheSIsImlzUGxhaW5PYmplY3QiLCJhZGQiLCJyb3ciLCJkcmF3IiwiZmxhdHRlbiIsInRvQXJyYXkiLCJmbkFkanVzdENvbHVtblNpemluZyIsImJSZWRyYXciLCJjb2x1bW5zIiwiYWRqdXN0Iiwic2V0dGluZ3MiLCJzY3JvbGwiLCJvU2Nyb2xsIiwic1giLCJzWSIsIl9mblNjcm9sbERyYXciLCJmbkNsZWFyVGFibGUiLCJjbGVhciIsImZuQ2xvc2UiLCJuVHIiLCJjaGlsZCIsImhpZGUiLCJmbkRlbGV0ZVJvdyIsInRhcmdldCIsImNhbGxiYWNrIiwiYW9EYXRhIiwicmVtb3ZlIiwiY2FsbCIsImZuRGVzdHJveSIsImRlc3Ryb3kiLCJmbkRyYXciLCJjb21wbGV0ZSIsImZuRmlsdGVyIiwic0lucHV0IiwiaUNvbHVtbiIsImJSZWdleCIsImJTbWFydCIsImJTaG93R2xvYmFsIiwiYkNhc2VJbnNlbnNpdGl2ZSIsInNlYXJjaCIsImNvbHVtbiIsImZuR2V0RGF0YSIsInNyYyIsImNvbCIsInR5cGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiY2VsbCIsImZuR2V0Tm9kZXMiLCJpUm93Iiwibm9kZSIsIm5vZGVzIiwiZm5HZXRQb3NpdGlvbiIsInRvVXBwZXJDYXNlIiwiaW5kZXgiLCJjb2x1bW5WaXNpYmxlIiwiZm5Jc09wZW4iLCJpc1Nob3duIiwiZm5PcGVuIiwibUh0bWwiLCJzQ2xhc3MiLCJzaG93IiwiZm5QYWdlQ2hhbmdlIiwibUFjdGlvbiIsInBhZ2UiLCJmblNldENvbHVtblZpcyIsImlDb2wiLCJiU2hvdyIsInZpc2libGUiLCJmblNldHRpbmdzIiwiZm5Tb3J0IiwiYWFTb3J0Iiwib3JkZXIiLCJmblNvcnRMaXN0ZW5lciIsIm5Ob2RlIiwiZm5DYWxsYmFjayIsImxpc3RlbmVyIiwiZm5VcGRhdGUiLCJtRGF0YSIsIm1Sb3ciLCJiQWN0aW9uIiwiZm5WZXJzaW9uQ2hlY2siLCJfdGhhdCIsImVtcHR5SW5pdCIsImxlbiIsImxlbmd0aCIsIm9BcGkiLCJpbnRlcm5hbCIsImZuIiwiZXh0IiwiX2ZuRXh0ZXJuQXBpRnVuYyIsImVhY2giLCJvIiwib0luaXQiLCJfZm5FeHRlbmQiLCJpIiwiaUxlbiIsImoiLCJqTGVuIiwiayIsImtMZW4iLCJzSWQiLCJnZXRBdHRyaWJ1dGUiLCJiSW5pdEhhbmRlZE9mZiIsImRlZmF1bHRzIiwiJHRoaXMiLCJfZm5Mb2ciLCJfZm5Db21wYXRPcHRzIiwiX2ZuQ29tcGF0Q29scyIsIl9mbkNhbWVsVG9IdW5nYXJpYW4iLCJleHRlbmQiLCJhbGxTZXR0aW5ncyIsInMiLCJuVGFibGUiLCJuVEhlYWQiLCJwYXJlbnROb2RlIiwiblRGb290IiwiYlJldHJpZXZlIiwiYkRlc3Ryb3kiLCJvSW5zdGFuY2UiLCJzVGFibGVJZCIsImlkIiwic3BsaWNlIiwiX3VuaXF1ZSIsIm9TZXR0aW5ncyIsIm1vZGVscyIsInN0eWxlIiwid2lkdGgiLCJwdXNoIiwiZGF0YVRhYmxlIiwiX2ZuTGFuZ3VhZ2VDb21wYXQiLCJvTGFuZ3VhZ2UiLCJhTGVuZ3RoTWVudSIsImlEaXNwbGF5TGVuZ3RoIiwiX2ZuTWFwIiwib0ZlYXR1cmVzIiwiX2ZuQ2FsbGJhY2tSZWciLCJmbkRyYXdDYWxsYmFjayIsImZuU2VydmVyUGFyYW1zIiwiZm5TdGF0ZVNhdmVQYXJhbXMiLCJmblN0YXRlTG9hZFBhcmFtcyIsImZuU3RhdGVMb2FkZWQiLCJmblJvd0NhbGxiYWNrIiwiZm5DcmVhdGVkUm93IiwiZm5IZWFkZXJDYWxsYmFjayIsImZuRm9vdGVyQ2FsbGJhY2siLCJmbkluaXRDb21wbGV0ZSIsImZuUHJlRHJhd0NhbGxiYWNrIiwicm93SWRGbiIsIl9mbkdldE9iamVjdERhdGFGbiIsInJvd0lkIiwiX2ZuQnJvd3NlckRldGVjdCIsIm9DbGFzc2VzIiwiY2xhc3NlcyIsImFkZENsYXNzIiwic1RhYmxlIiwiaUluaXREaXNwbGF5U3RhcnQiLCJpRGlzcGxheVN0YXJ0IiwiX2lEaXNwbGF5U3RhcnQiLCJpRGVmZXJMb2FkaW5nIiwiYkRlZmVyTG9hZGluZyIsInRtcCIsIl9pUmVjb3Jkc0Rpc3BsYXkiLCJfaVJlY29yZHNUb3RhbCIsInNVcmwiLCJhamF4IiwiZGF0YVR5cGUiLCJ1cmwiLCJzdWNjZXNzIiwianNvbiIsIl9mbkluaXRpYWxpc2UiLCJlcnJvciIsImFzU3RyaXBlQ2xhc3NlcyIsInNTdHJpcGVPZGQiLCJzU3RyaXBlRXZlbiIsInN0cmlwZUNsYXNzZXMiLCJyb3dPbmUiLCJjaGlsZHJlbiIsImZpbmQiLCJlcSIsImluQXJyYXkiLCJtYXAiLCJlbCIsImhhc0NsYXNzIiwicmVtb3ZlQ2xhc3MiLCJqb2luIiwiYXNEZXN0cm95U3RyaXBlcyIsInNsaWNlIiwiYW5UaHMiLCJhb0NvbHVtbnNJbml0IiwiblRoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJfZm5EZXRlY3RIZWFkZXIiLCJhb0hlYWRlciIsIl9mbkdldFVuaXF1ZVRocyIsImFvQ29sdW1ucyIsIl9mbkFkZENvbHVtbiIsIl9mbkFwcGx5Q29sdW1uRGVmcyIsImFvQ29sdW1uRGVmcyIsIm9EZWYiLCJfZm5Db2x1bW5PcHRpb25zIiwiYSIsIm5hbWUiLCJzb3J0IiwiZmlsdGVyIiwiZmVhdHVyZXMiLCJsb2FkZWRJbml0IiwiYWFTb3J0aW5nIiwic29ydGluZyIsImFzU29ydGluZyIsIl9mblNvcnRpbmdDbGFzc2VzIiwiYlNvcnQiLCJiU29ydGVkIiwiYVNvcnQiLCJfZm5Tb3J0RmxhdHRlbiIsInNvcnRlZENvbHVtbnMiLCJ2YWwiLCJkaXIiLCJfZm5DYWxsYmFja0ZpcmUiLCJfZm5Tb3J0QXJpYSIsIl9mbkRhdGFTb3VyY2UiLCJiRGVmZXJSZW5kZXIiLCJjYXB0aW9ucyIsIl9jYXB0aW9uU2lkZSIsImNzcyIsInRoZWFkIiwiYXBwZW5kVG8iLCJ0Ym9keSIsIm5UQm9keSIsInRmb290Iiwic05vRm9vdGVyIiwiYW9Gb290ZXIiLCJhYURhdGEiLCJfZm5BZGREYXRhIiwiX2ZuQWRkVHIiLCJhaURpc3BsYXkiLCJhaURpc3BsYXlNYXN0ZXIiLCJiSW5pdGlhbGlzZWQiLCJiU3RhdGVTYXZlIiwiX2ZuU2F2ZVN0YXRlIiwiX2ZuTG9hZFN0YXRlIiwiX2FwaV9yZWdpc3RlciIsIl9hcGlfcmVnaXN0ZXJQbHVyYWwiLCJfcmVfZGljIiwiX3JlX25ld19saW5lcyIsIl9yZV9odG1sIiwiX3JlX2RhdGUiLCJfcmVfZXNjYXBlX3JlZ2V4IiwiUmVnRXhwIiwiX3JlX2Zvcm1hdHRlZF9udW1lcmljIiwiX2VtcHR5IiwiZCIsIl9pbnRWYWwiLCJpbnRlZ2VyIiwicGFyc2VJbnQiLCJpc05hTiIsImlzRmluaXRlIiwiX251bVRvRGVjaW1hbCIsIm51bSIsImRlY2ltYWxQb2ludCIsIl9mbkVzY2FwZVJlZ2V4IiwicmVwbGFjZSIsIl9pc051bWJlciIsImZvcm1hdHRlZCIsInN0clR5cGUiLCJwYXJzZUZsb2F0IiwiX2lzSHRtbCIsIl9odG1sTnVtZXJpYyIsImh0bWwiLCJfc3RyaXBIdG1sIiwiX3BsdWNrIiwicHJvcCIsInByb3AyIiwib3V0IiwiaWVuIiwiX3BsdWNrX29yZGVyIiwiX3JhbmdlIiwic3RhcnQiLCJlbmQiLCJfcmVtb3ZlRW1wdHkiLCJfYXJlQWxsVW5pcXVlIiwic29ydGVkIiwibGFzdCIsImFnYWluIiwiX2ZsYXR0ZW4iLCJhcmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsIlN0cmluZyIsInRyaW0iLCJ1dGlsIiwidGhyb3R0bGUiLCJmcmVxIiwiZnJlcXVlbmN5IiwidGltZXIiLCJ0aGF0Iiwibm93IiwiRGF0ZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJlc2NhcGVSZWdleCIsIl9mbkh1bmdhcmlhbk1hcCIsImh1bmdhcmlhbiIsIm1hdGNoIiwibmV3S2V5Iiwia2V5IiwiaW5kZXhPZiIsIl9odW5nYXJpYW5NYXAiLCJ1c2VyIiwiZm9yY2UiLCJodW5nYXJpYW5LZXkiLCJjaGFyQXQiLCJsYW5nIiwiZGVmYXVsdERlY2ltYWwiLCJzRGVjaW1hbCIsIl9hZGROdW1lcmljU29ydCIsInplcm9SZWNvcmRzIiwic1plcm9SZWNvcmRzIiwic0VtcHR5VGFibGUiLCJzTG9hZGluZ1JlY29yZHMiLCJzSW5mb1Rob3VzYW5kcyIsInNUaG91c2FuZHMiLCJkZWNpbWFsIiwiX2ZuQ29tcGF0TWFwIiwia25ldyIsIm9sZCIsImluaXQiLCJzU2Nyb2xsWCIsInNjcm9sbFgiLCJzZWFyY2hDb2xzIiwiYW9TZWFyY2hDb2xzIiwib1NlYXJjaCIsImRhdGFTb3J0IiwiYURhdGFTb3J0IiwiX19icm93c2VyIiwiYnJvd3NlciIsIm4iLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwiaGVpZ2h0Iiwib3ZlcmZsb3ciLCJhcHBlbmQiLCJvdXRlciIsImlubmVyIiwiYmFyV2lkdGgiLCJvZmZzZXRXaWR0aCIsImNsaWVudFdpZHRoIiwiYlNjcm9sbE92ZXJzaXplIiwiYlNjcm9sbGJhckxlZnQiLCJNYXRoIiwicm91bmQiLCJvZmZzZXQiLCJiQm91bmRpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvQnJvd3NlciIsImlCYXJXaWR0aCIsIl9mblJlZHVjZSIsImluYyIsInZhbHVlIiwiaXNTZXQiLCJoYXNPd25Qcm9wZXJ0eSIsIm5UaCIsIm9EZWZhdWx0cyIsIm9Db2wiLCJvQ29sdW1uIiwiY3JlYXRlRWxlbWVudCIsInNUaXRsZSIsImlubmVySFRNTCIsImlkeCIsImFvUHJlU2VhcmNoQ29scyIsIm9PcHRpb25zIiwidGgiLCJzV2lkdGhPcmlnIiwiYXR0ciIsInQiLCJtRGF0YVByb3AiLCJzVHlwZSIsIl9zTWFudWFsVHlwZSIsImNsYXNzTmFtZSIsImlEYXRhU29ydCIsIm1EYXRhU3JjIiwibVJlbmRlciIsImF0dHJUZXN0IiwiX2JBdHRyU3JjIiwiX3NldHRlciIsInJvd0RhdGEiLCJtZXRhIiwiaW5uZXJEYXRhIiwiZm5TZXREYXRhIiwiX2ZuU2V0T2JqZWN0RGF0YUZuIiwiX3Jvd1JlYWRPYmplY3QiLCJiU29ydGFibGUiLCJzU29ydGFibGVOb25lIiwiYkFzYyIsImJEZXNjIiwic1NvcnRpbmdDbGFzcyIsInNTb3J0aW5nQ2xhc3NKVUkiLCJzU29ydGFibGVBc2MiLCJzU29ydEpVSUFzY0FsbG93ZWQiLCJzU29ydGFibGVEZXNjIiwic1NvcnRKVUlEZXNjQWxsb3dlZCIsInNTb3J0YWJsZSIsInNTb3J0SlVJIiwiX2ZuQWRqdXN0Q29sdW1uU2l6aW5nIiwiYkF1dG9XaWR0aCIsIl9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyIsInNXaWR0aCIsIl9mblZpc2libGVUb0NvbHVtbkluZGV4IiwiaU1hdGNoIiwiYWlWaXMiLCJfZm5HZXRDb2x1bW5zIiwiX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUiLCJpUG9zIiwiX2ZuVmlzYmxlQ29sdW1ucyIsInZpcyIsImJWaXNpYmxlIiwic1BhcmFtIiwiX2ZuQ29sdW1uVHlwZXMiLCJ0eXBlcyIsImRldGVjdCIsImplbiIsImtlbiIsImRldGVjdGVkVHlwZSIsImNhY2hlIiwiX2ZuR2V0Q2VsbERhdGEiLCJhb0NvbERlZnMiLCJhb0NvbHMiLCJkZWYiLCJhVGFyZ2V0cyIsInRhcmdldHMiLCJhRGF0YUluIiwiYW5UZHMiLCJvRGF0YSIsIm9Sb3ciLCJfYURhdGEiLCJuVGQiLCJzVGhpc1R5cGUiLCJhSWRzIiwiX2ZuQ3JlYXRlVHIiLCJ0cnMiLCJfZm5HZXRSb3dFbGVtZW50cyIsImNlbGxzIiwiX2ZuTm9kZVRvRGF0YUluZGV4IiwiX0RUX1Jvd0luZGV4IiwiX2ZuTm9kZVRvQ29sdW1uSW5kZXgiLCJhbkNlbGxzIiwicm93SWR4IiwiY29sSWR4IiwiaURyYXciLCJkZWZhdWx0Q29udGVudCIsInNEZWZhdWx0Q29udGVudCIsImNlbGxEYXRhIiwiaURyYXdFcnJvciIsIl9mblNldENlbGxEYXRhIiwiX19yZUFycmF5IiwiX19yZUZuIiwiX2ZuU3BsaXRPYmpOb3RhdGlvbiIsInN0ciIsIm1Tb3VyY2UiLCJmZXRjaERhdGEiLCJhcnJheU5vdGF0aW9uIiwiZnVuY05vdGF0aW9uIiwiaW5uZXJTcmMiLCJzdWJzdHJpbmciLCJzZXREYXRhIiwiYiIsImFMYXN0IiwiRXJyb3IiLCJfZm5HZXREYXRhTWFzdGVyIiwiX2ZuQ2xlYXJUYWJsZSIsIl9mbkRlbGV0ZUluZGV4IiwiaVRhcmdldCIsImlUYXJnZXRJbmRleCIsIl9mbkludmFsaWRhdGUiLCJjZWxsV3JpdGUiLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwiX2FTb3J0RGF0YSIsIl9hRmlsdGVyRGF0YSIsImNvbHMiLCJfZm5Sb3dBdHRyaWJ1dGVzIiwidGRzIiwidGQiLCJjb250ZW50cyIsIm9iamVjdFJlYWQiLCJzZXR0ZXIiLCJjZWxsUHJvY2VzcyIsIm5leHRTaWJsaW5nIiwicm93Tm9kZSIsIm5UckluIiwiY3JlYXRlIiwic0NlbGxUeXBlIiwiX0RUX0NlbGxJbmRleCIsImFwcGVuZENoaWxkIiwiZm5DcmVhdGVkQ2VsbCIsInNldEF0dHJpYnV0ZSIsInRyIiwiRFRfUm93Q2xhc3MiLCJzcGxpdCIsIl9fcm93YyIsImNvbmNhdCIsIkRUX1Jvd0F0dHIiLCJEVF9Sb3dEYXRhIiwiX2ZuQnVpbGRIZWFkIiwiY3JlYXRlSGVhZGVyIiwiaVRhYkluZGV4IiwiX2ZuU29ydEF0dGFjaExpc3RlbmVyIiwiX2ZuUmVuZGVyZXIiLCJzSGVhZGVyVEgiLCJzRm9vdGVyVEgiLCJuVGYiLCJfZm5EcmF3SGVhZCIsImFvU291cmNlIiwiYkluY2x1ZGVIaWRkZW4iLCJuTG9jYWxUciIsImFvTG9jYWwiLCJhQXBwbGllZCIsImlDb2x1bW5zIiwiaVJvd3NwYW4iLCJpQ29sc3BhbiIsIl9mbkRyYXciLCJhUHJlRHJhdyIsIl9mblByb2Nlc3NpbmdEaXNwbGF5IiwiYW5Sb3dzIiwiaVJvd0NvdW50IiwiaVN0cmlwZXMiLCJpT3BlblJvd3MiLCJhb09wZW5Sb3dzIiwib0xhbmciLCJiU2VydmVyU2lkZSIsImJEcmF3aW5nIiwiZm5SZWNvcmRzRGlzcGxheSIsImlEaXNwbGF5RW5kIiwiZm5EaXNwbGF5RW5kIiwiYkRlc3Ryb3lpbmciLCJfZm5BamF4VXBkYXRlIiwiaVN0YXJ0IiwiaUVuZCIsImlEYXRhSW5kZXgiLCJuUm93Iiwic1N0cmlwZSIsIl9zUm93U3RyaXBlIiwic1plcm8iLCJmblJlY29yZHNUb3RhbCIsInNSb3dFbXB0eSIsImJvZHkiLCJkZXRhY2giLCJiRmlsdGVyZWQiLCJfZm5SZURyYXciLCJob2xkUG9zaXRpb24iLCJiRmlsdGVyIiwiX2ZuU29ydCIsIl9mbkZpbHRlckNvbXBsZXRlIiwib1ByZXZpb3VzU2VhcmNoIiwiX2RyYXdIb2xkIiwiX2ZuQWRkT3B0aW9uc0h0bWwiLCJ0YWJsZSIsImhvbGRpbmciLCJpbnNlcnRCZWZvcmUiLCJpbnNlcnQiLCJzV3JhcHBlciIsIm5Ib2xkaW5nIiwiblRhYmxlV3JhcHBlciIsIm5UYWJsZVJlaW5zZXJ0QmVmb3JlIiwiYURvbSIsInNEb20iLCJmZWF0dXJlTm9kZSIsImNPcHRpb24iLCJuTmV3Tm9kZSIsImNOZXh0Iiwic0F0dHIiLCJzSlVJSGVhZGVyIiwic0pVSUZvb3RlciIsImFTcGxpdCIsInN1YnN0ciIsInBhcmVudCIsImJQYWdpbmF0ZSIsImJMZW5ndGhDaGFuZ2UiLCJfZm5GZWF0dXJlSHRtbExlbmd0aCIsIl9mbkZlYXR1cmVIdG1sRmlsdGVyIiwiYlByb2Nlc3NpbmciLCJfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmciLCJfZm5GZWF0dXJlSHRtbFRhYmxlIiwiYkluZm8iLCJfZm5GZWF0dXJlSHRtbEluZm8iLCJfZm5GZWF0dXJlSHRtbFBhZ2luYXRlIiwiZmVhdHVyZSIsImFvRmVhdHVyZXMiLCJjRmVhdHVyZSIsImZuSW5pdCIsImFhbkZlYXR1cmVzIiwicmVwbGFjZVdpdGgiLCJhTGF5b3V0IiwiblRycyIsIm5DZWxsIiwibCIsImlDb2xTaGlmdGVkIiwiYlVuaXF1ZSIsImZuU2hpZnRDb2wiLCJuSGVhZGVyIiwiYVJldHVybiIsInVuaXF1ZSIsImJTb3J0Q2VsbHNUb3AiLCJfZm5CdWlsZEFqYXgiLCJyYnJhY2tldCIsImFqYXhEYXRhIiwiaW5zdGFuY2UiLCJqcVhIUiIsIm5ld0RhdGEiLCJiYXNlQWpheCIsInNFcnJvciIsInNTZXJ2ZXJNZXRob2QiLCJ4aHIiLCJ0aHJvd24iLCJyZXQiLCJyZWFkeVN0YXRlIiwib0FqYXhEYXRhIiwiZm5TZXJ2ZXJEYXRhIiwic0FqYXhTb3VyY2UiLCJiQWpheERhdGFHZXQiLCJfZm5BamF4UGFyYW1ldGVycyIsIl9mbkFqYXhVcGRhdGVEcmF3IiwiY29sdW1uQ291bnQiLCJwcmVTZWFyY2giLCJwcmVDb2xTZWFyY2giLCJkYXRhUHJvcCIsImNvbHVtblNlYXJjaCIsImRpc3BsYXlTdGFydCIsImRpc3BsYXlMZW5ndGgiLCJfaURpc3BsYXlMZW5ndGgiLCJwYXJhbSIsInNTZWFyY2giLCJyZWdleCIsInNOYW1lIiwic2VhcmNoYWJsZSIsImJTZWFyY2hhYmxlIiwib3JkZXJhYmxlIiwibGVnYWN5IiwiY29tcGF0IiwibW9kZXJuIiwiX2ZuQWpheERhdGFTcmMiLCJyZWNvcmRzVG90YWwiLCJyZWNvcmRzRmlsdGVyZWQiLCJfYkluaXRDb21wbGV0ZSIsIl9mbkluaXRDb21wbGV0ZSIsImRhdGFTcmMiLCJzQWpheERhdGFQcm9wIiwidGFibGVJZCIsImxhbmd1YWdlIiwicHJldmlvdXNTZWFyY2giLCJpbnB1dCIsInNGaWx0ZXJJbnB1dCIsImYiLCJzRmlsdGVyIiwic2VhcmNoRm4iLCJzZWFyY2hEZWxheSIsImpxRmlsdGVyIiwic1NlYXJjaFBsYWNlaG9sZGVyIiwib24iLCJfZm5UaHJvdHRsZSIsImUiLCJrZXlDb2RlIiwiZXYiLCJhY3RpdmVFbGVtZW50Iiwib0lucHV0IiwiaUZvcmNlIiwib1ByZXZTZWFyY2giLCJhb1ByZXZTZWFyY2giLCJmblNhdmVGaWx0ZXIiLCJvRmlsdGVyIiwiZm5SZWdleCIsImJFc2NhcGVSZWdleCIsIl9mbkZpbHRlciIsIl9mbkZpbHRlckNvbHVtbiIsIl9mbkZpbHRlckN1c3RvbSIsImZpbHRlcnMiLCJkaXNwbGF5Um93cyIsIm1lcmdlIiwic2VhcmNoU3RyIiwic21hcnQiLCJjYXNlSW5zZW5zaXRpdmUiLCJkaXNwbGF5IiwicnBTZWFyY2giLCJfZm5GaWx0ZXJDcmVhdGVTZWFyY2giLCJ0ZXN0IiwicHJldlNlYXJjaCIsImRpc3BsYXlNYXN0ZXIiLCJpbnZhbGlkYXRlZCIsImZpbHRlcmVkIiwiX2ZuRmlsdGVyRGF0YSIsIl9zRmlsdGVyUm93Iiwid29yZCIsIm0iLCJfX2ZpbHRlcl9kaXYiLCJfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsImZpbHRlckRhdGEiLCJmb21hdHRlcnMiLCJ3YXNJbnZhbGlkYXRlZCIsImlubmVyVGV4dCIsIl9mblNlYXJjaFRvQ2FtZWwiLCJvYmoiLCJfZm5TZWFyY2hUb0h1bmciLCJ0aWQiLCJzSW5mbyIsImFvRHJhd0NhbGxiYWNrIiwiX2ZuVXBkYXRlSW5mbyIsIm1heCIsInRvdGFsIiwic0luZm9FbXB0eSIsInNJbmZvRmlsdGVyZWQiLCJzSW5mb1Bvc3RGaXgiLCJfZm5JbmZvTWFjcm9zIiwiZm5JbmZvQ2FsbGJhY2siLCJmb3JtYXR0ZXIiLCJmbkZvcm1hdE51bWJlciIsImFsbCIsImNlaWwiLCJpQWpheFN0YXJ0IiwiZGVmZXJMb2FkaW5nIiwiX2ZuU3RyaW5nVG9Dc3MiLCJhRGF0YSIsIl9mbkxlbmd0aENoYW5nZSIsIl9mbkxlbmd0aE92ZXJmbG93IiwibWVudSIsImQyIiwibGVuZ3RocyIsInNlbGVjdCIsInNMZW5ndGhTZWxlY3QiLCJPcHRpb24iLCJkaXYiLCJzTGVuZ3RoIiwic0xlbmd0aE1lbnUiLCJvdXRlckhUTUwiLCJzUGFnaW5hdGlvblR5cGUiLCJwbHVnaW4iLCJwYWdlciIsInNQYWdpbmciLCJwIiwidmlzUmVjb3JkcyIsInBhZ2VzIiwiYnV0dG9ucyIsIl9mblBhZ2VDaGFuZ2UiLCJhY3Rpb24iLCJyZWNvcmRzIiwiZmxvb3IiLCJjaGFuZ2VkIiwiciIsInNQcm9jZXNzaW5nIiwic2Nyb2xsWSIsImNhcHRpb24iLCJjYXB0aW9uU2lkZSIsImhlYWRlckNsb25lIiwiY2xvbmVOb2RlIiwiZm9vdGVyQ2xvbmUiLCJmb290ZXIiLCJfZGl2Iiwic2l6ZSIsInNjcm9sbGVyIiwic1Njcm9sbFdyYXBwZXIiLCJzU2Nyb2xsSGVhZCIsImJvcmRlciIsInNTY3JvbGxIZWFkSW5uZXIiLCJzWElubmVyIiwicmVtb3ZlQXR0ciIsInNTY3JvbGxCb2R5Iiwic1Njcm9sbEZvb3QiLCJzU2Nyb2xsRm9vdElubmVyIiwic2Nyb2xsSGVhZCIsInNjcm9sbEJvZHkiLCJzY3JvbGxGb290IiwiYkNvbGxhcHNlIiwiblNjcm9sbEhlYWQiLCJuU2Nyb2xsQm9keSIsIm5TY3JvbGxGb290Iiwic2Nyb2xsWElubmVyIiwiZGl2SGVhZGVyIiwiZGl2SGVhZGVyU3R5bGUiLCJkaXZIZWFkZXJJbm5lciIsImRpdkhlYWRlcklubmVyU3R5bGUiLCJkaXZIZWFkZXJUYWJsZSIsImRpdkJvZHlFbCIsImRpdkJvZHkiLCJkaXZCb2R5U3R5bGUiLCJkaXZGb290ZXIiLCJkaXZGb290ZXJJbm5lciIsImRpdkZvb3RlclRhYmxlIiwiaGVhZGVyIiwidGFibGVFbCIsInRhYmxlU3R5bGUiLCJpZTY3IiwiZHRIZWFkZXJDZWxscyIsImhlYWRlclRyZ0VscyIsImZvb3RlclRyZ0VscyIsImhlYWRlclNyY0VscyIsImZvb3RlclNyY0VscyIsImhlYWRlckNvcHkiLCJmb290ZXJDb3B5IiwiaGVhZGVyV2lkdGhzIiwiZm9vdGVyV2lkdGhzIiwiaGVhZGVyQ29udGVudCIsImZvb3RlckNvbnRlbnQiLCJjb3JyZWN0aW9uIiwic2FuaXR5V2lkdGgiLCJ6ZXJvT3V0IiwiblNpemVyIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwic2Nyb2xsQmFyVmlzIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY2xvbmUiLCJwcmVwZW5kVG8iLCJfZm5BcHBseVRvQ2hpbGRyZW4iLCJvdXRlcldpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiblRvU2l6ZSIsImlPdXRlcldpZHRoIiwiYlNjcm9sbGluZyIsInBhZGRpbmciLCJ0cmlnZ2VyIiwic2Nyb2xsVG9wIiwiYW4xIiwiYW4yIiwibk5vZGUxIiwibk5vZGUyIiwibm9kZVR5cGUiLCJfX3JlX2h0bWxfcmVtb3ZlIiwidmlzaWJsZUNvbHVtbnMiLCJoZWFkZXJDZWxscyIsInRhYmxlV2lkdGhBdHRyIiwidGFibGVDb250YWluZXIiLCJ1c2VySW5wdXRzIiwiY29sdW1uSWR4Iiwic3R5bGVXaWR0aCIsIl9mbkNvbnZlcnRUb1dpZHRoIiwidG1wVGFibGUiLCJtYXJnaW4iLCJfZm5HZXRXaWRlc3ROb2RlIiwic0NvbnRlbnRQYWRkaW5nIiwiaG9sZGVyIiwicmlnaHQiLCJib3VuZGluZyIsIl9yZXN6RXZ0IiwiYmluZFJlc2l6ZSIsInNJbnN0YW5jZSIsIl9mbkdldE1heExlblN0cmluZyIsIm1heElkeCIsImFpT3JpZyIsInNyY0NvbCIsImZpeGVkIiwiYWFTb3J0aW5nRml4ZWQiLCJmaXhlZE9iaiIsIm5lc3RlZFNvcnQiLCJwcmUiLCJwb3N0IiwiX2lkeCIsInNEYXRhVHlwZSIsIm9FeHRTb3J0Iiwib1NvcnQiLCJmb3JtYXR0ZXJzIiwic29ydENvbCIsIl9mblNvcnREYXRhIiwieCIsInkiLCJkYXRhQSIsImRhdGFCIiwibGFiZWwiLCJuZXh0U29ydCIsIm9BcmlhIiwicmVtb3ZlQXR0cmlidXRlIiwic1NvcnRBc2NlbmRpbmciLCJzU29ydERlc2NlbmRpbmciLCJfZm5Tb3J0TGlzdGVuZXIiLCJuZXh0U29ydElkeCIsIm5leHQiLCJiU29ydE11bHRpIiwic29ydElkeCIsImF0dGFjaFRvIiwiX2ZuQmluZEFjdGlvbiIsInNoaWZ0S2V5Iiwib2xkU29ydCIsImFMYXN0U29ydCIsInNvcnRDbGFzcyIsInNTb3J0Q29sdW1uIiwiYlNvcnRDbGFzc2VzIiwiY3VzdG9tU29ydCIsInNTb3J0RGF0YVR5cGUiLCJjdXN0b21EYXRhIiwic3RhdGUiLCJ0aW1lIiwib1NhdmVkU3RhdGUiLCJmblN0YXRlU2F2ZUNhbGxiYWNrIiwibG9hZGVkIiwiYWJTdGF0ZUxvYWQiLCJkdXJhdGlvbiIsImlTdGF0ZUR1cmF0aW9uIiwib0xvYWRlZFN0YXRlIiwiZm5TdGF0ZUxvYWRDYWxsYmFjayIsImxldmVsIiwibXNnIiwidG4iLCJzRXJyTW9kZSIsImVyck1vZGUiLCJhbGVydCIsImNvbnNvbGUiLCJsb2ciLCJtYXBwZWROYW1lIiwiZXh0ZW5kZXIiLCJicmVha1JlZnMiLCJ3aGljaCIsInByZXZlbnREZWZhdWx0Iiwic1N0b3JlIiwiY2FsbGJhY2tBcnIiLCJldmVudE5hbWUiLCJyZXZlcnNlIiwiRXZlbnQiLCJyZXN1bHQiLCJyZW5kZXJlciIsImhvc3QiLCJfX2FwaVN0cnVjdCIsIl9fYXJyYXlQcm90byIsIl90b1NldHRpbmdzIiwibWl4ZWQiLCJqcSIsInRhYmxlcyIsImNvbnRleHQiLCJjdHhTZXR0aW5ncyIsInNlbGVjdG9yIiwib3B0cyIsIkFwaSIsImFueSIsImNvdW50IiwiY3R4IiwiaXRlcmF0b3IiLCJhbHdheXNOZXciLCJpdGVtcyIsIml0ZW0iLCJhcGlJbnN0IiwiX3NlbGVjdG9yX3Jvd19pbmRleGVzIiwiYXBpU2VsZWN0b3IiLCJsYXN0SW5kZXhPZiIsInBsdWNrIiwicG9wIiwicmVkdWNlIiwicmVkdWNlUmlnaHQiLCJzaGlmdCIsInRvJCIsInRvSlF1ZXJ5IiwidW5zaGlmdCIsInNjb3BlIiwiX19kdF93cmFwcGVyIiwic3RydWN0IiwibWV0aG9kU2NvcGluZyIsInN0cnVjIiwibWV0aG9kRXh0IiwicHJvcEV4dCIsInJlZ2lzdGVyIiwiaGVpciIsIm1ldGhvZCIsInJlZ2lzdGVyUGx1cmFsIiwicGx1cmFsTmFtZSIsInNpbmd1bGFyTmFtZSIsIl9fdGFibGVfc2VsZWN0b3IiLCJwYWdpbmciLCJpbmZvIiwiX19yZWxvYWQiLCJvbmUiLCJhYm9ydCIsInJlc2V0UGFnaW5nIiwiX3NlbGVjdG9yX3J1biIsInNlbGVjdEZuIiwicmVzIiwic2VsZWN0b3JUeXBlIiwiX3NlbGVjdG9yX29wdHMiLCJfc2VsZWN0b3JfZmlyc3QiLCJpbnN0IiwiZGlzcGxheUZpbHRlcmVkIiwiZGlzcGxheUZpbHRlcmVkTWFwIiwiX19yb3dfc2VsZWN0b3IiLCJydW4iLCJzZWwiLCJzZWxJbnQiLCJjZWxsSWR4IiwiY2xvc2VzdCIsInJvd09iaiIsImhhc2giLCJ0aGF0SWR4IiwibG9vcFJvdyIsImxvb3BDZWxscyIsIm5ld1Jvd3MiLCJtb2RSb3dzIiwiX19kZXRhaWxzX2FkZCIsImtsYXNzIiwiYWRkUm93IiwiY3JlYXRlZCIsImNvbFNwYW4iLCJfZGV0YWlscyIsIl9kZXRhaWxzU2hvdyIsImluc2VydEFmdGVyIiwiX19kZXRhaWxzX3JlbW92ZSIsIl9fZGV0YWlsc19kaXNwbGF5IiwiX19kZXRhaWxzX2V2ZW50cyIsIm5hbWVzcGFjZSIsImRyYXdFdmVudCIsImNvbHZpc0V2ZW50IiwiZGVzdHJveUV2ZW50Iiwib2ZmIiwiX2VtcCIsIl9jaGlsZF9vYmoiLCJfY2hpbGRfbXRoIiwiX19yZV9jb2x1bW5fc2VsZWN0b3IiLCJfX2NvbHVtbkRhdGEiLCJyMSIsInIyIiwiX19jb2x1bW5fc2VsZWN0b3IiLCJuYW1lcyIsInZpc0NvbHVtbnMiLCJqcVJlc3VsdCIsIl9fc2V0Q29sdW1uVmlzIiwiY2FsYyIsIl9fY2VsbF9zZWxlY3RvciIsImFsbENlbGxzIiwiZm5TZWxlY3RvciIsInJvd1NlbGVjdG9yIiwiY29sdW1uU2VsZWN0b3IiLCJpbnRlcm5hbE9wdHMiLCJjZWxsc05vT3B0cyIsInNlbGVjdGVkIiwic2V0IiwiY2FzZUluc2VuIiwidmVyc2lvbkNoZWNrIiwidmVyc2lvbiIsImFUaGlzIiwiYVRoYXQiLCJpVGhpcyIsImlUaGF0IiwiaXNEYXRhVGFibGUiLCJmbklzRGF0YVRhYmxlIiwiZ2V0IiwiaXMiLCJoZWFkIiwiZm9vdCIsImZuVGFibGVzIiwiY2FtZWxUb0h1bmdhcmlhbiIsImpxUm93cyIsIm9yaWciLCJqcVRhYmxlIiwianFUYm9keSIsImpxV3JhcHBlciIsInJlbW92ZWRNZXRob2QiLCJzRGVzdHJveVdpZHRoIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsInRva2VuIiwicGx1cmFsIiwicmVzb2x2ZWQiLCJ0b0Zvcm1hdCIsIkpTT04iLCJwYXJzZSIsInNlc3Npb25TdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicGFnaW5hdGUiLCJtaW4iLCJidWlsZGVyIiwicGFnZUJ1dHRvbiIsIm9KVUlDbGFzc2VzIiwic1ZlcnNpb24iLCJhZm5GaWx0ZXJpbmciLCJhVHlwZXMiLCJvZm5TZWFyY2giLCJhZm5Tb3J0RGF0YSIsIm9TdGRDbGFzc2VzIiwib1BhZ2luYXRpb24iLCJleHRQYWdpbmF0aW9uIiwiX251bWJlcnMiLCJudW1iZXJzIiwibnVtYmVyc19sZW5ndGgiLCJoYWxmIiwiRFRfZWwiLCJzaW1wbGUiLCJmdWxsIiwic2ltcGxlX251bWJlcnMiLCJmdWxsX251bWJlcnMiLCJmaXJzdF9sYXN0X251bWJlcnMiLCJvUGFnaW5hdGUiLCJhcmlhIiwiYnRuRGlzcGxheSIsImJ0bkNsYXNzIiwiY291bnRlciIsImF0dGFjaCIsImNvbnRhaW5lciIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGlzYWJsZWRDbGFzcyIsInNQYWdlQnV0dG9uRGlzYWJsZWQiLCJjbGlja0hhbmRsZXIiLCJzRmlyc3QiLCJzUHJldmlvdXMiLCJzTmV4dCIsInNMYXN0Iiwic1BhZ2VCdXR0b25BY3RpdmUiLCJzUGFnZUJ1dHRvbiIsImFjdGl2ZUVsIiwiZW1wdHkiLCJwYXJzZWQiLCJzdHJpbmciLCJfX251bWVyaWNSZXBsYWNlIiwiZGVjaW1hbFBsYWNlIiwicmUxIiwicmUyIiwiSW5maW5pdHkiLCJ0cyIsInNTb3J0QXNjIiwic1NvcnREZXNjIiwianF1ZXJ5dWkiLCJzU29ydEpVSVdyYXBwZXIiLCJzU29ydEljb24iLCJzU29ydEpVSUFzYyIsInNTb3J0SlVJRGVzYyIsIl9faHRtbEVzY2FwZUVudGl0aWVzIiwicmVuZGVyIiwibnVtYmVyIiwidGhvdXNhbmRzIiwicHJlY2lzaW9uIiwicHJlZml4IiwicG9zdGZpeCIsIm5lZ2F0aXZlIiwiZmxvIiwidG9GaXhlZCIsImFicyIsImludFBhcnQiLCJmbG9hdFBhcnQiLCJ0ZXh0IiwiX2ZuQ2FsY3VsYXRlRW5kIiwiZGF0YVRhYmxlU2V0dGluZ3MiLCJkYXRhVGFibGVFeHQiLCJyZWFkeSIsIndvd3BpUm9zdGVyQWpheCIsImRhdGF0YWJsZV9pZCIsImFqYXh1cmwiLCJpY29uIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsWUFBUSxJQTlRWTs7QUFpUnBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxtQkFBZSxDQUFFLEVBQUYsRUFBTSxFQUFOLEVBQVUsRUFBVixFQUFjLEdBQWQsQ0F4U0s7O0FBMlNwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxpQkFBYSxJQXZUTzs7QUF5VHBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usb0JBQWdCLElBNVVJOztBQStVcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usb0JBQWdCLEVBdldJOztBQTBXcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsdUJBQW1CLElBNVhDOztBQStYcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGtCQUFjLElBaFpNOztBQW1acEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLG9CQUFnQixLQXZhSTs7QUEwYXBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsZ0JBQVksS0FuY1E7O0FBc2NwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxlQUFXLElBM2RTOztBQThkcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGFBQVMsSUEvZVc7O0FBa2ZwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLHFCQUFpQixJQWxnQkc7O0FBcWdCcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsaUJBQWEsSUFwaEJPOztBQXVoQnBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLG1CQUFlLEtBemlCSzs7QUE0aUJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsaUJBQWEsS0Eva0JPOztBQWtsQnBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLHVCQUFtQixLQXZtQkM7O0FBMG1CcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxtQkFBZSxLQTduQks7O0FBZ29CcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxhQUFTLElBaHBCVzs7QUFtcEJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usa0JBQWMsSUFwcUJNOztBQXVxQnBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsS0F4ckJHOztBQTJyQnBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usb0JBQWdCLElBOXNCSTs7QUFpdEJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGtCQUFjLEtBdnVCTTs7QUEwdUJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLG9CQUFnQixJQW53Qkk7O0FBc3dCcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usc0JBQWtCLElBeHhCRTs7QUEyeEJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLHdCQUFvQixJQXB6QkE7O0FBdXpCcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usc0JBQWtCLFVBQVdvOEIsUUFBWCxFQUFzQjtBQUN2QyxhQUFPQSxRQUFRLENBQUM1d0IsUUFBVCxHQUFvQjNCLE9BQXBCLENBQ04sdUJBRE0sRUFFTixLQUFLbEksU0FBTCxDQUFla00sVUFGVCxDQUFQO0FBSUEsS0F2MUJtQjs7QUEwMUJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usd0JBQW9CLElBcDNCQTs7QUF1M0JwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxzQkFBa0IsSUFsNUJFOztBQXE1QnBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usc0JBQWtCLElBMzZCRTs7QUE4NkJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UseUJBQXFCLElBcjhCRDs7QUF3OEJwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UscUJBQWlCLElBbCtCRzs7QUFxK0JwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usb0JBQWdCLElBNS9CSTs7QUErL0JwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxzQkFBa0IsSUF2aENFOztBQTBoQ3BCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLDJCQUF1QixVQUFXM1QsUUFBWCxFQUFzQjtBQUM1QyxVQUFJO0FBQ0gsZUFBT21pQyxJQUFJLENBQUNDLEtBQUwsQ0FDTixDQUFDcGlDLFFBQVEsQ0FBQyszQixjQUFULEtBQTRCLENBQUMsQ0FBN0IsR0FBaUNzSyxjQUFqQyxHQUFrREMsWUFBbkQsRUFBaUVDLE9BQWpFLENBQ0MsZ0JBQWN2aUMsUUFBUSxDQUFDNDBCLFNBQXZCLEdBQWlDLEdBQWpDLEdBQXFDNE4sUUFBUSxDQUFDQyxRQUQvQyxDQURNLENBQVA7QUFLQSxPQU5ELENBTUUsT0FBT3haLENBQVAsRUFBVTtBQUNYLGVBQU8sRUFBUDtBQUNBO0FBQ0QsS0Fsa0NtQjs7QUFxa0NwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UseUJBQXFCLElBeG1DRDs7QUEybUNwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsSUFob0NHOztBQW1vQ3BCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSwyQkFBdUIsVUFBV2pwQixRQUFYLEVBQXFCcEIsSUFBckIsRUFBNEI7QUFDbEQsVUFBSTtBQUNILFNBQUNvQixRQUFRLENBQUMrM0IsY0FBVCxLQUE0QixDQUFDLENBQTdCLEdBQWlDc0ssY0FBakMsR0FBa0RDLFlBQW5ELEVBQWlFSSxPQUFqRSxDQUNDLGdCQUFjMWlDLFFBQVEsQ0FBQzQwQixTQUF2QixHQUFpQyxHQUFqQyxHQUFxQzROLFFBQVEsQ0FBQ0MsUUFEL0MsRUFFQ04sSUFBSSxDQUFDUSxTQUFMLENBQWdCL2pDLElBQWhCLENBRkQ7QUFJQSxPQUxELENBS0UsT0FBT3FxQixDQUFQLEVBQVUsQ0FBRTtBQUNkLEtBdnFDbUI7O0FBMHFDcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UseUJBQXFCLElBbHNDRDs7QUFxc0NwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usc0JBQWtCLElBdHRDRTs7QUF5dENwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UscUJBQWlCLElBbHdDRzs7QUFxd0NwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usc0JBQWtCLEVBdHhDRTs7QUF5eENwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsQ0EzeUNHOztBQTh5Q3BCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxpQkFBYSxDQWwwQ087O0FBcTBDcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGdCQUFZLEVBNzBDUTs7QUFnMUNwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGlCQUFhO0FBQ1o7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRyxlQUFTO0FBQ1I7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ksMEJBQWtCLHFDQXRCVjs7QUF3QlI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ksMkJBQW1CO0FBN0NYLE9BUkc7O0FBd0RaO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHLG1CQUFhO0FBQ1o7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJLGtCQUFVLE9BckJFOztBQXdCWjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ksaUJBQVMsTUE1Q0c7O0FBK0NaO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSSxpQkFBUyxNQW5FRzs7QUFzRVo7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJLHFCQUFhO0FBMUZELE9BOUREOztBQTJKWjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0cscUJBQWUsNEJBL0tIOztBQWtMWjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0csZUFBUyw2Q0EvTUc7O0FBa05aO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHLG9CQUFjLDZCQXBPRjs7QUF1T1o7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRyx1QkFBaUIscUNBMVBMOztBQTZQWjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0csc0JBQWdCLEVBalJKOztBQW9SWjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHLGtCQUFZLEVBaFRBOztBQW1UWjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0csb0JBQWMsR0F2VUY7O0FBMFVaO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRyxxQkFBZSxxQkFoWEg7O0FBbVhaO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHLHlCQUFtQixZQXhZUDs7QUEyWVo7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0cscUJBQWUsZUE3Wkg7O0FBZ2FaO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRyxpQkFBVyxTQWhjQzs7QUFtY1o7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHLDRCQUFzQixFQTNjVjs7QUE4Y1o7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRyxjQUFRLEVBcGVJOztBQXVlWjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHLHNCQUFnQjtBQTFmSixLQXYxQ087O0FBcTFEcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsZUFBV2hyQixDQUFDLENBQUNtSSxNQUFGLENBQVUsRUFBVixFQUFjL0gsU0FBUyxDQUFDOEksTUFBVixDQUFpQmtOLE9BQS9CLENBMTJEUzs7QUE2MkRwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsTUEvM0RHOztBQWs0RHBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsbUJBQWUsSUFsNURLOztBQXE1RHBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLFlBQVEsUUF4OERZOztBQTI4RHBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxtQkFBZSxJQTU5REs7O0FBKzlEcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSx1QkFBbUIsZ0JBeC9EQzs7QUEyL0RwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGdCQUFZLEVBamhFUTs7QUFvaEVwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsRUF6aUVHOztBQTRpRXBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGdCQUFZLEVBamtFUTs7QUFva0VwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsS0FubEVHOztBQXNsRXBCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGdCQUFZLElBcm1FUTs7QUF3bUVwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsYUFBUztBQWhuRVcsR0FBckI7O0FBbW5FQTlCLGlCQUFlLENBQUVsVSxTQUFTLENBQUN5SCxRQUFaLENBQWY7QUFJQTtBQUNEO0FBQ0E7QUFDQTs7QUFFQztBQUNEO0FBQ0E7QUFDQTs7O0FBQ0N6SCxXQUFTLENBQUN5SCxRQUFWLENBQW1CaEUsTUFBbkIsR0FBNEI7QUFDM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGlCQUFhLElBdkNjO0FBd0MzQixpQkFBYSxDQUFDLENBeENhOztBQTJDM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsaUJBQWEsQ0FBRSxLQUFGLEVBQVMsTUFBVCxDQS9FYzs7QUFrRjNCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLG1CQUFlLElBaEhZOztBQW1IM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsaUJBQWEsSUFqSmM7O0FBb0ozQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxnQkFBWSxJQWxMZTs7QUFxTDNCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxxQkFBaUIsSUFsTlU7O0FBcU4zQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGFBQVMsSUF2WWtCOztBQTBZM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGVBQVcsSUFqZ0JnQjs7QUFvZ0IzQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxpQkFBYSxJQXpoQmM7O0FBNGhCM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTZFWixJQUFJLENBQUMrb0MsSUFBbEYsR0FBeUYsU0FBekYsR0FBcUcvb0MsSUFBSSxDQUFDb04sSUFBMUcsR0FBaUgsWUFBeEg7QUFDSCxPQUpMO0FBS0ksa0JBQVk7QUFMaEIsS0FMTyxFQVlQO0FBQ0ksY0FBUSxPQURaO0FBRUksZ0JBQVUsZ0JBQVNwTixJQUFULEVBQWVzRCxJQUFmLEVBQXFCMUMsR0FBckIsRUFBMEI7QUFDaEMsZUFBTyw2RUFBNkVaLElBQUksQ0FBQytvQyxJQUFsRixHQUF5RixTQUF6RixHQUFxRy9vQyxJQUFJLENBQUNvTixJQUExRyxHQUFpSCxZQUF4SDtBQUNILE9BSkw7QUFLSSxrQkFBWTtBQUxoQixLQVpPLEVBbUJQO0FBQ0ksY0FBUSxNQURaO0FBRUksZ0JBQVUsZ0JBQVVwTixJQUFWLEVBQWdCc0QsSUFBaEIsRUFBc0IxQyxHQUF0QixFQUEyQjtBQUNqQyxlQUFPLGtGQUFrRlosSUFBSSxDQUFDc0QsSUFBdkYsR0FBOEYsYUFBOUYsR0FBOEd0RCxJQUFJLENBQUNvTixJQUFuSCxHQUEwSCxZQUFqSTtBQUNILE9BSkw7QUFLSSxrQkFBWTtBQUxoQixLQW5CTyxFQTBCUDtBQUNJLGNBQVEsT0FEWjtBQUVJLGtCQUFZO0FBRmhCLEtBMUJPLEVBOEJQO0FBQ0ksY0FBUSxNQURaO0FBRUksa0JBQVk7QUFGaEIsS0E5Qk87QUFONkIsR0FBaEQ7QUEyQ0gsQ0E1Q0QsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQSx3QiIsImZpbGUiOiJ3b3dwaS1ndWlsZC1yb3N0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4iLCIvKiEgRGF0YVRhYmxlcyAxLjEwLjIyXG4gKiDCqTIwMDgtMjAyMCBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIERhdGFUYWJsZXNcbiAqIEBkZXNjcmlwdGlvbiBQYWdpbmF0ZSwgc2VhcmNoIGFuZCBvcmRlciBIVE1MIHRhYmxlc1xuICogQHZlcnNpb24gICAgIDEuMTAuMjJcbiAqIEBmaWxlICAgICAgICBqcXVlcnkuZGF0YVRhYmxlcy5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGRcbiAqIEBjb250YWN0ICAgICB3d3cuZGF0YXRhYmxlcy5uZXRcbiAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAwOC0yMDIwIFNwcnlNZWRpYSBMdGQuXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBmcmVlIHNvZnR3YXJlLCBhdmFpbGFibGUgdW5kZXIgdGhlIGZvbGxvd2luZyBsaWNlbnNlOlxuICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHVuZGVmOiB0cnVlLCBicm93c2VyOiB0cnVlICovXG4vKmdsb2JhbHMgJCxyZXF1aXJlLGpRdWVyeSxkZWZpbmUsX3NlbGVjdG9yX3J1bixfc2VsZWN0b3Jfb3B0cyxfc2VsZWN0b3JfZmlyc3QsX3NlbGVjdG9yX3Jvd19pbmRleGVzLF9leHQsX0FwaSxfYXBpX3JlZ2lzdGVyLF9hcGlfcmVnaXN0ZXJQbHVyYWwsX3JlX25ld19saW5lcyxfcmVfaHRtbCxfcmVfZm9ybWF0dGVkX251bWVyaWMsX3JlX2VzY2FwZV9yZWdleCxfZW1wdHksX2ludFZhbCxfbnVtVG9EZWNpbWFsLF9pc051bWJlcixfaXNIdG1sLF9odG1sTnVtZXJpYyxfcGx1Y2ssX3BsdWNrX29yZGVyLF9yYW5nZSxfc3RyaXBIdG1sLF91bmlxdWUsX2ZuQnVpbGRBamF4LF9mbkFqYXhVcGRhdGUsX2ZuQWpheFBhcmFtZXRlcnMsX2ZuQWpheFVwZGF0ZURyYXcsX2ZuQWpheERhdGFTcmMsX2ZuQWRkQ29sdW1uLF9mbkNvbHVtbk9wdGlvbnMsX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLF9mblZpc2libGVUb0NvbHVtbkluZGV4LF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLF9mblZpc2JsZUNvbHVtbnMsX2ZuR2V0Q29sdW1ucyxfZm5Db2x1bW5UeXBlcyxfZm5BcHBseUNvbHVtbkRlZnMsX2ZuSHVuZ2FyaWFuTWFwLF9mbkNhbWVsVG9IdW5nYXJpYW4sX2ZuTGFuZ3VhZ2VDb21wYXQsX2ZuQnJvd3NlckRldGVjdCxfZm5BZGREYXRhLF9mbkFkZFRyLF9mbk5vZGVUb0RhdGFJbmRleCxfZm5Ob2RlVG9Db2x1bW5JbmRleCxfZm5HZXRDZWxsRGF0YSxfZm5TZXRDZWxsRGF0YSxfZm5TcGxpdE9iak5vdGF0aW9uLF9mbkdldE9iamVjdERhdGFGbixfZm5TZXRPYmplY3REYXRhRm4sX2ZuR2V0RGF0YU1hc3RlcixfZm5DbGVhclRhYmxlLF9mbkRlbGV0ZUluZGV4LF9mbkludmFsaWRhdGUsX2ZuR2V0Um93RWxlbWVudHMsX2ZuQ3JlYXRlVHIsX2ZuQnVpbGRIZWFkLF9mbkRyYXdIZWFkLF9mbkRyYXcsX2ZuUmVEcmF3LF9mbkFkZE9wdGlvbnNIdG1sLF9mbkRldGVjdEhlYWRlcixfZm5HZXRVbmlxdWVUaHMsX2ZuRmVhdHVyZUh0bWxGaWx0ZXIsX2ZuRmlsdGVyQ29tcGxldGUsX2ZuRmlsdGVyQ3VzdG9tLF9mbkZpbHRlckNvbHVtbixfZm5GaWx0ZXIsX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLF9mbkVzY2FwZVJlZ2V4LF9mbkZpbHRlckRhdGEsX2ZuRmVhdHVyZUh0bWxJbmZvLF9mblVwZGF0ZUluZm8sX2ZuSW5mb01hY3JvcyxfZm5Jbml0aWFsaXNlLF9mbkluaXRDb21wbGV0ZSxfZm5MZW5ndGhDaGFuZ2UsX2ZuRmVhdHVyZUh0bWxMZW5ndGgsX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxfZm5QYWdlQ2hhbmdlLF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxfZm5Qcm9jZXNzaW5nRGlzcGxheSxfZm5GZWF0dXJlSHRtbFRhYmxlLF9mblNjcm9sbERyYXcsX2ZuQXBwbHlUb0NoaWxkcmVuLF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxfZm5UaHJvdHRsZSxfZm5Db252ZXJ0VG9XaWR0aCxfZm5HZXRXaWRlc3ROb2RlLF9mbkdldE1heExlblN0cmluZyxfZm5TdHJpbmdUb0NzcyxfZm5Tb3J0RmxhdHRlbixfZm5Tb3J0LF9mblNvcnRBcmlhLF9mblNvcnRMaXN0ZW5lcixfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsX2ZuU29ydGluZ0NsYXNzZXMsX2ZuU29ydERhdGEsX2ZuU2F2ZVN0YXRlLF9mbkxvYWRTdGF0ZSxfZm5TZXR0aW5nc0Zyb21Ob2RlLF9mbkxvZyxfZm5NYXAsX2ZuQmluZEFjdGlvbixfZm5DYWxsYmFja1JlZyxfZm5DYWxsYmFja0ZpcmUsX2ZuTGVuZ3RoT3ZlcmZsb3csX2ZuUmVuZGVyZXIsX2ZuRGF0YVNvdXJjZSxfZm5Sb3dBdHRyaWJ1dGVzKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0Ly8gQ29tbW9uSlMgZW52aXJvbm1lbnRzIHdpdGhvdXQgYSB3aW5kb3cgZ2xvYmFsIG11c3QgcGFzcyBhXG5cdFx0XHRcdC8vIHJvb3QuIFRoaXMgd2lsbCBnaXZlIGFuIGVycm9yIG90aGVyd2lzZVxuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCApIHtcblx0XHRcdFx0JCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gLy8galF1ZXJ5J3MgZmFjdG9yeSBjaGVja3MgZm9yIGEgZ2xvYmFsIHdpbmRvd1xuXHRcdFx0XHRcdHJlcXVpcmUoJ2pxdWVyeScpIDpcblx0XHRcdFx0XHRyZXF1aXJlKCdqcXVlcnknKSggcm9vdCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59XG4oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgaXMgYSBwbHVnLWluIGZvciB0aGUgalF1ZXJ5IEphdmFzY3JpcHQgbGlicmFyeS4gSXQgaXMgYSBoaWdobHlcblx0ICogZmxleGlibGUgdG9vbCwgYmFzZWQgdXBvbiB0aGUgZm91bmRhdGlvbnMgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsXG5cdCAqIHdoaWNoIHdpbGwgYWRkIGFkdmFuY2VkIGludGVyYWN0aW9uIGNvbnRyb2xzIHRvIGFueSBIVE1MIHRhYmxlLiBGb3IgYVxuXHQgKiBmdWxsIGxpc3Qgb2YgZmVhdHVyZXMgcGxlYXNlIHJlZmVyIHRvXG5cdCAqIFtEYXRhVGFibGVzLm5ldF0oaHJlZj1cImh0dHA6Ly9kYXRhdGFibGVzLm5ldCkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZWAgb2JqZWN0IGlzIG5vdCBhIGdsb2JhbCB2YXJpYWJsZSBidXQgaXMgYWxpYXNlZFxuXHQgKiB0byBgalF1ZXJ5LmZuLkRhdGFUYWJsZWAgYW5kIGBqUXVlcnkuZm4uZGF0YVRhYmxlYCB0aHJvdWdoIHdoaWNoIGl0IG1heVxuXHQgKiBiZSAgYWNjZXNzZWQuXG5cdCAqXG5cdCAqICBAY2xhc3Ncblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbaW5pdD17fV0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMuIE9wdGlvbnNcblx0ICogICAgYXJlIGRlZmluZWQgYnkge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c31cblx0ICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gQmFzaWMgaW5pdGlhbGlzYXRpb25cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBJbml0aWFsaXNhdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAtIGluIHRoaXMgY2FzZSwgZGlzYWJsZVxuXHQgKiAgICAvLyBwYWdpbmF0aW9uIGFuZCBzb3J0aW5nLlxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxuXHQgKiAgICAgICAgXCJzb3J0XCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR2YXIgRGF0YVRhYmxlID0gZnVuY3Rpb24gKCBvcHRpb25zIClcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXG5cdFx0ICogcmV0dXJuIHRoZSByZXN1bHRpbmcgalF1ZXJ5IG9iamVjdC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5maWx0ZXI9bm9uZV0gU2VsZWN0IFRSIGVsZW1lbnRzIHRoYXQgbWVldCB0aGUgY3VycmVudCBmaWx0ZXJcblx0XHQgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgVFIgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cblx0XHQgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuXHRcdCAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG5cdFx0ICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuXHRcdCAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXG5cdFx0ICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSGlnaGxpZ2h0IGV2ZXJ5IHNlY29uZCByb3dcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvIHJvd3Mgd2l0aCAnV2Via2l0JyBpbiB0aGVtLCBhZGQgYSBiYWNrZ3JvdW5kIGNvbG91ciBhbmQgdGhlblxuXHRcdCAqICAgICAgLy8gcmVtb3ZlIHRoZSBmaWx0ZXIsIHRodXMgaGlnaGxpZ2h0aW5nIHRoZSAnV2Via2l0JyByb3dzIG9ubHkuXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSkuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCAnYmx1ZScpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCcnKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy4kID0gZnVuY3Rpb24gKCBzU2VsZWN0b3IsIG9PcHRzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkodHJ1ZSkuJCggc1NlbGVjdG9yLCBvT3B0cyApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWxtb3N0IGlkZW50aWNhbCB0byAkIGluIG9wZXJhdGlvbiwgYnV0IGluIHRoaXMgY2FzZSByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbWF0Y2hlZFxuXHRcdCAqIHJvd3MgLSBhcyBzdWNoLCB0aGUgalF1ZXJ5IHNlbGVjdG9yIHVzZWQgc2hvdWxkIG1hdGNoIFRSIHJvdyBub2RlcyBvciBURC9USCBjZWxsIG5vZGVzXG5cdFx0ICogcmF0aGVyIHRoYW4gYW55IGRlc2NlbmRhbnRzLCBzbyB0aGUgZGF0YSBjYW4gYmUgb2J0YWluZWQgZm9yIHRoZSByb3cvY2VsbC4gSWYgbWF0Y2hpbmdcblx0XHQgKiByb3dzIGFyZSBmb3VuZCwgdGhlIGRhdGEgcmV0dXJuZWQgaXMgdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkvb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG9cblx0XHQgKiBjcmVhdGUgdGhlIHJvdyAob3IgYSBnZW5lcmF0ZWQgYXJyYXkgaWYgZnJvbSBhIERPTSBzb3VyY2UpLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgb2Z0ZW4gdXNlZnVsIGluLWNvbWJpbmF0aW9uIHdpdGggJCB3aGVyZSBib3RoIGZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlXG5cdFx0ICogc2FtZSBwYXJhbWV0ZXJzIGFuZCB0aGUgYXJyYXkgaW5kZXhlcyB3aWxsIG1hdGNoIGlkZW50aWNhbGx5LlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuXHRcdCAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBkYXRhIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXG5cdFx0ICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3Jcblx0XHQgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxuXHRcdCAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcblx0XHQgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IERhdGEgZm9yIHRoZSBtYXRjaGVkIGVsZW1lbnRzLiBJZiBhbnkgZWxlbWVudHMsIGFzIGEgcmVzdWx0IG9mIHRoZVxuXHRcdCAqICAgIHNlbGVjdG9yLCB3ZXJlIG5vdCBUUiwgVEQgb3IgVEggZWxlbWVudHMgaW4gdGhlIERhdGFUYWJsZSwgdGhleSB3aWxsIGhhdmUgYSBudWxsXG5cdFx0ICogICAgZW50cnkgaW4gdGhlIGFycmF5LlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZVxuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHI6Zmlyc3QnKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBkYXRhXG5cdFx0ICogICAgICBhbGVydCggXCJGaXJzdCBjZWxsIGlzOiBcIitkYXRhWzBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvICdXZWJraXQnIGFuZCBnZXQgYWxsIGRhdGEgZm9yXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGFcblx0XHQgKiAgICAgIGFsZXJ0KCBkYXRhLmxlbmd0aCtcIiByb3dzIG1hdGNoZWQgdGhlIHNlYXJjaFwiICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuXyA9IGZ1bmN0aW9uICggc1NlbGVjdG9yLCBvT3B0cyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKHRydWUpLnJvd3MoIHNTZWxlY3Rvciwgb09wdHMgKS5kYXRhKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBEYXRhVGFibGVzIEFwaSBpbnN0YW5jZSwgd2l0aCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYmxlcyBmb3Jcblx0XHQgKiB0aGUgQXBpJ3MgY29udGV4dC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFkaXRpb25hbD1mYWxzZV0gU2V0IHRoZSBBUEkgaW5zdGFuY2UncyBjb250ZXh0IHRvIGJlXG5cdFx0ICogICBvbmx5IHRoZSB0YWJsZSByZWZlcnJlZCB0byBieSB0aGUgYERhdGFUYWJsZS5leHQuaUFwaUluZGV4YCBvcHRpb24sIGFzIHdhc1xuXHRcdCAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxuXHRcdCAqICAgb3IgaWYgYWxsIHRhYmxlcyBjYXB0dXJlZCBpbiB0aGUgalF1ZXJ5IG9iamVjdCBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBAcmV0dXJuIHtEYXRhVGFibGVzLkFwaX1cblx0XHQgKi9cblx0XHR0aGlzLmFwaSA9IGZ1bmN0aW9uICggdHJhZGl0aW9uYWwgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cmFkaXRpb25hbCA/XG5cdFx0XHRcdG5ldyBfQXBpKFxuXHRcdFx0XHRcdF9mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbIF9leHQuaUFwaUluZGV4IF0gKVxuXHRcdFx0XHQpIDpcblx0XHRcdFx0bmV3IF9BcGkoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXG5cdFx0ICogdGhhdCB0aGlzIGlzIHN1aXRhYmxlIGZvciBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIG9ubHkgLSBpZiB5b3UgYXJlIHVzaW5nXG5cdFx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAoaS5lLiBcImJTZXJ2ZXJTaWRlXCI6IHRydWUpLCB0aGVuIHRvIGFkZCBkYXRhLCB5b3Vcblx0XHQgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRhYmxlLiBUaGlzIGNhbiBiZTpcblx0XHQgKiAgICA8dWw+XG5cdFx0ICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XG5cdFx0ICogICAgICA8bGk+MkQgYXJyYXkgb2YgYXJyYXlzIC0gYWRkIG11bHRpcGxlIHJvd3MgaW4gYSBzaW5nbGUgY2FsbDwvbGk+XG5cdFx0ICogICAgICA8bGk+b2JqZWN0IC0gZGF0YSBvYmplY3Qgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgIDwvdWw+XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxuXHRcdCAqICAgIDxpPmFvRGF0YTwvaT4gKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc30pIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvXG5cdFx0ICogICAgdGhlIHRhYmxlLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBHbG9iYWwgdmFyIGZvciBjb3VudGVyXG5cdFx0ICogICAgdmFyIGdpQ291bnQgPSAyO1xuXHRcdCAqXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIGZuQ2xpY2tBZGRSb3coKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjFcIixcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi4yXCIsXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjRcIiBdXG5cdFx0ICogICAgICApO1xuXHRcdCAqXG5cdFx0ICogICAgICBnaUNvdW50Kys7XG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGREYXRhID0gZnVuY3Rpb24oIGRhdGEsIHJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHQvKiBDaGVjayBpZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSByb3dzIG9yIG5vdCAqL1xuXHRcdFx0dmFyIHJvd3MgPSBBcnJheS5pc0FycmF5KGRhdGEpICYmICggQXJyYXkuaXNBcnJheShkYXRhWzBdKSB8fCAkLmlzUGxhaW5PYmplY3QoZGF0YVswXSkgKSA/XG5cdFx0XHRcdGFwaS5yb3dzLmFkZCggZGF0YSApIDpcblx0XHRcdFx0YXBpLnJvdy5hZGQoIGRhdGEgKTtcblx0XHRcblx0XHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIHJvd3MuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIERhdGFUYWJsZXMgcmVjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXplcywgYmFzZWQgb24gdGhlIGRhdGFcblx0XHQgKiBjb250YWluZWQgaW4gdGhlIHRhYmxlIGFuZCB0aGUgc2l6ZXMgYXBwbGllZCB0byB0aGUgY29sdW1ucyAoaW4gdGhlIERPTSwgQ1NTIG9yXG5cdFx0ICogdGhyb3VnaCB0aGUgc1dpZHRoIHBhcmFtZXRlcikuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUnc1xuXHRcdCAqIHBhcmVudCBlbGVtZW50IGNoYW5nZXMgKGZvciBleGFtcGxlIGEgd2luZG93IHJlc2l6ZSkuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3QsIHlvdSB3aWxsIHR5cGljYWxseSB3YW50IHRvXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic1Njcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcImJQYWdpbmF0ZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgb1RhYmxlLmZuQWRqdXN0Q29sdW1uU2l6aW5nKCk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGp1c3RDb2x1bW5TaXppbmcgPSBmdW5jdGlvbiAoIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSBhcGkuc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsLnNYICE9PSBcIlwiIHx8IHNjcm9sbC5zWSAhPT0gXCJcIiApIHtcblx0XHRcdFx0LyogSWYgbm90IHJlZHJhd2luZywgYnV0IHNjcm9sbGluZywgd2Ugd2FudCB0byBhcHBseSB0aGUgbmV3IGNvbHVtbiBzaXplcyBhbnl3YXkgKi9cblx0XHRcdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFF1aWNrbHkgYW5kIHNpbXBseSBjbGVhciBhIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW1tZWRpYXRlbHkgJ251a2UnIHRoZSBjdXJyZW50IHJvd3MgKHBlcmhhcHMgd2FpdGluZyBmb3IgYW4gQWpheCBjYWxsYmFjay4uLilcblx0XHQgKiAgICAgIG9UYWJsZS5mbkNsZWFyVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkNsZWFyVGFibGUgPSBmdW5jdGlvbiggYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY2xlYXIoKTtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXhhY3Qgb3Bwb3NpdGUgb2YgJ29wZW5pbmcnIGEgcm93LCB0aGlzIGZ1bmN0aW9uIHdpbGwgY2xvc2UgYW55IHJvd3Mgd2hpY2hcblx0XHQgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byAnY2xvc2UnXG5cdFx0ICogIEByZXR1cm5zIHtpbnR9IDAgb24gc3VjY2Vzcywgb3IgMSBpZiBmYWlsZWQgKGNhbid0IGZpbmQgdGhlIHJvdylcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHRcdCAqICAgICAgICB9IGVsc2Uge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkNsb3NlID0gZnVuY3Rpb24oIG5UciApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmhpZGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhIHJvdyBmb3IgdGhlIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7bWl4ZWR9IHRhcmdldCBUaGUgaW5kZXggb2YgdGhlIHJvdyBmcm9tIGFvRGF0YSB0byBiZSBkZWxldGVkLCBvclxuXHRcdCAqICAgIHRoZSBUUiBlbGVtZW50IHlvdSB3YW50IHRvIGRlbGV0ZVxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IFtjYWxsQmFja10gQ2FsbGJhY2sgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEByZXR1cm5zIHthcnJheX0gVGhlIHJvdyB0aGF0IHdhcyBkZWxldGVkXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgZmlyc3Qgcm93XG5cdFx0ICogICAgICBvVGFibGUuZm5EZWxldGVSb3coIDAgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkRlbGV0ZVJvdyA9IGZ1bmN0aW9uKCB0YXJnZXQsIGNhbGxiYWNrLCByZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFx0dmFyIHJvd3MgPSBhcGkucm93cyggdGFyZ2V0ICk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSByb3dzLnNldHRpbmdzKClbMF07XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93c1swXVswXSBdO1xuXHRcdFxuXHRcdFx0cm93cy5yZW1vdmUoKTtcblx0XHRcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXMsIHNldHRpbmdzLCBkYXRhICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVzdG9yZSB0aGUgdGFibGUgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSBpbiB0aGUgRE9NIGJ5IHJlbW92aW5nIGFsbCBvZiBEYXRhVGFibGVzXG5cdFx0ICogZW5oYW5jZW1lbnRzLCBhbHRlcmF0aW9ucyB0byB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdGFibGUgYW5kIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKiAgQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlPWZhbHNlXSBDb21wbGV0ZWx5IHJlbW92ZSB0aGUgdGFibGUgZnJvbSB0aGUgRE9NXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgLy8gVGhpcyBleGFtcGxlIGlzIGZhaXJseSBwb2ludGxlc3MgaW4gcmVhbGl0eSwgYnV0IHNob3dzIGhvdyBmbkRlc3Ryb3kgY2FuIGJlIHVzZWRcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRGVzdHJveSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRGVzdHJveSA9IGZ1bmN0aW9uICggcmVtb3ZlIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLmRlc3Ryb3koIHJlbW92ZSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVkcmF3IHRoZSB0YWJsZVxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtjb21wbGV0ZT10cnVlXSBSZS1maWx0ZXIgYW5kIHJlc29ydCAoaWYgZW5hYmxlZCkgdGhlIHRhYmxlIGJlZm9yZSB0aGUgZHJhdy5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gUmUtZHJhdyB0aGUgdGFibGUgLSB5b3Ugd291bGRuJ3Qgd2FudCB0byBkbyBpdCBoZXJlLCBidXQgaXQncyBhbiBleGFtcGxlIDotKVxuXHRcdCAqICAgICAgb1RhYmxlLmZuRHJhdygpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRHJhdyA9IGZ1bmN0aW9uKCBjb21wbGV0ZSApXG5cdFx0e1xuXHRcdFx0Ly8gTm90ZSB0aGF0IHRoaXMgaXNuJ3QgYW4gZXhhY3QgbWF0Y2ggdG8gdGhlIG9sZCBjYWxsIHRvIF9mbkRyYXcgLSBpdCB0YWtlc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50IHRoZSBuZXcgZGF0YSwgYnV0IGNhbiBob2xkIHBvc2l0aW9uLlxuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5kcmF3KCBjb21wbGV0ZSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyIHRoZSBpbnB1dCBiYXNlZCBvbiBkYXRhXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgU3RyaW5nIHRvIGZpbHRlciB0aGUgdGFibGUgb25cblx0XHQgKiAgQHBhcmFtIHtpbnR8bnVsbH0gW2lDb2x1bW5dIENvbHVtbiB0byBsaW1pdCBmaWx0ZXJpbmcgdG9cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZ2V4PWZhbHNlXSBUcmVhdCBhcyByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JTbWFydD10cnVlXSBQZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlNob3dHbG9iYWw9dHJ1ZV0gU2hvdyB0aGUgaW5wdXQgZ2xvYmFsIGZpbHRlciBpbiBpdCdzIGlucHV0IGJveChlcylcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYkNhc2VJbnNlbnNpdGl2ZT10cnVlXSBEbyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nICh0cnVlKSBvciBub3QgKGZhbHNlKVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTb21ldGltZSBsYXRlciAtIGZpbHRlci4uLlxuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCAndGVzdCBzdHJpbmcnICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5GaWx0ZXIgPSBmdW5jdGlvbiggc0lucHV0LCBpQ29sdW1uLCBiUmVnZXgsIGJTbWFydCwgYlNob3dHbG9iYWwsIGJDYXNlSW5zZW5zaXRpdmUgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0aWYgKCBpQ29sdW1uID09PSBudWxsIHx8IGlDb2x1bW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0YXBpLnNlYXJjaCggc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5jb2x1bW4oIGlDb2x1bW4gKS5zZWFyY2goIHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB3aG9sZSB0YWJsZSwgYW4gaW5kaXZpZHVhbCByb3cgb3IgYW4gaW5kaXZpZHVhbCBjZWxsIGJhc2VkIG9uIHRoZVxuXHRcdCAqIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG5cdFx0ICogIEBwYXJhbSB7aW50fG5vZGV9IFtzcmNdIEEgVFIgcm93IG5vZGUsIFREL1RIIGNlbGwgbm9kZSBvciBhbiBpbnRlZ2VyLiBJZiBnaXZlbiBhc1xuXHRcdCAqICAgIGEgVFIgbm9kZSB0aGVuIHRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhXG5cdFx0ICogICAgVEQvVEggY2VsbCBub2RlIHRoZW4gaUNvbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdGhlIGRhdGEgZm9yIHRoZVxuXHRcdCAqICAgIGNlbGwgcmV0dXJuZWQuIElmIGdpdmVuIGFzIGFuIGludGVnZXIsIHRoZW4gdGhpcyBpcyB0cmVhdGVkIGFzIHRoZSBhb0RhdGEgaW50ZXJuYWxcblx0XHQgKiAgICBkYXRhIGluZGV4IGZvciB0aGUgcm93IChzZWUgZm5HZXRQb3NpdGlvbikgYW5kIHRoZSBkYXRhIGZvciB0aGF0IHJvdyB1c2VkLlxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2NvbF0gT3B0aW9uYWwgY29sdW1uIGluZGV4IHRoYXQgeW91IHdhbnQgdGhlIGRhdGEgb2YuXG5cdFx0ICogIEByZXR1cm5zIHthcnJheXxvYmplY3R8c3RyaW5nfSBJZiBtUm93IGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgZGF0YSBmb3IgYWxsIHJvd3MgaXNcblx0XHQgKiAgICByZXR1cm5lZC4gSWYgbVJvdyBpcyBkZWZpbmVkLCBqdXN0IGRhdGEgZm9yIHRoYXQgcm93LCBhbmQgaXMgaUNvbCBpc1xuXHRcdCAqICAgIGRlZmluZWQsIG9ubHkgZGF0YSBmb3IgdGhlIGRlc2lnbmF0ZWQgY2VsbCBpcyByZXR1cm5lZC5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUm93IGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIHZhciBkYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuXHRcdCAqICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFycmF5IC8gb2JqZWN0IG9mIGRhdGEgZm9yIHRoZSByb3dcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBJbmRpdmlkdWFsIGNlbGwgZGF0YVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgdmFyIHNEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuXHRcdCAqICAgICAgICBhbGVydCggJ1RoZSBjZWxsIGNsaWNrZWQgb24gaGFkIHRoZSB2YWx1ZSBvZiAnK3NEYXRhICk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5HZXREYXRhID0gZnVuY3Rpb24oIHNyYywgY29sIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdGlmICggc3JjICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gc3JjLm5vZGVOYW1lID8gc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0XHRcblx0XHRcdFx0cmV0dXJuIGNvbCAhPT0gdW5kZWZpbmVkIHx8IHR5cGUgPT0gJ3RkJyB8fCB0eXBlID09ICd0aCcgP1xuXHRcdFx0XHRcdGFwaS5jZWxsKCBzcmMsIGNvbCApLmRhdGEoKSA6XG5cdFx0XHRcdFx0YXBpLnJvdyggc3JjICkuZGF0YSgpIHx8IG51bGw7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRyZXR1cm4gYXBpLmRhdGEoKS50b0FycmF5KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgYW4gYXJyYXkgb2YgdGhlIFRSIG5vZGVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlJ3MgYm9keS4gTm90ZSB0aGF0IHlvdSB3aWxsXG5cdFx0ICogdHlwaWNhbGx5IHdhbnQgdG8gdXNlIHRoZSAnJCcgQVBJIG1ldGhvZCBpbiBwcmVmZXJlbmNlIHRvIHRoaXMgYXMgaXQgaXMgbW9yZVxuXHRcdCAqIGZsZXhpYmxlLlxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2lSb3ddIE9wdGlvbmFsIHJvdyBpbmRleCBmb3IgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnRcblx0XHQgKiAgQHJldHVybnMge2FycmF5fG5vZGV9IElmIGlSb3cgaXMgdW5kZWZpbmVkLCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBUUiBlbGVtZW50c1xuXHRcdCAqICAgIGluIHRoZSB0YWJsZSdzIGJvZHksIG9yIGlSb3cgaXMgZGVmaW5lZCwganVzdCB0aGUgVFIgZWxlbWVudCByZXF1ZXN0ZWQuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEdldCB0aGUgbm9kZXMgZnJvbSB0aGUgdGFibGVcblx0XHQgKiAgICAgIHZhciBuTm9kZXMgPSBvVGFibGUuZm5HZXROb2RlcyggKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldE5vZGVzID0gZnVuY3Rpb24oIGlSb3cgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0cmV0dXJuIGlSb3cgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGFwaS5yb3coIGlSb3cgKS5ub2RlKCkgOlxuXHRcdFx0XHRhcGkucm93cygpLm5vZGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgYXJyYXkgaW5kZXhlcyBvZiBhIHBhcnRpY3VsYXIgY2VsbCBmcm9tIGl0J3MgRE9NIGVsZW1lbnRcblx0XHQgKiBhbmQgY29sdW1uIGluZGV4IGluY2x1ZGluZyBoaWRkZW4gY29sdW1uc1xuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5vZGUgdGhpcyBjYW4gZWl0aGVyIGJlIGEgVFIsIFREIG9yIFRIIGluIHRoZSB0YWJsZSdzIGJvZHlcblx0XHQgKiAgQHJldHVybnMge2ludH0gSWYgbk5vZGUgaXMgZ2l2ZW4gYXMgYSBUUiwgdGhlbiBhIHNpbmdsZSBpbmRleCBpcyByZXR1cm5lZCwgb3Jcblx0XHQgKiAgICBpZiBnaXZlbiBhcyBhIGNlbGwsIGFuIGFycmF5IG9mIFtyb3cgaW5kZXgsIGNvbHVtbiBpbmRleCAodmlzaWJsZSksXG5cdFx0ICogICAgY29sdW1uIGluZGV4IChhbGwpXSBpcyBnaXZlbi5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0YSBmcm9tIHRoZSBub2RlXG5cdFx0ICogICAgICAgIHZhciBhUG9zID0gb1RhYmxlLmZuR2V0UG9zaXRpb24oIHRoaXMgKTtcblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBHZXQgdGhlIGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogICAgICAgIHZhciBhRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIGFQb3NbMF0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBVcGRhdGUgdGhlIGRhdGEgYXJyYXkgYW5kIHJldHVybiB0aGUgdmFsdWVcblx0XHQgKiAgICAgICAgYURhdGFbIGFQb3NbMV0gXSA9ICdjbGlja2VkJztcblx0XHQgKiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnY2xpY2tlZCc7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEluaXQgRGF0YVRhYmxlc1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldFBvc2l0aW9uID0gZnVuY3Rpb24oIG5vZGUgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdFxuXHRcdFx0aWYgKCBub2RlTmFtZSA9PSAnVFInICkge1xuXHRcdFx0XHRyZXR1cm4gYXBpLnJvdyggbm9kZSApLmluZGV4KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggbm9kZU5hbWUgPT0gJ1REJyB8fCBub2RlTmFtZSA9PSAnVEgnICkge1xuXHRcdFx0XHR2YXIgY2VsbCA9IGFwaS5jZWxsKCBub2RlICkuaW5kZXgoKTtcblx0XHRcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRjZWxsLnJvdyxcblx0XHRcdFx0XHRjZWxsLmNvbHVtblZpc2libGUsXG5cdFx0XHRcdFx0Y2VsbC5jb2x1bW5cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgdG8gc2VlIGlmIGEgcm93IGlzICdvcGVuJyBvciBub3QuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIHRoZSB0YWJsZSByb3cgdG8gY2hlY2tcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdyBpcyBjdXJyZW50bHkgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgfSBlbHNlIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Jc09wZW4gPSBmdW5jdGlvbiggblRyIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmlzU2hvd24oKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XG5cdFx0ICogb24gZGlzcGxheSBvbiB0aGUgcGFnZSwgd2l0aCB0aGUgSFRNTCBjb250ZW50cyB0aGF0IGlzIHBhc3NlZCBpbnRvIHRoZVxuXHRcdCAqIGZ1bmN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gYXNrIGZvciBjb25maXJtYXRpb24gdGhhdCBhXG5cdFx0ICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIFRoZSB0YWJsZSByb3cgdG8gJ29wZW4nXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBtSHRtbCBUaGUgSFRNTCB0byBwdXQgaW50byB0aGUgcm93XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcblx0XHQgKiAgQHJldHVybnMge25vZGV9IFRoZSByb3cgb3BlbmVkLiBOb3RlIHRoYXQgaWYgdGhlIHRhYmxlIHJvdyBwYXNzZWQgaW4gYXMgdGhlXG5cdFx0ICogICAgZmlyc3QgcGFyYW1ldGVyLCBpcyBub3QgZm91bmQgaW4gdGhlIHRhYmxlLCB0aGlzIG1ldGhvZCB3aWxsIHNpbGVudGx5XG5cdFx0ICogICAgcmV0dXJuLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGU7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG5cdFx0ICogICAgICAgIH0gZWxzZSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuT3BlbiA9IGZ1bmN0aW9uKCBuVHIsIG1IdG1sLCBzQ2xhc3MgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSggdHJ1ZSApXG5cdFx0XHRcdC5yb3coIG5UciApXG5cdFx0XHRcdC5jaGlsZCggbUh0bWwsIHNDbGFzcyApXG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LmNoaWxkKClbMF07XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIHBhZ2luYXRpb24gLSBwcm92aWRlcyB0aGUgaW50ZXJuYWwgbG9naWMgZm9yIHBhZ2luYXRpb24gaW4gYSBzaW1wbGUgQVBJXG5cdFx0ICogZnVuY3Rpb24uIFdpdGggdGhpcyBmdW5jdGlvbiB5b3UgY2FuIGhhdmUgYSBEYXRhVGFibGVzIHRhYmxlIGdvIHRvIHRoZSBuZXh0LFxuXHRcdCAqIHByZXZpb3VzLCBmaXJzdCBvciBsYXN0IHBhZ2VzLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IG1BY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIiwgXCJuZXh0XCIgb3IgXCJsYXN0XCJcblx0XHQgKiAgICBvciBwYWdlIG51bWJlciB0byBqdW1wIHRvIChpbnRlZ2VyKSwgbm90ZSB0aGF0IHBhZ2UgMCBpcyB0aGUgZmlyc3QgcGFnZS5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuUGFnZUNoYW5nZSggJ25leHQnICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5QYWdlQ2hhbmdlID0gZnVuY3Rpb24gKCBtQWN0aW9uLCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5wYWdlKCBtQWN0aW9uICk7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBTaG93IGEgcGFydGljdWxhciBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgVGhlIGNvbHVtbiB3aG9zZSBkaXNwbGF5IHNob3VsZCBiZSBjaGFuZ2VkXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gYlNob3cgU2hvdyAodHJ1ZSkgb3IgaGlkZSAoZmFsc2UpIHRoZSBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBIaWRlIHRoZSBzZWNvbmQgY29sdW1uIGFmdGVyIGluaXRpYWxpc2F0aW9uXG5cdFx0ICogICAgICBvVGFibGUuZm5TZXRDb2x1bW5WaXMoIDEsIGZhbHNlICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5TZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIGlDb2wsIGJTaG93LCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jb2x1bW4oIGlDb2wgKS52aXNpYmxlKCBiU2hvdyApO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmNvbHVtbnMuYWRqdXN0KCkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzZXR0aW5ncyBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cblx0XHQgKiAgQHJldHVybnMge29iamVjdH0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIHZhciBvU2V0dGluZ3MgPSBvVGFibGUuZm5TZXR0aW5ncygpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTaG93IGFuIGV4YW1wbGUgcGFyYW1ldGVyIGZyb20gdGhlIHNldHRpbmdzXG5cdFx0ICogICAgICBhbGVydCggb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5TZXR0aW5ncyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tfZXh0LmlBcGlJbmRleF0gKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNvcnQgdGhlIHRhYmxlIGJ5IGEgcGFydGljdWxhciBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgdGhlIGRhdGEgaW5kZXggdG8gc29ydCBvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgbWF0Y2ggdGhlXG5cdFx0ICogICAgJ2Rpc3BsYXkgaW5kZXgnIGlmIHlvdSBoYXZlIGhpZGRlbiBkYXRhIGVudHJpZXNcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29ydCBpbW1lZGlhdGVseSB3aXRoIGNvbHVtbnMgMCBhbmQgMVxuXHRcdCAqICAgICAgb1RhYmxlLmZuU29ydCggWyBbMCwnYXNjJ10sIFsxLCdhc2MnXSBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Tb3J0ID0gZnVuY3Rpb24oIGFhU29ydCApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5vcmRlciggYWFTb3J0ICkuZHJhdygpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5Ob2RlIHRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc29ydCBsaXN0ZW5lciB0b1xuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtmbkNhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvcnQgb24gY29sdW1uIDEsIHdoZW4gJ3NvcnRlcicgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgb1RhYmxlLmZuU29ydExpc3RlbmVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29ydGVyJyksIDEgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5vcmRlci5saXN0ZW5lciggbk5vZGUsIGlDb2x1bW4sIGZuQ2FsbGJhY2sgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSBhIHRhYmxlIGNlbGwgb3Igcm93IC0gdGhpcyBtZXRob2Qgd2lsbCBhY2NlcHQgZWl0aGVyIGEgc2luZ2xlIHZhbHVlIHRvXG5cdFx0ICogdXBkYXRlIHRoZSBjZWxsIHdpdGgsIGFuIGFycmF5IG9mIHZhbHVlcyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGNvbHVtbiBvclxuXHRcdCAqIGFuIG9iamVjdCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlLiBUaGUgZnVuY3Rpb24gaXNcblx0XHQgKiBzZWxmLXJlZmVyZW5jaW5nIGluIG9yZGVyIHRvIG1ha2UgdGhlIG11bHRpIGNvbHVtbiB1cGRhdGVzIGVhc2llci5cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfSBtRGF0YSBEYXRhIHRvIHVwZGF0ZSB0aGUgY2VsbC9yb3cgd2l0aFxuXHRcdCAqICBAcGFyYW0ge25vZGV8aW50fSBtUm93IFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gdXBkYXRlIG9yIHRoZSBhb0RhdGEgaW5kZXhcblx0XHQgKiAgQHBhcmFtIHtpbnR9IFtpQ29sdW1uXSBUaGUgY29sdW1uIHRvIHVwZGF0ZSwgZ2l2ZSBhcyBudWxsIG9yIHVuZGVmaW5lZCB0b1xuXHRcdCAqICAgIHVwZGF0ZSBhIHdob2xlIHJvdy5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiQWN0aW9uPXRydWVdIFBlcmZvcm0gcHJlLWRyYXcgYWN0aW9ucyBvciBub3Rcblx0XHQgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCAxIG9uIGVycm9yXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5VcGRhdGUoICdFeGFtcGxlIHVwZGF0ZScsIDAsIDAgKTsgLy8gU2luZ2xlIGNlbGxcblx0XHQgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgJCgndGJvZHkgdHInKVswXSApOyAvLyBSb3dcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblVwZGF0ZSA9IGZ1bmN0aW9uKCBtRGF0YSwgbVJvdywgaUNvbHVtbiwgYlJlZHJhdywgYkFjdGlvbiApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRpZiAoIGlDb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBpQ29sdW1uID09PSBudWxsICkge1xuXHRcdFx0XHRhcGkucm93KCBtUm93ICkuZGF0YSggbURhdGEgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhcGkuY2VsbCggbVJvdywgaUNvbHVtbiApLmRhdGEoIG1EYXRhICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIGJBY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBiQWN0aW9uICkge1xuXHRcdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nIHVzZWQsIGluIG9yZGVyXG5cdFx0ICogdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzVmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLiBOb3RlIHRoYXQgdGhlXG5cdFx0ICogICAgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZSByZXF1aXJlZFxuXHRcdCAqICAgIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90IHN1aXRhYmxlXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIGFsZXJ0KCBvVGFibGUuZm5WZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuVmVyc2lvbkNoZWNrID0gX2V4dC5mblZlcnNpb25DaGVjaztcblx0XHRcblxuXHRcdHZhciBfdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGVtcHR5SW5pdCA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZDtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGVtcHR5SW5pdCApIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9XG5cblx0XHR0aGlzLm9BcGkgPSB0aGlzLmludGVybmFsID0gX2V4dC5pbnRlcm5hbDtcblxuXHRcdC8vIEV4dGVuZCB3aXRoIG9sZCBzdHlsZSBwbHVnLWluIEFQSSBtZXRob2RzXG5cdFx0Zm9yICggdmFyIGZuIGluIERhdGFUYWJsZS5leHQuaW50ZXJuYWwgKSB7XG5cdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHR0aGlzW2ZuXSA9IF9mbkV4dGVybkFwaUZ1bmMoZm4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdC8vIEZvciBlYWNoIGluaXRpYWxpc2F0aW9uIHdlIHdhbnQgdG8gZ2l2ZSBpdCBhIGNsZWFuIGluaXRpYWxpc2F0aW9uXG5cdFx0XHQvLyBvYmplY3QgdGhhdCBjYW4gYmUgYmFzaGVkIGFyb3VuZFxuXHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdHZhciBvSW5pdCA9IGxlbiA+IDEgPyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSB0YWJsZSBjYXNlXG5cdFx0XHRcdF9mbkV4dGVuZCggbywgb3B0aW9ucywgdHJ1ZSApIDpcblx0XHRcdFx0b3B0aW9ucztcblxuXHRcdFx0LypnbG9iYWwgb0luaXQsX3RoYXQsZW1wdHlJbml0Ki9cblx0XHRcdHZhciBpPTAsIGlMZW4sIGosIGpMZW4sIGssIGtMZW47XG5cdFx0XHR2YXIgc0lkID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdHZhciBiSW5pdEhhbmRlZE9mZiA9IGZhbHNlO1xuXHRcdFx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvKiBTYW5pdHkgY2hlY2sgKi9cblx0XHRcdGlmICggdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICd0YWJsZScgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5Mb2coIG51bGwsIDAsICdOb24tdGFibGUgbm9kZSBpbml0aWFsaXNhdGlvbiAoJyt0aGlzLm5vZGVOYW1lKycpJywgMiApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgZGVmYXVsdHMgKi9cblx0XHRcdF9mbkNvbXBhdE9wdHMoIGRlZmF1bHRzICk7XG5cdFx0XHRfZm5Db21wYXRDb2xzKCBkZWZhdWx0cy5jb2x1bW4gKTtcblx0XHRcdFxuXHRcdFx0LyogQ29udmVydCB0aGUgY2FtZWwtY2FzZSBkZWZhdWx0cyB0byBIdW5nYXJpYW4gKi9cblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCBkZWZhdWx0cywgdHJ1ZSApO1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUgKTtcblx0XHRcdFxuXHRcdFx0LyogU2V0dGluZyB1cCB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0ICovXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgJC5leHRlbmQoIG9Jbml0LCAkdGhpcy5kYXRhKCkgKSwgdHJ1ZSApO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xuXHRcdFx0dmFyIGFsbFNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFsbFNldHRpbmdzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBzID0gYWxsU2V0dGluZ3NbaV07XG5cdFx0XHRcblx0XHRcdFx0LyogQmFzZSBjaGVjayBvbiB0YWJsZSBub2RlICovXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRzLm5UYWJsZSA9PSB0aGlzIHx8XG5cdFx0XHRcdFx0KHMublRIZWFkICYmIHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcykgfHxcblx0XHRcdFx0XHQocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdFx0dmFyIGJEZXN0cm95ID0gb0luaXQuYkRlc3Ryb3kgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJEZXN0cm95IDogZGVmYXVsdHMuYkRlc3Ryb3k7XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBzLm9JbnN0YW5jZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGJEZXN0cm95IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxuXHRcdFx0XHQgKiBpbml0aWFsaXNlZCwgYnV0IHRoZSB0YWJsZSBub2RlcyBkb24ndCBtYXRjaCAoZnJvbSBiZWZvcmUpIHRoZW4gd2UgZGVzdHJveSB0aGUgb2xkXG5cdFx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0XHQgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFNldHRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cblx0XHRcdGlmICggc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIiApXG5cdFx0XHR7XG5cdFx0XHRcdHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIisoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuXHRcdFx0XHR0aGlzLmlkID0gc0lkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xuXHRcdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFx0XCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XHRcInNJbnN0YW5jZVwiOiAgICAgc0lkLFxuXHRcdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkXG5cdFx0XHR9ICk7XG5cdFx0XHRvU2V0dGluZ3MublRhYmxlID0gdGhpcztcblx0XHRcdG9TZXR0aW5ncy5vQXBpICAgPSBfdGhhdC5pbnRlcm5hbDtcblx0XHRcdG9TZXR0aW5ncy5vSW5pdCAgPSBvSW5pdDtcblx0XHRcdFxuXHRcdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdC8vIE5lZWQgdG8gYWRkIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBhZGRlZFxuXHRcdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRcdG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoPT09MSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRcdF9mbkNvbXBhdE9wdHMoIG9Jbml0ICk7XG5cdFx0XHRfZm5MYW5ndWFnZUNvbXBhdCggb0luaXQub0xhbmd1YWdlICk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBsZW5ndGggbWVudSBpcyBnaXZlbiwgYnV0IHRoZSBpbml0IGRpc3BsYXkgbGVuZ3RoIGlzIG5vdCwgdXNlIHRoZSBsZW5ndGggbWVudVxuXHRcdFx0aWYgKCBvSW5pdC5hTGVuZ3RoTWVudSAmJiAhIG9Jbml0LmlEaXNwbGF5TGVuZ3RoIClcblx0XHRcdHtcblx0XHRcdFx0b0luaXQuaURpc3BsYXlMZW5ndGggPSBBcnJheS5pc0FycmF5KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApID9cblx0XHRcdFx0XHRvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcdFwiYkluZm9cIixcblx0XHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFx0XCJhc1N0cmlwZUNsYXNzZXNcIixcblx0XHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XHRcInNBamF4U291cmNlXCIsXG5cdFx0XHRcdFwic0FqYXhEYXRhUHJvcFwiLFxuXHRcdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFx0XCJyb3dJZFwiLFxuXHRcdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFx0WyBcImFvU2VhcmNoQ29sc1wiLCBcImFvUHJlU2VhcmNoQ29sc1wiIF0sXG5cdFx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF1cblx0XHRcdF0gKTtcblx0XHRcdF9mbk1hcCggb1NldHRpbmdzLm9TY3JvbGwsIG9Jbml0LCBbXG5cdFx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxZXCIsIFwic1lcIiBdLFxuXHRcdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdFx0XSApO1xuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0xhbmd1YWdlLCBvSW5pdCwgXCJmbkluZm9DYWxsYmFja1wiICk7XG5cdFx0XHRcblx0XHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAgICAgICBvSW5pdC5mbkRyYXdDYWxsYmFjaywgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICAgICAgIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgICAgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQsICAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCAgICAgICAgb0luaXQuZm5Sb3dDYWxsYmFjaywgICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3csICAgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAgICAgICBvSW5pdC5mbkluaXRDb21wbGV0ZSwgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAgICd1c2VyJyApO1xuXHRcdFx0XG5cdFx0XHRvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbiggb0luaXQucm93SWQgKTtcblx0XHRcdFxuXHRcdFx0LyogQnJvd3NlciBzdXBwb3J0IGRldGVjdGlvbiAqL1xuXHRcdFx0X2ZuQnJvd3NlckRldGVjdCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdHZhciBvQ2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFxuXHRcdFx0JC5leHRlbmQoIG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0XHQkdGhpcy5hZGRDbGFzcyggb0NsYXNzZXMuc1RhYmxlICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXG5cdFx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQuaURlZmVyTG9hZGluZyAhPT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHRtcCA9IEFycmF5LmlzQXJyYXkoIG9Jbml0LmlEZWZlckxvYWRpbmcgKTtcblx0XHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzBdIDogb0luaXQuaURlZmVyTG9hZGluZztcblx0XHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gdG1wID8gb0luaXQuaURlZmVyTG9hZGluZ1sxXSA6IG9Jbml0LmlEZWZlckxvYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIExhbmd1YWdlIGRlZmluaXRpb25zICovXG5cdFx0XHR2YXIgb0xhbmd1YWdlID0gb1NldHRpbmdzLm9MYW5ndWFnZTtcblx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFx0XG5cdFx0XHRpZiAoIG9MYW5ndWFnZS5zVXJsIClcblx0XHRcdHtcblx0XHRcdFx0LyogR2V0IHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyBmcm9tIGEgZmlsZSAtIGJlY2F1c2UgdGhpcyBBamF4IGNhbGwgbWFrZXMgdGhlIGxhbmd1YWdlXG5cdFx0XHRcdCAqIGdldCBhc3luYyB0byB0aGUgcmVtYWluZGVyIG9mIHRoaXMgZnVuY3Rpb24gd2UgdXNlIGJJbml0SGFuZGVkT2ZmIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdFx0ICogX2ZuSW5pdGlhbGlzZSB3aWxsIGJlIGZpcmVkIGJ5IHRoZSByZXR1cm5lZCBBamF4IGhhbmRsZXIsIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvclxuXHRcdFx0XHQgKi9cblx0XHRcdFx0JC5hamF4KCB7XG5cdFx0XHRcdFx0ZGF0YVR5cGU6ICdqc29uJyxcblx0XHRcdFx0XHR1cmw6IG9MYW5ndWFnZS5zVXJsLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHRcdFx0XHRcdF9mbkxhbmd1YWdlQ29tcGF0KCBqc29uICk7XG5cdFx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cy5vTGFuZ3VhZ2UsIGpzb24gKTtcblx0XHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIGpzb24gKTtcblx0XHRcdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vIEVycm9yIG9jY3VycmVkIGxvYWRpbmcgbGFuZ3VhZ2UgZmlsZSwgY29udGludWUgb24gYXMgYmVzdCB3ZSBjYW5cblx0XHRcdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRiSW5pdEhhbmRlZE9mZiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQgKiBTdHJpcGVzXG5cdFx0XHQgKi9cblx0XHRcdGlmICggb0luaXQuYXNTdHJpcGVDbGFzc2VzID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0b1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcyA9W1xuXHRcdFx0XHRcdG9DbGFzc2VzLnNTdHJpcGVPZGQsXG5cdFx0XHRcdFx0b0NsYXNzZXMuc1N0cmlwZUV2ZW5cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogUmVtb3ZlIHJvdyBzdHJpcGUgY2xhc3NlcyBpZiB0aGV5IGFyZSBhbHJlYWR5IG9uIHRoZSB0YWJsZSByb3cgKi9cblx0XHRcdHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcztcblx0XHRcdHZhciByb3dPbmUgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKS5maW5kKCd0cicpLmVxKDApO1xuXHRcdFx0aWYgKCAkLmluQXJyYXkoIHRydWUsICQubWFwKCBzdHJpcGVDbGFzc2VzLCBmdW5jdGlvbihlbCwgaSkge1xuXHRcdFx0XHRyZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcblx0XHRcdH0gKSApICE9PSAtMSApIHtcblx0XHRcdFx0JCgndGJvZHkgdHInLCB0aGlzKS5yZW1vdmVDbGFzcyggc3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykgKTtcblx0XHRcdFx0b1NldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMgPSBzdHJpcGVDbGFzc2VzLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQgKiBDb2x1bW5zXG5cdFx0XHQgKiBTZWUgaWYgd2Ugc2hvdWxkIGxvYWQgY29sdW1ucyBhdXRvbWF0aWNhbGx5IG9yIHVzZSBkZWZpbmVkIG9uZXNcblx0XHRcdCAqL1xuXHRcdFx0dmFyIGFuVGhzID0gW107XG5cdFx0XHR2YXIgYW9Db2x1bW5zSW5pdDtcblx0XHRcdHZhciBuVGhlYWQgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aGVhZCcpO1xuXHRcdFx0aWYgKCBuVGhlYWQubGVuZ3RoICE9PSAwIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MuYW9IZWFkZXIsIG5UaGVhZFswXSApO1xuXHRcdFx0XHRhblRocyA9IF9mbkdldFVuaXF1ZVRocyggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIElmIG5vdCBnaXZlbiBhIGNvbHVtbiBhcnJheSwgZ2VuZXJhdGUgb25lIHdpdGggbnVsbHMgKi9cblx0XHRcdGlmICggb0luaXQuYW9Db2x1bW5zID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0YW9Db2x1bW5zSW5pdCA9IFtdO1xuXHRcdFx0XHRmb3IgKCBpPTAsIGlMZW49YW5UaHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFvQ29sdW1uc0luaXQucHVzaCggbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGFvQ29sdW1uc0luaXQgPSBvSW5pdC5hb0NvbHVtbnM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEFkZCB0aGUgY29sdW1ucyAqL1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29sdW1uc0luaXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MsIGFuVGhzID8gYW5UaHNbaV0gOiBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEFwcGx5IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgKi9cblx0XHRcdF9mbkFwcGx5Q29sdW1uRGVmcyggb1NldHRpbmdzLCBvSW5pdC5hb0NvbHVtbkRlZnMsIGFvQ29sdW1uc0luaXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XG5cdFx0XHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb0RlZiApO1xuXHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHQvKiBIVE1MNSBhdHRyaWJ1dGUgZGV0ZWN0aW9uIC0gYnVpbGQgYW4gbURhdGEgb2JqZWN0IGF1dG9tYXRpY2FsbHkgaWYgdGhlXG5cdFx0XHQgKiBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIHJvd09uZS5sZW5ndGggKSB7XG5cdFx0XHRcdHZhciBhID0gZnVuY3Rpb24gKCBjZWxsLCBuYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBjZWxsLmdldEF0dHJpYnV0ZSggJ2RhdGEtJytuYW1lICkgIT09IG51bGwgPyBuYW1lIDogbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XHQkKCByb3dPbmVbMF0gKS5jaGlsZHJlbigndGgsIHRkJykuZWFjaCggZnVuY3Rpb24gKGksIGNlbGwpIHtcblx0XHRcdFx0XHR2YXIgY29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcblx0XHRcdFxuXHRcdFx0XHRcdGlmICggY29sLm1EYXRhID09PSBpICkge1xuXHRcdFx0XHRcdFx0dmFyIHNvcnQgPSBhKCBjZWxsLCAnc29ydCcgKSB8fCBhKCBjZWxsLCAnb3JkZXInICk7XG5cdFx0XHRcdFx0XHR2YXIgZmlsdGVyID0gYSggY2VsbCwgJ2ZpbHRlcicgKSB8fCBhKCBjZWxsLCAnc2VhcmNoJyApO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoIHNvcnQgIT09IG51bGwgfHwgZmlsdGVyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRjb2wubURhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XzogICAgICBpKycuZGlzcGxheScsXG5cdFx0XHRcdFx0XHRcdFx0c29ydDogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyOiBmaWx0ZXIgIT09IG51bGwgPyBpKycuQGRhdGEtJytmaWx0ZXIgOiB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XHRcdHZhciBsb2FkZWRJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBTb3J0aW5nXG5cdFx0XHRcdCAqIEB0b2RvIEZvciBtb2R1bGFyaXNhdGlvbiAoMS4xMSkgdGhpcyBuZWVkcyB0byBkbyBpbnRvIGEgc29ydCBzdGFydCB1cCBoYW5kbGVyXG5cdFx0XHRcdCAqL1xuXHRcdFx0XG5cdFx0XHRcdC8vIElmIGFhU29ydGluZyBpcyBub3QgZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGluZGljYXRvciBpbiBhc1NvcnRpbmdcblx0XHRcdFx0Ly8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cblx0XHRcdFx0aWYgKCBvSW5pdC5hYVNvcnRpbmcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR2YXIgc29ydGluZyA9IG9TZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0XHRcdFx0Zm9yICggaT0wLCBpTGVuPXNvcnRpbmcubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0c29ydGluZ1tpXVsxXSA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGkgXS5hc1NvcnRpbmdbMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cblx0XHRcdFx0ICogYWNjb3VudCwgYW5kIGFsc28gd2lsbCBhcHBseSBzb3J0aW5nIGRpc2FibGVkIGNsYXNzZXMgaWYgZGlzYWJsZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdFxuXHRcdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmICggb1NldHRpbmdzLmJTb3J0ZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdFx0dmFyIHNvcnRlZENvbHVtbnMgPSB7fTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHQkLmVhY2goIGFTb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0c29ydGVkQ29sdW1uc1sgdmFsLnNyYyBdID0gdmFsLmRpcjtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydCwgc29ydGVkQ29sdW1uc10gKTtcblx0XHRcdFx0XHRcdFx0X2ZuU29ydEFyaWEoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIgKSB7XG5cdFx0XHRcdFx0XHRfZm5Tb3J0aW5nQ2xhc3Nlcyggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAnc2MnICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBGaW5hbCBpbml0XG5cdFx0XHRcdCAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcblx0XHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xuXHRcdFx0XHR2YXIgY2FwdGlvbnMgPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLl9jYXB0aW9uU2lkZSA9ICQodGhpcykuY3NzKCdjYXB0aW9uLXNpZGUnKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHRcdHZhciB0aGVhZCA9ICR0aGlzLmNoaWxkcmVuKCd0aGVhZCcpO1xuXHRcdFx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHR0aGVhZCA9ICQoJzx0aGVhZC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcblx0XHRcdFx0aWYgKCB0Ym9keS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0dGJvZHkgPSAkKCc8dGJvZHkvPicpLmFwcGVuZFRvKCR0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XG5cdFx0XHRcblx0XHRcdFx0dmFyIHRmb290ID0gJHRoaXMuY2hpbGRyZW4oJ3Rmb290Jyk7XG5cdFx0XHRcdGlmICggdGZvb3QubGVuZ3RoID09PSAwICYmIGNhcHRpb25zLmxlbmd0aCA+IDAgJiYgKG9TZXR0aW5ncy5vU2Nyb2xsLnNYICE9PSBcIlwiIHx8IG9TZXR0aW5ncy5vU2Nyb2xsLnNZICE9PSBcIlwiKSApIHtcblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgYSBzY3JvbGxpbmcgdGFibGUsIGFuZCBubyBmb290ZXIgaGFzIGJlZW4gZ2l2ZW4sIHRoZW4gd2UgbmVlZCB0byBjcmVhdGVcblx0XHRcdFx0XHQvLyBhIHRmb290IGVsZW1lbnQgZm9yIHRoZSBjYXB0aW9uIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgdG9cblx0XHRcdFx0XHR0Zm9vdCA9ICQoJzx0Zm9vdC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0aWYgKCB0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0JHRoaXMuYWRkQ2xhc3MoIG9DbGFzc2VzLnNOb0Zvb3RlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0Zm9vdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdG9TZXR0aW5ncy5uVEZvb3QgPSB0Zm9vdFswXTtcblx0XHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIG9TZXR0aW5ncy5hb0Zvb3Rlciwgb1NldHRpbmdzLm5URm9vdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yICovXG5cdFx0XHRcdGlmICggb0luaXQuYWFEYXRhICkge1xuXHRcdFx0XHRcdGZvciAoIGk9MCA7IGk8b0luaXQuYWFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRcdF9mbkFkZERhdGEoIG9TZXR0aW5ncywgb0luaXQuYWFEYXRhWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdkb20nICkge1xuXHRcdFx0XHRcdC8qIEdyYWIgdGhlIGRhdGEgZnJvbSB0aGUgcGFnZSAtIG9ubHkgZG8gdGhpcyB3aGVuIGRlZmVycmVkIGxvYWRpbmcgb3Igbm8gQWpheFxuXHRcdFx0XHRcdCAqIHNvdXJjZSBzaW5jZSB0aGVyZSBpcyBubyBwb2ludCBpbiByZWFkaW5nIHRoZSBET00gZGF0YSBpZiB3ZSBhcmUgdGhlbiBnb2luZ1xuXHRcdFx0XHRcdCAqIHRvIHJlcGxhY2UgaXQgd2l0aCBBamF4IGRhdGFcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRfZm5BZGRUciggb1NldHRpbmdzLCAkKG9TZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpICk7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHQvKiBDb3B5IHRoZSBkYXRhIGluZGV4IGFycmF5ICovXG5cdFx0XHRcdG9TZXR0aW5ncy5haURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XHRcblx0XHRcdFx0LyogSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd24gKi9cblx0XHRcdFx0b1NldHRpbmdzLmJJbml0aWFsaXNlZCA9IHRydWU7XG5cdFx0XHRcblx0XHRcdFx0LyogQ2hlY2sgaWYgd2UgbmVlZCB0byBpbml0aWFsaXNlIHRoZSB0YWJsZSAoaXQgbWlnaHQgbm90IGhhdmUgYmVlbiBoYW5kZWQgb2ZmIHRvIHRoZVxuXHRcdFx0XHQgKiBsYW5ndWFnZSBwcm9jZXNzb3IpXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGJJbml0SGFuZGVkT2ZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyogTXVzdCBiZSBkb25lIGFmdGVyIGV2ZXJ5dGhpbmcgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0YXRlIHNhdmluZyEgKi9cblx0XHRcdGlmICggb0luaXQuYlN0YXRlU2F2ZSApXG5cdFx0XHR7XG5cdFx0XHRcdGZlYXR1cmVzLmJTdGF0ZVNhdmUgPSB0cnVlO1xuXHRcdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBfZm5TYXZlU3RhdGUsICdzdGF0ZV9zYXZlJyApO1xuXHRcdFx0XHRfZm5Mb2FkU3RhdGUoIG9TZXR0aW5ncywgb0luaXQsIGxvYWRlZEluaXQgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsb2FkZWRJbml0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9ICk7XG5cdFx0X3RoYXQgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdFxuXHQvKlxuXHQgKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXG5cdCAqIERhdGFUYWJsZXMgZnVuY3Rpb25zIGNhbiBhY2Nlc3MgdGhlbSBhbmQgdGhleSBkb24ndCBsZWFrIGludG8gZ2xvYmFsIHNwYWNlLlxuXHQgKiBBdCB0aGUgc2FtZSB0aW1lIHRoZXNlIGZ1bmN0aW9ucyBhcmUgb2Z0ZW4gdXNlZnVsIG92ZXIgbXVsdGlwbGUgZmlsZXMgaW4gdGhlXG5cdCAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcblx0ICogYnkgRGF0YVRhYmxlcyBhcyBwcml2YXRlIHZhcmlhYmxlcyBoZXJlLiBUaGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vXG5cdCAqIGNsYXNoaW5nIG9mIHZhcmlhYmxlIG5hbWVzIGFuZCB0aGF0IHRoZXkgY2FuIGVhc2lseSByZWZlcmVuY2VkIGZvciByZXVzZS5cblx0ICovXG5cdFxuXHRcblx0Ly8gRGVmaW5lZCBlbHNlIHdoZXJlXG5cdC8vICBfc2VsZWN0b3JfcnVuXG5cdC8vICBfc2VsZWN0b3Jfb3B0c1xuXHQvLyAgX3NlbGVjdG9yX2ZpcnN0XG5cdC8vICBfc2VsZWN0b3Jfcm93X2luZGV4ZXNcblx0XG5cdHZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XG5cdHZhciBfQXBpOyAvLyBEYXRhVGFibGUuQXBpXG5cdHZhciBfYXBpX3JlZ2lzdGVyOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyXG5cdHZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXG5cdFxuXHR2YXIgX3JlX2RpYyA9IHt9O1xuXHR2YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXFx1MjAyOF0vZztcblx0dmFyIF9yZV9odG1sID0gLzwuKj8+L2c7XG5cdFxuXHQvLyBUaGlzIGlzIG5vdCBzdHJpY3QgSVNPODYwMSAtIERhdGUucGFyc2UoKSBpcyBxdWl0ZSBsYXgsIGFsdGhvdWdoXG5cdC8vIGltcGxlbWVudGF0aW9ucyBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy5cblx0dmFyIF9yZV9kYXRlID0gL15cXGR7Miw0fVtcXC5cXC9cXC1dXFxkezEsMn1bXFwuXFwvXFwtXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6XFwuXVxcZHsyfShbXFwuOl1cXGR7Mn0pPyk/JC87XG5cdFxuXHQvLyBFc2NhcGUgcmVndWxhciBleHByZXNzaW9uIHNwZWNpYWwgY2hhcmFjdGVyc1xuXHR2YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoICcoXFxcXCcgKyBbICcvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJywgJyQnLCAnXicsICctJyBdLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyApO1xuXHRcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JlaWduX2V4Y2hhbmdlX21hcmtldFxuXHQvLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxuXHQvLyAtIFxcdTIwYTkgLSBTb3V0aCBLb3JlYW4gV29uXG5cdC8vIC0gXFx1MjBCQSAtIFR1cmtpc2ggTGlyYVxuXHQvLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcblx0Ly8gLSBSIC0gQnJhemlsIChSJCkgYW5kIFNvdXRoIEFmcmljYVxuXHQvLyAtIGZyIC0gU3dpc3MgRnJhbmNcblx0Ly8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXG5cdC8vIC0gXFx1MjAwOSBpcyB0aGluIHNwYWNlIGFuZCBcXHUyMDJGIGlzIG5hcnJvdyBuby1icmVhayBzcGFjZSwgYm90aCB1c2VkIGluIG1hbnlcblx0Ly8gLSDJgyAtIEJpdGNvaW5cblx0Ly8gLSDOniAtIEV0aGVyZXVtXG5cdC8vICAgc3RhbmRhcmRzIGFzIHRob3VzYW5kcyBzZXBhcmF0b3JzLlxuXHR2YXIgX3JlX2Zvcm1hdHRlZF9udW1lcmljID0gL1snXFx1MDBBMCwkwqPigqzCpSVcXHUyMDA5XFx1MjAyRlxcdTIwQkRcXHUyMGE5XFx1MjBCQXJma8mDzp5dL2dpO1xuXHRcblx0XG5cdHZhciBfZW1wdHkgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfaW50VmFsID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoIHMsIDEwICk7XG5cdFx0cmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xuXHR9O1xuXHRcblx0Ly8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXG5cdC8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcblx0dmFyIF9udW1Ub0RlY2ltYWwgPSBmdW5jdGlvbiAoIG51bSwgZGVjaW1hbFBvaW50ICkge1xuXHRcdC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cblx0XHRpZiAoICEgX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gKSB7XG5cdFx0XHRfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSA9IG5ldyBSZWdFeHAoIF9mbkVzY2FwZVJlZ2V4KCBkZWNpbWFsUG9pbnQgKSwgJ2cnICk7XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBkZWNpbWFsUG9pbnQgIT09ICcuJyA/XG5cdFx0XHRudW0ucmVwbGFjZSggL1xcLi9nLCAnJyApLnJlcGxhY2UoIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdLCAnLicgKSA6XG5cdFx0XHRudW07XG5cdH07XG5cdFxuXHRcblx0dmFyIF9pc051bWJlciA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSB7XG5cdFx0dmFyIHN0clR5cGUgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZyc7XG5cdFxuXHRcdC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcblx0XHQvLyBmb3JtYXR0ZWQgc3RyaW5nICh0aGlzIHN0b3BzIHRoZSBzdHJpbmcgXCJrXCIsIG9yIFwia3JcIiwgZXRjIGJlaW5nIGRldGVjdGVkXG5cdFx0Ly8gYXMgYSBmb3JtYXR0ZWQgbnVtYmVyIGZvciBjdXJyZW5jeVxuXHRcdGlmICggX2VtcHR5KCBkICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0XHRkID0gX251bVRvRGVjaW1hbCggZCwgZGVjaW1hbFBvaW50ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZvcm1hdHRlZCAmJiBzdHJUeXBlICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChkKSApICYmIGlzRmluaXRlKCBkICk7XG5cdH07XG5cdFxuXHRcblx0Ly8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcblx0dmFyIF9pc0h0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcblx0fTtcblx0XG5cdFxuXHR2YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApIHtcblx0XHRpZiAoIF9lbXB0eSggZCApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHRtbCA9IF9pc0h0bWwoIGQgKTtcblx0XHRyZXR1cm4gISBodG1sID9cblx0XHRcdG51bGwgOlxuXHRcdFx0X2lzTnVtYmVyKCBfc3RyaXBIdG1sKCBkICksIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkICkgP1xuXHRcdFx0XHR0cnVlIDpcblx0XHRcdFx0bnVsbDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3BsdWNrID0gZnVuY3Rpb24gKCBhLCBwcm9wLCBwcm9wMiApIHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGk9MCwgaWVuPWEubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhW2ldICYmIGFbaV1bIHByb3AgXSApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFbaV0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdC8vIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBfcGx1Y2ssIGJ1dCByYXRoZXIgdGhhbiBsb29waW5nIG92ZXIgYGFgIHdlIHVzZSBgb3JkZXJgXG5cdC8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcblx0dmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uICggYSwgb3JkZXIsIHByb3AsIHByb3AyIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgaT0wLCBpZW49b3JkZXIubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JhbmdlID0gZnVuY3Rpb24gKCBsZW4sIHN0YXJ0IClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgZW5kO1xuXHRcblx0XHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRlbmQgPSBsZW47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IGxlbjtcblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPXN0YXJ0IDsgaTxlbmQgOyBpKysgKSB7XG5cdFx0XHRvdXQucHVzaCggaSApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKCBhIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gKSB7IC8vIGNhcmVmdWwgLSB3aWxsIHJlbW92ZSBhbGwgZmFsc3kgdmFsdWVzIVxuXHRcdFx0XHRvdXQucHVzaCggYVtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gZC5yZXBsYWNlKCBfcmVfaHRtbCwgJycgKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGFsbCB2YWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB1bmlxdWUuIFRoaXMgbWVhbnMgd2UgY2FuIHNob3J0XG5cdCAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuXHQgKiB0byBlYXNpbHkgY2hlY2sgdGhlIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbGwgdW5pcXVlLCBmYWxzZSBvdGhlcndpc2Vcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9hcmVBbGxVbmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRpZiAoIHNyYy5sZW5ndGggPCAyICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHRcdHZhciBsYXN0ID0gc29ydGVkWzBdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBzb3J0ZWRbaV0gPT09IGxhc3QgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRsYXN0ID0gc29ydGVkW2ldO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbmQgdGhlIHVuaXF1ZSBlbGVtZW50cyBpbiBhIHNvdXJjZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX3VuaXF1ZSA9IGZ1bmN0aW9uICggc3JjIClcblx0e1xuXHRcdGlmICggX2FyZUFsbFVuaXF1ZSggc3JjICkgKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcblx0XHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdFx0Ly8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcblx0XHQvLyBpbmZvcm1hdGlvbi5cblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0XHRqLCBrPTA7XG5cdFxuXHRcdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhbCA9IHNyY1tpXTtcblx0XG5cdFx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRcdGlmICggb3V0W2pdID09PSB2YWwgKSB7XG5cdFx0XHRcdFx0Y29udGludWUgYWdhaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0XHRrKys7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0Ly8gU3VycHJpc2luZ2x5IHRoaXMgaXMgZmFzdGVyIHRoYW4gW10uY29uY2F0LmFwcGx5XG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9mbGF0dGVuLWFuLWFycmF5LWxvb3AtdnMtcmVkdWNlLzJcblx0dmFyIF9mbGF0dGVuID0gZnVuY3Rpb24gKG91dCwgdmFsKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTx2YWwubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRcdF9mbGF0dGVuKG91dCwgdmFsW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRvdXQucHVzaCh2YWwpO1xuXHRcdH1cblx0ICBcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cdFxuXHQvLyBBcnJheS5pc0FycmF5IHBvbHlmaWxsLlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5cdGlmICghIEFycmF5LmlzQXJyYXkpIHtcblx0ICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdCAgICB9O1xuXHR9XG5cdFxuXHQvLyAudHJpbSgpIHBvbHlmaWxsXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltXG5cdGlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG5cdCAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblx0ICB9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcblx0ICogXG5cdCAqIFRoaXMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBtZXRob2RzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGludGVybmFsbHkgdG9cblx0ICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXG5cdCAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2Zcblx0ICogY29kZS5cblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS51dGlsID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWRcblx0XHQgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xuXHRcdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dGhyb3R0bGU6IGZ1bmN0aW9uICggZm4sIGZyZXEgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0ZnJlcXVlbmN5ID0gZnJlcSAhPT0gdW5kZWZpbmVkID8gZnJlcSA6IDIwMCxcblx0XHRcdFx0bGFzdCxcblx0XHRcdFx0dGltZXI7XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0bm93ICA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFxuXHRcdFx0XHRpZiAoIGxhc3QgJiYgbm93IDwgbGFzdCArIGZyZXF1ZW5jeSApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0fSwgZnJlcXVlbmN5ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGFzdCA9IG5vdztcblx0XHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBzdHJpbmcgdG8gZXNjYXBlXG5cdFx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG5cdFx0ICovXG5cdFx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uICggdmFsICkge1xuXHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKCBfcmVfZXNjYXBlX3JlZ2V4LCAnXFxcXCQxJyApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIG1hcHBpbmcgb2JqZWN0IHRoYXQgYWxsb3dzIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBiZSBsb29rZWQgdXBcblx0ICogZm9yIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHMuIFRoZSBtYXBwaW5nIGlzIHN0b3JlZCBpbiBhIHByaXZhdGVcblx0ICogcGFyYW1ldGVyIGNhbGxlZCBgX2h1bmdhcmlhbk1hcGAgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSHVuZ2FyaWFuTWFwICggbyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGh1bmdhcmlhbiA9ICdhIGFhIGFpIGFvIGFzIGIgZm4gaSBtIG8gcyAnLFxuXHRcdFx0bWF0Y2gsXG5cdFx0XHRuZXdLZXksXG5cdFx0XHRtYXAgPSB7fTtcblx0XG5cdFx0JC5lYWNoKCBvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eKFteQS1aXSs/KShbQS1aXSkvKTtcblx0XG5cdFx0XHRpZiAoIG1hdGNoICYmIGh1bmdhcmlhbi5pbmRleE9mKG1hdGNoWzFdKycgJykgIT09IC0xIClcblx0XHRcdHtcblx0XHRcdFx0bmV3S2V5ID0ga2V5LnJlcGxhY2UoIG1hdGNoWzBdLCBtYXRjaFsyXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRcdG1hcFsgbmV3S2V5IF0gPSBrZXk7XG5cdFxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdID09PSAnbycgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBvW2tleV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0by5faHVuZ2FyaWFuTWFwID0gbWFwO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcblx0ICogY3JlYXRlZCBieSBfZm5IdW5nYXJpYW5NYXAuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbWVsVG9IdW5nYXJpYW4gKCBzcmMsIHVzZXIsIGZvcmNlIClcblx0e1xuXHRcdGlmICggISBzcmMuX2h1bmdhcmlhbk1hcCApIHtcblx0XHRcdF9mbkh1bmdhcmlhbk1hcCggc3JjICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHVuZ2FyaWFuS2V5O1xuXHRcblx0XHQkLmVhY2goIHVzZXIsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0aHVuZ2FyaWFuS2V5ID0gc3JjLl9odW5nYXJpYW5NYXBbIGtleSBdO1xuXHRcblx0XHRcdGlmICggaHVuZ2FyaWFuS2V5ICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IHVzZXJbaHVuZ2FyaWFuS2V5XSA9PT0gdW5kZWZpbmVkKSApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXG5cdFx0XHRcdGlmICggaHVuZ2FyaWFuS2V5LmNoYXJBdCgwKSA9PT0gJ28nIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxuXHRcdFx0XHRcdGlmICggISB1c2VyWyBodW5nYXJpYW5LZXkgXSApIHtcblx0XHRcdFx0XHRcdHVzZXJbIGh1bmdhcmlhbktleSBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCB1c2VyW2h1bmdhcmlhbktleV0sIHVzZXJba2V5XSApO1xuXHRcblx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBzcmNbaHVuZ2FyaWFuS2V5XSwgdXNlcltodW5nYXJpYW5LZXldLCBmb3JjZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIExhbmd1YWdlIGNvbXBhdGliaWxpdHkgLSB3aGVuIGNlcnRhaW4gb3B0aW9ucyBhcmUgZ2l2ZW4sIGFuZCBvdGhlcnMgYXJlbid0LCB3ZVxuXHQgKiBuZWVkIHRvIGR1cGxpY2F0ZSB0aGUgdmFsdWVzIG92ZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0ICogd2l0aCBvbGRlciBsYW5ndWFnZSBmaWxlcy5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTGFuZ3VhZ2VDb21wYXQoIGxhbmcgKVxuXHR7XG5cdFx0Ly8gTm90ZSB0aGUgdXNlIG9mIHRoZSBIdW5nYXJpYW4gbm90YXRpb24gZm9yIHRoZSBwYXJhbWV0ZXJzIGluIHRoaXMgbWV0aG9kIGFzXG5cdFx0Ly8gdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1hcHBpbmcgb2YgY2FtZWxDYXNlIHRvIEh1bmdhcmlhblxuXHRcdHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2U7XG5cdFxuXHRcdC8vIERlZmF1bHQgbWFwcGluZ1xuXHRcdHZhciBkZWZhdWx0RGVjaW1hbCA9IGRlZmF1bHRzLnNEZWNpbWFsO1xuXHRcdGlmICggZGVmYXVsdERlY2ltYWwgKSB7XG5cdFx0XHRfYWRkTnVtZXJpY1NvcnQoIGRlZmF1bHREZWNpbWFsICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGxhbmcgKSB7XG5cdFx0XHR2YXIgemVyb1JlY29yZHMgPSBsYW5nLnNaZXJvUmVjb3Jkcztcblx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIGlmIHRoZXJlIGlzIG5vIHNFbXB0eVRhYmxlIGdpdmVuLCB0aGVuIHVzZSB0aGUgc2FtZSBhc1xuXHRcdFx0Ly8gc1plcm9SZWNvcmRzIC0gYXNzdW1pbmcgdGhhdCBpcyBnaXZlbi5cblx0XHRcdGlmICggISBsYW5nLnNFbXB0eVRhYmxlICYmIHplcm9SZWNvcmRzICYmXG5cdFx0XHRcdGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5NYXAoIGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0VtcHR5VGFibGUnICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTGlrZXdpc2Ugd2l0aCBsb2FkaW5nIHJlY29yZHNcblx0XHRcdGlmICggISBsYW5nLnNMb2FkaW5nUmVjb3JkcyAmJiB6ZXJvUmVjb3JkcyAmJlxuXHRcdFx0XHRkZWZhdWx0cy5zTG9hZGluZ1JlY29yZHMgPT09IFwiTG9hZGluZy4uLlwiIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTWFwKCBsYW5nLCBsYW5nLCAnc1plcm9SZWNvcmRzJywgJ3NMb2FkaW5nUmVjb3JkcycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBPbGQgcGFyYW1ldGVyIG5hbWUgb2YgdGhlIHRob3VzYW5kcyBzZXBhcmF0b3IgbWFwcGVkIG9udG8gdGhlIG5ld1xuXHRcdFx0aWYgKCBsYW5nLnNJbmZvVGhvdXNhbmRzICkge1xuXHRcdFx0XHRsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBkZWNpbWFsID0gbGFuZy5zRGVjaW1hbDtcblx0XHRcdGlmICggZGVjaW1hbCAmJiBkZWZhdWx0RGVjaW1hbCAhPT0gZGVjaW1hbCApIHtcblx0XHRcdFx0X2FkZE51bWVyaWNTb3J0KCBkZWNpbWFsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE1hcCBvbmUgcGFyYW1ldGVyIG9udG8gYW5vdGhlclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gT2JqZWN0IHRvIG1hcFxuXHQgKiAgQHBhcmFtIHsqfSBrbmV3IFRoZSBuZXcgcGFyYW1ldGVyIG5hbWVcblx0ICogIEBwYXJhbSB7Kn0gb2xkIFRoZSBvbGQgcGFyYW1ldGVyIG5hbWVcblx0ICovXG5cdHZhciBfZm5Db21wYXRNYXAgPSBmdW5jdGlvbiAoIG8sIGtuZXcsIG9sZCApIHtcblx0XHRpZiAoIG9bIGtuZXcgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b1sgb2xkIF0gPSBvWyBrbmV3IF07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgbWFpbiBEVCBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ld1xuXHQgKiBvcHRpb25zIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlXG5cdCAqIGNoYW5nZSBvbmx5LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29tcGF0T3B0cyAoIGluaXQgKVxuXHR7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJpbmcnLCAgICAgICdiU29ydCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlck11bHRpJywgICAgJ2JTb3J0TXVsdGknICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDbGFzc2VzJywgICdiU29ydENsYXNzZXMnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDZWxsc1RvcCcsICdiU29ydENlbGxzVG9wJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyJywgICAgICAgICAnYWFTb3J0aW5nJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRml4ZWQnLCAgICAnYWFTb3J0aW5nRml4ZWQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nJywgICAgICAgICdiUGFnaW5hdGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nVHlwZScsICAgICdzUGFnaW5hdGlvblR5cGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnZUxlbmd0aCcsICAgICdpRGlzcGxheUxlbmd0aCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdzZWFyY2hpbmcnLCAgICAgJ2JGaWx0ZXInICk7XG5cdFxuXHRcdC8vIEJvb2xlYW4gaW5pdGlhbGlzYXRpb24gb2YgeC1zY3JvbGxpbmdcblx0XHRpZiAoIHR5cGVvZiBpbml0LnNTY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRpbml0LnNTY3JvbGxYID0gaW5pdC5zU2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBpbml0LnNjcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRcdGluaXQuc2Nyb2xsWCA9IGluaXQuc2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29sdW1uIHNlYXJjaCBvYmplY3RzIGFyZSBpbiBhbiBhcnJheSwgc28gaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG5cdFx0Ly8gZWxlbWVudCBieSBlbGVtZW50XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcblx0XG5cdFx0aWYgKCBzZWFyY2hDb2xzICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNlYXJjaENvbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2VhcmNoQ29sc1tpXSApIHtcblx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBjb2x1bW4gb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXcgb3B0aW9uc1xuXHQgKiBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZSBjaGFuZ2Vcblx0ICogb25seS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbXBhdENvbHMgKCBpbml0IClcblx0e1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyYWJsZScsICAgICAnYlNvcnRhYmxlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YScsICAgICAnYURhdGFTb3J0JyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyU2VxdWVuY2UnLCAnYXNTb3J0aW5nJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YVR5cGUnLCAnc29ydERhdGFUeXBlJyApO1xuXHRcblx0XHQvLyBvcmRlckRhdGEgY2FuIGJlIGdpdmVuIGFzIGFuIGludGVnZXJcblx0XHR2YXIgZGF0YVNvcnQgPSBpbml0LmFEYXRhU29ydDtcblx0XHRpZiAoIHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgISBBcnJheS5pc0FycmF5KCBkYXRhU29ydCApICkge1xuXHRcdFx0aW5pdC5hRGF0YVNvcnQgPSBbIGRhdGFTb3J0IF07XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJyb3dzZXIgZmVhdHVyZSBkZXRlY3Rpb24gZm9yIGNhcGFiaWxpdGllcywgcXVpcmtzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQnJvd3NlckRldGVjdCggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzIGV2ZXJ5IHRpbWUgRGF0YVRhYmxlcyBpcyBjb25zdHJ1Y3RlZCwgdGhlIHZhbHVlc1xuXHRcdC8vIGNhbGN1bGF0ZWQgYXJlIHNwZWNpZmljIHRvIHRoZSBicm93c2VyIGFuZCBPUyBjb25maWd1cmF0aW9uIHdoaWNoIHdlXG5cdFx0Ly8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xuXHRcdGlmICggISBEYXRhVGFibGUuX19icm93c2VyICkge1xuXHRcdFx0dmFyIGJyb3dzZXIgPSB7fTtcblx0XHRcdERhdGFUYWJsZS5fX2Jyb3dzZXIgPSBicm93c2VyO1xuXHRcblx0XHRcdC8vIFNjcm9sbGluZyBmZWF0dXJlIC8gcXVpcmtzIGRldGVjdGlvblxuXHRcdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCcsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6ICQod2luZG93KS5zY3JvbGxMZWZ0KCkqLTEsIC8vIGFsbG93IGZvciBzY3JvbGxpbmdcblx0XHRcdFx0XHRoZWlnaHQ6IDEsXG5cdFx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDEsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IDEsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAxMDAsXG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJ1xuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IDEwXG5cdFx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHRcdFx0LmFwcGVuZFRvKCAnYm9keScgKTtcblx0XG5cdFx0XHR2YXIgb3V0ZXIgPSBuLmNoaWxkcmVuKCk7XG5cdFx0XHR2YXIgaW5uZXIgPSBvdXRlci5jaGlsZHJlbigpO1xuXHRcblx0XHRcdC8vIE51bWJlcnMgYmVsb3csIGluIG9yZGVyLCBhcmU6XG5cdFx0XHQvLyBpbm5lci5vZmZzZXRXaWR0aCwgaW5uZXIuY2xpZW50V2lkdGgsIG91dGVyLm9mZnNldFdpZHRoLCBvdXRlci5jbGllbnRXaWR0aFxuXHRcdFx0Ly9cblx0XHRcdC8vIElFNiBYUDogICAgICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcblx0XHRcdC8vIElFNyBWaXN0YTogICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcblx0XHRcdC8vIElFIDgrIFdpbmRvd3M6ICAgICAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHRcdC8vIEV2ZXJncmVlbiBXaW5kb3dzOiAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aCBzY3JvbGxiYXJzOiAgICAgODUgIDg1IDEwMCAgODVcblx0XHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aG91dCBzY3JvbGxiYXJzOiAxMDAgMTAwIDEwMCAxMDBcblx0XG5cdFx0XHQvLyBHZXQgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0XHRicm93c2VyLmJhcldpZHRoID0gb3V0ZXJbMF0ub2Zmc2V0V2lkdGggLSBvdXRlclswXS5jbGllbnRXaWR0aDtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIG92ZXJzaXplIGEgd2lkdGggMTAwJSBlbGVtZW50IGluc2lkZSBhIHNjcm9sbGluZyBlbGVtZW50LCB0b1xuXHRcdFx0Ly8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhciwgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZW5zdXJlIHRoZSBpbm5lclxuXHRcdFx0Ly8gZWxlbWVudCBpcyBjb250YWluZWQgd2l0aG91dCBmb3JjaW5nIHNjcm9sbGluZ1xuXHRcdFx0YnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUgPSBpbm5lclswXS5vZmZzZXRXaWR0aCA9PT0gMTAwICYmIG91dGVyWzBdLmNsaWVudFdpZHRoICE9PSAxMDA7XG5cdFxuXHRcdFx0Ly8gSW4gcnRsIHRleHQgbGF5b3V0LCBzb21lIGJyb3dzZXJzIChtb3N0LCBidXQgbm90IGFsbCkgd2lsbCBwbGFjZSB0aGVcblx0XHRcdC8vIHNjcm9sbGJhciBvbiB0aGUgbGVmdCwgcmF0aGVyIHRoYW4gdGhlIHJpZ2h0LlxuXHRcdFx0YnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA9IE1hdGgucm91bmQoIGlubmVyLm9mZnNldCgpLmxlZnQgKSAhPT0gMTtcblx0XG5cdFx0XHQvLyBJRTgtIGRvbid0IHByb3ZpZGUgaGVpZ2h0IGFuZCB3aWR0aCBmb3IgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRicm93c2VyLmJCb3VuZGluZyA9IG5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0cnVlIDogZmFsc2U7XG5cdFxuXHRcdFx0bi5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vQnJvd3NlciwgRGF0YVRhYmxlLl9fYnJvd3NlciApO1xuXHRcdHNldHRpbmdzLm9TY3JvbGwuaUJhcldpZHRoID0gRGF0YVRhYmxlLl9fYnJvd3Nlci5iYXJXaWR0aDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcnJheS5wcm90b3R5cGUgcmVkdWNlW1JpZ2h0XSBtZXRob2QsIHVzZWQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnRcblx0ICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJlZHVjZSAoIHRoYXQsIGZuLCBpbml0LCBzdGFydCwgZW5kLCBpbmMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpID0gc3RhcnQsXG5cdFx0XHR2YWx1ZSxcblx0XHRcdGlzU2V0ID0gZmFsc2U7XG5cdFxuXHRcdGlmICggaW5pdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSBpbml0O1xuXHRcdFx0aXNTZXQgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0d2hpbGUgKCBpICE9PSBlbmQgKSB7XG5cdFx0XHRpZiAoICEgdGhhdC5oYXNPd25Qcm9wZXJ0eShpKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dmFsdWUgPSBpc1NldCA/XG5cdFx0XHRcdGZuKCB2YWx1ZSwgdGhhdFtpXSwgaSwgdGhhdCApIDpcblx0XHRcdFx0dGhhdFtpXTtcblx0XG5cdFx0XHRpc1NldCA9IHRydWU7XG5cdFx0XHRpICs9IGluYztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIGNvbHVtbiB0byB0aGUgbGlzdCB1c2VkIGZvciB0aGUgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGggVGhlIHRoIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZENvbHVtbiggb1NldHRpbmdzLCBuVGggKVxuXHR7XG5cdFx0Ly8gQWRkIGNvbHVtbiB0byBhb0NvbHVtbnMgYXJyYXlcblx0XHR2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcblx0XHR2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBvQ29sID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xuXHRcdFx0XCJuVGhcIjogblRoID8gblRoIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSxcblx0XHRcdFwic1RpdGxlXCI6ICAgIG9EZWZhdWx0cy5zVGl0bGUgICAgPyBvRGVmYXVsdHMuc1RpdGxlICAgIDogblRoID8gblRoLmlubmVySFRNTCA6ICcnLFxuXHRcdFx0XCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXG5cdFx0XHRcIm1EYXRhXCI6IG9EZWZhdWx0cy5tRGF0YSA/IG9EZWZhdWx0cy5tRGF0YSA6IGlDb2wsXG5cdFx0XHRpZHg6IGlDb2xcblx0XHR9ICk7XG5cdFx0b1NldHRpbmdzLmFvQ29sdW1ucy5wdXNoKCBvQ29sICk7XG5cdFxuXHRcdC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXG5cdFx0Ly8gcGFzc2VkIGludG8gZXh0ZW5kIGNhbiBiZSB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGdpdmUgYSBkZWZhdWx0XG5cdFx0Ly8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHRcdHNlYXJjaENvbHNbIGlDb2wgXSA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzWyBpQ29sIF0gKTtcblx0XG5cdFx0Ly8gVXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBvcHRpb25zIGZ1bmN0aW9uIHRvIGluaXRpYWxpc2UgY2xhc3NlcyBldGNcblx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsICQoblRoKS5kYXRhKCkgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcHBseSBvcHRpb25zIGZvciBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb09wdGlvbnMgb2JqZWN0IHdpdGggc1R5cGUsIGJWaXNpYmxlIGFuZCBiU2VhcmNoYWJsZSBldGNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucyApXG5cdHtcblx0XHR2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGlDb2wgXTtcblx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRoID0gJChvQ29sLm5UaCk7XG5cdFxuXHRcdC8vIFRyeSB0byBnZXQgd2lkdGggaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBXZSBjYW4ndCBnZXQgaXQgZnJvbSBDU1Ncblx0XHQvLyBhcyB3ZSdkIG5lZWQgdG8gcGFyc2UgdGhlIENTUyBzdHlsZXNoZWV0LiBgd2lkdGhgIG9wdGlvbiBjYW4gb3ZlcnJpZGVcblx0XHRpZiAoICEgb0NvbC5zV2lkdGhPcmlnICkge1xuXHRcdFx0Ly8gV2lkdGggYXR0cmlidXRlXG5cdFx0XHRvQ29sLnNXaWR0aE9yaWcgPSB0aC5hdHRyKCd3aWR0aCcpIHx8IG51bGw7XG5cdFxuXHRcdFx0Ly8gU3R5bGUgYXR0cmlidXRlXG5cdFx0XHR2YXIgdCA9ICh0aC5hdHRyKCdzdHlsZScpIHx8ICcnKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7XG5cdFx0XHRpZiAoIHQgKSB7XG5cdFx0XHRcdG9Db2wuc1dpZHRoT3JpZyA9IHRbMV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBVc2VyIHNwZWNpZmllZCBjb2x1bW4gb3B0aW9ucyAqL1xuXHRcdGlmICggb09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdF9mbkNvbXBhdENvbHMoIG9PcHRpb25zICk7XG5cdFxuXHRcdFx0Ly8gTWFwIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucywgdHJ1ZSApO1xuXHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cblx0XHRcdGlmICggb09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhIClcblx0XHRcdHtcblx0XHRcdFx0b09wdGlvbnMubURhdGEgPSBvT3B0aW9ucy5tRGF0YVByb3A7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5zVHlwZSApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXG5cdFx0XHQvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5jbGFzc05hbWUgJiYgISBvT3B0aW9ucy5zQ2xhc3MgKVxuXHRcdFx0e1xuXHRcdFx0XHRvT3B0aW9ucy5zQ2xhc3MgPSBvT3B0aW9ucy5jbGFzc05hbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9PcHRpb25zLnNDbGFzcyApIHtcblx0XHRcdFx0dGguYWRkQ2xhc3MoIG9PcHRpb25zLnNDbGFzcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdCQuZXh0ZW5kKCBvQ29sLCBvT3B0aW9ucyApO1xuXHRcdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJzV2lkdGhcIiwgXCJzV2lkdGhPcmlnXCIgKTtcblx0XG5cdFx0XHQvKiBpRGF0YVNvcnQgdG8gYmUgYXBwbGllZCAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLCBidXQgYURhdGFTb3J0IHdpbGwgdGFrZVxuXHRcdFx0ICogcHJpb3JpdHkgaWYgZGVmaW5lZFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIG9PcHRpb25zLmlEYXRhU29ydCAhPT0gdW5kZWZpbmVkIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbC5hRGF0YVNvcnQgPSBbIG9PcHRpb25zLmlEYXRhU29ydCBdO1xuXHRcdFx0fVxuXHRcdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJhRGF0YVNvcnRcIiApO1xuXHRcdH1cblx0XG5cdFx0LyogQ2FjaGUgdGhlIGRhdGEgZ2V0IGFuZCBzZXQgZnVuY3Rpb25zIGZvciBzcGVlZCAqL1xuXHRcdHZhciBtRGF0YVNyYyA9IG9Db2wubURhdGE7XG5cdFx0dmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApO1xuXHRcdHZhciBtUmVuZGVyID0gb0NvbC5tUmVuZGVyID8gX2ZuR2V0T2JqZWN0RGF0YUZuKCBvQ29sLm1SZW5kZXIgKSA6IG51bGw7XG5cdFxuXHRcdHZhciBhdHRyVGVzdCA9IGZ1bmN0aW9uKCBzcmMgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLmluZGV4T2YoJ0AnKSAhPT0gLTE7XG5cdFx0fTtcblx0XHRvQ29sLl9iQXR0clNyYyA9ICQuaXNQbGFpbk9iamVjdCggbURhdGFTcmMgKSAmJiAoXG5cdFx0XHRhdHRyVGVzdChtRGF0YVNyYy5zb3J0KSB8fCBhdHRyVGVzdChtRGF0YVNyYy50eXBlKSB8fCBhdHRyVGVzdChtRGF0YVNyYy5maWx0ZXIpXG5cdFx0KTtcblx0XHRvQ29sLl9zZXR0ZXIgPSBudWxsO1xuXHRcblx0XHRvQ29sLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhLCB0eXBlLCBtZXRhKSB7XG5cdFx0XHR2YXIgaW5uZXJEYXRhID0gbURhdGEoIHJvd0RhdGEsIHR5cGUsIHVuZGVmaW5lZCwgbWV0YSApO1xuXHRcblx0XHRcdHJldHVybiBtUmVuZGVyICYmIHR5cGUgP1xuXHRcdFx0XHRtUmVuZGVyKCBpbm5lckRhdGEsIHR5cGUsIHJvd0RhdGEsIG1ldGEgKSA6XG5cdFx0XHRcdGlubmVyRGF0YTtcblx0XHR9O1xuXHRcdG9Db2wuZm5TZXREYXRhID0gZnVuY3Rpb24gKCByb3dEYXRhLCB2YWwsIG1ldGEgKSB7XG5cdFx0XHRyZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApKCByb3dEYXRhLCB2YWwsIG1ldGEgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBJbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCByZWFkIERPTSBkYXRhIGFzIGFuIG9iamVjdCBvciBhcnJheVxuXHRcdC8vIFVzZWQgaW4gX2ZuR2V0Um93RWxlbWVudHNcblx0XHRpZiAoIHR5cGVvZiBtRGF0YVNyYyAhPT0gJ251bWJlcicgKSB7XG5cdFx0XHRvU2V0dGluZ3MuX3Jvd1JlYWRPYmplY3QgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0LyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cblx0XHRpZiAoICFvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0IClcblx0XHR7XG5cdFx0XHRvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xuXHRcdFx0dGguYWRkQ2xhc3MoIG9DbGFzc2VzLnNTb3J0YWJsZU5vbmUgKTsgLy8gSGF2ZSB0byBhZGQgY2xhc3MgaGVyZSBhcyBvcmRlciBldmVudCBpc24ndCBjYWxsZWRcblx0XHR9XG5cdFxuXHRcdC8qIENoZWNrIHRoYXQgdGhlIGNsYXNzIGFzc2lnbm1lbnQgaXMgY29ycmVjdCBmb3Igc29ydGluZyAqL1xuXHRcdHZhciBiQXNjID0gJC5pbkFycmF5KCdhc2MnLCBvQ29sLmFzU29ydGluZykgIT09IC0xO1xuXHRcdHZhciBiRGVzYyA9ICQuaW5BcnJheSgnZGVzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdFx0aWYgKCAhb0NvbC5iU29ydGFibGUgfHwgKCFiQXNjICYmICFiRGVzYykgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZU5vbmU7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBcIlwiO1xuXHRcdH1cblx0XHRlbHNlIGlmICggYkFzYyAmJiAhYkRlc2MgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZUFzYztcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICFiQXNjICYmIGJEZXNjIClcblx0XHR7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVEZXNjO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZTtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGp1c3QgdGhlIHRhYmxlIGNvbHVtbiB3aWR0aHMgZm9yIG5ldyBkYXRhLiBOb3RlOiB5b3Ugd291bGQgcHJvYmFibHkgd2FudCB0b1xuXHQgKiBkbyBhIHJlZHJhdyBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24hXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRqdXN0Q29sdW1uU2l6aW5nICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogTm90IGludGVyZXN0ZWQgaW4gZG9pbmcgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uIGlmIGF1dG8td2lkdGggaXMgZGlzYWJsZWQgKi9cblx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iQXV0b1dpZHRoICE9PSBmYWxzZSApXG5cdFx0e1xuXHRcdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdFx0X2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKCBzZXR0aW5ncyApO1xuXHRcdFx0Zm9yICggdmFyIGk9MCAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRjb2x1bW5zW2ldLm5UaC5zdHlsZS53aWR0aCA9IGNvbHVtbnNbaV0uc1dpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdFx0aWYgKCBzY3JvbGwuc1kgIT09ICcnIHx8IHNjcm9sbC5zWCAhPT0gJycpXG5cdFx0e1xuXHRcdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tc2l6aW5nJywgW3NldHRpbmdzXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvdmVydCB0aGUgaW5kZXggb2YgYSB2aXNpYmxlIGNvbHVtbiB0byB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkgKHRha2UgYWNjb3VudFxuXHQgKiBvZiBoaWRkZW4gY29sdW1ucylcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpTWF0Y2ggVmlzaWJsZSBjb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XG5cdFx0cmV0dXJuIHR5cGVvZiBhaVZpc1tpTWF0Y2hdID09PSAnbnVtYmVyJyA/XG5cdFx0XHRhaVZpc1tpTWF0Y2hdIDpcblx0XHRcdG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuXHQgKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XHR2YXIgaVBvcyA9ICQuaW5BcnJheSggaU1hdGNoLCBhaVZpcyApO1xuXHRcblx0XHRyZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhciB2aXMgPSAwO1xuXHRcblx0XHQvLyBObyByZWR1Y2UgaW4gSUU4LCB1c2UgYSBsb29wIGZvciBub3dcblx0XHQkLmVhY2goIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0aWYgKCBjb2wuYlZpc2libGUgJiYgJChjb2wublRoKS5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnICkge1xuXHRcdFx0XHR2aXMrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiB2aXM7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRoYXQgbWF0Y2ggYSBnaXZlbiBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNQYXJhbSBQYXJhbWV0ZXIgaW4gYW9Db2x1bW5zIHRvIGxvb2sgZm9yIC0gdHlwaWNhbGx5XG5cdCAqICAgIGJWaXNpYmxlIG9yIGJTZWFyY2hhYmxlXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCBzUGFyYW0gKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0JC5tYXAoIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uKHZhbCwgaSkge1xuXHRcdFx0aWYgKCB2YWxbc1BhcmFtXSApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gYTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcblx0XHR2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcblx0XHR2YXIgY29sLCBjZWxsLCBkZXRlY3RlZFR5cGUsIGNhY2hlO1xuXHRcblx0XHQvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgXG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRjYWNoZSA9IFtdO1xuXHRcblx0XHRcdGlmICggISBjb2wuc1R5cGUgJiYgY29sLl9zTWFudWFsVHlwZSApIHtcblx0XHRcdFx0Y29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49dHlwZXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggaz0wLCBrZW49ZGF0YS5sZW5ndGggOyBrPGtlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdC8vIFVzZSBhIGNhY2hlIGFycmF5IHNvIHdlIG9ubHkgbmVlZCB0byBnZXQgdGhlIHR5cGUgZGF0YVxuXHRcdFx0XHRcdFx0Ly8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuXHRcdFx0XHRcdFx0aWYgKCBjYWNoZVtrXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRjYWNoZVtrXSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaywgaSwgJ3R5cGUnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gdHlwZXNbal0oIGNhY2hlW2tdLCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0XHRcdC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xuXHRcdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdGVzdGluZyBhbGwgY2VsbHMsIGJyZWFrIG91dC4gVGhlcmUgaXMgYW5cblx0XHRcdFx0XHRcdC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxuXHRcdFx0XHRcdFx0Ly8gdHlwZXNcblx0XHRcdFx0XHRcdGlmICggISBkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIE9ubHkgYSBzaW5nbGUgbWF0Y2ggaXMgbmVlZGVkIGZvciBodG1sIHR5cGUgc2luY2UgaXQgaXNcblx0XHRcdFx0XHRcdC8vIGJvdHRvbSBvZiB0aGUgcGlsZSBhbmQgdmVyeSBzaW1pbGFyIHRvIHN0cmluZ1xuXHRcdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgPT09ICdodG1sJyApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBUeXBlIGlzIHZhbGlkIGZvciBhbGwgZGF0YSBwb2ludHMgaW4gdGhlIGNvbHVtbiAtIHVzZSB0aGlzXG5cdFx0XHRcdFx0Ly8gdHlwZVxuXHRcdFx0XHRcdGlmICggZGV0ZWN0ZWRUeXBlICkge1xuXHRcdFx0XHRcdFx0Y29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBGYWxsIGJhY2sgLSBpZiBubyB0eXBlIHdhcyBkZXRlY3RlZCwgYWx3YXlzIHVzZSBzdHJpbmdcblx0XHRcdFx0aWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0XHRjb2wuc1R5cGUgPSAnc3RyaW5nJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIHN0YXRpYyBjb2x1bW5zIGFycmF5cyBhbmQgY2FsY3VsYXRlIGhvd1xuXHQgKiB0aGV5IHJlbGF0ZSB0byBjb2x1bW4gaW5kZXhlcy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgdGhlbiBhcHBseSB0aGVcblx0ICogZGVmaW5pdGlvbiBmb3VuZCBmb3IgYSBjb2x1bW4gdG8gYSBzdWl0YWJsZSBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFvQ29sRGVmcyBUaGUgYW9Db2x1bW5EZWZzIGFycmF5IHRoYXQgaXMgdG8gYmUgYXBwbGllZFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xzIFRoZSBhb0NvbHVtbnMgYXJyYXkgdGhhdCBkZWZpbmVzIGNvbHVtbnMgaW5kaXZpZHVhbGx5XG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiAtIHRha2VzIHR3byBwYXJhbWV0ZXJzLCB0aGUgY2FsY3VsYXRlZFxuXHQgKiAgICBjb2x1bW4gaW5kZXggYW5kIHRoZSBkZWZpbml0aW9uIGZvciB0aGF0IGNvbHVtbi5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBmbiApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgZGVmO1xuXHRcdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0Ly8gQ29sdW1uIGRlZmluaXRpb25zIHdpdGggYVRhcmdldHNcblx0XHRpZiAoIGFvQ29sRGVmcyApXG5cdFx0e1xuXHRcdFx0LyogTG9vcCBvdmVyIHRoZSBkZWZpbml0aW9ucyBhcnJheSAtIGxvb3AgaW4gcmV2ZXJzZSBzbyBmaXJzdCBpbnN0YW5jZSBoYXMgcHJpb3JpdHkgKi9cblx0XHRcdGZvciAoIGk9YW9Db2xEZWZzLmxlbmd0aC0xIDsgaT49MCA7IGktLSApXG5cdFx0XHR7XG5cdFx0XHRcdGRlZiA9IGFvQ29sRGVmc1tpXTtcblx0XG5cdFx0XHRcdC8qIEVhY2ggZGVmaW5pdGlvbiBjYW4gdGFyZ2V0IG11bHRpcGxlIGNvbHVtbnMsIGFzIGl0IGlzIGFuIGFycmF5ICovXG5cdFx0XHRcdHZhciBhVGFyZ2V0cyA9IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGRlZi50YXJnZXRzIDpcblx0XHRcdFx0XHRkZWYuYVRhcmdldHM7XG5cdFxuXHRcdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggYVRhcmdldHMgKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhVGFyZ2V0cyA9IFsgYVRhcmdldHMgXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICggaj0wLCBqTGVuPWFUYXJnZXRzLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPj0gMCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogQWRkIGNvbHVtbnMgdGhhdCB3ZSBkb24ndCB5ZXQga25vdyBhYm91dCAqL1xuXHRcdFx0XHRcdFx0d2hpbGUoIGNvbHVtbnMubGVuZ3RoIDw9IGFUYXJnZXRzW2pdIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvKiBJbnRlZ2VyLCBiYXNpYyBpbmRleCAqL1xuXHRcdFx0XHRcdFx0Zm4oIGFUYXJnZXRzW2pdLCBkZWYgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPCAwIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBOZWdhdGl2ZSBpbnRlZ2VyLCByaWdodCB0byBsZWZ0IGNvbHVtbiBjb3VudGluZyAqL1xuXHRcdFx0XHRcdFx0Zm4oIGNvbHVtbnMubGVuZ3RoK2FUYXJnZXRzW2pdLCBkZWYgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ3N0cmluZycgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIENsYXNzIG5hbWUgbWF0Y2hpbmcgb24gVEggZWxlbWVudCAqL1xuXHRcdFx0XHRcdFx0Zm9yICggaz0wLCBrTGVuPWNvbHVtbnMubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCBhVGFyZ2V0c1tqXSA9PSBcIl9hbGxcIiB8fFxuXHRcdFx0XHRcdFx0XHQgICAgICQoY29sdW1uc1trXS5uVGgpLmhhc0NsYXNzKCBhVGFyZ2V0c1tqXSApIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGZuKCBrLCBkZWYgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gU3RhdGljYWxseSBkZWZpbmVkIGNvbHVtbnMgYXJyYXlcblx0XHRpZiAoIGFvQ29scyApXG5cdFx0e1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29scy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRmbiggaSwgYW9Db2xzW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGEgZGF0YSBhcnJheSB0byB0aGUgdGFibGUsIGNyZWF0aW5nIERPTSBub2RlIGV0Yy4gVGhpcyBpcyB0aGUgcGFyYWxsZWwgdG9cblx0ICogX2ZuR2F0aGVyRGF0YSwgYnV0IGZvciBhZGRpbmcgcm93cyBmcm9tIGEgSmF2YXNjcmlwdCBzb3VyY2UsIHJhdGhlciB0aGFuIGFcblx0ICogRE9NIHNvdXJjZS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFEYXRhIGRhdGEgYXJyYXkgdG8gYmUgYWRkZWRcblx0ICogIEBwYXJhbSB7bm9kZX0gW25Ucl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcblx0ICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XG5cdCAqICBAcGFyYW0ge2FycmF5fSBbYW5UZHNdIEFycmF5IG9mIFREfFRIIGVsZW1lbnRzIGZvciB0aGUgcm93IC0gbXVzdCBiZSBnaXZlblxuXHQgKiAgICBpZiBuVHIgaXMuXG5cdCAqICBAcmV0dXJucyB7aW50fSA+PTAgaWYgc3VjY2Vzc2Z1bCAoaW5kZXggb2YgbmV3IGFvRGF0YSBlbnRyeSksIC0xIGlmIGZhaWxlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGREYXRhICggb1NldHRpbmdzLCBhRGF0YUluLCBuVHIsIGFuVGRzIClcblx0e1xuXHRcdC8qIENyZWF0ZSB0aGUgb2JqZWN0IGZvciBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHJvdyAqL1xuXHRcdHZhciBpUm93ID0gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGg7XG5cdFx0dmFyIG9EYXRhID0gJC5leHRlbmQoIHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Sb3csIHtcblx0XHRcdHNyYzogblRyID8gJ2RvbScgOiAnZGF0YScsXG5cdFx0XHRpZHg6IGlSb3dcblx0XHR9ICk7XG5cdFxuXHRcdG9EYXRhLl9hRGF0YSA9IGFEYXRhSW47XG5cdFx0b1NldHRpbmdzLmFvRGF0YS5wdXNoKCBvRGF0YSApO1xuXHRcblx0XHQvKiBDcmVhdGUgdGhlIGNlbGxzICovXG5cdFx0dmFyIG5UZCwgc1RoaXNUeXBlO1xuXHRcdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0Ly8gSW52YWxpZGF0ZSB0aGUgY29sdW1uIHR5cGVzIGFzIHRoZSBuZXcgZGF0YSBuZWVkcyB0byBiZSByZXZhbGlkYXRlZFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGNvbHVtbnNbaV0uc1R5cGUgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0LyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXG5cdFx0b1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5wdXNoKCBpUm93ICk7XG5cdFxuXHRcdHZhciBpZCA9IG9TZXR0aW5ncy5yb3dJZEZuKCBhRGF0YUluICk7XG5cdFx0aWYgKCBpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b1NldHRpbmdzLmFJZHNbIGlkIF0gPSBvRGF0YTtcblx0XHR9XG5cdFxuXHRcdC8qIENyZWF0ZSB0aGUgRE9NIGluZm9ybWF0aW9uLCBvciByZWdpc3RlciBpdCBpZiBhbHJlYWR5IHByZXNlbnQgKi9cblx0XHRpZiAoIG5UciB8fCAhIG9TZXR0aW5ncy5vRmVhdHVyZXMuYkRlZmVyUmVuZGVyIClcblx0XHR7XG5cdFx0XHRfZm5DcmVhdGVUciggb1NldHRpbmdzLCBpUm93LCBuVHIsIGFuVGRzICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gaVJvdztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGQgb25lIG9yIG1vcmUgVFIgZWxlbWVudHMgdG8gdGhlIHRhYmxlLiBHZW5lcmFsbHkgd2UnZCBleHBlY3QgdG9cblx0ICogdXNlIHRoaXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIGEgRE9NIHNvdXJjZWQgdGFibGUsIGJ1dCBpdCBjb3VsZCBiZVxuXHQgKiB1c2VkIGZvciBhbiBUUiBlbGVtZW50LiBOb3RlIHRoYXQgaWYgYSBUUiBpcyBnaXZlbiwgaXQgaXMgdXNlZCAoaS5lLlxuXHQgKiBpdCBpcyBub3QgY2xvbmVkKS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheXxub2RlfGpRdWVyeX0gdHJzIFRoZSBUUiBlbGVtZW50KHMpIHRvIGFkZCB0byB0aGUgdGFibGVcblx0ICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyBmb3IgdGhlIGFkZGVkIHJvd3Ncblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkVHIoIHNldHRpbmdzLCB0cnMgKVxuXHR7XG5cdFx0dmFyIHJvdztcblx0XG5cdFx0Ly8gQWxsb3cgYW4gaW5kaXZpZHVhbCBub2RlIHRvIGJlIHBhc3NlZCBpblxuXHRcdGlmICggISAodHJzIGluc3RhbmNlb2YgJCkgKSB7XG5cdFx0XHR0cnMgPSAkKHRycyk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdHJzLm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRyb3cgPSBfZm5HZXRSb3dFbGVtZW50cyggc2V0dGluZ3MsIGVsICk7XG5cdFx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdy5kYXRhLCBlbCwgcm93LmNlbGxzICk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgYSBUUiBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IHRvIGFuIGluZGV4IGluIGFvRGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuIHRoZSBUUiBlbGVtZW50IHRvIGZpbmRcblx0ICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCBudWxsIGlmIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ob2RlVG9EYXRhSW5kZXgoIG9TZXR0aW5ncywgbiApXG5cdHtcblx0XHRyZXR1cm4gKG4uX0RUX1Jvd0luZGV4IT09dW5kZWZpbmVkKSA/IG4uX0RUX1Jvd0luZGV4IDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIGEgVEQgZWxlbWVudCBhbmQgY29udmVydCBpdCBpbnRvIGEgY29sdW1uIGRhdGEgaW5kZXggKG5vdCB0aGUgdmlzaWJsZSBpbmRleClcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgbnVtYmVyIHRoZSBURC9USCBjYW4gYmUgZm91bmQgaW5cblx0ICogIEBwYXJhbSB7bm9kZX0gbiBUaGUgVEQvVEggZWxlbWVudCB0byBmaW5kXG5cdCAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgLTEgaWYgbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbk5vZGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlSb3csIG4gKVxuXHR7XG5cdFx0cmV0dXJuICQuaW5BcnJheSggbiwgb1NldHRpbmdzLmFvRGF0YVsgaVJvdyBdLmFuQ2VsbHMgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gY2VsbCBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSwgdGFraW5nIGludG8gYWNjb3VudCBkYXRhIG1hcHBpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnKVxuXHQgKiAgQHJldHVybnMgeyp9IENlbGwgZGF0YVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB0eXBlIClcblx0e1xuXHRcdHZhciBkcmF3ICAgICAgICAgICA9IHNldHRpbmdzLmlEcmF3O1xuXHRcdHZhciBjb2wgICAgICAgICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHRcdHZhciByb3dEYXRhICAgICAgICA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcblx0XHR2YXIgZGVmYXVsdENvbnRlbnQgPSBjb2wuc0RlZmF1bHRDb250ZW50O1xuXHRcdHZhciBjZWxsRGF0YSAgICAgICA9IGNvbC5mbkdldERhdGEoIHJvd0RhdGEsIHR5cGUsIHtcblx0XHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0XHRjb2w6ICAgICAgY29sSWR4XG5cdFx0fSApO1xuXHRcblx0XHRpZiAoIGNlbGxEYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzLmlEcmF3RXJyb3IgIT0gZHJhdyAmJiBkZWZhdWx0Q29udGVudCA9PT0gbnVsbCApIHtcblx0XHRcdFx0X2ZuTG9nKCBzZXR0aW5ncywgMCwgXCJSZXF1ZXN0ZWQgdW5rbm93biBwYXJhbWV0ZXIgXCIrXG5cdFx0XHRcdFx0KHR5cGVvZiBjb2wubURhdGE9PSdmdW5jdGlvbicgPyAne2Z1bmN0aW9ufScgOiBcIidcIitjb2wubURhdGErXCInXCIpK1xuXHRcdFx0XHRcdFwiIGZvciByb3cgXCIrcm93SWR4K1wiLCBjb2x1bW4gXCIrY29sSWR4LCA0ICk7XG5cdFx0XHRcdHNldHRpbmdzLmlEcmF3RXJyb3IgPSBkcmF3O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlZmF1bHRDb250ZW50O1xuXHRcdH1cblx0XG5cdFx0Ly8gV2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCBhbmQgYSBzcGVjaWZpYyBkYXRhIHR5cGUgaXMgcmVxdWVzdGVkIChpLmUuXG5cdFx0Ly8gbm90IHRoZSBvcmlnaW5hbCBkYXRhKSwgd2UgY2FuIHVzZSBkZWZhdWx0IGNvbHVtbiBkYXRhXG5cdFx0aWYgKCAoY2VsbERhdGEgPT09IHJvd0RhdGEgfHwgY2VsbERhdGEgPT09IG51bGwpICYmIGRlZmF1bHRDb250ZW50ICE9PSBudWxsICYmIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNlbGxEYXRhID0gZGVmYXVsdENvbnRlbnQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgY2VsbERhdGEgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBJZiB0aGUgZGF0YSBzb3VyY2UgaXMgYSBmdW5jdGlvbiwgdGhlbiB3ZSBydW4gaXQgYW5kIHVzZSB0aGUgcmV0dXJuLFxuXHRcdFx0Ly8gZXhlY3V0aW5nIGluIHRoZSBzY29wZSBvZiB0aGUgZGF0YSBvYmplY3QgKGZvciBpbnN0YW5jZXMpXG5cdFx0XHRyZXR1cm4gY2VsbERhdGEuY2FsbCggcm93RGF0YSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBjZWxsRGF0YSA9PT0gbnVsbCAmJiB0eXBlID09ICdkaXNwbGF5JyApIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIGNlbGxEYXRhO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc3BlY2lmaWMgY2VsbCwgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBjYWNoZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG5cdCAqICBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byBzZXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdmFsIClcblx0e1xuXHRcdHZhciBjb2wgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdFx0dmFyIHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XG5cdFxuXHRcdGNvbC5mblNldERhdGEoIHJvd0RhdGEsIHZhbCwge1xuXHRcdFx0c2V0dGluZ3M6IHNldHRpbmdzLFxuXHRcdFx0cm93OiAgICAgIHJvd0lkeCxcblx0XHRcdGNvbDogICAgICBjb2xJZHhcblx0XHR9ICApO1xuXHR9XG5cdFxuXHRcblx0Ly8gUHJpdmF0ZSB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gbWF0Y2ggYWN0aW9uIHN5bnRheCBpbiB0aGUgZGF0YSBwcm9wZXJ0eSBvYmplY3Rcblx0dmFyIF9fcmVBcnJheSA9IC9cXFsuKj9cXF0kLztcblx0dmFyIF9fcmVGbiA9IC9cXChcXCkkLztcblx0XG5cdC8qKlxuXHQgKiBTcGxpdCBzdHJpbmcgb24gcGVyaW9kcywgdGFraW5nIGludG8gYWNjb3VudCBlc2NhcGVkIHBlcmlvZHNcblx0ICogQHBhcmFtICB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0XG5cdCAqIEByZXR1cm4ge2FycmF5fSBTcGxpdCBzdHJpbmdcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNwbGl0T2JqTm90YXRpb24oIHN0ciApXG5cdHtcblx0XHRyZXR1cm4gJC5tYXAoIHN0ci5tYXRjaCgvKFxcXFwufFteXFwuXSkrL2cpIHx8IFsnJ10sIGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHJldHVybiBzLnJlcGxhY2UoL1xcXFxcXC4vZywgJy4nKTtcblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG5cdCAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2Vcblx0ICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBnZXQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0T2JqZWN0RGF0YUZuKCBtU291cmNlIClcblx0e1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBtU291cmNlICkgKVxuXHRcdHtcblx0XHRcdC8qIEJ1aWxkIGFuIG9iamVjdCBvZiBnZXQgZnVuY3Rpb25zLCBhbmQgd3JhcCB0aGVtIGluIGEgc2luZ2xlIGNhbGwgKi9cblx0XHRcdHZhciBvID0ge307XG5cdFx0XHQkLmVhY2goIG1Tb3VyY2UsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRvW2tleV0gPSBfZm5HZXRPYmplY3REYXRhRm4oIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0dmFyIHQgPSBvW3R5cGVdIHx8IG8uXztcblx0XHRcdFx0cmV0dXJuIHQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0dChkYXRhLCB0eXBlLCByb3csIG1ldGEpIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1Tb3VyY2UgPT09IG51bGwgKVxuXHRcdHtcblx0XHRcdC8qIEdpdmUgYW4gZW1wdHkgc3RyaW5nIGZvciByZW5kZXJpbmcgLyBzb3J0aW5nIGV0YyAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHR5cGUsIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnZnVuY3Rpb24nIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xuXHRcdFx0XHRyZXR1cm4gbVNvdXJjZSggZGF0YSwgdHlwZSwgcm93LCBtZXRhICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIG1Tb3VyY2UgPT09ICdzdHJpbmcnICYmIChtU291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcblx0XHRcdCAgICAgIG1Tb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBtU291cmNlLmluZGV4T2YoJygnKSAhPT0gLTEpIClcblx0XHR7XG5cdFx0XHQvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxuXHRcdFx0ICogbmVzdGVkIG9iamVjdCBzbyB3ZSBsb29wIG92ZXIgdGhlIGRhdGEgZm9yIGVhY2ggbGV2ZWwgdG8gZ2V0IHRoZSBuZXh0XG5cdFx0XHQgKiBsZXZlbCBkb3duLiBPbiBlYWNoIGxvb3Agd2UgdGVzdCBmb3IgdW5kZWZpbmVkLCBhbmQgaWYgZm91bmQgaW1tZWRpYXRlbHlcblx0XHRcdCAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXG5cdFx0XHQgKiBiZSB1c2VkIGlmIGRlZmluZWQsIHJhdGhlciB0aGFuIHRocm93aW5nIGFuIGVycm9yXG5cdFx0XHQgKi9cblx0XHRcdHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XG5cdFx0XHRcdHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRpZiAoIHNyYyAhPT0gXCJcIiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApO1xuXHRcblx0XHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cblx0XHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0XHRmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBhcnJheU5vdGF0aW9uIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gQXJyYXkgbm90YXRpb25cblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxuXHRcdFx0XHRcdFx0XHRpZiAoIGFbaV0gIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRvdXQgPSBbXTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIGdldFxuXHRcdFx0XHRcdFx0XHRhLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRcdGlubmVyU3JjID0gYS5qb2luKCcuJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBnZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0LnB1c2goIGZldGNoRGF0YSggZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMgKSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxuXHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gKGpvaW49PT1cIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBmZXRjaERhdGEoIGRhdGEsIHR5cGUsIG1Tb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGRhdGFbbVNvdXJjZV07XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcblx0ICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIHNldCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UgKVxuXHR7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIG1Tb3VyY2UgKSApXG5cdFx0e1xuXHRcdFx0LyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXG5cdFx0XHQgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3Rcblx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0ICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UuXyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbVNvdXJjZSA9PT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0LyogTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge307XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcblx0XHRcdFx0bVNvdXJjZSggZGF0YSwgJ3NldCcsIHZhbCwgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogTGlrZSB0aGUgZ2V0LCB3ZSBuZWVkIHRvIGdldCBkYXRhIGZyb20gYSBuZXN0ZWQgb2JqZWN0ICovXG5cdFx0XHR2YXIgc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB2YWwsIHNyYykge1xuXHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApLCBiO1xuXHRcdFx0XHR2YXIgYUxhc3QgPSBhW2EubGVuZ3RoLTFdO1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvLCBpbm5lclNyYztcblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGgtMSA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBQcm90ZWN0IGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHRcdGlmIChhW2ldID09PSAnX19wcm90b19fJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHByb3RvdHlwZSB2YWx1ZXMnKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXkgbm90YXRpb24gcmVxdWVzdFxuXHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSBbXTtcblx0XG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBzZXQgc28gd2UgY2FuIHJlY3Vyc2Vcblx0XHRcdFx0XHRcdGIgPSBhLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRiLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRpbm5lclNyYyA9IGIuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IHNldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj12YWwubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzZXREYXRhKCBvLCB2YWxbal0sIGlubmVyU3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBXZSd2ZSBiZWVuIGFza2VkIHRvIHNhdmUgZGF0YSB0byBhbiBhcnJheSwgYnV0IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlzbid0IGFycmF5IGRhdGEgdG8gYmUgc2F2ZWQuIEJlc3QgdGhhdCBjYW4gYmUgZG9uZVxuXHRcdFx0XHRcdFx0XHQvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHQvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGZ1bmNOb3RhdGlvbiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5lc3RlZCBvYmplY3QgZG9lc24ndCBjdXJyZW50bHkgZXhpc3QgLSBzaW5jZSB3ZSBhcmVcblx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxuXHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gTGFzdCBpdGVtIGluIHRoZSBpbnB1dCAtIGkuZSwgdGhlIGFjdHVhbCBzZXRcblx0XHRcdFx0aWYgKCBhTGFzdC5tYXRjaChfX3JlRm4gKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUZuLCAnJykgXSggdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHQvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxuXHRcdFx0XHRcdGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUFycmF5LCAnJykgXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIHNldERhdGEoIGRhdGEsIHZhbCwgbVNvdXJjZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8qIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmcgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRkYXRhW21Tb3VyY2VdID0gdmFsO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIGZ1bGwgdGFibGUgZGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE51a2UgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNsZWFyVGFibGUoIHNldHRpbmdzIClcblx0e1xuXHRcdHNldHRpbmdzLmFvRGF0YS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFJZHMgPSB7fTtcblx0fVxuXHRcblx0XG5cdCAvKipcblx0ICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3Rcblx0ICogdGhlIGtleSEpXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZWxldGVJbmRleCggYSwgaVRhcmdldCwgc3BsaWNlIClcblx0e1xuXHRcdHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0aWYgKCBhW2ldID09IGlUYXJnZXQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpVGFyZ2V0SW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGFbaV0gPiBpVGFyZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0YVtpXS0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBpVGFyZ2V0SW5kZXggIT0gLTEgJiYgc3BsaWNlID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdGEuc3BsaWNlKCBpVGFyZ2V0SW5kZXgsIDEgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG5cdCAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcblx0ICogICAgIG9yICdkYXRhJ1xuXHQgKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcblx0ICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXG5cdCAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKlxuXHQgKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xuXHQgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcblx0ICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcblx0e1xuXHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNlbGxXcml0ZSA9IGZ1bmN0aW9uICggY2VsbCwgY29sICkge1xuXHRcdFx0Ly8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcblx0XHRcdC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcblx0XHRcdC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcblx0XHRcdHdoaWxlICggY2VsbC5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2VsbC5yZW1vdmVDaGlsZCggY2VsbC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRcdGlmICggc3JjID09PSAnZG9tJyB8fCAoKCEgc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykgKSB7XG5cdFx0XHQvLyBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIERPTVxuXHRcdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRcdHNldHRpbmdzLCByb3csIGNvbElkeCwgY29sSWR4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3cuX2FEYXRhXG5cdFx0XHRcdClcblx0XHRcdFx0LmRhdGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdFx0dmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjZWxsV3JpdGUoIGNlbGxzW2NvbElkeF0sIGNvbElkeCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tpXSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuXHRcdC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XG5cdFx0cm93Ll9hU29ydERhdGEgPSBudWxsO1xuXHRcdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXHRcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXG5cdFx0Ly8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdFx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xzW2ldLnNUeXBlID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XG5cdFx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBzZXR0aW5ncywgcm93ICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIGEgZGF0YSBzb3VyY2Ugb2JqZWN0IGZyb20gYW4gSFRNTCByb3csIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcblx0ICogICBvYmplY3QgZnJvbSB3aGljaCB0byByZS1yZWFkIHRoZSBkYXRhIGZyb20gdGhlIGNlbGxzXG5cdCAqIEBwYXJhbSB7aW50fSBbY29sSWR4XSBPcHRpb25hbCBjb2x1bW4gaW5kZXhcblx0ICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xuXHQgKiAgIHBhcmFtZXRlciBzaG91bGQgYWxzbyBiZSBnaXZlbiBhbmQgd2lsbCBiZSB1c2VkIHRvIHdyaXRlIHRoZSBkYXRhIGludG8uXG5cdCAqICAgT25seSB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIHdpbGwgYmUgd3JpdHRlblxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXG5cdCAqICAgZG9jdW1lbnQgb3JkZXIsIGFuZCBgY2VsbHNgIGFuZCBhcnJheSBvZiBub2RlcyAodGhleSBjYW4gYmUgdXNlZnVsIHRvIHRoZVxuXHQgKiAgIGNhbGxlciwgc28gcmF0aGVyIHRoYW4gbmVlZGluZyBhIHNlY29uZCB0cmF2ZXJzYWwgdG8gZ2V0IHRoZW0sIGp1c3QgcmV0dXJuXG5cdCAqICAgdGhlbSBmcm9tIGhlcmUpLlxuXHQgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0ZHMgPSBbXSxcblx0XHRcdHRkID0gcm93LmZpcnN0Q2hpbGQsXG5cdFx0XHRuYW1lLCBjb2wsIG8sIGk9MCwgY29udGVudHMsXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0b2JqZWN0UmVhZCA9IHNldHRpbmdzLl9yb3dSZWFkT2JqZWN0O1xuXHRcblx0XHQvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3Rcblx0XHRkID0gZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGQgOlxuXHRcdFx0b2JqZWN0UmVhZCA/XG5cdFx0XHRcdHt9IDpcblx0XHRcdFx0W107XG5cdFxuXHRcdHZhciBhdHRyID0gZnVuY3Rpb24gKCBzdHIsIHRkICApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHZhciBpZHggPSBzdHIuaW5kZXhPZignQCcpO1xuXHRcblx0XHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHRcdHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyggaWR4KzEgKTtcblx0XHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBzdHIgKTtcblx0XHRcdFx0XHRzZXR0ZXIoIGQsIHRkLmdldEF0dHJpYnV0ZSggYXR0ciApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBSZWFkIGRhdGEgZnJvbSBhIGNlbGwgYW5kIHN0b3JlIGludG8gdGhlIGRhdGEgb2JqZWN0XG5cdFx0dmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKCBjZWxsICkge1xuXHRcdFx0aWYgKCBjb2xJZHggPT09IHVuZGVmaW5lZCB8fCBjb2xJZHggPT09IGkgKSB7XG5cdFx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRcdGNvbnRlbnRzID0gKGNlbGwuaW5uZXJIVE1MKS50cmltKCk7XG5cdFxuXHRcdFx0XHRpZiAoIGNvbCAmJiBjb2wuX2JBdHRyU3JjICkge1xuXHRcdFx0XHRcdHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIGNvbC5tRGF0YS5fICk7XG5cdFx0XHRcdFx0c2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcblx0XHRcdFx0XHRhdHRyKCBjb2wubURhdGEuc29ydCwgY2VsbCApO1xuXHRcdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS50eXBlLCBjZWxsICk7XG5cdFx0XHRcdFx0YXR0ciggY29sLm1EYXRhLmZpbHRlciwgY2VsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYGRhdGFgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbnMgdGhlIGRhdGEgY2FuXG5cdFx0XHRcdFx0Ly8gYmUgcmVhZCB0byBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuXHRcdFx0XHRcdGlmICggb2JqZWN0UmVhZCApIHtcblx0XHRcdFx0XHRcdGlmICggISBjb2wuX3NldHRlciApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIHNldHRlciBmdW5jdGlvblxuXHRcdFx0XHRcdFx0XHRjb2wuX3NldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2wuX3NldHRlciggZCwgY29udGVudHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRkW2ldID0gY29udGVudHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFxuXHRcdGlmICggdGQgKSB7XG5cdFx0XHQvLyBgdHJgIGVsZW1lbnQgd2FzIHBhc3NlZCBpblxuXHRcdFx0d2hpbGUgKCB0ZCApIHtcblx0XHRcdFx0bmFtZSA9IHRkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFxuXHRcdFx0XHRpZiAoIG5hbWUgPT0gXCJURFwiIHx8IG5hbWUgPT0gXCJUSFwiICkge1xuXHRcdFx0XHRcdGNlbGxQcm9jZXNzKCB0ZCApO1xuXHRcdFx0XHRcdHRkcy5wdXNoKCB0ZCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR0ZCA9IHRkLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXG5cdFx0XHR0ZHMgPSByb3cuYW5DZWxscztcblx0XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGRzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRjZWxsUHJvY2VzcyggdGRzW2pdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBSZWFkIHRoZSBJRCBmcm9tIHRoZSBET00gaWYgcHJlc2VudFxuXHRcdHZhciByb3dOb2RlID0gcm93LmZpcnN0Q2hpbGQgPyByb3cgOiByb3cublRyO1xuXHRcblx0XHRpZiAoIHJvd05vZGUgKSB7XG5cdFx0XHR2YXIgaWQgPSByb3dOb2RlLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcblx0XHRcdGlmICggaWQgKSB7XG5cdFx0XHRcdF9mblNldE9iamVjdERhdGFGbiggc2V0dGluZ3Mucm93SWQgKSggZCwgaWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBkLFxuXHRcdFx0Y2VsbHM6IHRkc1xuXHRcdH07XG5cdH1cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBUUiBlbGVtZW50IChhbmQgaXQncyBURCBjaGlsZHJlbikgZm9yIGEgcm93XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gaVJvdyBSb3cgdG8gY29uc2lkZXJcblx0ICogIEBwYXJhbSB7bm9kZX0gW25UckluXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuXHQgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcblx0ICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG5cdCAqICAgIGlmIG5UciBpcy5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ3JlYXRlVHIgKCBvU2V0dGluZ3MsIGlSb3csIG5UckluLCBhblRkcyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHJvdyA9IG9TZXR0aW5ncy5hb0RhdGFbaVJvd10sXG5cdFx0XHRyb3dEYXRhID0gcm93Ll9hRGF0YSxcblx0XHRcdGNlbGxzID0gW10sXG5cdFx0XHRuVHIsIG5UZCwgb0NvbCxcblx0XHRcdGksIGlMZW4sIGNyZWF0ZTtcblx0XG5cdFx0aWYgKCByb3cublRyID09PSBudWxsIClcblx0XHR7XG5cdFx0XHRuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXHRcblx0XHRcdHJvdy5uVHIgPSBuVHI7XG5cdFx0XHRyb3cuYW5DZWxscyA9IGNlbGxzO1xuXHRcblx0XHRcdC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcblx0XHRcdCAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxuXHRcdFx0ICovXG5cdFx0XHRuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcblx0XG5cdFx0XHQvKiBTcGVjaWFsIHBhcmFtZXRlcnMgY2FuIGJlIGdpdmVuIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBiZSB1c2VkIG9uIHRoZSByb3cgKi9cblx0XHRcdF9mblJvd0F0dHJpYnV0ZXMoIG9TZXR0aW5ncywgcm93ICk7XG5cdFxuXHRcdFx0LyogUHJvY2VzcyBlYWNoIGNvbHVtbiAqL1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPW9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XHRcdGNyZWF0ZSA9IG5UckluID8gZmFsc2UgOiB0cnVlO1xuXHRcblx0XHRcdFx0blRkID0gY3JlYXRlID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggb0NvbC5zQ2VsbFR5cGUgKSA6IGFuVGRzW2ldO1xuXHRcdFx0XHRuVGQuX0RUX0NlbGxJbmRleCA9IHtcblx0XHRcdFx0XHRyb3c6IGlSb3csXG5cdFx0XHRcdFx0Y29sdW1uOiBpXG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjZWxscy5wdXNoKCBuVGQgKTtcblx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIHRoZSBIVE1MIGlmIG5ldywgb3IgaWYgYSByZW5kZXJpbmcgZnVuY3Rpb24gaXMgZGVmaW5lZFxuXHRcdFx0XHRpZiAoIGNyZWF0ZSB8fCAoKCFuVHJJbiB8fCBvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcblx0XHRcdFx0XHQgKCEkLmlzUGxhaW5PYmplY3Qob0NvbC5tRGF0YSkgfHwgb0NvbC5tRGF0YS5fICE9PSBpKycuZGlzcGxheScpXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRuVGQuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSwgJ2Rpc3BsYXknICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8qIEFkZCB1c2VyIGRlZmluZWQgY2xhc3MgKi9cblx0XHRcdFx0aWYgKCBvQ29sLnNDbGFzcyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuVGQuY2xhc3NOYW1lICs9ICcgJytvQ29sLnNDbGFzcztcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gVmlzaWJpbGl0eSAtIGFkZCBvciByZW1vdmUgYXMgcmVxdWlyZWRcblx0XHRcdFx0aWYgKCBvQ29sLmJWaXNpYmxlICYmICEgblRySW4gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0blRyLmFwcGVuZENoaWxkKCBuVGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggISBvQ29sLmJWaXNpYmxlICYmIG5UckluIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5UZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBuVGQgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCBvQ29sLmZuQ3JlYXRlZENlbGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0b0NvbC5mbkNyZWF0ZWRDZWxsLmNhbGwoIG9TZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRcdFx0XHRuVGQsIF9mbkdldENlbGxEYXRhKCBvU2V0dGluZ3MsIGlSb3csIGkgKSwgcm93RGF0YSwgaVJvdywgaVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgbnVsbCwgW25Uciwgcm93RGF0YSwgaVJvdywgY2VsbHNdICk7XG5cdFx0fVxuXHRcblx0XHQvLyBSZW1vdmUgb25jZSB3ZWJraXQgYnVnIDEzMTgxOSBhbmQgQ2hyb21pdW0gYnVnIDM2NTYxOSBoYXZlIGJlZW4gcmVzb2x2ZWRcblx0XHQvLyBhbmQgZGVwbG95ZWRcblx0XHRyb3cublRyLnNldEF0dHJpYnV0ZSggJ3JvbGUnLCAncm93JyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxuXHQgKiBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKVxuXHR7XG5cdFx0dmFyIHRyID0gcm93Lm5Ucjtcblx0XHR2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cdFxuXHRcdGlmICggdHIgKSB7XG5cdFx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhICk7XG5cdFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0dHIuaWQgPSBpZDtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93Q2xhc3MgKSB7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgY2xhc3NlcyBhZGRlZCBieSBEVF9Sb3dDbGFzcyBiZWZvcmVcblx0XHRcdFx0dmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XG5cdFx0XHRcdHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cblx0XHRcdFx0XHRfdW5pcXVlKCByb3cuX19yb3djLmNvbmNhdCggYSApICkgOlxuXHRcdFx0XHRcdGE7XG5cdFxuXHRcdFx0XHQkKHRyKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggcm93Ll9fcm93Yy5qb2luKCcgJykgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggZGF0YS5EVF9Sb3dDbGFzcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZGF0YS5EVF9Sb3dBdHRyICkge1xuXHRcdFx0XHQkKHRyKS5hdHRyKCBkYXRhLkRUX1Jvd0F0dHIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93RGF0YSApIHtcblx0XHRcdFx0JCh0cikuZGF0YSggZGF0YS5EVF9Sb3dEYXRhICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEhlYWQoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaWVuLCBjZWxsLCByb3csIGNvbHVtbjtcblx0XHR2YXIgdGhlYWQgPSBvU2V0dGluZ3MublRIZWFkO1xuXHRcdHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XG5cdFx0dmFyIGNyZWF0ZUhlYWRlciA9ICQoJ3RoLCB0ZCcsIHRoZWFkKS5sZW5ndGggPT09IDA7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdHJvdyA9ICQoJzx0ci8+JykuYXBwZW5kVG8oIHRoZWFkICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdGNlbGwgPSAkKCBjb2x1bW4ublRoICkuYWRkQ2xhc3MoIGNvbHVtbi5zQ2xhc3MgKTtcblx0XG5cdFx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdFx0Y2VsbC5hcHBlbmRUbyggcm93ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gMS4xMSBtb3ZlIGludG8gc29ydGluZ1xuXHRcdFx0aWYgKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRjZWxsLmFkZENsYXNzKCBjb2x1bW4uc1NvcnRpbmdDbGFzcyApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQuYXR0ciggJ3RhYmluZGV4Jywgb1NldHRpbmdzLmlUYWJJbmRleCApXG5cdFx0XHRcdFx0XHQuYXR0ciggJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQgKTtcblx0XG5cdFx0XHRcdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKCBvU2V0dGluZ3MsIGNvbHVtbi5uVGgsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggY29sdW1uLnNUaXRsZSAhPSBjZWxsWzBdLmlubmVySFRNTCApIHtcblx0XHRcdFx0Y2VsbC5odG1sKCBjb2x1bW4uc1RpdGxlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuUmVuZGVyZXIoIG9TZXR0aW5ncywgJ2hlYWRlcicgKShcblx0XHRcdFx0b1NldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCApO1xuXHRcdH1cblx0XHRcblx0XHQvKiBBUklBIHJvbGUgZm9yIHRoZSByb3dzICovXG5cdFx0JCh0aGVhZCkuY2hpbGRyZW4oJ3RyJykuYXR0cigncm9sZScsICdyb3cnKTtcblx0XG5cdFx0LyogRGVhbCB3aXRoIHRoZSBmb290ZXIgLSBhZGQgY2xhc3NlcyBpZiByZXF1aXJlZCAqL1xuXHRcdCQodGhlYWQpLmNoaWxkcmVuKCd0cicpLmNoaWxkcmVuKCd0aCwgdGQnKS5hZGRDbGFzcyggY2xhc3Nlcy5zSGVhZGVyVEggKTtcblx0XHQkKHRmb290KS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJykuYWRkQ2xhc3MoIGNsYXNzZXMuc0Zvb3RlclRIICk7XG5cdFxuXHRcdC8vIENhY2hlIHRoZSBmb290ZXIgY2VsbHMuIE5vdGUgdGhhdCB3ZSBvbmx5IHRha2UgdGhlIGNlbGxzIGZyb20gdGhlIGZpcnN0XG5cdFx0Ly8gcm93IGluIHRoZSBmb290ZXIuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcm93IHRoZSB1c2VyIHdhbnRzIHRvXG5cdFx0Ly8gaW50ZXJhY3Qgd2l0aCwgdGhleSBuZWVkIHRvIHVzZSB0aGUgdGFibGUoKS5mb290KCkgbWV0aG9kLiBOb3RlIGFsc28gdGhpc1xuXHRcdC8vIGFsbG93cyBjZWxscyB0byBiZSB1c2VkIGZvciBtdWx0aXBsZSBjb2x1bW5zIHVzaW5nIGNvbHNwYW5cblx0XHRpZiAoIHRmb290ICE9PSBudWxsICkge1xuXHRcdFx0dmFyIGNlbGxzID0gb1NldHRpbmdzLmFvRm9vdGVyWzBdO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHRjb2x1bW4ublRmID0gY2VsbHNbaV0uY2VsbDtcblx0XG5cdFx0XHRcdGlmICggY29sdW1uLnNDbGFzcyApIHtcblx0XHRcdFx0XHQkKGNvbHVtbi5uVGYpLmFkZENsYXNzKCBjb2x1bW4uc0NsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy4gVGhlXG5cdCAqIG1ldGhvZG9sb2d5IGhlcmUgaXMgdG8gdXNlIHRoZSBsYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXIsIG1vZGlmaWVkIGZvclxuXHQgKiB0aGUgaW5zdGFudGFuZW91cyBjb2x1bW4gdmlzaWJpbGl0eSwgdG8gY29uc3RydWN0IHRoZSBuZXcgbGF5b3V0LiBUaGUgZ3JpZCBpc1xuXHQgKiB0cmF2ZXJzZWQgb3ZlciBjZWxsIGF0IGEgdGltZSBpbiBhIHJvd3MgeCBjb2x1bW5zIGdyaWQgZmFzaGlvbiwgYWx0aG91Z2ggZWFjaFxuXHQgKiBjZWxsIGluc2VydCBjYW4gY292ZXIgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIGdyaWQgLSB3aGljaCBpcyB0cmFja3MgdXNpbmcgdGhlXG5cdCAqIGFBcHBsaWVkIGFycmF5LiBDZWxsIGluc2VydHMgaW4gdGhlIGdyaWQgd2lsbCBvbmx5IG9jY3VyIHdoZXJlIHRoZXJlIGlzbid0XG5cdCAqIGFscmVhZHkgYSBjZWxsIGluIHRoYXQgcG9zaXRpb24uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdHN9IGFvU291cmNlIExheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlclxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYkluY2x1ZGVIaWRkZW49ZmFsc2VdIElmIHRydWUgdGhlbiBpbmNsdWRlIHRoZSBoaWRkZW4gY29sdW1ucyBpbiB0aGUgY2FsYyxcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhd0hlYWQoIG9TZXR0aW5ncywgYW9Tb3VyY2UsIGJJbmNsdWRlSGlkZGVuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBuLCBuTG9jYWxUcjtcblx0XHR2YXIgYW9Mb2NhbCA9IFtdO1xuXHRcdHZhciBhQXBwbGllZCA9IFtdO1xuXHRcdHZhciBpQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBpUm93c3BhbiwgaUNvbHNwYW47XG5cdFxuXHRcdGlmICggISBhb1NvdXJjZSApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAgYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0YkluY2x1ZGVIaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aG91dCB0aGUgdmlzaWJsZSBjb2x1bW5zIGluIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvU291cmNlLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0YW9Mb2NhbFtpXSA9IGFvU291cmNlW2ldLnNsaWNlKCk7XG5cdFx0XHRhb0xvY2FsW2ldLm5UciA9IGFvU291cmNlW2ldLm5Ucjtcblx0XG5cdFx0XHQvKiBSZW1vdmUgYW55IGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBoaWRkZW4gKi9cblx0XHRcdGZvciAoIGo9aUNvbHVtbnMtMSA7IGo+PTAgOyBqLS0gKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFvU2V0dGluZ3MuYW9Db2x1bW5zW2pdLmJWaXNpYmxlICYmICFiSW5jbHVkZUhpZGRlbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhb0xvY2FsW2ldLnNwbGljZSggaiwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUHJlcCB0aGUgYXBwbGllZCBhcnJheSAtIGl0IG5lZWRzIGFuIGVsZW1lbnQgZm9yIGVhY2ggcm93ICovXG5cdFx0XHRhQXBwbGllZC5wdXNoKCBbXSApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvTG9jYWwubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRuTG9jYWxUciA9IGFvTG9jYWxbaV0ublRyO1xuXHRcblx0XHRcdC8qIEFsbCBjZWxscyBhcmUgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHNvIGVtcHR5IG91dCB0aGUgcm93ICovXG5cdFx0XHRpZiAoIG5Mb2NhbFRyIClcblx0XHRcdHtcblx0XHRcdFx0d2hpbGUoIChuID0gbkxvY2FsVHIuZmlyc3RDaGlsZCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGo9MCwgakxlbj1hb0xvY2FsW2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlSb3dzcGFuID0gMTtcblx0XHRcdFx0aUNvbHNwYW4gPSAxO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuXHRcdFx0XHQgKiBpbnNlcnQgcG9pbnQuIElmIHRoZXJlIGlzLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIuYXBwZW5kQ2hpbGQoIGFvTG9jYWxbaV1bal0uY2VsbCApO1xuXHRcdFx0XHRcdGFBcHBsaWVkW2ldW2pdID0gMTtcblx0XG5cdFx0XHRcdFx0LyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cblx0XHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaStpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaStpUm93c3Bhbl1bal0uY2VsbCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YUFwcGxpZWRbaStpUm93c3Bhbl1bal0gPSAxO1xuXHRcdFx0XHRcdFx0aVJvd3NwYW4rKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IGNvbHVtbnMgYXMgbmVlZGVkICovXG5cdFx0XHRcdFx0d2hpbGUgKCBhb0xvY2FsW2ldW2oraUNvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2ldW2oraUNvbHNwYW5dLmNlbGwgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIE11c3QgdXBkYXRlIHRoZSBhcHBsaWVkIGFycmF5IG92ZXIgdGhlIHJvd3MgZm9yIHRoZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGlSb3dzcGFuIDsgaysrIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YUFwcGxpZWRbaStrXVtqK2lDb2xzcGFuXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpQ29sc3BhbisrO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogRG8gdGhlIGFjdHVhbCBleHBhbnNpb24gaW4gdGhlIERPTSAqL1xuXHRcdFx0XHRcdCQoYW9Mb2NhbFtpXVtqXS5jZWxsKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3Bhbilcblx0XHRcdFx0XHRcdC5hdHRyKCdjb2xzcGFuJywgaUNvbHNwYW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhdyggb1NldHRpbmdzIClcblx0e1xuXHRcdC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXG5cdFx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFQcmVEcmF3ICkgIT09IC0xIClcblx0XHR7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyIGksIGlMZW4sIG47XG5cdFx0dmFyIGFuUm93cyA9IFtdO1xuXHRcdHZhciBpUm93Q291bnQgPSAwO1xuXHRcdHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHRcdHZhciBpU3RyaXBlcyA9IGFzU3RyaXBlQ2xhc3Nlcy5sZW5ndGg7XG5cdFx0dmFyIGlPcGVuUm93cyA9IG9TZXR0aW5ncy5hb09wZW5Sb3dzLmxlbmd0aDtcblx0XHR2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdHZhciBpSW5pdERpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0XHR2YXIgYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheTtcblx0XG5cdFx0b1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcblx0XG5cdFx0LyogQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZyAqL1xuXHRcdGlmICggaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IGJTZXJ2ZXJTaWRlID9cblx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQgOlxuXHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydDtcblx0XG5cdFx0XHRvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcblx0XHR9XG5cdFxuXHRcdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHRcdHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcblx0XG5cdFx0LyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xuXHRcdGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhYlNlcnZlclNpZGUgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhX2ZuQWpheFVwZGF0ZSggb1NldHRpbmdzICkgKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggYWlEaXNwbGF5Lmxlbmd0aCAhPT0gMCApXG5cdFx0e1xuXHRcdFx0dmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcblx0XG5cdFx0XHRmb3IgKCB2YXIgaj1pU3RhcnQgOyBqPGlFbmQgOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaURhdGFJbmRleCA9IGFpRGlzcGxheVtqXTtcblx0XHRcdFx0dmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbIGlEYXRhSW5kZXggXTtcblx0XHRcdFx0aWYgKCBhb0RhdGEublRyID09PSBudWxsIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9mbkNyZWF0ZVRyKCBvU2V0dGluZ3MsIGlEYXRhSW5kZXggKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0dmFyIG5Sb3cgPSBhb0RhdGEublRyO1xuXHRcblx0XHRcdFx0LyogUmVtb3ZlIHRoZSBvbGQgc3RyaXBpbmcgY2xhc3NlcyBhbmQgdGhlbiBhZGQgdGhlIG5ldyBvbmUgKi9cblx0XHRcdFx0aWYgKCBpU3RyaXBlcyAhPT0gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgc1N0cmlwZSA9IGFzU3RyaXBlQ2xhc3Nlc1sgaVJvd0NvdW50ICUgaVN0cmlwZXMgXTtcblx0XHRcdFx0XHRpZiAoIGFvRGF0YS5fc1Jvd1N0cmlwZSAhPSBzU3RyaXBlIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQkKG5Sb3cpLnJlbW92ZUNsYXNzKCBhb0RhdGEuX3NSb3dTdHJpcGUgKS5hZGRDbGFzcyggc1N0cmlwZSApO1xuXHRcdFx0XHRcdFx0YW9EYXRhLl9zUm93U3RyaXBlID0gc1N0cmlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xuXHRcdFx0XHQvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXG5cdFx0XHRcdC8vIHVzZWZ1bD9cblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgbnVsbCxcblx0XHRcdFx0XHRbblJvdywgYW9EYXRhLl9hRGF0YSwgaVJvd0NvdW50LCBqLCBpRGF0YUluZGV4XSApO1xuXHRcblx0XHRcdFx0YW5Sb3dzLnB1c2goIG5Sb3cgKTtcblx0XHRcdFx0aVJvd0NvdW50Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXQgKi9cblx0XHRcdHZhciBzWmVybyA9IG9MYW5nLnNaZXJvUmVjb3Jkcztcblx0XHRcdGlmICggb1NldHRpbmdzLmlEcmF3ID09IDEgJiYgIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdhamF4JyApXG5cdFx0XHR7XG5cdFx0XHRcdHNaZXJvID0gb0xhbmcuc0xvYWRpbmdSZWNvcmRzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9MYW5nLnNFbXB0eVRhYmxlICYmIG9TZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwIClcblx0XHRcdHtcblx0XHRcdFx0c1plcm8gPSBvTGFuZy5zRW1wdHlUYWJsZTtcblx0XHRcdH1cblx0XG5cdFx0XHRhblJvd3NbIDAgXSA9ICQoICc8dHIvPicsIHsgJ2NsYXNzJzogaVN0cmlwZXMgPyBhc1N0cmlwZUNsYXNzZXNbMF0gOiAnJyB9IClcblx0XHRcdFx0LmFwcGVuZCggJCgnPHRkIC8+Jywge1xuXHRcdFx0XHRcdCd2YWxpZ24nOiAgJ3RvcCcsXG5cdFx0XHRcdFx0J2NvbFNwYW4nOiBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSxcblx0XHRcdFx0XHQnY2xhc3MnOiAgIG9TZXR0aW5ncy5vQ2xhc3Nlcy5zUm93RW1wdHlcblx0XHRcdFx0fSApLmh0bWwoIHNaZXJvICkgKVswXTtcblx0XHR9XG5cdFxuXHRcdC8qIEhlYWRlciBhbmQgZm9vdGVyIGNhbGxiYWNrcyAqL1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICdoZWFkZXInLCBbICQob1NldHRpbmdzLm5USGVhZCkuY2hpbGRyZW4oJ3RyJylbMF0sXG5cdFx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsICdmb290ZXInLCBbICQob1NldHRpbmdzLm5URm9vdCkuY2hpbGRyZW4oJ3RyJylbMF0sXG5cdFx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cdFxuXHRcdHZhciBib2R5ID0gJChvU2V0dGluZ3MublRCb2R5KTtcblx0XG5cdFx0Ym9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xuXHRcdGJvZHkuYXBwZW5kKCAkKGFuUm93cykgKTtcblx0XG5cdFx0LyogQ2FsbCBhbGwgcmVxdWlyZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgZW5kIG9mIGEgZHJhdyAqL1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAnZHJhdycsIFtvU2V0dGluZ3NdICk7XG5cdFxuXHRcdC8qIERyYXcgaXMgY29tcGxldGUsIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBtdXN0IGJlIGFzIHdlbGwgKi9cblx0XHRvU2V0dGluZ3MuYlNvcnRlZCA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5iRmlsdGVyZWQgPSBmYWxzZTtcblx0XHRvU2V0dGluZ3MuYkRyYXdpbmcgPSBmYWxzZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2hvbGRQb3NpdGlvbl0gS2VlcCB0aGUgY3VycmVudCBwYWdpbmcgcG9zaXRpb24uIEJ5IGRlZmF1bHRcblx0ICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRcdHNvcnQgICAgID0gZmVhdHVyZXMuYlNvcnQsXG5cdFx0XHRmaWx0ZXIgICA9IGZlYXR1cmVzLmJGaWx0ZXI7XG5cdFxuXHRcdGlmICggc29ydCApIHtcblx0XHRcdF9mblNvcnQoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZpbHRlciApIHtcblx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gZmlsdGVyaW5nLCBzbyB3ZSB3YW50IHRvIGp1c3QgdXNlIHRoZSBkaXNwbGF5IG1hc3RlclxuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGhvbGRQb3NpdGlvbiAhPT0gdHJ1ZSApIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHR9XG5cdFxuXHRcdC8vIExldCBhbnkgbW9kdWxlcyBrbm93IGFib3V0IHRoZSBkcmF3IGhvbGQgcG9zaXRpb24gc3RhdGUgKHVzZWQgYnlcblx0XHQvLyBzY3JvbGxpbmcgaW50ZXJuYWxseSlcblx0XHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBob2xkUG9zaXRpb247XG5cdFxuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdHNldHRpbmdzLl9kcmF3SG9sZCA9IGZhbHNlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCB0aGUgb3B0aW9ucyB0byB0aGUgcGFnZSBIVE1MIGZvciB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkT3B0aW9uc0h0bWwgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRhYmxlID0gJChvU2V0dGluZ3MublRhYmxlKTtcblx0XHR2YXIgaG9sZGluZyA9ICQoJzxkaXYvPicpLmluc2VydEJlZm9yZSggdGFibGUgKTsgLy8gSG9sZGluZyBlbGVtZW50IGZvciBzcGVlZFxuXHRcdHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFxuXHRcdC8vIEFsbCBEYXRhVGFibGVzIGFyZSB3cmFwcGVkIGluIGEgZGl2XG5cdFx0dmFyIGluc2VydCA9ICQoJzxkaXYvPicsIHtcblx0XHRcdGlkOiAgICAgIG9TZXR0aW5ncy5zVGFibGVJZCsnX3dyYXBwZXInLFxuXHRcdFx0J2NsYXNzJzogY2xhc3Nlcy5zV3JhcHBlciArIChvU2V0dGluZ3MublRGb290ID8gJycgOiAnICcrY2xhc3Nlcy5zTm9Gb290ZXIpXG5cdFx0fSApO1xuXHRcblx0XHRvU2V0dGluZ3MubkhvbGRpbmcgPSBob2xkaW5nWzBdO1xuXHRcdG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyID0gaW5zZXJ0WzBdO1xuXHRcdG9TZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSA9IG9TZXR0aW5ncy5uVGFibGUubmV4dFNpYmxpbmc7XG5cdFxuXHRcdC8qIExvb3Agb3ZlciB0aGUgdXNlciBzZXQgcG9zaXRpb25pbmcgYW5kIHBsYWNlIHRoZSBlbGVtZW50cyBhcyBuZWVkZWQgKi9cblx0XHR2YXIgYURvbSA9IG9TZXR0aW5ncy5zRG9tLnNwbGl0KCcnKTtcblx0XHR2YXIgZmVhdHVyZU5vZGUsIGNPcHRpb24sIG5OZXdOb2RlLCBjTmV4dCwgc0F0dHIsIGo7XG5cdFx0Zm9yICggdmFyIGk9MCA7IGk8YURvbS5sZW5ndGggOyBpKysgKVxuXHRcdHtcblx0XHRcdGZlYXR1cmVOb2RlID0gbnVsbDtcblx0XHRcdGNPcHRpb24gPSBhRG9tW2ldO1xuXHRcblx0XHRcdGlmICggY09wdGlvbiA9PSAnPCcgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBOZXcgY29udGFpbmVyIGRpdiAqL1xuXHRcdFx0XHRuTmV3Tm9kZSA9ICQoJzxkaXYvPicpWzBdO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBhcHBlbmQgYW4gaWQgYW5kL29yIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyICovXG5cdFx0XHRcdGNOZXh0ID0gYURvbVtpKzFdO1xuXHRcdFx0XHRpZiAoIGNOZXh0ID09IFwiJ1wiIHx8IGNOZXh0ID09ICdcIicgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c0F0dHIgPSBcIlwiO1xuXHRcdFx0XHRcdGogPSAyO1xuXHRcdFx0XHRcdHdoaWxlICggYURvbVtpK2pdICE9IGNOZXh0IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciArPSBhRG9tW2kral07XG5cdFx0XHRcdFx0XHRqKys7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvKiBSZXBsYWNlIGpRdWVyeSBVSSBjb25zdGFudHMgQHRvZG8gZGVwcmVjaWF0ZWQgKi9cblx0XHRcdFx0XHRpZiAoIHNBdHRyID09IFwiSFwiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUhlYWRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyID09IFwiRlwiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUZvb3Rlcjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIFRoZSBhdHRyaWJ1dGUgY2FuIGJlIGluIHRoZSBmb3JtYXQgb2YgXCIjaWQuY2xhc3NcIiwgXCIjaWRcIiBvciBcImNsYXNzXCIgVGhpcyBsb2dpY1xuXHRcdFx0XHRcdCAqIGJyZWFrcyB0aGUgc3RyaW5nIGludG8gcGFydHMgYW5kIGFwcGxpZXMgdGhlbSBhcyBuZWVkZWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpZiAoIHNBdHRyLmluZGV4T2YoJy4nKSAhPSAtMSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGFTcGxpdCA9IHNBdHRyLnNwbGl0KCcuJyk7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IGFTcGxpdFswXS5zdWJzdHIoMSwgYVNwbGl0WzBdLmxlbmd0aC0xKTtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmNsYXNzTmFtZSA9IGFTcGxpdFsxXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyLmNoYXJBdCgwKSA9PSBcIiNcIiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuaWQgPSBzQXR0ci5zdWJzdHIoMSwgc0F0dHIubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuY2xhc3NOYW1lID0gc0F0dHI7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpICs9IGo7IC8qIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5ICovXG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGluc2VydC5hcHBlbmQoIG5OZXdOb2RlICk7XG5cdFx0XHRcdGluc2VydCA9ICQobk5ld05vZGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJz4nIClcblx0XHRcdHtcblx0XHRcdFx0LyogRW5kIGNvbnRhaW5lciBkaXYgKi9cblx0XHRcdFx0aW5zZXJ0ID0gaW5zZXJ0LnBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQHRvZG8gTW92ZSBvcHRpb25zIGludG8gdGhlaXIgb3duIHBsdWdpbnM/XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnbCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlICYmIGZlYXR1cmVzLmJMZW5ndGhDaGFuZ2UgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBMZW5ndGggKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbExlbmd0aCggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnZicgJiYgZmVhdHVyZXMuYkZpbHRlciApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEZpbHRlciAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sRmlsdGVyKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdyJyAmJiBmZWF0dXJlcy5iUHJvY2Vzc2luZyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIHBSb2Nlc3NpbmcgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3QnIClcblx0XHRcdHtcblx0XHRcdFx0LyogVGFibGUgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFRhYmxlKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICAnaScgJiYgZmVhdHVyZXMuYkluZm8gKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBJbmZvICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxJbmZvKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdwJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBQYWdpbmF0aW9uICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFBsdWctaW4gZmVhdHVyZXMgKi9cblx0XHRcdFx0dmFyIGFvRmVhdHVyZXMgPSBEYXRhVGFibGUuZXh0LmZlYXR1cmU7XG5cdFx0XHRcdGZvciAoIHZhciBrPTAsIGtMZW49YW9GZWF0dXJlcy5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCBjT3B0aW9uID09IGFvRmVhdHVyZXNba10uY0ZlYXR1cmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZlYXR1cmVOb2RlID0gYW9GZWF0dXJlc1trXS5mbkluaXQoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQWRkIHRvIHRoZSAyRCBmZWF0dXJlcyBhcnJheSAqL1xuXHRcdFx0aWYgKCBmZWF0dXJlTm9kZSApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBhYW5GZWF0dXJlcyA9IG9TZXR0aW5ncy5hYW5GZWF0dXJlcztcblx0XG5cdFx0XHRcdGlmICggISBhYW5GZWF0dXJlc1tjT3B0aW9uXSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXSA9IFtdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXS5wdXNoKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0XHRpbnNlcnQuYXBwZW5kKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogQnVpbHQgb3VyIERPTSBzdHJ1Y3R1cmUgLSByZXBsYWNlIHRoZSBob2xkaW5nIGRpdiB3aXRoIHdoYXQgd2Ugd2FudCAqL1xuXHRcdGhvbGRpbmcucmVwbGFjZVdpdGgoIGluc2VydCApO1xuXHRcdG9TZXR0aW5ncy5uSG9sZGluZyA9IG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXNlIHRoZSBET00gc291cmNlIHRvIGNyZWF0ZSB1cCBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbHMuIFRoZSBpZGVhIGhlcmUgaXMgdG9cblx0ICogY3JlYXRlIGEgbGF5b3V0IGdyaWQgKGFycmF5KSBvZiByb3dzIHggY29sdW1ucywgd2hpY2ggY29udGFpbnMgYSByZWZlcmVuY2Vcblx0ICogdG8gdGhlIGNlbGwgdGhhdCB0aGF0IHBvaW50IGluIHRoZSBncmlkIChyZWdhcmRsZXNzIG9mIGNvbC9yb3dzcGFuKSwgc3VjaCB0aGF0XG5cdCAqIGFueSBjb2x1bW4gLyByb3cgY291bGQgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBncmlkIGNvbnN0cnVjdGVkXG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdH0gYUxheW91dCBBcnJheSB0byBzdG9yZSB0aGUgY2FsY3VsYXRlZCBsYXlvdXQgaW5cblx0ICogIEBwYXJhbSB7bm9kZX0gblRoZWFkIFRoZSBoZWFkZXIvZm9vdGVyIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZXRlY3RIZWFkZXIgKCBhTGF5b3V0LCBuVGhlYWQgKVxuXHR7XG5cdFx0dmFyIG5UcnMgPSAkKG5UaGVhZCkuY2hpbGRyZW4oJ3RyJyk7XG5cdFx0dmFyIG5UciwgbkNlbGw7XG5cdFx0dmFyIGksIGssIGwsIGlMZW4sIGpMZW4sIGlDb2xTaGlmdGVkLCBpQ29sdW1uLCBpQ29sc3BhbiwgaVJvd3NwYW47XG5cdFx0dmFyIGJVbmlxdWU7XG5cdFx0dmFyIGZuU2hpZnRDb2wgPSBmdW5jdGlvbiAoIGEsIGksIGogKSB7XG5cdFx0XHR2YXIgayA9IGFbaV07XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoIGtbal0gKSB7XG5cdFx0XHRcdGorKztcblx0XHRcdH1cblx0XHRcdHJldHVybiBqO1xuXHRcdH07XG5cdFxuXHRcdGFMYXlvdXQuc3BsaWNlKCAwLCBhTGF5b3V0Lmxlbmd0aCApO1xuXHRcblx0XHQvKiBXZSBrbm93IGhvdyBtYW55IHJvd3MgdGhlcmUgYXJlIGluIHRoZSBsYXlvdXQgLSBzbyBwcmVwIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPW5UcnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRhTGF5b3V0LnB1c2goIFtdICk7XG5cdFx0fVxuXHRcblx0XHQvKiBDYWxjdWxhdGUgYSBsYXlvdXQgYXJyYXkgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49blRycy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdG5UciA9IG5UcnNbaV07XG5cdFx0XHRpQ29sdW1uID0gMDtcblx0XG5cdFx0XHQvKiBGb3IgZXZlcnkgY2VsbCBpbiB0aGUgcm93Li4uICovXG5cdFx0XHRuQ2VsbCA9IG5Uci5maXJzdENoaWxkO1xuXHRcdFx0d2hpbGUgKCBuQ2VsbCApIHtcblx0XHRcdFx0aWYgKCBuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVERcIiB8fFxuXHRcdFx0XHQgICAgIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJUSFwiIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIEdldCB0aGUgY29sIGFuZCByb3dzcGFuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgRE9NIGFuZCBzYW5pdGlzZSB0aGVtICovXG5cdFx0XHRcdFx0aUNvbHNwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XG5cdFx0XHRcdFx0aVJvd3NwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSAqIDE7XG5cdFx0XHRcdFx0aUNvbHNwYW4gPSAoIWlDb2xzcGFuIHx8IGlDb2xzcGFuPT09MCB8fCBpQ29sc3Bhbj09PTEpID8gMSA6IGlDb2xzcGFuO1xuXHRcdFx0XHRcdGlSb3dzcGFuID0gKCFpUm93c3BhbiB8fCBpUm93c3Bhbj09PTAgfHwgaVJvd3NwYW49PT0xKSA/IDEgOiBpUm93c3Bhbjtcblx0XG5cdFx0XHRcdFx0LyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XG5cdFx0XHRcdFx0ICogYWNjb3JkaW5nbHlcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woIGFMYXlvdXQsIGksIGlDb2x1bW4gKTtcblx0XG5cdFx0XHRcdFx0LyogQ2FjaGUgY2FsY3VsYXRpb24gZm9yIHVuaXF1ZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0YlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xuXHRcblx0XHRcdFx0XHQvKiBJZiB0aGVyZSBpcyBjb2wgLyByb3dzcGFuLCBjb3B5IHRoZSBpbmZvcm1hdGlvbiBpbnRvIHRoZSBsYXlvdXQgZ3JpZCAqL1xuXHRcdFx0XHRcdGZvciAoIGw9MCA7IGw8aUNvbHNwYW4gOyBsKysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8aVJvd3NwYW4gOyBrKysgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRhTGF5b3V0W2kra11baUNvbFNoaWZ0ZWQrbF0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0XCJjZWxsXCI6IG5DZWxsLFxuXHRcdFx0XHRcdFx0XHRcdFwidW5pcXVlXCI6IGJVbmlxdWVcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YUxheW91dFtpK2tdLm5UciA9IG5Ucjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bkNlbGwgPSBuQ2VsbC5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIHVuaXF1ZSB0aCBlbGVtZW50cywgb25lIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuSGVhZGVyIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBsYXlvdXQgZnJvbSB0aGlzIG5vZGUgLSBvcHRpb25hbFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYUxheW91dCB0aGVhZC90Zm9vdCBsYXlvdXQgZnJvbSBfZm5EZXRlY3RIZWFkZXIgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMgYXJyYXkge25vZGV9IGFSZXR1cm4gbGlzdCBvZiB1bmlxdWUgdGgnc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRVbmlxdWVUaHMgKCBvU2V0dGluZ3MsIG5IZWFkZXIsIGFMYXlvdXQgKVxuXHR7XG5cdFx0dmFyIGFSZXR1cm4gPSBbXTtcblx0XHRpZiAoICFhTGF5b3V0IClcblx0XHR7XG5cdFx0XHRhTGF5b3V0ID0gb1NldHRpbmdzLmFvSGVhZGVyO1xuXHRcdFx0aWYgKCBuSGVhZGVyIClcblx0XHRcdHtcblx0XHRcdFx0YUxheW91dCA9IFtdO1xuXHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIGFMYXlvdXQsIG5IZWFkZXIgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YUxheW91dC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49YUxheW91dFtpXS5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIGFMYXlvdXRbaV1bal0udW5pcXVlICYmXG5cdFx0XHRcdFx0ICghYVJldHVybltqXSB8fCAhb1NldHRpbmdzLmJTb3J0Q2VsbHNUb3ApIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFSZXR1cm5bal0gPSBhTGF5b3V0W2ldW2pdLmNlbGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhUmV0dXJuO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGFuIEFqYXggY2FsbCBiYXNlZCBvbiB0aGUgdGFibGUncyBzZXR0aW5ncywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0XG5cdCAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxuXHQgKiAgICAgRGF0YVRhYmxlcyAtIG1heSBiZSBhdWdtZW50ZWQgYnkgZGV2ZWxvcGVyIGNhbGxiYWNrc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiBkYXRhIGlzIG9idGFpbmVkXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEFqYXgoIG9TZXR0aW5ncywgZGF0YSwgZm4gKVxuXHR7XG5cdFx0Ly8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0sIGFsbG93IGZuU2VydmVyRGF0YSBhbmQgZXZlbnQgdG8gbWFuaXB1bGF0ZVxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9TZXJ2ZXJQYXJhbXMnLCAnc2VydmVyUGFyYW1zJywgW2RhdGFdICk7XG5cdFxuXHRcdC8vIENvbnZlcnQgdG8gb2JqZWN0IGJhc2VkIGZvciAxLjEwKyBpZiB1c2luZyB0aGUgb2xkIGFycmF5IHNjaGVtZSB3aGljaCBjYW5cblx0XHQvLyBjb21lIGZyb20gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBvciBzZXJ2ZXJQYXJhbXNcblx0XHRpZiAoIGRhdGEgJiYgQXJyYXkuaXNBcnJheShkYXRhKSApIHtcblx0XHRcdHZhciB0bXAgPSB7fTtcblx0XHRcdHZhciByYnJhY2tldCA9IC8oLio/KVxcW1xcXSQvO1xuXHRcblx0XHRcdCQuZWFjaCggZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRcdHZhciBtYXRjaCA9IHZhbC5uYW1lLm1hdGNoKHJicmFja2V0KTtcblx0XG5cdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXlzXG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBtYXRjaFswXTtcblx0XG5cdFx0XHRcdFx0aWYgKCAhIHRtcFsgbmFtZSBdICkge1xuXHRcdFx0XHRcdFx0dG1wWyBuYW1lIF0gPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG1wWyBuYW1lIF0ucHVzaCggdmFsLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dG1wW3ZhbC5uYW1lXSA9IHZhbC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0ZGF0YSA9IHRtcDtcblx0XHR9XG5cdFxuXHRcdHZhciBhamF4RGF0YTtcblx0XHR2YXIgYWpheCA9IG9TZXR0aW5ncy5hamF4O1xuXHRcdHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XG5cdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBqc29uLCBvU2V0dGluZ3MuanFYSFJdICk7XG5cdFx0XHRmbigganNvbiApO1xuXHRcdH07XG5cdFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBhamF4ICkgJiYgYWpheC5kYXRhIClcblx0XHR7XG5cdFx0XHRhamF4RGF0YSA9IGFqYXguZGF0YTtcblx0XG5cdFx0XHR2YXIgbmV3RGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdGFqYXhEYXRhKCBkYXRhLCBvU2V0dGluZ3MgKSA6ICAvLyBmbiBjYW4gbWFuaXB1bGF0ZSBkYXRhIG9yIHJldHVyblxuXHRcdFx0XHRhamF4RGF0YTsgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9iamVjdCBvciBhcnJheSB0byBtZXJnZVxuXHRcblx0XHRcdC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXG5cdFx0XHRkYXRhID0gdHlwZW9mIGFqYXhEYXRhID09PSAnZnVuY3Rpb24nICYmIG5ld0RhdGEgP1xuXHRcdFx0XHRuZXdEYXRhIDpcblx0XHRcdFx0JC5leHRlbmQoIHRydWUsIGRhdGEsIG5ld0RhdGEgKTtcblx0XG5cdFx0XHQvLyBSZW1vdmUgdGhlIGRhdGEgcHJvcGVydHkgYXMgd2UndmUgcmVzb2x2ZWQgaXQgYWxyZWFkeSBhbmQgZG9uJ3Qgd2FudFxuXHRcdFx0Ly8galF1ZXJ5IHRvIGRvIGl0IGFnYWluIChpdCBpcyByZXN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbilcblx0XHRcdGRlbGV0ZSBhamF4LmRhdGE7XG5cdFx0fVxuXHRcblx0XHR2YXIgYmFzZUFqYXggPSB7XG5cdFx0XHRcImRhdGFcIjogZGF0YSxcblx0XHRcdFwic3VjY2Vzc1wiOiBmdW5jdGlvbiAoanNvbikge1xuXHRcdFx0XHR2YXIgZXJyb3IgPSBqc29uLmVycm9yIHx8IGpzb24uc0Vycm9yO1xuXHRcdFx0XHRpZiAoIGVycm9yICkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCBlcnJvciApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRvU2V0dGluZ3MuanNvbiA9IGpzb247XG5cdFx0XHRcdGNhbGxiYWNrKCBqc29uICk7XG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhVHlwZVwiOiBcImpzb25cIixcblx0XHRcdFwiY2FjaGVcIjogZmFsc2UsXG5cdFx0XHRcInR5cGVcIjogb1NldHRpbmdzLnNTZXJ2ZXJNZXRob2QsXG5cdFx0XHRcImVycm9yXCI6IGZ1bmN0aW9uICh4aHIsIGVycm9yLCB0aHJvd24pIHtcblx0XHRcdFx0dmFyIHJldCA9IF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywgbnVsbCwgb1NldHRpbmdzLmpxWEhSXSApO1xuXHRcblx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIHRydWUsIHJldCApID09PSAtMSApIHtcblx0XHRcdFx0XHRpZiAoIGVycm9yID09IFwicGFyc2VyZXJyb3JcIiApIHtcblx0XHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW52YWxpZCBKU09OIHJlc3BvbnNlJywgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cdFx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0FqYXggZXJyb3InLCA3ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdC8vIFN0b3JlIHRoZSBkYXRhIHN1Ym1pdHRlZCBmb3IgdGhlIEFQSVxuXHRcdG9TZXR0aW5ncy5vQWpheERhdGEgPSBkYXRhO1xuXHRcblx0XHQvLyBBbGxvdyBwbHVnLWlucyBhbmQgZXh0ZXJuYWwgcHJvY2Vzc2VzIHRvIG1vZGlmeSB0aGUgZGF0YVxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAncHJlWGhyJywgW29TZXR0aW5ncywgZGF0YV0gKTtcblx0XG5cdFx0aWYgKCBvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhIClcblx0XHR7XG5cdFx0XHQvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxuXHRcdFx0b1NldHRpbmdzLmZuU2VydmVyRGF0YS5jYWxsKCBpbnN0YW5jZSxcblx0XHRcdFx0b1NldHRpbmdzLnNBamF4U291cmNlLFxuXHRcdFx0XHQkLm1hcCggZGF0YSwgZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIE5lZWQgdG8gY29udmVydCBiYWNrIHRvIDEuOSB0cmFkIGZvcm1hdFxuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGtleSwgdmFsdWU6IHZhbCB9O1xuXHRcdFx0XHR9ICksXG5cdFx0XHRcdGNhbGxiYWNrLFxuXHRcdFx0XHRvU2V0dGluZ3Ncblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvU2V0dGluZ3Muc0FqYXhTb3VyY2UgfHwgdHlwZW9mIGFqYXggPT09ICdzdHJpbmcnIClcblx0XHR7XG5cdFx0XHQvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxuXHRcdFx0b1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCAkLmV4dGVuZCggYmFzZUFqYXgsIHtcblx0XHRcdFx0dXJsOiBhamF4IHx8IG9TZXR0aW5ncy5zQWpheFNvdXJjZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgYWpheCA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0Ly8gSXMgYSBmdW5jdGlvbiAtIGxldCB0aGUgY2FsbGVyIGRlZmluZSB3aGF0IG5lZWRzIHRvIGJlIGRvbmVcblx0XHRcdG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbCggaW5zdGFuY2UsIGRhdGEsIGNhbGxiYWNrLCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8vIE9iamVjdCB0byBleHRlbmQgdGhlIGJhc2Ugc2V0dGluZ3Ncblx0XHRcdG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCggJC5leHRlbmQoIGJhc2VBamF4LCBhamF4ICkgKTtcblx0XG5cdFx0XHQvLyBSZXN0b3JlIGZvciBuZXh0IHRpbWUgYXJvdW5kXG5cdFx0XHRhamF4LmRhdGEgPSBhamF4RGF0YTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIHRoZSB0YWJsZSB1c2luZyBhbiBBamF4IGNhbGxcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IEJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4VXBkYXRlKCBzZXR0aW5ncyApXG5cdHtcblx0XHRpZiAoIHNldHRpbmdzLmJBamF4RGF0YUdldCApIHtcblx0XHRcdHNldHRpbmdzLmlEcmF3Kys7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHRfZm5CdWlsZEFqYXgoXG5cdFx0XHRcdHNldHRpbmdzLFxuXHRcdFx0XHRfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKSxcblx0XHRcdFx0ZnVuY3Rpb24oanNvbikge1xuXHRcdFx0XHRcdF9mbkFqYXhVcGRhdGVEcmF3KCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnVpbGQgdXAgdGhlIHBhcmFtZXRlcnMgaW4gYW4gb2JqZWN0IG5lZWRlZCBmb3IgYSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdCAqIHJlcXVlc3QuIE5vdGUgdGhhdCB0aGlzIGlzIGJhc2ljYWxseSBkb25lIHR3aWNlLCBpcyBkaWZmZXJlbnQgd2F5cyAtIGEgbW9kZXJuXG5cdCAqIG1ldGhvZCB3aGljaCBpcyB1c2VkIGJ5IGRlZmF1bHQgaW4gRGF0YVRhYmxlcyAxLjEwIHdoaWNoIHVzZXMgb2JqZWN0cyBhbmRcblx0ICogYXJyYXlzLCBvciB0aGUgMS45LSBtZXRob2Qgd2l0aCBpcyBuYW1lIC8gdmFsdWUgcGFpcnMuIDEuOSBtZXRob2QgaXMgdXNlZCBpZlxuXHQgKiB0aGUgc0FqYXhTb3VyY2Ugb3B0aW9uIGlzIHVzZWQgaW4gdGhlIGluaXRpYWxpc2F0aW9uLCBvciB0aGUgbGVnYWN5QWpheFxuXHQgKiBvcHRpb24gaXMgc2V0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Jvb2x9IGJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0Y29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdFx0cHJlU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLFxuXHRcdFx0cHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxuXHRcdFx0aSwgZGF0YSA9IFtdLCBkYXRhUHJvcCwgY29sdW1uLCBjb2x1bW5TZWFyY2gsXG5cdFx0XHRzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICksXG5cdFx0XHRkaXNwbGF5U3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGRpc3BsYXlMZW5ndGggPSBmZWF0dXJlcy5iUGFnaW5hdGUgIT09IGZhbHNlID9cblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdFx0LTE7XG5cdFxuXHRcdHZhciBwYXJhbSA9IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRkYXRhLnB1c2goIHsgJ25hbWUnOiBuYW1lLCAndmFsdWUnOiB2YWx1ZSB9ICk7XG5cdFx0fTtcblx0XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGlibGUgbWV0aG9kXG5cdFx0cGFyYW0oICdzRWNobycsICAgICAgICAgIHNldHRpbmdzLmlEcmF3ICk7XG5cdFx0cGFyYW0oICdpQ29sdW1ucycsICAgICAgIGNvbHVtbkNvdW50ICk7XG5cdFx0cGFyYW0oICdzQ29sdW1ucycsICAgICAgIF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApLmpvaW4oJywnKSApO1xuXHRcdHBhcmFtKCAnaURpc3BsYXlTdGFydCcsICBkaXNwbGF5U3RhcnQgKTtcblx0XHRwYXJhbSggJ2lEaXNwbGF5TGVuZ3RoJywgZGlzcGxheUxlbmd0aCApO1xuXHRcblx0XHQvLyBEYXRhVGFibGVzIDEuMTArIG1ldGhvZFxuXHRcdHZhciBkID0ge1xuXHRcdFx0ZHJhdzogICAgc2V0dGluZ3MuaURyYXcsXG5cdFx0XHRjb2x1bW5zOiBbXSxcblx0XHRcdG9yZGVyOiAgIFtdLFxuXHRcdFx0c3RhcnQ6ICAgZGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuZ3RoOiAgZGlzcGxheUxlbmd0aCxcblx0XHRcdHNlYXJjaDogIHtcblx0XHRcdFx0dmFsdWU6IHByZVNlYXJjaC5zU2VhcmNoLFxuXHRcdFx0XHRyZWdleDogcHJlU2VhcmNoLmJSZWdleFxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGZvciAoIGk9MCA7IGk8Y29sdW1uQ291bnQgOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0Y29sdW1uU2VhcmNoID0gcHJlQ29sU2VhcmNoW2ldO1xuXHRcdFx0ZGF0YVByb3AgPSB0eXBlb2YgY29sdW1uLm1EYXRhPT1cImZ1bmN0aW9uXCIgPyAnZnVuY3Rpb24nIDogY29sdW1uLm1EYXRhIDtcblx0XG5cdFx0XHRkLmNvbHVtbnMucHVzaCgge1xuXHRcdFx0XHRkYXRhOiAgICAgICBkYXRhUHJvcCxcblx0XHRcdFx0bmFtZTogICAgICAgY29sdW1uLnNOYW1lLFxuXHRcdFx0XHRzZWFyY2hhYmxlOiBjb2x1bW4uYlNlYXJjaGFibGUsXG5cdFx0XHRcdG9yZGVyYWJsZTogIGNvbHVtbi5iU29ydGFibGUsXG5cdFx0XHRcdHNlYXJjaDogICAgIHtcblx0XHRcdFx0XHR2YWx1ZTogY29sdW1uU2VhcmNoLnNTZWFyY2gsXG5cdFx0XHRcdFx0cmVnZXg6IGNvbHVtblNlYXJjaC5iUmVnZXhcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHBhcmFtKCBcIm1EYXRhUHJvcF9cIitpLCBkYXRhUHJvcCApO1xuXHRcblx0XHRcdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0cGFyYW0oICdzU2VhcmNoXycraSwgICAgIGNvbHVtblNlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdHBhcmFtKCAnYlJlZ2V4XycraSwgICAgICBjb2x1bW5TZWFyY2guYlJlZ2V4ICk7XG5cdFx0XHRcdHBhcmFtKCAnYlNlYXJjaGFibGVfJytpLCBjb2x1bW4uYlNlYXJjaGFibGUgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRwYXJhbSggJ2JTb3J0YWJsZV8nK2ksIGNvbHVtbi5iU29ydGFibGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdHBhcmFtKCAnc1NlYXJjaCcsIHByZVNlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRwYXJhbSggJ2JSZWdleCcsIHByZVNlYXJjaC5iUmVnZXggKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHQkLmVhY2goIHNvcnQsIGZ1bmN0aW9uICggaSwgdmFsICkge1xuXHRcdFx0XHRkLm9yZGVyLnB1c2goIHsgY29sdW1uOiB2YWwuY29sLCBkaXI6IHZhbC5kaXIgfSApO1xuXHRcblx0XHRcdFx0cGFyYW0oICdpU29ydENvbF8nK2ksIHZhbC5jb2wgKTtcblx0XHRcdFx0cGFyYW0oICdzU29ydERpcl8nK2ksIHZhbC5kaXIgKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRwYXJhbSggJ2lTb3J0aW5nQ29scycsIHNvcnQubGVuZ3RoICk7XG5cdFx0fVxuXHRcblx0XHQvLyBJZiB0aGUgbGVnYWN5LmFqYXggcGFyYW1ldGVyIGlzIG51bGwsIHRoZW4gd2UgYXV0b21hdGljYWxseSBkZWNpZGUgd2hpY2hcblx0XHQvLyBmb3JtIHRvIHVzZSwgYmFzZWQgb24gc0FqYXhTb3VyY2Vcblx0XHR2YXIgbGVnYWN5ID0gRGF0YVRhYmxlLmV4dC5sZWdhY3kuYWpheDtcblx0XHRpZiAoIGxlZ2FjeSA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5zQWpheFNvdXJjZSA/IGRhdGEgOiBkO1xuXHRcdH1cblx0XG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBsZWdhY3kgaGFzIGJlZW4gc3BlY2lmaWVkIHRoZW4gd2UgdXNlIHRoYXQgdG8gZGVjaWRlIG9uIHRoZVxuXHRcdC8vIGZvcm1cblx0XHRyZXR1cm4gbGVnYWN5ID8gZGF0YSA6IGQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24ganNvbiBkYXRhIHJldHVybiBmcm9tIHRoZSBzZXJ2ZXIuXG5cdCAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXG5cdCAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsRGlzcGxheVJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcgKCBzZXR0aW5ncywganNvbiApXG5cdHtcblx0XHQvLyB2MS4xMCB1c2VzIGNhbWVsQ2FzZSB2YXJpYWJsZXMsIHdoaWxlIDEuOSB1c2VzIEh1bmdhcmlhbiBub3RhdGlvbi5cblx0XHQvLyBTdXBwb3J0IGJvdGhcblx0XHR2YXIgY29tcGF0ID0gZnVuY3Rpb24gKCBvbGQsIG1vZGVybiApIHtcblx0XHRcdHJldHVybiBqc29uW29sZF0gIT09IHVuZGVmaW5lZCA/IGpzb25bb2xkXSA6IGpzb25bbW9kZXJuXTtcblx0XHR9O1xuXHRcblx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdHZhciBkcmF3ICAgICAgICAgICAgPSBjb21wYXQoICdzRWNobycsICAgICAgICAgICAgICAgICdkcmF3JyApO1xuXHRcdHZhciByZWNvcmRzVG90YWwgICAgPSBjb21wYXQoICdpVG90YWxSZWNvcmRzJywgICAgICAgICdyZWNvcmRzVG90YWwnICk7XG5cdFx0dmFyIHJlY29yZHNGaWx0ZXJlZCA9IGNvbXBhdCggJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcgKTtcblx0XG5cdFx0aWYgKCBkcmF3ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBQcm90ZWN0IGFnYWluc3Qgb3V0IG9mIHNlcXVlbmNlIHJldHVybnNcblx0XHRcdGlmICggZHJhdyoxIDwgc2V0dGluZ3MuaURyYXcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNldHRpbmdzLmlEcmF3ID0gZHJhdyAqIDE7XG5cdFx0fVxuXHRcblx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdHNldHRpbmdzLl9pUmVjb3Jkc1RvdGFsICAgPSBwYXJzZUludChyZWNvcmRzVG90YWwsIDEwKTtcblx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gcGFyc2VJbnQocmVjb3Jkc0ZpbHRlcmVkLCAxMCk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHR9XG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFxuXHRcdHNldHRpbmdzLmJBamF4RGF0YUdldCA9IGZhbHNlO1xuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdGlmICggISBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSApIHtcblx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MsIGpzb24gKTtcblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLmJBamF4RGF0YUdldCA9IHRydWU7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBKU09OIGRhdGEgc291cmNlIHRvIHVzZSBmb3IgZHJhd2luZyBhIHRhYmxlLiBVc2luZ1xuXHQgKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXG5cdCAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxuXHQgKiAgQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGRhdGEgdG8gdXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4RGF0YVNyYyAoIG9TZXR0aW5ncywganNvbiApXG5cdHtcblx0XHR2YXIgZGF0YVNyYyA9ICQuaXNQbGFpbk9iamVjdCggb1NldHRpbmdzLmFqYXggKSAmJiBvU2V0dGluZ3MuYWpheC5kYXRhU3JjICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0b1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XG5cdFx0XHRvU2V0dGluZ3Muc0FqYXhEYXRhUHJvcDsgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0uXG5cdFxuXHRcdC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLiBJbiBvcmRlciB0byByZWFkIGZyb20gYWFEYXRhLCBjaGVjayBpZiB0aGVcblx0XHQvLyBkZWZhdWx0IGhhcyBiZWVuIGNoYW5nZWQsIGlmIG5vdCwgY2hlY2sgZm9yIGFhRGF0YVxuXHRcdGlmICggZGF0YVNyYyA9PT0gJ2RhdGEnICkge1xuXHRcdFx0cmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVNyY107XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gZGF0YVNyYyAhPT0gXCJcIiA/XG5cdFx0XHRfZm5HZXRPYmplY3REYXRhRm4oIGRhdGFTcmMgKSgganNvbiApIDpcblx0XHRcdGpzb247XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZmlsdGVyaW5nIHRleHRcblx0ICogIEByZXR1cm5zIHtub2RlfSBGaWx0ZXIgY29udHJvbCBlbGVtZW50XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sRmlsdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkO1xuXHRcdHZhciBsYW5ndWFnZSA9IHNldHRpbmdzLm9MYW5ndWFnZTtcblx0XHR2YXIgcHJldmlvdXNTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cdFx0dmFyIGlucHV0ID0gJzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInK2NsYXNzZXMuc0ZpbHRlcklucHV0KydcIi8+Jztcblx0XG5cdFx0dmFyIHN0ciA9IGxhbmd1YWdlLnNTZWFyY2g7XG5cdFx0c3RyID0gc3RyLm1hdGNoKC9fSU5QVVRfLykgP1xuXHRcdFx0c3RyLnJlcGxhY2UoJ19JTlBVVF8nLCBpbnB1dCkgOlxuXHRcdFx0c3RyK2lucHV0O1xuXHRcblx0XHR2YXIgZmlsdGVyID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnaWQnOiAhIGZlYXR1cmVzLmYgPyB0YWJsZUlkKydfZmlsdGVyJyA6IG51bGwsXG5cdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc0ZpbHRlclxuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKCAkKCc8bGFiZWwvPicgKS5hcHBlbmQoIHN0ciApICk7XG5cdFxuXHRcdHZhciBzZWFyY2hGbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogVXBkYXRlIGFsbCBvdGhlciBmaWx0ZXIgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSBuZXcgZGlzcGxheSAqL1xuXHRcdFx0dmFyIG4gPSBmZWF0dXJlcy5mO1xuXHRcdFx0dmFyIHZhbCA9ICF0aGlzLnZhbHVlID8gXCJcIiA6IHRoaXMudmFsdWU7IC8vIG1lbnRhbCBJRTggZml4IDotKFxuXHRcblx0XHRcdC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXG5cdFx0XHRpZiAoIHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICkge1xuXHRcdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHtcblx0XHRcdFx0XHRcInNTZWFyY2hcIjogdmFsLFxuXHRcdFx0XHRcdFwiYlJlZ2V4XCI6IHByZXZpb3VzU2VhcmNoLmJSZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiBwcmV2aW91c1NlYXJjaC5iU21hcnQgLFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBwcmV2aW91c1NlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gcmVkcmF3LCB3aXRob3V0IHJlc29ydGluZ1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0dmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuXHRcdFx0c2V0dGluZ3Muc2VhcmNoRGVsYXkgOlxuXHRcdFx0X2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCcgP1xuXHRcdFx0XHQ0MDAgOlxuXHRcdFx0XHQwO1xuXHRcblx0XHR2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcblx0XHRcdC52YWwoIHByZXZpb3VzU2VhcmNoLnNTZWFyY2ggKVxuXHRcdFx0LmF0dHIoICdwbGFjZWhvbGRlcicsIGxhbmd1YWdlLnNTZWFyY2hQbGFjZWhvbGRlciApXG5cdFx0XHQub24oXG5cdFx0XHRcdCdrZXl1cC5EVCBzZWFyY2guRFQgaW5wdXQuRFQgcGFzdGUuRFQgY3V0LkRUJyxcblx0XHRcdFx0c2VhcmNoRGVsYXkgP1xuXHRcdFx0XHRcdF9mblRocm90dGxlKCBzZWFyY2hGbiwgc2VhcmNoRGVsYXkgKSA6XG5cdFx0XHRcdFx0c2VhcmNoRm5cblx0XHRcdClcblx0XHRcdC5vbiggJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdC8vIEVkZ2UgZml4ISBFZGdlIDE3IGRvZXMgbm90IHRyaWdnZXIgYW55dGhpbmcgb3RoZXIgdGhhbiBtb3VzZSBldmVudHMgd2hlbiBjbGlja2luZ1xuXHRcdFx0XHQvLyBvbiB0aGUgY2xlYXIgaWNvbiAoRWRnZSBidWcgMTc1ODQ1MTUpLiBUaGlzIGlzIHNhZmUgaW4gb3RoZXIgYnJvd3NlcnMgYXMgYHNlYXJjaEZuYFxuXHRcdFx0XHQvLyBjaGVja3MgdGhlIHZhbHVlIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZC4gSW4gb3RoZXIgYnJvd3NlcnMgaXQgd29uJ3QgaGF2ZS5cblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlYXJjaEZuLmNhbGwoanFGaWx0ZXJbMF0pO1xuXHRcdFx0XHR9LCAxMCk7XG5cdFx0XHR9IClcblx0XHRcdC5vbiggJ2tleXByZXNzLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xuXHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PSAxMyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0LmF0dHIoJ2FyaWEtY29udHJvbHMnLCB0YWJsZUlkKTtcblx0XG5cdFx0Ly8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdzZWFyY2guZHQuRFQnLCBmdW5jdGlvbiAoIGV2LCBzICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0Ly8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXG5cdFx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuLi5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIGpxRmlsdGVyWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0anFGaWx0ZXIudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gZmlsdGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgdXNpbmcgYm90aCB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgY29sdW1uIGJhc2VkIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZWFyY2ggc2VhcmNoIGluZm9ybWF0aW9uXG5cdCAqICBAcGFyYW0ge2ludH0gW2lGb3JjZV0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZSAoIG9TZXR0aW5ncywgb0lucHV0LCBpRm9yY2UgKVxuXHR7XG5cdFx0dmFyIG9QcmV2U2VhcmNoID0gb1NldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcblx0XHR2YXIgYW9QcmV2U2VhcmNoID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0XHR2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKCBvRmlsdGVyICkge1xuXHRcdFx0LyogU2F2ZSB0aGUgZmlsdGVyaW5nIHZhbHVlcyAqL1xuXHRcdFx0b1ByZXZTZWFyY2guc1NlYXJjaCA9IG9GaWx0ZXIuc1NlYXJjaDtcblx0XHRcdG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xuXHRcdFx0b1ByZXZTZWFyY2guYlNtYXJ0ID0gb0ZpbHRlci5iU21hcnQ7XG5cdFx0XHRvUHJldlNlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlID0gb0ZpbHRlci5iQ2FzZUluc2Vuc2l0aXZlO1xuXHRcdH07XG5cdFx0dmFyIGZuUmVnZXggPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBiRXNjYXBlUmVnZXggb3B0aW9uXG5cdFx0XHRyZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuXHRcdH07XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBBcyBwZXIgc29ydCAtIGNhbiB0aGlzIGJlIG1vdmVkIGludG8gYW4gZXZlbnQgaGFuZGxlcj9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdC8qIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmUgKi9cblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnIClcblx0XHR7XG5cdFx0XHQvKiBHbG9iYWwgZmlsdGVyICovXG5cdFx0XHRfZm5GaWx0ZXIoIG9TZXR0aW5ncywgb0lucHV0LnNTZWFyY2gsIGlGb3JjZSwgZm5SZWdleChvSW5wdXQpLCBvSW5wdXQuYlNtYXJ0LCBvSW5wdXQuYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblx0XG5cdFx0XHQvKiBOb3cgZG8gdGhlIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlciAqL1xuXHRcdFx0Zm9yICggdmFyIGk9MCA7IGk8YW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkZpbHRlckNvbHVtbiggb1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxuXHRcdFx0XHRcdGFvUHJldlNlYXJjaFtpXS5iU21hcnQsIGFvUHJldlNlYXJjaFtpXS5iQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQ3VzdG9tIGZpbHRlcmluZyAqL1xuXHRcdFx0X2ZuRmlsdGVyQ3VzdG9tKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGZuU2F2ZUZpbHRlciggb0lucHV0ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cblx0XHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xuXHRcdHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XHR2YXIgcm93LCByb3dJZHg7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1maWx0ZXJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIHJvd3MgPSBbXTtcblx0XG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cm93SWR4ID0gZGlzcGxheVJvd3NbIGogXTtcblx0XHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0XG5cdFx0XHRcdGlmICggZmlsdGVyc1tpXSggc2V0dGluZ3MsIHJvdy5fYUZpbHRlckRhdGEsIHJvd0lkeCwgcm93Ll9hRGF0YSwgaiApICkge1xuXHRcdFx0XHRcdHJvd3MucHVzaCggcm93SWR4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0XHQvLyBleGlzdGluZyBhcnJheVxuXHRcdFx0ZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcblx0XHRcdCQubWVyZ2UoIGRpc3BsYXlSb3dzLCByb3dzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgb24gYSBwZXItY29sdW1uIGJhc2lzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIGNvbHVtbiB0byBmaWx0ZXJcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IHNlYXJjaCBzdHJpbmcgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCB1c2Ugc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ29sdW1uICggc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHRpZiAoIHNlYXJjaFN0ciA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YTtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdFx0dmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBzZWFyY2hTdHIsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlICk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAgOyBpPGRpc3BsYXkubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9hRmlsdGVyRGF0YVsgY29sSWR4IF07XG5cdFxuXHRcdFx0aWYgKCBycFNlYXJjaC50ZXN0KCBkYXRhICkgKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBkaXNwbGF5W2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBvdXQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRmlsdGVyIHRoZSBkYXRhIHRhYmxlIGJhc2VkIG9uIHVzZXIgaW5wdXQgYW5kIGRyYXcgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXG5cdCAqICBAcGFyYW0ge2ludH0gZm9yY2Ugb3B0aW9uYWwgLSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXG5cdCAqICBAcGFyYW0ge2Jvb2x9IHJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBzbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gY2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyKCBzZXR0aW5ncywgaW5wdXQsIGZvcmNlLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHR2YXIgcnBTZWFyY2ggPSBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdHZhciBwcmV2U2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2g7XG5cdFx0dmFyIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdFx0dmFyIGRpc3BsYXksIGludmFsaWRhdGVkLCBpO1xuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXHRcblx0XHQvLyBOZWVkIHRvIHRha2UgYWNjb3VudCBvZiBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9ucyAtIGFsd2F5cyBmaWx0ZXJcblx0XHRpZiAoIERhdGFUYWJsZS5leHQuc2VhcmNoLmxlbmd0aCAhPT0gMCApIHtcblx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcm93cyB3ZXJlIGludmFsaWRhdGVkXG5cdFx0aW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJZiB0aGUgaW5wdXQgaXMgYmxhbmsgLSB3ZSBqdXN0IHdhbnQgdGhlIGZ1bGwgZGF0YSBzZXRcblx0XHRpZiAoIGlucHV0Lmxlbmd0aCA8PSAwICkge1xuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5ldyBzZWFyY2ggLSBzdGFydCBmcm9tIHRoZSBtYXN0ZXIgYXJyYXlcblx0XHRcdGlmICggaW52YWxpZGF0ZWQgfHxcblx0XHRcdFx0IGZvcmNlIHx8XG5cdFx0XHRcdCByZWdleCB8fFxuXHRcdFx0XHQgcHJldlNlYXJjaC5sZW5ndGggPiBpbnB1dC5sZW5ndGggfHxcblx0XHRcdFx0IGlucHV0LmluZGV4T2YocHJldlNlYXJjaCkgIT09IDAgfHxcblx0XHRcdFx0IHNldHRpbmdzLmJTb3J0ZWQgLy8gT24gcmVzb3J0LCB0aGUgZGlzcGxheSBtYXN0ZXIgbmVlZHMgdG8gYmVcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgLy8gcmUtZmlsdGVyZWQgc2luY2UgaW5kZXhlcyB3aWxsIGhhdmUgY2hhbmdlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWFyY2ggdGhlIGRpc3BsYXkgYXJyYXlcblx0XHRcdGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdFxuXHRcdFx0Zm9yICggaT0wIDsgaTxkaXNwbGF5Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBycFNlYXJjaC50ZXN0KCBzZXR0aW5ncy5hb0RhdGFbIGRpc3BsYXlbaV0gXS5fc0ZpbHRlclJvdyApICkge1xuXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goIGRpc3BsYXlbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IGZpbHRlcmVkO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCdWlsZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3Qgc3VpdGFibGUgZm9yIHNlYXJjaGluZyBhIHRhYmxlXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1NlYXJjaCBzdHJpbmcgdG8gc2VhcmNoIGZvclxuXHQgKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIG9yIG5vdFxuXHQgKiAgQHJldHVybnMge1JlZ0V4cH0gY29uc3RydWN0ZWQgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHRzZWFyY2ggPSByZWdleCA/XG5cdFx0XHRzZWFyY2ggOlxuXHRcdFx0X2ZuRXNjYXBlUmVnZXgoIHNlYXJjaCApO1xuXHRcdFxuXHRcdGlmICggc21hcnQgKSB7XG5cdFx0XHQvKiBGb3Igc21hcnQgZmlsdGVyaW5nIHdlIHdhbnQgdG8gYWxsb3cgdGhlIHNlYXJjaCB0byB3b3JrIHJlZ2FyZGxlc3Mgb2Zcblx0XHRcdCAqIHdvcmQgb3JkZXIuIFdlIGFsc28gd2FudCBkb3VibGUgcXVvdGVkIHRleHQgdG8gYmUgcHJlc2VydmVkLCBzbyB3b3JkXG5cdFx0XHQgKiBvcmRlciBpcyBpbXBvcnRhbnQgLSBhIGxhIGdvb2dsZS4gU28gdGhpcyBpcyB3aGF0IHdlIHdhbnQgdG9cblx0XHRcdCAqIGdlbmVyYXRlOlxuXHRcdFx0ICogXG5cdFx0XHQgKiBeKD89Lio/XFxib25lXFxiKSg/PS4qP1xcYnR3byB0aHJlZVxcYikoPz0uKj9cXGJmb3VyXFxiKS4qJFxuXHRcdFx0ICovXG5cdFx0XHR2YXIgYSA9ICQubWFwKCBzZWFyY2gubWF0Y2goIC9cIlteXCJdK1wifFteIF0rL2cgKSB8fCBbJyddLCBmdW5jdGlvbiAoIHdvcmQgKSB7XG5cdFx0XHRcdGlmICggd29yZC5jaGFyQXQoMCkgPT09ICdcIicgKSB7XG5cdFx0XHRcdFx0dmFyIG0gPSB3b3JkLm1hdGNoKCAvXlwiKC4qKVwiJC8gKTtcblx0XHRcdFx0XHR3b3JkID0gbSA/IG1bMV0gOiB3b3JkO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gd29yZC5yZXBsYWNlKCdcIicsICcnKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRzZWFyY2ggPSAnXig/PS4qPycrYS5qb2luKCAnKSg/PS4qPycgKSsnKS4qJCc7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbmV3IFJlZ0V4cCggc2VhcmNoLCBjYXNlSW5zZW5zaXRpdmUgPyAnaScgOiAnJyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzVmFsIHN0cmluZyB0byBlc2NhcGVcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdHZhciBfZm5Fc2NhcGVSZWdleCA9IERhdGFUYWJsZS51dGlsLmVzY2FwZVJlZ2V4O1xuXHRcblx0dmFyIF9fZmlsdGVyX2RpdiA9ICQoJzxkaXY+JylbMF07XG5cdHZhciBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgPSBfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZDtcblx0XG5cdC8vIFVwZGF0ZSB0aGUgZmlsdGVyaW5nIGRhdGEgZm9yIGVhY2ggcm93IGlmIG5lZWRlZCAoYnkgaW52YWxpZGF0aW9uIG9yIGZpcnN0IHJ1bilcblx0ZnVuY3Rpb24gX2ZuRmlsdGVyRGF0YSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBjb2x1bW47XG5cdFx0dmFyIGksIGosIGllbiwgamVuLCBmaWx0ZXJEYXRhLCBjZWxsRGF0YSwgcm93O1xuXHRcdHZhciBmb21hdHRlcnMgPSBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoO1xuXHRcdHZhciB3YXNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRyb3cgPSBzZXR0aW5ncy5hb0RhdGFbaV07XG5cdFxuXHRcdFx0aWYgKCAhIHJvdy5fYUZpbHRlckRhdGEgKSB7XG5cdFx0XHRcdGZpbHRlckRhdGEgPSBbXTtcblx0XG5cdFx0XHRcdGZvciAoIGo9MCwgamVuPWNvbHVtbnMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0Y29sdW1uID0gY29sdW1uc1tqXTtcblx0XG5cdFx0XHRcdFx0aWYgKCBjb2x1bW4uYlNlYXJjaGFibGUgKSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaSwgaiwgJ2ZpbHRlcicgKTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIGZvbWF0dGVyc1sgY29sdW1uLnNUeXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdGNlbGxEYXRhID0gZm9tYXR0ZXJzWyBjb2x1bW4uc1R5cGUgXSggY2VsbERhdGEgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvLyBTZWFyY2ggaW4gRGF0YVRhYmxlcyAxLjEwIGlzIHN0cmluZyBiYXNlZC4gSW4gMS4xMSB0aGlzXG5cdFx0XHRcdFx0XHQvLyBzaG91bGQgYmUgYWx0ZXJlZCB0byBhbHNvIGFsbG93IHN0cmljdCB0eXBlIGNoZWNraW5nLlxuXHRcdFx0XHRcdFx0aWYgKCBjZWxsRGF0YSA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSAnJztcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjZWxsRGF0YSAhPT0gJ3N0cmluZycgJiYgY2VsbERhdGEudG9TdHJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgaXQgbG9va3MgbGlrZSB0aGVyZSBpcyBhbiBIVE1MIGVudGl0eSBpbiB0aGUgc3RyaW5nLFxuXHRcdFx0XHRcdC8vIGF0dGVtcHQgdG8gZGVjb2RlIGl0IHNvIHNvcnRpbmcgd29ya3MgYXMgZXhwZWN0ZWQuIE5vdGUgdGhhdFxuXHRcdFx0XHRcdC8vIHdlIGNvdWxkIHVzZSBhIHNpbmdsZSBsaW5lIG9mIGpRdWVyeSB0byBkbyB0aGlzLCBidXQgdGhlIERPTVxuXHRcdFx0XHRcdC8vIG1ldGhvZCB1c2VkIGhlcmUgaXMgbXVjaCBmYXN0ZXIgaHR0cDovL2pzcGVyZi5jb20vaHRtbC1kZWNvZGVcblx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhLmluZGV4T2YgJiYgY2VsbERhdGEuaW5kZXhPZignJicpICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi5pbm5lckhUTUwgPSBjZWxsRGF0YTtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID9cblx0XHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LnRleHRDb250ZW50IDpcblx0XHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVyVGV4dDtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEucmVwbGFjZSApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEucmVwbGFjZSgvW1xcclxcblxcdTIwMjhdL2csICcnKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGZpbHRlckRhdGEucHVzaCggY2VsbERhdGEgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cm93Ll9hRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG5cdFx0XHRcdHJvdy5fc0ZpbHRlclJvdyA9IGZpbHRlckRhdGEuam9pbignICAnKTtcblx0XHRcdFx0d2FzSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHdhc0ludmFsaWRhdGVkO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSB0aGUgaW50ZXJuYWwgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsQ2FzZSBmb3IgZXh0ZXJuYWxcblx0ICogaW50ZXJhY3Rpb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGNvbnZlcnRcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IEludmVydGVkIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZWFyY2hUb0NhbWVsICggb2JqIClcblx0e1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZWFyY2g6ICAgICAgICAgIG9iai5zU2VhcmNoLFxuXHRcdFx0c21hcnQ6ICAgICAgICAgICBvYmouYlNtYXJ0LFxuXHRcdFx0cmVnZXg6ICAgICAgICAgICBvYmouYlJlZ2V4LFxuXHRcdFx0Y2FzZUluc2Vuc2l0aXZlOiBvYmouYkNhc2VJbnNlbnNpdGl2ZVxuXHRcdH07XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSBjYW1lbENhc2Ugbm90YXRpb24gdG8gdGhlIGludGVybmFsIEh1bmdhcmlhbi4gV2UgY291bGQgdXNlIHRoZVxuXHQgKiBIdW5nYXJpYW4gY29udmVydCBmdW5jdGlvbiBoZXJlLCBidXQgdGhpcyBpcyBjbGVhbmVyXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2VhcmNoVG9IdW5nICggb2JqIClcblx0e1xuXHRcdHJldHVybiB7XG5cdFx0XHRzU2VhcmNoOiAgICAgICAgICBvYmouc2VhcmNoLFxuXHRcdFx0YlNtYXJ0OiAgICAgICAgICAgb2JqLnNtYXJ0LFxuXHRcdFx0YlJlZ2V4OiAgICAgICAgICAgb2JqLnJlZ2V4LFxuXHRcdFx0YkNhc2VJbnNlbnNpdGl2ZTogb2JqLmNhc2VJbnNlbnNpdGl2ZVxuXHRcdH07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIGluZm8gZGlzcGxheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IEluZm9ybWF0aW9uIGVsZW1lbnRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxJbmZvICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0aWQgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaSxcblx0XHRcdG4gPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNJbmZvLFxuXHRcdFx0XHQnaWQnOiAhIG5vZGVzID8gdGlkKydfaW5mbycgOiBudWxsXG5cdFx0XHR9ICk7XG5cdFxuXHRcdGlmICggISBub2RlcyApIHtcblx0XHRcdC8vIFVwZGF0ZSBkaXNwbGF5IG9uIGVhY2ggZHJhd1xuXHRcdFx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCgge1xuXHRcdFx0XHRcImZuXCI6IF9mblVwZGF0ZUluZm8sXG5cdFx0XHRcdFwic05hbWVcIjogXCJpbmZvcm1hdGlvblwiXG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0blxuXHRcdFx0XHQuYXR0ciggJ3JvbGUnLCAnc3RhdHVzJyApXG5cdFx0XHRcdC5hdHRyKCAnYXJpYS1saXZlJywgJ3BvbGl0ZScgKTtcblx0XG5cdFx0XHQvLyBUYWJsZSBpcyBkZXNjcmliZWQgYnkgb3VyIGluZm8gZGl2XG5cdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkuYXR0ciggJ2FyaWEtZGVzY3JpYmVkYnknLCB0aWQrJ19pbmZvJyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG5bMF07XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50cyBpbiB0aGUgZGlzcGxheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblVwZGF0ZUluZm8gKCBzZXR0aW5ncyApXG5cdHtcblx0XHQvKiBTaG93IGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSAqL1xuXHRcdHZhciBub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmk7XG5cdFx0aWYgKCBub2Rlcy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGxhbmcgID0gc2V0dGluZ3Mub0xhbmd1YWdlLFxuXHRcdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCsxLFxuXHRcdFx0ZW5kICAgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcdG1heCAgID0gc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcdHRvdGFsID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0b3V0ICAgPSB0b3RhbCA/XG5cdFx0XHRcdGxhbmcuc0luZm8gOlxuXHRcdFx0XHRsYW5nLnNJbmZvRW1wdHk7XG5cdFxuXHRcdGlmICggdG90YWwgIT09IG1heCApIHtcblx0XHRcdC8qIFJlY29yZCBzZXQgYWZ0ZXIgZmlsdGVyaW5nICovXG5cdFx0XHRvdXQgKz0gJyAnICsgbGFuZy5zSW5mb0ZpbHRlcmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29udmVydCB0aGUgbWFjcm9zXG5cdFx0b3V0ICs9IGxhbmcuc0luZm9Qb3N0Rml4O1xuXHRcdG91dCA9IF9mbkluZm9NYWNyb3MoIHNldHRpbmdzLCBvdXQgKTtcblx0XG5cdFx0dmFyIGNhbGxiYWNrID0gbGFuZy5mbkluZm9DYWxsYmFjaztcblx0XHRpZiAoIGNhbGxiYWNrICE9PSBudWxsICkge1xuXHRcdFx0b3V0ID0gY2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLFxuXHRcdFx0XHRzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgb3V0XG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0JChub2RlcykuaHRtbCggb3V0ICk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5JbmZvTWFjcm9zICggc2V0dGluZ3MsIHN0ciApXG5cdHtcblx0XHQvLyBXaGVuIGluZmluaXRlIHNjcm9sbGluZywgd2UgYXJlIGFsd2F5cyBzdGFydGluZyBhdCAxLiBfaURpc3BsYXlTdGFydCBpcyB1c2VkIG9ubHlcblx0XHQvLyBpbnRlcm5hbGx5XG5cdFx0dmFyXG5cdFx0XHRmb3JtYXR0ZXIgID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIsXG5cdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHR2aXMgICAgICAgID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cdFxuXHRcdHJldHVybiBzdHIuXG5cdFx0XHRyZXBsYWNlKC9fU1RBUlRfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc3RhcnQgKSApLlxuXHRcdFx0cmVwbGFjZSgvX0VORF8vZywgICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpICkgKS5cblx0XHRcdHJlcGxhY2UoL19NQVhfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpICkgKS5cblx0XHRcdHJlcGxhY2UoL19UT1RBTF8vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCB2aXMgKSApLlxuXHRcdFx0cmVwbGFjZSgvX1BBR0VfL2csICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICkgKSApLlxuXHRcdFx0cmVwbGFjZSgvX1BBR0VTXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpcyAvIGxlbiApICkgKTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSW5pdGlhbGlzZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBpQWpheFN0YXJ0PXNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLCBjb2x1bW47XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdHZhciBkZWZlckxvYWRpbmcgPSBzZXR0aW5ncy5iRGVmZXJMb2FkaW5nOyAvLyB2YWx1ZSBtb2RpZmllZCBieSB0aGUgZHJhd1xuXHRcblx0XHQvKiBFbnN1cmUgdGhhdCB0aGUgdGFibGUgZGF0YSBpcyBmdWxseSBpbml0aWFsaXNlZCAqL1xuXHRcdGlmICggISBzZXR0aW5ncy5iSW5pdGlhbGlzZWQgKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpeyBfZm5Jbml0aWFsaXNlKCBzZXR0aW5ncyApOyB9LCAyMDAgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdC8qIFNob3cgdGhlIGRpc3BsYXkgSFRNTCBvcHRpb25zICovXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWwoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8qIEJ1aWxkIGFuZCBkcmF3IHRoZSBoZWFkZXIgLyBmb290ZXIgZm9yIHRoZSB0YWJsZSAqL1xuXHRcdF9mbkJ1aWxkSGVhZCggc2V0dGluZ3MgKTtcblx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3RlciApO1xuXHRcblx0XHQvKiBPa2F5IHRvIHNob3cgdGhhdCBzb21ldGhpbmcgaXMgZ29pbmcgb24gbm93ICovXG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdC8qIENhbGN1bGF0ZSBzaXplcyBmb3IgY29sdW1ucyAqL1xuXHRcdGlmICggZmVhdHVyZXMuYkF1dG9XaWR0aCApIHtcblx0XHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cdFxuXHRcdFx0aWYgKCBjb2x1bW4uc1dpZHRoICkge1xuXHRcdFx0XHRjb2x1bW4ublRoLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvbHVtbi5zV2lkdGggKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcmVJbml0JywgW3NldHRpbmdzXSApO1xuXHRcblx0XHQvLyBJZiB0aGVyZSBpcyBkZWZhdWx0IHNvcnRpbmcgcmVxdWlyZWQgLSBsZXQncyBkbyBpdC4gVGhlIHNvcnQgZnVuY3Rpb25cblx0XHQvLyB3aWxsIGRvIHRoZSBkcmF3aW5nIGZvciB1cy4gT3RoZXJ3aXNlIHdlIGRyYXcgdGhlIHRhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlXG5cdFx0Ly8gQWpheCBzb3VyY2UgLSB0aGlzIGFsbG93cyB0aGUgdGFibGUgdG8gbG9vayBpbml0aWFsaXNlZCBmb3IgQWpheCBzb3VyY2luZ1xuXHRcdC8vIGRhdGEgKHNob3cgJ2xvYWRpbmcnIG1lc3NhZ2UgcG9zc2libHkpXG5cdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGluaXQgY29tcGxldGUgaXMgZG9uZSBieSBfZm5BamF4VXBkYXRlRHJhd1xuXHRcdHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKTtcblx0XHRpZiAoIGRhdGFTcmMgIT0gJ3NzcCcgfHwgZGVmZXJMb2FkaW5nICkge1xuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gYWpheCBzb3VyY2UgbG9hZCB0aGUgZGF0YVxuXHRcdFx0aWYgKCBkYXRhU3JjID09ICdhamF4JyApIHtcblx0XHRcdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywgW10sIGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdFx0XHR2YXIgYURhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XG5cdFx0XHRcdFx0Ly8gR290IHRoZSBkYXRhIC0gYWRkIGl0IHRvIHRoZSB0YWJsZVxuXHRcdFx0XHRcdGZvciAoIGk9MCA7IGk8YURhdGEubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGFEYXRhW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBSZXNldCB0aGUgaW5pdCBkaXNwbGF5IGZvciBjb29raWUgc2F2aW5nLiBXZSd2ZSBhbHJlYWR5IGRvbmVcblx0XHRcdFx0XHQvLyBhIGZpbHRlciwgYW5kIHRoZXJlZm9yZSBjbGVhcmVkIGl0IGJlZm9yZS4gU28gd2UgbmVlZCB0byBtYWtlXG5cdFx0XHRcdFx0Ly8gaXQgYXBwZWFyICdmcmVzaCdcblx0XHRcdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IGlBamF4U3RhcnQ7XG5cdFxuXHRcdFx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0fSwgc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gW2pzb25dIEpTT04gZnJvbSB0aGUgc2VydmVyIHRoYXQgY29tcGxldGVkIHRoZSB0YWJsZSwgaWYgdXNpbmcgQWpheCBzb3VyY2Vcblx0ICogICAgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIChvcHRpb25hbClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSW5pdENvbXBsZXRlICggc2V0dGluZ3MsIGpzb24gKVxuXHR7XG5cdFx0c2V0dGluZ3MuX2JJbml0Q29tcGxldGUgPSB0cnVlO1xuXHRcblx0XHQvLyBXaGVuIGRhdGEgd2FzIGFkZGVkIGFmdGVyIHRoZSBpbml0aWFsaXNhdGlvbiAoZGF0YSBvciBBamF4KSB3ZSBuZWVkIHRvXG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6aW5nXG5cdFx0aWYgKCBqc29uIHx8IHNldHRpbmdzLm9Jbml0LmFhRGF0YSApIHtcblx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwbHVnaW4taW5pdCcsIFtzZXR0aW5ncywganNvbl0gKTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIFtzZXR0aW5ncywganNvbl0gKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mbkxlbmd0aENoYW5nZSAoIHNldHRpbmdzLCB2YWwgKVxuXHR7XG5cdFx0dmFyIGxlbiA9IHBhcnNlSW50KCB2YWwsIDEwICk7XG5cdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoID0gbGVuO1xuXHRcblx0XHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gRmlyZSBsZW5ndGggY2hhbmdlIGV2ZW50XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2xlbmd0aCcsIFtzZXR0aW5ncywgbGVuXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB1c2VyIGRpc3BsYXkgbGVuZ3RoIGNoYW5naW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBEaXNwbGF5IGxlbmd0aCBmZWF0dXJlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxMZW5ndGggKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGNsYXNzZXMgID0gc2V0dGluZ3Mub0NsYXNzZXMsXG5cdFx0XHR0YWJsZUlkICA9IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0bWVudSAgICAgPSBzZXR0aW5ncy5hTGVuZ3RoTWVudSxcblx0XHRcdGQyICAgICAgID0gQXJyYXkuaXNBcnJheSggbWVudVswXSApLFxuXHRcdFx0bGVuZ3RocyAgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxuXHRcdFx0bGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXHRcblx0XHR2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuXHRcdFx0J25hbWUnOiAgICAgICAgICB0YWJsZUlkKydfbGVuZ3RoJyxcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcblx0XHRcdCdjbGFzcyc6ICAgICAgICAgY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XG5cdFx0fSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGVuZ3Rocy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbihcblx0XHRcdFx0dHlwZW9mIGxhbmd1YWdlW2ldID09PSAnbnVtYmVyJyA/XG5cdFx0XHRcdFx0c2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGxhbmd1YWdlW2ldICkgOlxuXHRcdFx0XHRcdGxhbmd1YWdlW2ldLFxuXHRcdFx0XHRsZW5ndGhzW2ldXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRpdiA9ICQoJzxkaXY+PGxhYmVsLz48L2Rpdj4nKS5hZGRDbGFzcyggY2xhc3Nlcy5zTGVuZ3RoICk7XG5cdFx0aWYgKCAhIHNldHRpbmdzLmFhbkZlYXR1cmVzLmwgKSB7XG5cdFx0XHRkaXZbMF0uaWQgPSB0YWJsZUlkKydfbGVuZ3RoJztcblx0XHR9XG5cdFxuXHRcdGRpdi5jaGlsZHJlbigpLmFwcGVuZChcblx0XHRcdHNldHRpbmdzLm9MYW5ndWFnZS5zTGVuZ3RoTWVudS5yZXBsYWNlKCAnX01FTlVfJywgc2VsZWN0WzBdLm91dGVySFRNTCApXG5cdFx0KTtcblx0XG5cdFx0Ly8gQ2FuJ3QgdXNlIGBzZWxlY3RgIHZhcmlhYmxlIGFzIHVzZXIgbWlnaHQgcHJvdmlkZSB0aGVpciBvd24gYW5kIHRoZVxuXHRcdC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcblx0XHQkKCdzZWxlY3QnLCBkaXYpXG5cdFx0XHQudmFsKCBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggKVxuXHRcdFx0Lm9uKCAnY2hhbmdlLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpICk7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdC8vIFVwZGF0ZSBub2RlIHZhbHVlIHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXMgdGhlIHRhYmxlJ3MgbGVuZ3RoXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnbGVuZ3RoLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIGxlbikge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0JCgnc2VsZWN0JywgZGl2KS52YWwoIGxlbiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGRpdlswXTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBOb3RlIHRoYXQgbW9zdCBvZiB0aGUgcGFnaW5nIGxvZ2ljIGlzIGRvbmUgaW5cblx0ICogRGF0YVRhYmxlLmV4dC5wYWdlclxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZGVmYXVsdCBwYWdpbmF0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gUGFnaW5hdGlvbiBmZWF0dXJlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dHlwZSAgID0gc2V0dGluZ3Muc1BhZ2luYXRpb25UeXBlLFxuXHRcdFx0cGx1Z2luID0gRGF0YVRhYmxlLmV4dC5wYWdlclsgdHlwZSBdLFxuXHRcdFx0bW9kZXJuID0gdHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdHJlZHJhdyA9IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH0sXG5cdFx0XHRub2RlID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoIHNldHRpbmdzLm9DbGFzc2VzLnNQYWdpbmcgKyB0eXBlIClbMF0sXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcblx0XHRpZiAoICEgbW9kZXJuICkge1xuXHRcdFx0cGx1Z2luLmZuSW5pdCggc2V0dGluZ3MsIG5vZGUsIHJlZHJhdyApO1xuXHRcdH1cblx0XG5cdFx0LyogQWRkIGEgZHJhdyBjYWxsYmFjayBmb3IgdGhlIHBhZ2luYXRpb24gb24gZmlyc3QgaW5zdGFuY2UsIHRvIHVwZGF0ZSB0aGUgcGFnaW5nIGRpc3BsYXkgKi9cblx0XHRpZiAoICEgZmVhdHVyZXMucCApXG5cdFx0e1xuXHRcdFx0bm9kZS5pZCA9IHNldHRpbmdzLnNUYWJsZUlkKydfcGFnaW5hdGUnO1xuXHRcblx0XHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdFx0aWYgKCBtb2Rlcm4gKSB7XG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0XHRcdFx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMSxcblx0XHRcdFx0XHRcdFx0cGFnZSA9IGFsbCA/IDAgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICksXG5cdFx0XHRcdFx0XHRcdHBhZ2VzID0gYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFx0XHRcdFx0XHRidXR0b25zID0gcGx1Z2luKHBhZ2UsIHBhZ2VzKSxcblx0XHRcdFx0XHRcdFx0aSwgaWVuO1xuXHRcblx0XHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWZlYXR1cmVzLnAubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRcdF9mblJlbmRlcmVyKCBzZXR0aW5ncywgJ3BhZ2VCdXR0b24nICkoXG5cdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3MsIGZlYXR1cmVzLnBbaV0sIGksIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cGx1Z2luLmZuVXBkYXRlKCBzZXR0aW5ncywgcmVkcmF3ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInNOYW1lXCI6IFwicGFnaW5hdGlvblwiXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBhY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIixcblx0ICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcblx0ICogIEBwYXJhbSBbYm9vbF0gcmVkcmF3IEF1dG9tYXRpY2FsbHkgZHJhdyB0aGUgdXBkYXRlIG9yIG5vdFxuXHQgKiAgQHJldHVybnMge2Jvb2x9IHRydWUgcGFnZSBoYXMgY2hhbmdlZCwgZmFsc2UgLSBubyBjaGFuZ2Vcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUGFnZUNoYW5nZSAoIHNldHRpbmdzLCBhY3Rpb24sIHJlZHJhdyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHN0YXJ0ICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0cmVjb3JkcyAgID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpO1xuXHRcblx0XHRpZiAoIHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGFjdGlvbiA9PT0gXCJudW1iZXJcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBhY3Rpb24gKiBsZW47XG5cdFxuXHRcdFx0aWYgKCBzdGFydCA+IHJlY29yZHMgKVxuXHRcdFx0e1xuXHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJmaXJzdFwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJwcmV2aW91c1wiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IGxlbiA+PSAwID9cblx0XHRcdFx0c3RhcnQgLSBsZW4gOlxuXHRcdFx0XHQwO1xuXHRcblx0XHRcdGlmICggc3RhcnQgPCAwIClcblx0XHRcdHtcblx0XHRcdCAgc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwibmV4dFwiIClcblx0XHR7XG5cdFx0XHRpZiAoIHN0YXJ0ICsgbGVuIDwgcmVjb3JkcyApXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0ICs9IGxlbjtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImxhc3RcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBNYXRoLmZsb29yKCAocmVjb3Jkcy0xKSAvIGxlbikgKiBsZW47XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBcIlVua25vd24gcGFnaW5nIGFjdGlvbjogXCIrYWN0aW9uLCA1ICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgY2hhbmdlZCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICE9PSBzdGFydDtcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXHRcblx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGFnZScsIFtzZXR0aW5nc10gKTtcblx0XG5cdFx0XHRpZiAoIHJlZHJhdyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gUHJvY2Vzc2luZyBlbGVtZW50XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdpZCc6ICEgc2V0dGluZ3MuYWFuRmVhdHVyZXMuciA/IHNldHRpbmdzLnNUYWJsZUlkKydfcHJvY2Vzc2luZycgOiBudWxsLFxuXHRcdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zUHJvY2Vzc2luZ1xuXHRcdFx0fSApXG5cdFx0XHQuaHRtbCggc2V0dGluZ3Mub0xhbmd1YWdlLnNQcm9jZXNzaW5nIClcblx0XHRcdC5pbnNlcnRCZWZvcmUoIHNldHRpbmdzLm5UYWJsZSApWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3Jcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheSAoIHNldHRpbmdzLCBzaG93IClcblx0e1xuXHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nICkge1xuXHRcdFx0JChzZXR0aW5ncy5hYW5GZWF0dXJlcy5yKS5jc3MoICdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcm9jZXNzaW5nJywgW3NldHRpbmdzLCBzaG93XSApO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSk7XG5cdFxuXHRcdC8vIEFkZCB0aGUgQVJJQSBncmlkIHJvbGUgdG8gdGhlIHRhYmxlXG5cdFx0dGFibGUuYXR0ciggJ3JvbGUnLCAnZ3JpZCcgKTtcblx0XG5cdFx0Ly8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxuXHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcblx0XHRpZiAoIHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2Nyb2xsWCA9IHNjcm9sbC5zWDtcblx0XHR2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcblx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciBjYXB0aW9uID0gdGFibGUuY2hpbGRyZW4oJ2NhcHRpb24nKTtcblx0XHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcblx0XHR2YXIgaGVhZGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdFx0dmFyIGZvb3RlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHRcdHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcblx0XHR2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xuXHRcdHZhciBzaXplID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0cmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKCBzICk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAhIGZvb3Rlci5sZW5ndGggKSB7XG5cdFx0XHRmb290ZXIgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiBUaGUgSFRNTCBzdHJ1Y3R1cmUgdGhhdCB3ZSB3YW50IHRvIGdlbmVyYXRlIGluIHRoaXMgZnVuY3Rpb24gaXM6XG5cdFx0ICogIGRpdiAtIHNjcm9sbGVyXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcblx0XHQgKiAgICAgIGRpdiAtIHNjcm9sbCBoZWFkIGlubmVyXG5cdFx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcblx0XHQgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGJvZHlcblx0XHQgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcblx0XHQgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG5cdFx0ICogICAgICAgIHRib2R5IC0gdGJvZHlcblx0XHQgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxuXHRcdCAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcblx0XHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgZm9vdCB0YWJsZVxuXHRcdCAqICAgICAgICAgIHRmb290IC0gdGZvb3Rcblx0XHQgKi9cblx0XHR2YXIgc2Nyb2xsZXIgPSAkKCBfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbFdyYXBwZXIgfSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZCB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdFx0J2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGwuc1hJbm5lciB8fCAnMTAwJSdcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0aGVhZGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQuY3NzKCAnbWFyZ2luLWxlZnQnLCAwIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsQm9keSB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSggc2Nyb2xsWCApXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZCggdGFibGUgKVxuXHRcdFx0KTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRzY3JvbGxlci5hcHBlbmQoXG5cdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290IH0gKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdGZvb3RlckNsb25lXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKCBjYXB0aW9uU2lkZSA9PT0gJ2JvdHRvbScgPyBjYXB0aW9uIDogbnVsbCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdHZhciBjaGlsZHJlbiA9IHNjcm9sbGVyLmNoaWxkcmVuKCk7XG5cdFx0dmFyIHNjcm9sbEhlYWQgPSBjaGlsZHJlblswXTtcblx0XHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHRcdHZhciBzY3JvbGxGb290ID0gZm9vdGVyID8gY2hpbGRyZW5bMl0gOiBudWxsO1xuXHRcblx0XHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0XHRpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLm9uKCAnc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cdFxuXHRcdFx0XHRzY3JvbGxIZWFkLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcblx0XHRcdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsRm9vdC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0JChzY3JvbGxCb2R5KS5jc3MoJ21heC1oZWlnaHQnLCBzY3JvbGxZKTtcblx0XHRpZiAoISBzY3JvbGwuYkNvbGxhcHNlKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdFx0c2V0dGluZ3MublNjcm9sbEJvZHkgPSBzY3JvbGxCb2R5O1xuXHRcdHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblx0XG5cdFx0Ly8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xuXHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFwiZm5cIjogX2ZuU2Nyb2xsRHJhdyxcblx0XHRcdFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHNjcm9sbGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxuXHQgKiBhbGlnbm1lbnQuXG5cdCAqXG5cdCAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXG5cdCAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuXHQgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG5cdCAqICAgMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET01cblx0ICogICAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzIHRvIGFsaWduIHRoZSBjb2x1bW5zXG5cdCAqICAgNC4gQ2xlYW4gdXBcblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuXHRcdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0XHR2YXJcblx0XHRcdHNjcm9sbCAgICAgICAgID0gc2V0dGluZ3Mub1Njcm9sbCxcblx0XHRcdHNjcm9sbFggICAgICAgID0gc2Nyb2xsLnNYLFxuXHRcdFx0c2Nyb2xsWElubmVyICAgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdHNjcm9sbFkgICAgICAgID0gc2Nyb2xsLnNZLFxuXHRcdFx0YmFyV2lkdGggICAgICAgPSBzY3JvbGwuaUJhcldpZHRoLFxuXHRcdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRcdGRpdkhlYWRlclN0eWxlID0gZGl2SGVhZGVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXIgPSBkaXZIZWFkZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0XHRkaXZCb2R5ICAgICAgICA9ICQoZGl2Qm9keUVsKSxcblx0XHRcdGRpdkJvZHlTdHlsZSAgID0gZGl2Qm9keUVsLnN0eWxlLFxuXHRcdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRcdGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRcdGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHRcdHRhYmxlICAgICAgICAgID0gJChzZXR0aW5ncy5uVGFibGUpLFxuXHRcdFx0dGFibGVFbCAgICAgICAgPSB0YWJsZVswXSxcblx0XHRcdHRhYmxlU3R5bGUgICAgID0gdGFibGVFbC5zdHlsZSxcblx0XHRcdGZvb3RlciAgICAgICAgID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcblx0XHRcdGJyb3dzZXIgICAgICAgID0gc2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ICAgICAgICAgICA9IGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplLFxuXHRcdFx0ZHRIZWFkZXJDZWxscyAgPSBfcGx1Y2soIHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcgKSxcblx0XHRcdGhlYWRlclRyZ0VscywgZm9vdGVyVHJnRWxzLFxuXHRcdFx0aGVhZGVyU3JjRWxzLCBmb290ZXJTcmNFbHMsXG5cdFx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5LFxuXHRcdFx0aGVhZGVyV2lkdGhzPVtdLCBmb290ZXJXaWR0aHM9W10sXG5cdFx0XHRoZWFkZXJDb250ZW50PVtdLCBmb290ZXJDb250ZW50PVtdLFxuXHRcdFx0aWR4LCBjb3JyZWN0aW9uLCBzYW5pdHlXaWR0aCxcblx0XHRcdHplcm9PdXQgPSBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gblNpemVyLnN0eWxlO1xuXHRcdFx0XHRzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyVG9wV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gMDtcblx0XHRcdH07XG5cdFxuXHRcdC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cblx0XHQvLyBhZGp1c3QgdGhlIGNvbHVtbiBzaXplcyBhcyB0aGUgdGFibGUgd2lkdGggd2lsbCBoYXZlIGNoYW5nZWQgdG8gYWNjb3VudFxuXHRcdC8vIGZvciB0aGUgc2Nyb2xsYmFyXG5cdFx0dmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xuXHRcdFxuXHRcdGlmICggc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSBzY3JvbGxCYXJWaXMgJiYgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0XHRyZXR1cm47IC8vIGFkanVzdCBjb2x1bW4gc2l6aW5nIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHRcdCAqL1xuXHRcblx0XHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRmb290ZXJDb3B5ID0gZm9vdGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRcdFx0Zm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXG5cdFx0XHRmb290ZXJTcmNFbHMgPSBmb290ZXJDb3B5LmZpbmQoJ3RyJyk7XG5cdFx0fVxuXHRcblx0XHQvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxuXHRcdGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0aGVhZGVyVHJnRWxzID0gaGVhZGVyLmZpbmQoJ3RyJyk7IC8vIG9yaWdpbmFsIGhlYWRlciBpcyBpbiBpdHMgb3duIHRhYmxlXG5cdFx0aGVhZGVyU3JjRWxzID0gaGVhZGVyQ29weS5maW5kKCd0cicpO1xuXHRcdGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXG5cdFx0ICovXG5cdFxuXHRcdC8vIFJlbW92ZSBvbGQgc2l6aW5nIGFuZCBhcHBseSB0aGUgY2FsY3VsYXRlZCBjb2x1bW4gd2lkdGhzXG5cdFx0Ly8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxuXHRcdC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcblx0XHRpZiAoICEgc2Nyb2xsWCApXG5cdFx0e1xuXHRcdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdFx0ZGl2SGVhZGVyWzBdLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XG5cdFx0JC5lYWNoKCBfZm5HZXRVbmlxdWVUaHMoIHNldHRpbmdzLCBoZWFkZXJDb3B5ICksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0XHRpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGkgKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF0uc1dpZHRoO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0bi5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XHR9XG5cdFxuXHRcdC8vIFNpemUgdGhlIHRhYmxlIGFzIGEgd2hvbGVcblx0XHRzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgKSB7XG5cdFx0XHQvLyBObyB4IHNjcm9sbGluZ1xuXHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXHRcblx0XHRcdC8vIElFNyB3aWxsIG1ha2UgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSB3aGVuIDEwMCUgaW5jbHVkZSB0aGUgc2Nyb2xsYmFyXG5cdFx0XHQvLyAtIHdoaWNoIGlzIHNob3VsZG4ndC4gV2hlbiB0aGVyZSBpcyBhIHNjcm9sbGJhciB3ZSBuZWVkIHRvIHRha2UgdGhpc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50LlxuXHRcdFx0aWYgKCBpZTY3ICYmICh0YWJsZS5maW5kKCd0Ym9keScpLmhlaWdodCgpID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpXG5cdFx0XHQpIHtcblx0XHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZS5vdXRlcldpZHRoKCkgLSBiYXJXaWR0aCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuXHRcdFx0c2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzY3JvbGxYSW5uZXIgIT09IFwiXCIgKSB7XG5cdFx0XHQvLyBsZWdhY3kgeCBzY3JvbGwgaW5uZXIgaGFzIGJlZW4gZ2l2ZW4gLSB1c2UgaXRcblx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzY3JvbGxYSW5uZXIpO1xuXHRcblx0XHRcdC8vIFJlY2FsY3VsYXRlIHRoZSBzYW5pdHkgd2lkdGhcblx0XHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gSGlkZGVuIGhlYWRlciBzaG91bGQgaGF2ZSB6ZXJvIGhlaWdodCwgc28gcmVtb3ZlIHBhZGRpbmcgYW5kIGJvcmRlcnMuIFRoZW5cblx0XHQvLyBzZXQgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSByZWFsIGhlYWRlcnNcblx0XG5cdFx0Ly8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggemVyb091dCwgaGVhZGVyU3JjRWxzICk7XG5cdFxuXHRcdC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5TaXplcikge1xuXHRcdFx0aGVhZGVyQ29udGVudC5wdXNoKCBuU2l6ZXIuaW5uZXJIVE1MICk7XG5cdFx0XHRoZWFkZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHQvLyBBcHBseSBhbGwgd2lkdGhzIGluIGZpbmFsIHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5Ub1NpemUsIGkpIHtcblx0XHRcdC8vIE9ubHkgYXBwbHkgd2lkdGhzIHRvIHRoZSBEYXRhVGFibGVzIGRldGVjdGVkIGhlYWRlciBjZWxscyAtIHRoaXNcblx0XHRcdC8vIHByZXZlbnRzIGNvbXBsZXggaGVhZGVycyBmcm9tIGhhdmluZyBjb250cmFkaWN0b3J5IHNpemVzIGFwcGxpZWRcblx0XHRcdGlmICggJC5pbkFycmF5KCBuVG9TaXplLCBkdEhlYWRlckNlbGxzICkgIT09IC0xICkge1xuXHRcdFx0XHRuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdFx0fVxuXHRcdH0sIGhlYWRlclRyZ0VscyApO1xuXHRcblx0XHQkKGhlYWRlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcblx0XHQvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xuXHRcdGlmICggZm9vdGVyIClcblx0XHR7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGZvb3RlclNyY0VscyApO1xuXHRcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHRcdGZvb3RlckNvbnRlbnQucHVzaCggblNpemVyLmlubmVySFRNTCApO1xuXHRcdFx0XHRmb290ZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdFx0fSwgZm9vdGVyU3JjRWxzICk7XG5cdFxuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuVG9TaXplLCBpKSB7XG5cdFx0XHRcdG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XG5cdFx0XHR9LCBmb290ZXJUcmdFbHMgKTtcblx0XG5cdFx0XHQkKGZvb3RlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMy4gQXBwbHkgdGhlIG1lYXN1cmVtZW50c1xuXHRcdCAqL1xuXHRcblx0XHQvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcblx0XHQvLyB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBzbyB0aGF0IHRoZSB3aWR0aCBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgYW5kIGJvZHlcblx0XHQvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcblx0XHQvLyB3aWR0aCB0byB3aGF0IHRoZXkgY3VycmVudGx5IGFyZVxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyLCBpKSB7XG5cdFx0XHRuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicraGVhZGVyQ29udGVudFtpXSsnPC9kaXY+Jztcblx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0blNpemVyLmNoaWxkTm9kZXNbMF0uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApXG5cdFx0e1xuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdFx0blNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIj4nK2Zvb3RlckNvbnRlbnRbaV0rJzwvZGl2Pic7XG5cdFx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcblx0XHQvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcblx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoIClcblx0XHR7XG5cdFx0XHQvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG5cdFx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XG5cdFx0XHRcdFx0c2FuaXR5V2lkdGgrYmFyV2lkdGggOlxuXHRcdFx0XHRcdHNhbml0eVdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cblx0XHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRcdGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvcnJlY3Rpb24gPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5cdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvcnJlY3Rpb24gKTtcblx0XHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogNC4gQ2xlYW4gdXBcblx0XHQgKi9cblx0XHRpZiAoICEgc2Nyb2xsWSApIHtcblx0XHRcdC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuXHRcdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHRcdCAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggaWU2NyApIHtcblx0XHRcdFx0ZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZUVsLm9mZnNldEhlaWdodCtiYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogRmluYWxseSBzZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlcyAqL1xuXHRcdHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XG5cdFx0Ly8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cblx0XHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdFx0dmFyIGJTY3JvbGxpbmcgPSB0YWJsZS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHRcdHZhciBwYWRkaW5nID0gJ3BhZGRpbmcnICsgKGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPyAnTGVmdCcgOiAnUmlnaHQnICk7XG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZVsgcGFkZGluZyBdID0gYlNjcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCI7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0ZGl2Rm9vdGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0XHRkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuXHRcdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLmluc2VydEJlZm9yZSggdGFibGUuY2hpbGRyZW4oJ3RoZWFkJykgKTtcblx0XG5cdFx0LyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXG5cdFx0ZGl2Qm9keS50cmlnZ2VyKCdzY3JvbGwnKTtcblx0XG5cdFx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdFx0Ly8gb25seSBpZiB3ZSBhcmVuJ3QgaG9sZGluZyB0aGUgcG9zaXRpb25cblx0XHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XG5cdCAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xuXHQgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXG5cdCAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oIGZuLCBhbjEsIGFuMiApXG5cdHtcblx0XHR2YXIgaW5kZXg9MCwgaT0wLCBpTGVuPWFuMS5sZW5ndGg7XG5cdFx0dmFyIG5Ob2RlMSwgbk5vZGUyO1xuXHRcblx0XHR3aGlsZSAoIGkgPCBpTGVuICkge1xuXHRcdFx0bk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XG5cdFx0XHRuTm9kZTIgPSBhbjIgPyBhbjJbaV0uZmlyc3RDaGlsZCA6IG51bGw7XG5cdFxuXHRcdFx0d2hpbGUgKCBuTm9kZTEgKSB7XG5cdFx0XHRcdGlmICggbk5vZGUxLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggYW4yICkge1xuXHRcdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgbk5vZGUyLCBpbmRleCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGZuKCBuTm9kZTEsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XG5cdFx0XHRcdG5Ob2RlMiA9IGFuMiA/IG5Ob2RlMi5uZXh0U2libGluZyA6IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHR2YXIgX19yZV9odG1sX3JlbW92ZSA9IC88Lio/Pi9nO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG5cdFx0XHRjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdHNjcm9sbCA9IG9TZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRcdHNjcm9sbFggPSBzY3JvbGwuc1gsXG5cdFx0XHRzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHR2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApLFxuXHRcdFx0aGVhZGVyQ2VsbHMgPSAkKCd0aCcsIG9TZXR0aW5ncy5uVEhlYWQpLFxuXHRcdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRcdHVzZXJJbnB1dHMgPSBmYWxzZSxcblx0XHRcdGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aCxcblx0XHRcdGJyb3dzZXIgPSBvU2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemU7XG5cdFxuXHRcdHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG5cdFx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHRcdHRhYmxlV2lkdGhBdHRyID0gc3R5bGVXaWR0aDtcblx0XHR9XG5cdFxuXHRcdC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuXHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXTtcblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGNvbHVtbi5zV2lkdGggPSBfZm5Db252ZXJ0VG9XaWR0aCggY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyICk7XG5cdFxuXHRcdFx0XHR1c2VySW5wdXRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgRE9NIGVxdWFscyB0aGUgbnVtYmVyIHRoYXQgd2UgaGF2ZSB0b1xuXHRcdCAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcblx0XHQgKiB0aGUgd2ViLSBicm93c2VyLiBObyBjdXN0b20gc2l6ZXMgY2FuIGJlIHNldCBpbiBvcmRlciBmb3IgdGhpcyB0byBoYXBwZW4sXG5cdFx0ICogbm9yIHNjcm9sbGluZyB1c2VkXG5cdFx0ICovXG5cdFx0aWYgKCBpZTY3IHx8ICEgdXNlcklucHV0cyAmJiAhIHNjcm9sbFggJiYgISBzY3JvbGxZICYmXG5cdFx0ICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSAmJlxuXHRcdCAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG5cdFx0KSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0XHR2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaSApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1sgY29sSWR4IF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdFx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdFx0XHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHRcdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0XHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG5cdFx0XHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXHRcblx0XHRcdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdFx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXHRcblx0XHRcdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0XHQvLyBmcm9tIHRoZSBjbG9uZWQgdGFibGUsIHNpbmNlIGlmIHNjcm9sbGluZyBpcyBhY3RpdmUsIHRoZSB0YWJsZSdzXG5cdFx0XHQvLyByZWFsIGhlYWRlciBhbmQgZm9vdGVyIGFyZSBjb250YWluZWQgaW4gZGlmZmVyZW50IHRhYmxlIHRhZ3Ncblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcdFx0dG1wVGFibGVcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpIClcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cdFxuXHRcdFx0Ly8gQXBwbHkgY3VzdG9tIHNpemluZyB0byB0aGUgY2xvbmVkIGhlYWRlclxuXHRcdFx0aGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncywgdG1wVGFibGUuZmluZCgndGhlYWQnKVswXSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcblx0XHRcdFx0aGVhZGVyQ2VsbHNbaV0uc3R5bGUud2lkdGggPSBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gbnVsbCAmJiBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gJycgP1xuXHRcdFx0XHRcdF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoT3JpZyApIDpcblx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdC8vIEZvciBzY3JvbGxYIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNvbHVtbiB3aWR0aCBvdGhlcndpc2UgdGhlXG5cdFx0XHRcdC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFggKSB7XG5cdFx0XHRcdFx0JCggaGVhZGVyQ2VsbHNbaV0gKS5hcHBlbmQoICQoJzxkaXYvPicpLmNzcygge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNvbHVtbi5zV2lkdGhPcmlnLFxuXHRcdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdFx0cGFkZGluZzogMCxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHRcdH0gKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcblx0XHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXHRcblx0XHRcdFx0XHQkKCBfZm5HZXRXaWRlc3ROb2RlKCBvU2V0dGluZ3MsIGNvbHVtbklkeCApIClcblx0XHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggY29sdW1uLnNDb250ZW50UGFkZGluZyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHRcdFx0Ly8gZHVwbGljYXRlZCBpbiB0aGUgZG9tIChyYWRpbyBlbGVtZW50cyBmb3IgZXhhbXBsZSlcblx0XHRcdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0XHRcdC8vIEEgaG9sZGluZyBlbGVtZW50IGlzIHVzZWQsIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG5cdFx0XHQvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuXHRcdFx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHRcdFx0Ly8gbmVlZGVkXG5cdFx0XHR2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKCBzY3JvbGxYIHx8IHNjcm9sbFkgP1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0e31cblx0XHRcdFx0KVxuXHRcdFx0XHQuYXBwZW5kKCB0bXBUYWJsZSApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyAoWCBvciBZKSB3ZSB3YW50IHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIGFzIFxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHRcdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRcdFx0aWYgKCBzY3JvbGxYICYmIHNjcm9sbFhJbm5lciApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0XHRcdHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cdFxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0XHRcdC8vIGNvbGxhcHNlXG5cdFx0XHRcdGlmICggdG1wVGFibGUud2lkdGgoKSA8IHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICYmIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlIC0gd2UgbmVlZCB0b1xuXHRcdFx0Ly8ga25vdyB0aGUgaW5uZXIgd2lkdGggKHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgb3RoZXIgdGFibGUnc1xuXHRcdFx0Ly8gY2VsbHMpIGFuZCB0aGUgb3V0ZXIgd2lkdGggc28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgZnVsbCB3aWR0aCBvZiB0aGVcblx0XHRcdC8vIHRhYmxlLiBUaGlzIGlzIHNhZmUgc2luY2UgRGF0YVRhYmxlcyByZXF1aXJlcyBhIHVuaXF1ZSBjZWxsIGZvciBlYWNoXG5cdFx0XHQvLyBjb2x1bW4sIGJ1dCBpZiBldmVyIGEgaGVhZGVyIGNhbiBzcGFuIG11bHRpcGxlIGNvbHVtbnMsIHRoaXMgd2lsbFxuXHRcdFx0Ly8gbmVlZCB0byBiZSBtb2RpZmllZC5cblx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0dmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcblx0XHRcdFx0dmFyIGJvcmRlciA9IGNlbGwub3V0ZXJXaWR0aCgpIC0gY2VsbC53aWR0aCgpO1xuXHRcblx0XHRcdFx0Ly8gVXNlIGdldEJvdW5kaW5nLi4uIHdoZXJlIHBvc3NpYmxlIChub3QgSUU4LSkgYmVjYXVzZSBpdCBjYW4gZ2l2ZVxuXHRcdFx0XHQvLyBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcblx0XHRcdFx0dmFyIGJvdW5kaW5nID0gYnJvd3Nlci5iQm91bmRpbmcgP1xuXHRcdFx0XHRcdE1hdGguY2VpbCggaGVhZGVyQ2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA6XG5cdFx0XHRcdFx0Y2VsbC5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdFx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdFx0XHQvLyBvZiB0aGUgdGFibGUgbWlnaHQgbm90IGVxdWFsIHRoZSB0b3RhbCBnaXZlbiBoZXJlIChJRSEpLlxuXHRcdFx0XHR0b3RhbCArPSBib3VuZGluZztcblx0XG5cdFx0XHRcdC8vIFdpZHRoIGZvciBlYWNoIGNvbHVtbiB0byB1c2Vcblx0XHRcdFx0Y29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyggYm91bmRpbmcgLSBib3JkZXIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXHRcblx0XHRcdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0XHRcdGhvbGRlci5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0XHQvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcblx0XHQvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxuXHRcdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRcdGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgISBvU2V0dGluZ3MuX3Jlc3pFdnQgKSB7XG5cdFx0XHR2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytvU2V0dGluZ3Muc0luc3RhbmNlLCBfZm5UaHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fTtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXG5cdFx0XHQvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuXHRcdFx0aWYgKCBpZTY3ICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBiaW5kUmVzaXplLCAxMDAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YmluZFJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWQgZm9yXG5cdCAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgQHBhcmFtIHtpbnR9IFtmcmVxPTIwMF0gY2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHR2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBhIENTUyB1bml0IHdpZHRoIHRvIHBpeGVscyAoZS5nLiAyZW0pXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gd2lkdGggd2lkdGggdG8gYmUgY29udmVydGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IHBhcmVudCBwYXJlbnQgdG8gZ2V0IHRoZSB3aXRoIGZvciAocmVxdWlyZWQgZm9yIHJlbGF0aXZlIHdpZHRocykgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbnZlcnRUb1dpZHRoICggd2lkdGgsIHBhcmVudCApXG5cdHtcblx0XHRpZiAoICEgd2lkdGggKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFxuXHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoICd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCB3aWR0aCApIClcblx0XHRcdC5hcHBlbmRUbyggcGFyZW50IHx8IGRvY3VtZW50LmJvZHkgKTtcblx0XG5cdFx0dmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XG5cdFx0bi5yZW1vdmUoKTtcblx0XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZGVzdCBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgaWR4IF07XG5cdFx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHRcdCQoJzx0ZC8+JykuaHRtbCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknICkgKVswXSA6XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbElkeCBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoIHNldHRpbmdzLCBjb2xJZHggKVxuXHR7XG5cdFx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdFx0cyA9IHMucmVwbGFjZSggX19yZV9odG1sX3JlbW92ZSwgJycgKTtcblx0XHRcdHMgPSBzLnJlcGxhY2UoIC8mbmJzcDsvZywgJyAnICk7XG5cdFxuXHRcdFx0aWYgKCBzLmxlbmd0aCA+IG1heCApIHtcblx0XHRcdFx0bWF4ID0gcy5sZW5ndGg7XG5cdFx0XHRcdG1heElkeCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbWF4SWR4O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlIHdpdGggY3NzIHVuaXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU3RyaW5nVG9Dc3MoIHMgKVxuXHR7XG5cdFx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuICcwcHgnO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB0eXBlb2YgcyA9PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHRcdCcwcHgnIDpcblx0XHRcdFx0cysncHgnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaXQgaGFzIGEgdW5pdCBjaGFyYWN0ZXIgYWxyZWFkeVxuXHRcdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdFx0cysncHgnIDpcblx0XHRcdHM7XG5cdH1cblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEZsYXR0ZW4gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGlMZW4sIGssIGtMZW4sXG5cdFx0XHRhU29ydCA9IFtdLFxuXHRcdFx0YWlPcmlnID0gW10sXG5cdFx0XHRhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG5cdFx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdFx0Zml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoIGZpeGVkICksXG5cdFx0XHRuZXN0ZWRTb3J0ID0gW10sXG5cdFx0XHRhZGQgPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRcdGlmICggYS5sZW5ndGggJiYgISBBcnJheS5pc0FycmF5KCBhWzBdICkgKSB7XG5cdFx0XHRcdFx0Ly8gMUQgYXJyYXlcblx0XHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2goIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyAyRCBhcnJheVxuXHRcdFx0XHRcdCQubWVyZ2UoIG5lc3RlZFNvcnQsIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0Ly8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxuXHRcdC8vIHNwZWNpZmllZFxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggZml4ZWQgKSApIHtcblx0XHRcdGFkZCggZml4ZWQgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZml4ZWRPYmogJiYgZml4ZWQucHJlICkge1xuXHRcdFx0YWRkKCBmaXhlZC5wcmUgKTtcblx0XHR9XG5cdFxuXHRcdGFkZCggc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cdFxuXHRcdGlmIChmaXhlZE9iaiAmJiBmaXhlZC5wb3N0ICkge1xuXHRcdFx0YWRkKCBmaXhlZC5wb3N0ICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAgOyBpPG5lc3RlZFNvcnQubGVuZ3RoIDsgaSsrIClcblx0XHR7XG5cdFx0XHRzcmNDb2wgPSBuZXN0ZWRTb3J0W2ldWzBdO1xuXHRcdFx0YURhdGFTb3J0ID0gYW9Db2x1bW5zWyBzcmNDb2wgXS5hRGF0YVNvcnQ7XG5cdFxuXHRcdFx0Zm9yICggaz0wLCBrTGVuPWFEYXRhU29ydC5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpQ29sID0gYURhdGFTb3J0W2tdO1xuXHRcdFx0XHRzVHlwZSA9IGFvQ29sdW1uc1sgaUNvbCBdLnNUeXBlIHx8ICdzdHJpbmcnO1xuXHRcblx0XHRcdFx0aWYgKCBuZXN0ZWRTb3J0W2ldLl9pZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRuZXN0ZWRTb3J0W2ldLl9pZHggPSAkLmluQXJyYXkoIG5lc3RlZFNvcnRbaV1bMV0sIGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YVNvcnQucHVzaCgge1xuXHRcdFx0XHRcdHNyYzogICAgICAgc3JjQ29sLFxuXHRcdFx0XHRcdGNvbDogICAgICAgaUNvbCxcblx0XHRcdFx0XHRkaXI6ICAgICAgIG5lc3RlZFNvcnRbaV1bMV0sXG5cdFx0XHRcdFx0aW5kZXg6ICAgICBuZXN0ZWRTb3J0W2ldLl9pZHgsXG5cdFx0XHRcdFx0dHlwZTogICAgICBzVHlwZSxcblx0XHRcdFx0XHRmb3JtYXR0ZXI6IERhdGFUYWJsZS5leHQudHlwZS5vcmRlclsgc1R5cGUrXCItcHJlXCIgXVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gYVNvcnQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqICBAdG9kbyBUaGlzIHJlYWxseSBuZWVkcyBzcGxpdCB1cCFcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnQgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sXG5cdFx0XHRzRGF0YVR5cGUsIG5UaCxcblx0XHRcdGFpT3JpZyA9IFtdLFxuXHRcdFx0b0V4dFNvcnQgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsXG5cdFx0XHRhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhLFxuXHRcdFx0YW9Db2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGFEYXRhU29ydCwgZGF0YSwgaUNvbCwgc1R5cGUsIG9Tb3J0LFxuXHRcdFx0Zm9ybWF0dGVycyA9IDAsXG5cdFx0XHRzb3J0Q29sLFxuXHRcdFx0ZGlzcGxheU1hc3RlciA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsXG5cdFx0XHRhU29ydDtcblx0XG5cdFx0Ly8gUmVzb2x2ZSBhbnkgY29sdW1uIHR5cGVzIHRoYXQgYXJlIHVua25vd24gZHVlIHRvIGFkZGl0aW9uIG9yIGludmFsaWRhdGlvblxuXHRcdC8vIEB0b2RvIENhbiB0aGlzIGJlIG1vdmVkIGludG8gYSAnZGF0YS1yZWFkeScgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlblxuXHRcdC8vICAgZGF0YSBpcyBnb2luZyB0byBiZSB1c2VkIGluIHRoZSB0YWJsZT9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1hU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNvcnRDb2wgPSBhU29ydFtpXTtcblx0XG5cdFx0XHQvLyBUcmFjayBpZiB3ZSBjYW4gdXNlIHRoZSBmYXN0IHNvcnQgYWxnb3JpdGhtXG5cdFx0XHRpZiAoIHNvcnRDb2wuZm9ybWF0dGVyICkge1xuXHRcdFx0XHRmb3JtYXR0ZXJzKys7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTG9hZCB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBzb3J0LCBmb3IgZWFjaCBjZWxsXG5cdFx0XHRfZm5Tb3J0RGF0YSggb1NldHRpbmdzLCBzb3J0Q29sLmNvbCApO1xuXHRcdH1cblx0XG5cdFx0LyogTm8gc29ydGluZyByZXF1aXJlZCBpZiBzZXJ2ZXItc2lkZSBvciBubyBzb3J0aW5nIGFycmF5ICovXG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDAgKVxuXHRcdHtcblx0XHRcdC8vIENyZWF0ZSBhIHZhbHVlIC0ga2V5IGFycmF5IG9mIHRoZSBjdXJyZW50IHJvdyBwb3NpdGlvbnMgc3VjaCB0aGF0IHdlIGNhbiB1c2UgdGhlaXJcblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gZHVyaW5nIHRoZSBzb3J0LCBpZiB2YWx1ZXMgbWF0Y2gsIGluIG9yZGVyIHRvIHBlcmZvcm0gc3RhYmxlIHNvcnRpbmdcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1kaXNwbGF5TWFzdGVyLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0YWlPcmlnWyBkaXNwbGF5TWFzdGVyW2ldIF0gPSBpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8qIERvIHRoZSBzb3J0IC0gaGVyZSB3ZSB3YW50IG11bHRpLWNvbHVtbiBzb3J0aW5nIGJhc2VkIG9uIGEgZ2l2ZW4gZGF0YSBzb3VyY2UgKGNvbHVtbilcblx0XHRcdCAqIGFuZCBzb3J0aW5nIGZ1bmN0aW9uIChmcm9tIG9Tb3J0KSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBJdCdzIHJlYXNvbmFibHkgY29tcGxleCB0b1xuXHRcdFx0ICogZm9sbG93IG9uIGl0J3Mgb3duLCBidXQgdGhpcyBpcyB3aGF0IHdlIHdhbnQgKGV4YW1wbGUgdHdvIGNvbHVtbiBzb3J0aW5nKTpcblx0XHRcdCAqICBmbkxvY2FsU29ydGluZyA9IGZ1bmN0aW9uKGEsYil7XG5cdFx0XHQgKiAgICB2YXIgaVRlc3Q7XG5cdFx0XHQgKiAgICBpVGVzdCA9IG9Tb3J0WydzdHJpbmctYXNjJ10oJ2RhdGExMScsICdkYXRhMTInKTtcblx0XHRcdCAqICAgICAgaWYgKGlUZXN0ICE9PSAwKVxuXHRcdFx0ICogICAgICAgIHJldHVybiBpVGVzdDtcblx0XHRcdCAqICAgIGlUZXN0ID0gb1NvcnRbJ251bWVyaWMtZGVzYyddKCdkYXRhMjEnLCAnZGF0YTIyJyk7XG5cdFx0XHQgKiAgICBpZiAoaVRlc3QgIT09IDApXG5cdFx0XHQgKiAgICAgIHJldHVybiBpVGVzdDtcblx0XHRcdCAqICAgIHJldHVybiBvU29ydFsnbnVtZXJpYy1hc2MnXSggYWlPcmlnW2FdLCBhaU9yaWdbYl0gKTtcblx0XHRcdCAqICB9XG5cdFx0XHQgKiBCYXNpY2FsbHkgd2UgaGF2ZSBhIHRlc3QgZm9yIGVhY2ggc29ydGluZyBjb2x1bW4sIGlmIHRoZSBkYXRhIGluIHRoYXQgY29sdW1uIGlzIGVxdWFsLFxuXHRcdFx0ICogdGVzdCB0aGUgbmV4dCBjb2x1bW4uIElmIGFsbCBjb2x1bW5zIG1hdGNoLCB0aGVuIHdlIHVzZSBhIG51bWVyaWMgc29ydCBvbiB0aGUgcm93XG5cdFx0XHQgKiBwb3NpdGlvbnMgaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgdG8gcHJvdmlkZSBhIHN0YWJsZSBzb3J0LlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgLSBJIGtub3cgaXQgc2VlbXMgZXhjZXNzaXZlIHRvIGhhdmUgdHdvIHNvcnRpbmcgbWV0aG9kcywgYnV0IHRoZSBmaXJzdCBpcyBhcm91bmRcblx0XHRcdCAqIDE1JSBmYXN0ZXIsIHNvIHRoZSBzZWNvbmQgaXMgb25seSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNvcnRpbmdcblx0XHRcdCAqIG1ldGhvZHMgd2hpY2ggZG8gbm90IGhhdmUgYSBwcmUtc29ydCBmb3JtYXR0aW5nIGZ1bmN0aW9uLlxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIGZvcm1hdHRlcnMgPT09IGFTb3J0Lmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gQWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uc1xuXHRcdFx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHgsIHksIGssIHRlc3QsIHNvcnQsXG5cdFx0XHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cdFxuXHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXHRcblx0XHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblx0XG5cdFx0XHRcdFx0XHR0ZXN0ID0geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvcnQuZGlyID09PSAnYXNjJyA/IHRlc3QgOiAtdGVzdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIERlcHJlY2lhdGVkIC0gcmVtb3ZlIGluIDEuMTEgKHByb3ZpZGluZyBhIHBsdWctaW4gb3B0aW9uKVxuXHRcdFx0XHQvLyBOb3QgYWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIG1ldGhvZHMsIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGVpciBzb3J0aW5nXG5cdFx0XHRcdC8vIG1ldGhvZHMuXG5cdFx0XHRcdGRpc3BsYXlNYXN0ZXIuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0eCwgeSwgaywgbCwgdGVzdCwgc29ydCwgZm4sXG5cdFx0XHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cdFxuXHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXHRcblx0XHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblx0XG5cdFx0XHRcdFx0XHRmbiA9IG9FeHRTb3J0WyBzb3J0LnR5cGUrXCItXCIrc29ydC5kaXIgXSB8fCBvRXh0U29ydFsgXCJzdHJpbmctXCIrc29ydC5kaXIgXTtcblx0XHRcdFx0XHRcdHRlc3QgPSBmbiggeCwgeSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0ZXN0ICE9PSAwICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB0aGF0IHdlIGhhdmUgc29ydGVkIHRoZSBkYXRhICovXG5cdFx0b1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEFyaWEgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgbGFiZWw7XG5cdFx0dmFyIG5leHRTb3J0O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHRcdHZhciBvQXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYTtcblx0XG5cdFx0Ly8gQVJJQSBhdHRyaWJ1dGVzIC0gbmVlZCB0byBsb29wIGFsbCBjb2x1bW5zLCB0byB1cGRhdGUgYWxsIChyZW1vdmluZyBvbGRcblx0XHQvLyBhdHRyaWJ1dGVzIGFzIG5lZWRlZClcblx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgY29sID0gY29sdW1uc1tpXTtcblx0XHRcdHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuXHRcdFx0dmFyIHNUaXRsZSA9IGNvbC5zVGl0bGUucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdHZhciB0aCA9IGNvbC5uVGg7XG5cdFxuXHRcdFx0Ly8gSUU3IGlzIHRocm93aW5nIGFuIGVycm9yIHdoZW4gc2V0dGluZyB0aGVzZSBwcm9wZXJ0aWVzIHdpdGggalF1ZXJ5J3Ncblx0XHRcdC8vIGF0dHIoKSBhbmQgcmVtb3ZlQXR0cigpIG1ldGhvZHMuLi5cblx0XHRcdHRoLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1zb3J0Jyk7XG5cdFxuXHRcdFx0LyogSW4gQVJJQSBvbmx5IHRoZSBmaXJzdCBzb3J0aW5nIGNvbHVtbiBjYW4gYmUgbWFya2VkIGFzIHNvcnRpbmcgLSBubyBtdWx0aS1zb3J0IG9wdGlvbiAqL1xuXHRcdFx0aWYgKCBjb2wuYlNvcnRhYmxlICkge1xuXHRcdFx0XHRpZiAoIGFTb3J0Lmxlbmd0aCA+IDAgJiYgYVNvcnRbMF0uY29sID09IGkgKSB7XG5cdFx0XHRcdFx0dGguc2V0QXR0cmlidXRlKCdhcmlhLXNvcnQnLCBhU29ydFswXS5kaXI9PVwiYXNjXCIgPyBcImFzY2VuZGluZ1wiIDogXCJkZXNjZW5kaW5nXCIgKTtcblx0XHRcdFx0XHRuZXh0U29ydCA9IGFzU29ydGluZ1sgYVNvcnRbMF0uaW5kZXgrMSBdIHx8IGFzU29ydGluZ1swXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRuZXh0U29ydCA9IGFzU29ydGluZ1swXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0bGFiZWwgPSBzVGl0bGUgKyAoIG5leHRTb3J0ID09PSBcImFzY1wiID9cblx0XHRcdFx0XHRvQXJpYS5zU29ydEFzY2VuZGluZyA6XG5cdFx0XHRcdFx0b0FyaWEuc1NvcnREZXNjZW5kaW5nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGFiZWwgPSBzVGl0bGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dGguc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBydW4gb24gdXNlciBzb3J0IHJlcXVlc3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYXBwZW5kPWZhbHNlXSBBcHBlbmQgdGhlIHJlcXVlc3RlZCBzb3J0IHRvIHRoZSBleGlzdGluZ1xuXHQgKiAgICBzb3J0IGlmIHRydWUgKGkuZS4gbXVsdGktY29sdW1uIHNvcnQpXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnRMaXN0ZW5lciAoIHNldHRpbmdzLCBjb2xJZHgsIGFwcGVuZCwgY2FsbGJhY2sgKVxuXHR7XG5cdFx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdFx0dmFyIHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0dmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XG5cdFx0dmFyIG5leHRTb3J0SWR4O1xuXHRcdHZhciBuZXh0ID0gZnVuY3Rpb24gKCBhLCBvdmVyZmxvdyApIHtcblx0XHRcdHZhciBpZHggPSBhLl9pZHg7XG5cdFx0XHRpZiAoIGlkeCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpZHggPSAkLmluQXJyYXkoIGFbMV0sIGFzU29ydGluZyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBpZHgrMSA8IGFzU29ydGluZy5sZW5ndGggP1xuXHRcdFx0XHRpZHgrMSA6XG5cdFx0XHRcdG92ZXJmbG93ID9cblx0XHRcdFx0XHRudWxsIDpcblx0XHRcdFx0XHQwO1xuXHRcdH07XG5cdFxuXHRcdC8vIENvbnZlcnQgdG8gMkQgYXJyYXkgaWYgbmVlZGVkXG5cdFx0aWYgKCB0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nID0gWyBzb3J0aW5nIF07XG5cdFx0fVxuXHRcblx0XHQvLyBJZiBhcHBlbmRpbmcgdGhlIHNvcnQgdGhlbiB3ZSBhcmUgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHRpZiAoIGFwcGVuZCAmJiBzZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnRNdWx0aSApIHtcblx0XHRcdC8vIEFyZSB3ZSBhbHJlYWR5IGRvaW5nIHNvbWUga2luZCBvZiBzb3J0IG9uIHRoaXMgY29sdW1uP1xuXHRcdFx0dmFyIHNvcnRJZHggPSAkLmluQXJyYXkoIGNvbElkeCwgX3BsdWNrKHNvcnRpbmcsICcwJykgKTtcblx0XG5cdFx0XHRpZiAoIHNvcnRJZHggIT09IC0xICkge1xuXHRcdFx0XHQvLyBZZXMsIG1vZGlmeSB0aGUgc29ydFxuXHRcdFx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbc29ydElkeF0sIHRydWUgKTtcblx0XG5cdFx0XHRcdGlmICggbmV4dFNvcnRJZHggPT09IG51bGwgJiYgc29ydGluZy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0bmV4dFNvcnRJZHggPSAwOyAvLyBjYW4ndCByZW1vdmUgc29ydGluZyBjb21wbGV0ZWx5XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmICggbmV4dFNvcnRJZHggPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0c29ydGluZy5zcGxpY2UoIHNvcnRJZHgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdFx0XHRcdHNvcnRpbmdbc29ydElkeF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gTm8gc29ydCBvbiB0aGlzIGNvbHVtbiB5ZXRcblx0XHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdLCAwIF0gKTtcblx0XHRcdFx0c29ydGluZ1tzb3J0aW5nLmxlbmd0aC0xXS5faWR4ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNvcnRpbmcubGVuZ3RoICYmIHNvcnRpbmdbMF1bMF0gPT0gY29sSWR4ICkge1xuXHRcdFx0Ly8gU2luZ2xlIGNvbHVtbiAtIGFscmVhZHkgc29ydGluZyBvbiB0aGlzIGNvbHVtbiwgbW9kaWZ5IHRoZSBzb3J0XG5cdFx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbMF0gKTtcblx0XG5cdFx0XHRzb3J0aW5nLmxlbmd0aCA9IDE7XG5cdFx0XHRzb3J0aW5nWzBdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdFx0c29ydGluZ1swXS5faWR4ID0gbmV4dFNvcnRJZHg7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gU2luZ2xlIGNvbHVtbiAtIHNvcnQgb25seSBvbiB0aGlzIGNvbHVtblxuXHRcdFx0c29ydGluZy5sZW5ndGggPSAwO1xuXHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdIF0gKTtcblx0XHRcdHNvcnRpbmdbMF0uX2lkeCA9IDA7XG5cdFx0fVxuXHRcblx0XHQvLyBSdW4gdGhlIHNvcnQgYnkgY2FsbGluZyBhIGZ1bGwgcmVkcmF3XG5cdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBjYWxsYmFjayB1c2VkIGZvciBhc3luYyB1c2VyIGludGVyYWN0aW9uXG5cdFx0aWYgKCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGNhbGxiYWNrKCBzZXR0aW5ncyApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRhY2ggYSBzb3J0IGhhbmRsZXIgKGNsaWNrKSB0byBhIG5vZGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIgKCBzZXR0aW5ncywgYXR0YWNoVG8sIGNvbElkeCwgY2FsbGJhY2sgKVxuXHR7XG5cdFx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdFxuXHRcdF9mbkJpbmRBY3Rpb24oIGF0dGFjaFRvLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdC8qIElmIHRoZSBjb2x1bW4gaXMgbm90IHNvcnRhYmxlIC0gZG9uJ3QgdG8gYW55dGhpbmcgKi9cblx0XHRcdGlmICggY29sLmJTb3J0YWJsZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBJZiBwcm9jZXNzaW5nIGlzIGVuYWJsZWQgdXNlIGEgdGltZW91dCB0byBhbGxvdyB0aGUgcHJvY2Vzc2luZ1xuXHRcdFx0Ly8gZGlzcGxheSB0byBiZSBzaG93biAtIG90aGVyd2lzZSB0byBpdCBzeW5jaHJvbm91c2x5XG5cdFx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZyApIHtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfZm5Tb3J0TGlzdGVuZXIoIHNldHRpbmdzLCBjb2xJZHgsIGUuc2hpZnRLZXksIGNhbGxiYWNrICk7XG5cdFxuXHRcdFx0XHRcdC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIHRoZSBkcmF3IGNhbGxiYWNrIHdpbGwgcmVtb3ZlIHRoZVxuXHRcdFx0XHRcdC8vIHByb2Nlc3NpbmcgZGlzcGxheVxuXHRcdFx0XHRcdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSAhPT0gJ3NzcCcgKSB7XG5cdFx0XHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0X2ZuU29ydExpc3RlbmVyKCBzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIHNvcnRpbmcgY2xhc3NlcyBvbiB0YWJsZSdzIGJvZHksIE5vdGU6IGl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXG5cdCAqIHdoZW4gYlNvcnQgYW5kIGJTb3J0Q2xhc3NlcyBhcmUgZmFsc2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBvbGRTb3J0ID0gc2V0dGluZ3MuYUxhc3RTb3J0O1xuXHRcdHZhciBzb3J0Q2xhc3MgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5zU29ydENvbHVtbjtcblx0XHR2YXIgc29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblx0XHR2YXIgaSwgaWVuLCBjb2xJZHg7XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYlNvcnQgJiYgZmVhdHVyZXMuYlNvcnRDbGFzc2VzICkge1xuXHRcdFx0Ly8gUmVtb3ZlIG9sZCBzb3J0aW5nIGNsYXNzZXNcblx0XHRcdGZvciAoIGk9MCwgaWVuPW9sZFNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGNvbElkeCA9IG9sZFNvcnRbaV0uc3JjO1xuXHRcblx0XHRcdFx0Ly8gUmVtb3ZlIGNvbHVtbiBzb3J0aW5nXG5cdFx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFkZCBuZXcgY29sdW1uIHNvcnRpbmdcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGNvbElkeCA9IHNvcnRbaV0uc3JjO1xuXHRcblx0XHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggc29ydENsYXNzICsgKGk8MiA/IGkrMSA6IDMpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5hTGFzdFNvcnQgPSBzb3J0O1xuXHR9XG5cdFxuXHRcblx0Ly8gR2V0IHRoZSBkYXRhIHRvIHNvcnQgYSBjb2x1bW4sIGJlIGl0IGZyb20gY2FjaGUsIGZyZXNoIChwb3B1bGF0aW5nIHRoZVxuXHQvLyBjYWNoZSksIG9yIGZyb20gYSBzb3J0IGZvcm1hdHRlclxuXHRmdW5jdGlvbiBfZm5Tb3J0RGF0YSggc2V0dGluZ3MsIGlkeCApXG5cdHtcblx0XHQvLyBDdXN0b20gc29ydGluZyBmdW5jdGlvbiAtIHByb3ZpZGVkIGJ5IHRoZSBzb3J0IGRhdGEgdHlwZVxuXHRcdHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGlkeCBdO1xuXHRcdHZhciBjdXN0b21Tb3J0ID0gRGF0YVRhYmxlLmV4dC5vcmRlclsgY29sdW1uLnNTb3J0RGF0YVR5cGUgXTtcblx0XHR2YXIgY3VzdG9tRGF0YTtcblx0XG5cdFx0aWYgKCBjdXN0b21Tb3J0ICkge1xuXHRcdFx0Y3VzdG9tRGF0YSA9IGN1c3RvbVNvcnQuY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgaWR4LFxuXHRcdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGlkeCApXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0Ly8gVXNlIC8gcG9wdWxhdGUgY2FjaGVcblx0XHR2YXIgcm93LCBjZWxsRGF0YTtcblx0XHR2YXIgZm9ybWF0dGVyID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyWyBjb2x1bW4uc1R5cGUrXCItcHJlXCIgXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hU29ydERhdGEgKSB7XG5cdFx0XHRcdHJvdy5fYVNvcnREYXRhID0gW107XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhW2lkeF0gfHwgY3VzdG9tU29ydCApIHtcblx0XHRcdFx0Y2VsbERhdGEgPSBjdXN0b21Tb3J0ID9cblx0XHRcdFx0XHRjdXN0b21EYXRhW2ldIDogLy8gSWYgdGhlcmUgd2FzIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24sIHVzZSBkYXRhIGZyb20gdGhlcmVcblx0XHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIGksIGlkeCwgJ3NvcnQnICk7XG5cdFxuXHRcdFx0XHRyb3cuX2FTb3J0RGF0YVsgaWR4IF0gPSBmb3JtYXR0ZXIgP1xuXHRcdFx0XHRcdGZvcm1hdHRlciggY2VsbERhdGEgKSA6XG5cdFx0XHRcdFx0Y2VsbERhdGE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTYXZlIHRoZSBzdGF0ZSBvZiBhIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNhdmVTdGF0ZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdGlmICggIXNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlIHx8IHNldHRpbmdzLmJEZXN0cm95aW5nIClcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBTdG9yZSB0aGUgaW50ZXJlc3RpbmcgdmFyaWFibGVzICovXG5cdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0dGltZTogICAgK25ldyBEYXRlKCksXG5cdFx0XHRzdGFydDogICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbmd0aDogIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdG9yZGVyOiAgICQuZXh0ZW5kKCB0cnVlLCBbXSwgc2V0dGluZ3MuYWFTb3J0aW5nICksXG5cdFx0XHRzZWFyY2g6ICBfZm5TZWFyY2hUb0NhbWVsKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKSxcblx0XHRcdGNvbHVtbnM6ICQubWFwKCBzZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggY29sLCBpICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZpc2libGU6IGNvbC5iVmlzaWJsZSxcblx0XHRcdFx0XHRzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSApXG5cdFx0XHRcdH07XG5cdFx0XHR9IClcblx0XHR9O1xuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvU3RhdGVTYXZlUGFyYW1zXCIsICdzdGF0ZVNhdmVQYXJhbXMnLCBbc2V0dGluZ3MsIHN0YXRlXSApO1xuXHRcblx0XHRzZXR0aW5ncy5vU2F2ZWRTdGF0ZSA9IHN0YXRlO1xuXHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgc3RhdGUgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGxvYWQgYSBzYXZlZCB0YWJsZSBzdGF0ZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9Jbml0IERhdGFUYWJsZXMgaW5pdCBvYmplY3Qgc28gd2UgY2FuIG92ZXJyaWRlIHNldHRpbmdzXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Mb2FkU3RhdGUgKCBzZXR0aW5ncywgb0luaXQsIGNhbGxiYWNrIClcblx0e1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGxvYWRlZCA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdGlmICggISBzIHx8ICEgcy50aW1lICkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQWxsb3cgY3VzdG9tIGFuZCBwbHVnLWluIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgdG8gYWx0ZXIgdGhlIHNhdmVkIGRhdGEgc2V0IGFuZFxuXHRcdFx0Ly8gY2FuY2VsbGluZyBvZiBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHRcdFx0dmFyIGFiU3RhdGVMb2FkID0gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc10gKTtcblx0XHRcdGlmICggJC5pbkFycmF5KCBmYWxzZSwgYWJTdGF0ZUxvYWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBSZWplY3Qgb2xkIGRhdGFcblx0XHRcdHZhciBkdXJhdGlvbiA9IHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uO1xuXHRcdFx0aWYgKCBkdXJhdGlvbiA+IDAgJiYgcy50aW1lIDwgK25ldyBEYXRlKCkgLSAoZHVyYXRpb24qMTAwMCkgKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBOdW1iZXIgb2YgY29sdW1ucyBoYXZlIGNoYW5nZWQgLSBhbGwgYmV0cyBhcmUgb2ZmLCBubyByZXN0b3JlIG9mIHNldHRpbmdzXG5cdFx0XHRpZiAoIHMuY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCAhPT0gcy5jb2x1bW5zLmxlbmd0aCApIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFN0b3JlIHRoZSBzYXZlZCBzdGF0ZSBzbyBpdCBtaWdodCBiZSBhY2Nlc3NlZCBhdCBhbnkgdGltZVxuXHRcdFx0c2V0dGluZ3Mub0xvYWRlZFN0YXRlID0gJC5leHRlbmQoIHRydWUsIHt9LCBzICk7XG5cdFxuXHRcdFx0Ly8gUmVzdG9yZSBrZXkgZmVhdHVyZXMgLSB0b2RvIC0gZm9yIDEuMTEgdGhpcyBuZWVkcyB0byBiZSBkb25lIGJ5XG5cdFx0XHQvLyBzdWJzY3JpYmVkIGV2ZW50c1xuXHRcdFx0aWYgKCBzLnN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICAgID0gcy5zdGFydDtcblx0XHRcdFx0c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBzLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBzLmxlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggICA9IHMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE9yZGVyXG5cdFx0XHRpZiAoIHMub3JkZXIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG5cdFx0XHRcdCQuZWFjaCggcy5vcmRlciwgZnVuY3Rpb24gKCBpLCBjb2wgKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nLnB1c2goIGNvbFswXSA+PSBjb2x1bW5zLmxlbmd0aCA/XG5cdFx0XHRcdFx0XHRbIDAsIGNvbFsxXSBdIDpcblx0XHRcdFx0XHRcdGNvbFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWFyY2hcblx0XHRcdGlmICggcy5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0JC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgX2ZuU2VhcmNoVG9IdW5nKCBzLnNlYXJjaCApICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ29sdW1uc1xuXHRcdFx0Ly9cblx0XHRcdGlmICggcy5jb2x1bW5zICkge1xuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1zLmNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFyIGNvbCA9IHMuY29sdW1uc1tpXTtcblx0XG5cdFx0XHRcdFx0Ly8gVmlzaWJpbGl0eVxuXHRcdFx0XHRcdGlmICggY29sLnZpc2libGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGNvbHVtbnNbaV0uYlZpc2libGUgPSBjb2wudmlzaWJsZTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFNlYXJjaFxuXHRcdFx0XHRcdGlmICggY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0JC5leHRlbmQoIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSwgX2ZuU2VhcmNoVG9IdW5nKCBjb2wuc2VhcmNoICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsICdzdGF0ZUxvYWRlZCcsIFtzZXR0aW5ncywgc10gKTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlICkge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciBzdGF0ZSA9IHNldHRpbmdzLmZuU3RhdGVMb2FkQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgbG9hZGVkICk7XG5cdFxuXHRcdGlmICggc3RhdGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGxvYWRlZCggc3RhdGUgKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbG9hZGVkIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgcGFydGljdWxhciB0YWJsZVxuXHQgKiAgQHBhcmFtIHtub2RlfSB0YWJsZSB0YWJsZSB3ZSBhcmUgdXNpbmcgYXMgYSBkYXRhVGFibGVcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IFNldHRpbmdzIG9iamVjdCAtIG9yIG51bGwgaWYgbm90IGZvdW5kXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNldHRpbmdzRnJvbU5vZGUgKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggdGFibGUsIF9wbHVjayggc2V0dGluZ3MsICduVGFibGUnICkgKTtcblx0XG5cdFx0cmV0dXJuIGlkeCAhPT0gLTEgP1xuXHRcdFx0c2V0dGluZ3NbIGlkeCBdIDpcblx0XHRcdG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTG9nIGFuIGVycm9yIG1lc3NhZ2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2Vcblx0ICogIEBwYXJhbSB7aW50fSB0biBUZWNobmljYWwgbm90ZSBpZCB0byBnZXQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkxvZyggc2V0dGluZ3MsIGxldmVsLCBtc2csIHRuIClcblx0e1xuXHRcdG1zZyA9ICdEYXRhVGFibGVzIHdhcm5pbmc6ICcrXG5cdFx0XHQoc2V0dGluZ3MgPyAndGFibGUgaWQ9JytzZXR0aW5ncy5zVGFibGVJZCsnIC0gJyA6ICcnKSttc2c7XG5cdFxuXHRcdGlmICggdG4gKSB7XG5cdFx0XHRtc2cgKz0gJy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBlcnJvciwgcGxlYXNlIHNlZSAnK1xuXHRcdFx0J2h0dHA6Ly9kYXRhdGFibGVzLm5ldC90bi8nK3RuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAhIGxldmVsICApIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSAxLjEwXG5cdFx0XHR2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcblx0XHRcdHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xuXHRcblx0XHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdlcnJvcicsIFsgc2V0dGluZ3MsIHRuLCBtc2cgXSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggdHlwZSA9PSAnYWxlcnQnICkge1xuXHRcdFx0XHRhbGVydCggbXNnICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PSAndGhyb3cnICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR0eXBlKCBzZXR0aW5ncywgdG4sIG1zZyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cgKSB7XG5cdFx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSByZXQgdGFyZ2V0IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBzb3VyY2Ugb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFttYXBwZWROYW1lXSBuYW1lIHRvIG1hcCB0b28gLSBvcHRpb25hbCwgbmFtZSB1c2VkIGlmIG5vdCBnaXZlblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5NYXAoIHJldCwgc3JjLCBuYW1lLCBtYXBwZWROYW1lIClcblx0e1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0JC5lYWNoKCBuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0X2ZuTWFwKCByZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggbWFwcGVkTmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bWFwcGVkTmFtZSA9IG5hbWU7XG5cdFx0fVxuXHRcblx0XHRpZiAoIHNyY1tuYW1lXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBFeHRlbmQgb2JqZWN0cyAtIHZlcnkgc2ltaWxhciB0byBqUXVlcnkuZXh0ZW5kLCBidXQgZGVlcCBjb3B5IG9iamVjdHMsIGFuZFxuXHQgKiBzaGFsbG93IGNvcHkgYXJyYXlzLiBUaGUgcmVhc29uIHdlIG5lZWQgdG8gZG8gdGhpcywgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvXG5cdCAqIGRlZXAgY29weSBhcnJheSBpbml0IHZhbHVlcyAoc3VjaCBhcyBhYVNvcnRpbmcpIHNpbmNlIHRoZSBkZXYgd291bGRuJ3QgYmVcblx0ICogYWJsZSB0byBvdmVycmlkZSB0aGVtLCBidXQgd2UgZG8gd2FudCB0byBkZWVwIGNvcHkgYXJyYXlzLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG91dCBPYmplY3QgdG8gZXh0ZW5kXG5cdCAqICBAcGFyYW0ge29iamVjdH0gZXh0ZW5kZXIgT2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnRpZXMgd2lsbCBiZSBhcHBsaWVkIHRvXG5cdCAqICAgICAgb3V0XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGJyZWFrUmVmcyBJZiB0cnVlLCB0aGVuIGFycmF5cyB3aWxsIGJlIHNsaWNlZCB0byB0YWtlIGFuXG5cdCAqICAgICAgaW5kZXBlbmRlbnQgY29weSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIGBkYXRhYCBvciBgYWFEYXRhYCBwYXJhbWV0ZXJzXG5cdCAqICAgICAgaWYgdGhleSBhcmUgcHJlc2VudC4gVGhpcyBpcyBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjb2xsZWN0aW9uIHRvXG5cdCAqICAgICAgRGF0YVRhYmxlcyBhbmQgaGF2ZSB0aGF0IHVzZWQgYXMgeW91ciBkYXRhIHNvdXJjZSB3aXRob3V0IGJyZWFraW5nIHRoZVxuXHQgKiAgICAgIHJlZmVyZW5jZXNcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IG91dCBSZWZlcmVuY2UsIGp1c3QgZm9yIGNvbnZlbmllbmNlIC0gb3V0ID09PSB0aGUgcmV0dXJuLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqICBAdG9kbyBUaGlzIGRvZXNuJ3QgdGFrZSBhY2NvdW50IG9mIGFycmF5cyBpbnNpZGUgdGhlIGRlZXAgY29waWVkIG9iamVjdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5FeHRlbmQoIG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcyApXG5cdHtcblx0XHR2YXIgdmFsO1xuXHRcblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBleHRlbmRlciApIHtcblx0XHRcdGlmICggZXh0ZW5kZXIuaGFzT3duUHJvcGVydHkocHJvcCkgKSB7XG5cdFx0XHRcdHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xuXHRcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbCApICkge1xuXHRcdFx0XHRcdGlmICggISAkLmlzUGxhaW5PYmplY3QoIG91dFtwcm9wXSApICkge1xuXHRcdFx0XHRcdFx0b3V0W3Byb3BdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvdXRbcHJvcF0sIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBicmVha1JlZnMgJiYgcHJvcCAhPT0gJ2RhdGEnICYmIHByb3AgIT09ICdhYURhdGEnICYmIEFycmF5LmlzQXJyYXkodmFsKSApIHtcblx0XHRcdFx0XHRvdXRbcHJvcF0gPSB2YWwuc2xpY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvdXRbcHJvcF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQmluZCBhbiBldmVudCBoYW5kZXJzIHRvIGFsbG93IGEgY2xpY2sgb3IgcmV0dXJuIGtleSB0byBhY3RpdmF0ZSB0aGUgY2FsbGJhY2suXG5cdCAqIFRoaXMgaXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSBzaW5jZSBhIHJldHVybiBvbiB0aGUga2V5Ym9hcmQgd2lsbCBoYXZlIHRoZVxuXHQgKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXG5cdCAqICBAcGFyYW0ge2VsZW1lbnR9IG4gRWxlbWVudCB0byBiaW5kIHRoZSBhY3Rpb24gdG9cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvRGF0YSBEYXRhIG9iamVjdCB0byBwYXNzIHRvIHRoZSB0cmlnZ2VyZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQmluZEFjdGlvbiggbiwgb0RhdGEsIGZuIClcblx0e1xuXHRcdCQobilcblx0XHRcdC5vbiggJ2NsaWNrLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0JChuKS50cmlnZ2VyKCdibHVyJyk7IC8vIFJlbW92ZSBmb2N1cyBvdXRsaW5lIGZvciBtb3VzZSB1c2Vyc1xuXHRcdFx0XHRcdGZuKGUpO1xuXHRcdFx0XHR9IClcblx0XHRcdC5vbiggJ2tleXByZXNzLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKXtcblx0XHRcdFx0XHRpZiAoIGUud2hpY2ggPT09IDEzICkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0Zm4oZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IClcblx0XHRcdC5vbiggJ3NlbGVjdHN0YXJ0LkRUJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8qIFRha2UgdGhlIGJydXRhbCBhcHByb2FjaCB0byBjYW5jZWxsaW5nIHRleHQgc2VsZWN0aW9uICovXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG5cdCAqIGFuIGFycmF5IHN0b3JlIG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGNhbiB0aGVuIGFsbCBiZSBjYWxsZWQgdG9nZXRoZXIuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1N0b3JlIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW4gb1NldHRpbmdzXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYmFja1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNOYW1lIElkZW50aWZ5aW5nIG5hbWUgZm9yIHRoZSBjYWxsYmFjayAoaS5lLiBhIGxhYmVsKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCBzU3RvcmUsIGZuLCBzTmFtZSApXG5cdHtcblx0XHRpZiAoIGZuIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3Nbc1N0b3JlXS5wdXNoKCB7XG5cdFx0XHRcdFwiZm5cIjogZm4sXG5cdFx0XHRcdFwic05hbWVcIjogc05hbWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcblx0ICogY2FsbGJhY2sgYXJyYXkgc3RvcmUgaXMgZG9uZSBiYWNrd2FyZHMhIEZ1cnRoZXIgbm90ZSB0aGF0IHlvdSBkbyBub3Qgd2FudCB0b1xuXHQgKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXG5cdCAqIGFzIGl0cyBzbG93LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxuXHQgKiAgICAgIG9TZXR0aW5nc1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBqUXVlcnkgY3VzdG9tIGV2ZW50IHRvIHRyaWdnZXIuIElmXG5cdCAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXG5cdCAqICAgICAgdHJpZ2dlclxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBjYWxsYmFja0FyciwgZXZlbnROYW1lLCBhcmdzIClcblx0e1xuXHRcdHZhciByZXQgPSBbXTtcblx0XG5cdFx0aWYgKCBjYWxsYmFja0FyciApIHtcblx0XHRcdHJldCA9ICQubWFwKCBzZXR0aW5nc1tjYWxsYmFja0Fycl0uc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uICh2YWwsIGkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbC5mbi5hcHBseSggc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGV2ZW50TmFtZSAhPT0gbnVsbCApIHtcblx0XHRcdHZhciBlID0gJC5FdmVudCggZXZlbnROYW1lKycuZHQnICk7XG5cdFxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLnRyaWdnZXIoIGUsIGFyZ3MgKTtcblx0XG5cdFx0XHRyZXQucHVzaCggZS5yZXN1bHQgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXQ7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5MZW5ndGhPdmVyZmxvdyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdFx0bGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoO1xuXHRcblx0XHQvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG5cdFx0aWYgKCBzdGFydCA+PSBlbmQgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gZW5kIC0gbGVuO1xuXHRcdH1cblx0XG5cdFx0Ly8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRzdGFydCAtPSAoc3RhcnQgJSBsZW4pO1xuXHRcblx0XHRpZiAoIGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCB0eXBlIClcblx0e1xuXHRcdHZhciByZW5kZXJlciA9IHNldHRpbmdzLnJlbmRlcmVyO1xuXHRcdHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblx0XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHJlbmRlcmVyICkgJiYgcmVuZGVyZXJbdHlwZV0gKSB7XG5cdFx0XHQvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG5cdFx0XHQvLyB0aGUgZGVmYXVsdC5cblx0XHRcdHJldHVybiBob3N0W3JlbmRlcmVyW3R5cGVdXSB8fCBob3N0Ll87XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgcmVuZGVyZXIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0Ly8gQ29tbW9uIHJlbmRlcmVyIC0gaWYgdGhlcmUgaXMgb25lIGF2YWlsYWJsZSBmb3IgdGhpcyB0eXBlIHVzZSBpdCxcblx0XHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcblx0XHRcdHJldHVybiBob3N0W3JlbmRlcmVyXSB8fCBob3N0Ll87XG5cdFx0fVxuXHRcblx0XHQvLyBVc2UgdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gaG9zdC5fO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVjdCB0aGUgZGF0YSBzb3VyY2UgYmVpbmcgdXNlZCBmb3IgdGhlIHRhYmxlLiBVc2VkIHRvIHNpbXBsaWZ5IHRoZSBjb2RlXG5cdCAqIGEgbGl0dGxlIChhamF4KSBhbmQgdG8gbWFrZSBpdCBjb21wcmVzcyBhIGxpdHRsZSBzbWFsbGVyLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBEYXRhIHNvdXJjZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EYXRhU291cmNlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0XHRyZXR1cm4gJ3NzcCc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZXR0aW5ncy5hamF4IHx8IHNldHRpbmdzLnNBamF4U291cmNlICkge1xuXHRcdFx0cmV0dXJuICdhamF4Jztcblx0XHR9XG5cdFx0cmV0dXJuICdkb20nO1xuXHR9XG5cdFxuXG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbXB1dGVkIHN0cnVjdHVyZSBvZiB0aGUgRGF0YVRhYmxlcyBBUEksIGRlZmluZWQgYnkgdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG5cdCAqIGBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKClgIHdoZW4gYnVpbGRpbmcgdGhlIEFQSS5cblx0ICpcblx0ICogVGhlIHN0cnVjdHVyZSBpcyBidWlsdCBpbiBvcmRlciB0byBzcGVlZCBjcmVhdGlvbiBhbmQgZXh0ZW5zaW9uIG9mIHRoZSBBcGlcblx0ICogb2JqZWN0cyBzaW5jZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZWZmZWN0aXZlbHkgcHJlLXBhcnNlZC5cblx0ICpcblx0ICogVGhlIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSwgd2hlcmUgdGhpc1xuXHQgKiBiYXNlIGFycmF5IHJlcHJlc2VudHMgdGhlIEFwaSBwcm90b3R5cGUgYmFzZTpcblx0ICpcblx0ICogICAgIFtcblx0ICogICAgICAge1xuXHQgKiAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuXHQgKiAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG5cdCAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuXHQgKiAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG5cdCAqICAgICAgIH0sXG5cdCAqICAgICAgIHtcblx0ICogICAgICAgICBuYW1lOiAgICAgJ3Jvdydcblx0ICogICAgICAgICB2YWw6ICAgICAgIHt9LFxuXHQgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0ICogICAgICAgICBwcm9wRXh0OiAgIFtcblx0ICogICAgICAgICAgIHtcblx0ICogICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcblx0ICogICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcblx0ICogICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQgKiAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cblx0ICogICAgICAgICAgIH0sXG5cdCAqICAgICAgICAgICAuLi5cblx0ICogICAgICAgICBdXG5cdCAqICAgICAgIH1cblx0ICogICAgIF1cblx0ICpcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX19hcGlTdHJ1Y3QgPSBbXTtcblx0XG5cdFxuXHQvKipcblx0ICogYEFycmF5LnByb3RvdHlwZWAgcmVmZXJlbmNlLlxuXHQgKlxuXHQgKiBAdHlwZSBvYmplY3Rcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0XG5cdFxuXHQvKipcblx0ICogQWJzdHJhY3Rpb24gZm9yIGBjb250ZXh0YCBwYXJhbWV0ZXIgb2YgdGhlIGBBcGlgIGNvbnN0cnVjdG9yIHRvIGFsbG93IGl0IHRvXG5cdCAqIHRha2Ugc2V2ZXJhbCBkaWZmZXJlbnQgZm9ybXMgZm9yIGVhc2Ugb2YgdXNlLlxuXHQgKlxuXHQgKiBFYWNoIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdHlwZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhVGFibGVzIHNldHRpbmdzXG5cdCAqIG9iamVjdCB3aGVyZSBwb3NzaWJsZS5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfG5vZGV8alF1ZXJ5fG9iamVjdH0gbWl4ZWQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIENhbiBiZSBvbmVcblx0ICogICBvZjpcblx0ICpcblx0ICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdCAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuXHQgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG5cdCAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuXHQgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgICogYERhdGFUYWJsZXMuQXBpYCAtIEFQSSBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHthcnJheXxudWxsfSBNYXRjaGluZyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuIGBudWxsYCBvclxuXHQgKiAgIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIGlmIG5vIG1hdGNoaW5nIERhdGFUYWJsZSBpcyBmb3VuZC5cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF90b1NldHRpbmdzID0gZnVuY3Rpb24gKCBtaXhlZCApXG5cdHtcblx0XHR2YXIgaWR4LCBqcTtcblx0XHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0dmFyIHRhYmxlcyA9ICQubWFwKCBzZXR0aW5ncywgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gZWwublRhYmxlO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCAhIG1peGVkICkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQublRhYmxlICYmIG1peGVkLm9BcGkgKSB7XG5cdFx0XHQvLyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0cmV0dXJuIFsgbWl4ZWQgXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScgKSB7XG5cdFx0XHQvLyBUYWJsZSBub2RlXG5cdFx0XHRpZHggPSAkLmluQXJyYXkoIG1peGVkLCB0YWJsZXMgKTtcblx0XHRcdHJldHVybiBpZHggIT09IC0xID8gWyBzZXR0aW5nc1tpZHhdIF0gOiBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIG1peGVkLnNldHRpbmdzKCkudG9BcnJheSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIG1peGVkID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIGpRdWVyeSBzZWxlY3RvclxuXHRcdFx0anEgPSAkKG1peGVkKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkIGluc3RhbmNlb2YgJCApIHtcblx0XHRcdC8vIGpRdWVyeSBvYmplY3QgKGFsc28gRGF0YVRhYmxlcyBpbnN0YW5jZSlcblx0XHRcdGpxID0gbWl4ZWQ7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGpxICkge1xuXHRcdFx0cmV0dXJuIGpxLm1hcCggZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRpZHggPSAkLmluQXJyYXkoIHRoaXMsIHRhYmxlcyApO1xuXHRcdFx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IHNldHRpbmdzW2lkeF0gOiBudWxsO1xuXHRcdFx0fSApLnRvQXJyYXkoKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcblx0ICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXG5cdCAqXG5cdCAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXG5cdCAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcblx0ICogYSBcImNvbnRleHRcIiAtIGkuZS4gdGhlIHRhYmxlcyB0aGF0IGl0IHdpbGwgb3BlcmF0ZSBvbi4gVGhpcyBjb3VsZCBiZSBhIHNpbmdsZVxuXHQgKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWxseSB0aGUgQVBJIGlzIGRlc2lnbmVkIHRvIGFsbG93IHlvdSB0byBlYXNpbHkgd29yayB3aXRoIHRoZSBkYXRhIGluXG5cdCAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XG5cdCAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBhcnJheSBkZXBlbmQgdXBvbiB0aGUgYWN0aW9ucyByZXF1ZXN0ZWQgYnkgZWFjaCBtZXRob2QgKGZvciBleGFtcGxlXG5cdCAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXG5cdCAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3Ncblx0ICogY29uZmlndXJhdGlvbikuIFRoZSBBUEkgb2JqZWN0IGhhcyBhIG51bWJlciBvZiBhcnJheSBsaWtlIG1ldGhvZHMgKGBwdXNoYCxcblx0ICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxuXHQgKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXG5cdCAqXG5cdCAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcblx0ICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxuXHQgKiB0b3AgbGV2ZWwgb2JqZWN0IGhhZC4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3byBjYWxscyBhcmUgZXF1aXZhbGVudDpcblx0ICpcblx0ICogICAgIC8vIE5vdCBjaGFpbmVkXG5cdCAqICAgICBhcGkucm93LmFkZCggey4uLn0gKTtcblx0ICogICAgIGFwaS5kcmF3KCk7XG5cdCAqXG5cdCAqICAgICAvLyBDaGFpbmVkXG5cdCAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBEYXRhVGFibGUuQXBpXG5cdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcblx0ICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXG5cdCAqICAgQ2FuIGJlIG9uZSBvZjpcblx0ICpcblx0ICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdCAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuXHQgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG5cdCAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuXHQgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXG5cdCAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3Rcblx0ICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5hcGkoKTtcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBJbml0aWFsaXNhdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG5cdCAqICAgdmFyIGFwaSA9IG5ldyAkLmZuLkRhdGFUYWJsZS5BcGkoICd0YWJsZS5kYXRhVGFibGUnICk7XG5cdCAqL1xuXHRfQXBpID0gZnVuY3Rpb24gKCBjb250ZXh0LCBkYXRhIClcblx0e1xuXHRcdGlmICggISAodGhpcyBpbnN0YW5jZW9mIF9BcGkpICkge1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCBjb250ZXh0LCBkYXRhICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2V0dGluZ3MgPSBbXTtcblx0XHR2YXIgY3R4U2V0dGluZ3MgPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHR2YXIgYSA9IF90b1NldHRpbmdzKCBvICk7XG5cdFx0XHRpZiAoIGEgKSB7XG5cdFx0XHRcdHNldHRpbmdzLnB1c2guYXBwbHkoIHNldHRpbmdzLCBhICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49Y29udGV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y3R4U2V0dGluZ3MoIGNvbnRleHRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHR0aGlzLmNvbnRleHQgPSBfdW5pcXVlKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJbml0aWFsIGRhdGFcblx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHQkLm1lcmdlKCB0aGlzLCBkYXRhICk7XG5cdFx0fVxuXHRcblx0XHQvLyBzZWxlY3RvclxuXHRcdHRoaXMuc2VsZWN0b3IgPSB7XG5cdFx0XHRyb3dzOiBudWxsLFxuXHRcdFx0Y29sczogbnVsbCxcblx0XHRcdG9wdHM6IG51bGxcblx0XHR9O1xuXHRcblx0XHRfQXBpLmV4dGVuZCggdGhpcywgdGhpcywgX19hcGlTdHJ1Y3QgKTtcblx0fTtcblx0XG5cdERhdGFUYWJsZS5BcGkgPSBfQXBpO1xuXHRcblx0Ly8gRG9uJ3QgZGVzdHJveSB0aGUgZXhpc3RpbmcgcHJvdG90eXBlLCBqdXN0IGV4dGVuZCBpdC4gUmVxdWlyZWQgZm9yIGpRdWVyeSAyJ3Ncblx0Ly8gaXNQbGFpbk9iamVjdC5cblx0JC5leHRlbmQoIF9BcGkucHJvdG90eXBlLCB7XG5cdFx0YW55OiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNvdW50KCkgIT09IDA7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGNvbmNhdDogIF9fYXJyYXlQcm90by5jb25jYXQsXG5cdFxuXHRcblx0XHRjb250ZXh0OiBbXSwgLy8gYXJyYXkgb2YgdGFibGUgc2V0dGluZ3Mgb2JqZWN0c1xuXHRcblx0XG5cdFx0Y291bnQ6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XG5cdFx0ZWFjaDogZnVuY3Rpb24gKCBmbiApXG5cdFx0e1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW47IGkrKyApIHtcblx0XHRcdFx0Zm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRlcTogZnVuY3Rpb24gKCBpZHggKVxuXHRcdHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggPiBpZHggP1xuXHRcdFx0XHRuZXcgX0FwaSggY3R4W2lkeF0sIHRoaXNbaWR4XSApIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9LFxuXHRcblx0XG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiAoIGZuIClcblx0XHR7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHRcdGlmICggX19hcnJheVByb3RvLmZpbHRlciApIHtcblx0XHRcdFx0YSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCggdGhpcywgZm4sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHRoaXNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRmbGF0dGVuOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYS5jb25jYXQuYXBwbHkoIGEsIHRoaXMudG9BcnJheSgpICkgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0am9pbjogICAgX19hcnJheVByb3RvLmpvaW4sXG5cdFxuXHRcblx0XHRpbmRleE9mOiBfX2FycmF5UHJvdG8uaW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0XHR7XG5cdFx0XHRmb3IgKCB2YXIgaT0oc3RhcnQgfHwgMCksIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHRoaXNbaV0gPT09IG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH0sXG5cdFxuXHRcdGl0ZXJhdG9yOiBmdW5jdGlvbiAoIGZsYXR0ZW4sIHR5cGUsIGZuLCBhbHdheXNOZXcgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0YSA9IFtdLCByZXQsXG5cdFx0XHRcdGksIGllbiwgaiwgamVuLFxuXHRcdFx0XHRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuXHRcdFx0XHRyb3dzLCBpdGVtcywgaXRlbSxcblx0XHRcdFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXHRcblx0XHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0XHRpZiAoIHR5cGVvZiBmbGF0dGVuID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWx3YXlzTmV3ID0gZm47XG5cdFx0XHRcdGZuID0gdHlwZTtcblx0XHRcdFx0dHlwZSA9IGZsYXR0ZW47XG5cdFx0XHRcdGZsYXR0ZW4gPSBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKCBjb250ZXh0W2ldICk7XG5cdFxuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICd0YWJsZScgKSB7XG5cdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaSApO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW5zJyB8fCB0eXBlID09PSAncm93cycgKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBoYXMgc2FtZSBsZW5ndGggYXMgY29udGV4dCAtIG9uZSBlbnRyeSBmb3IgZWFjaCB0YWJsZVxuXHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkgKTtcblx0XG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnY29sdW1uJyB8fCB0eXBlID09PSAnY29sdW1uLXJvd3MnIHx8IHR5cGUgPT09ICdyb3cnIHx8IHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHQvLyBjb2x1bW5zIGFuZCByb3dzIHNoYXJlIHRoZSBzYW1lIHN0cnVjdHVyZS5cblx0XHRcdFx0XHQvLyAndGhpcycgaXMgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgZm9yIGVhY2ggY29udGV4dFxuXHRcdFx0XHRcdGl0ZW1zID0gdGhpc1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY29sdW1uLXJvd3MnICkge1xuXHRcdFx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggY29udGV4dFtpXSwgc2VsZWN0b3Iub3B0cyApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Zm9yICggaj0wLCBqZW49aXRlbXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRpdGVtID0gaXRlbXNbal07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggYS5sZW5ndGggfHwgYWx3YXlzTmV3ICkge1xuXHRcdFx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIGNvbnRleHQsIGZsYXR0ZW4gPyBhLmNvbmNhdC5hcHBseSggW10sIGEgKSA6IGEgKTtcblx0XHRcdFx0dmFyIGFwaVNlbGVjdG9yID0gYXBpLnNlbGVjdG9yO1xuXHRcdFx0XHRhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcblx0XHRcdFx0YXBpU2VsZWN0b3IuY29scyA9IHNlbGVjdG9yLmNvbHM7XG5cdFx0XHRcdGFwaVNlbGVjdG9yLm9wdHMgPSBzZWxlY3Rvci5vcHRzO1xuXHRcdFx0XHRyZXR1cm4gYXBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGxhc3RJbmRleE9mOiBfX2FycmF5UHJvdG8ubGFzdEluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpXG5cdFx0e1xuXHRcdFx0Ly8gQml0IGNoZWVreS4uLlxuXHRcdFx0cmV0dXJuIHRoaXMuaW5kZXhPZi5hcHBseSggdGhpcy50b0FycmF5LnJldmVyc2UoKSwgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGxlbmd0aDogIDAsXG5cdFxuXHRcblx0XHRtYXA6IGZ1bmN0aW9uICggZm4gKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFxuXHRcdFx0aWYgKCBfX2FycmF5UHJvdG8ubWFwICkge1xuXHRcdFx0XHRhID0gX19hcnJheVByb3RvLm1hcC5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhLnB1c2goIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0cGx1Y2s6IGZ1bmN0aW9uICggcHJvcCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbiAoIGVsICkge1xuXHRcdFx0XHRyZXR1cm4gZWxbIHByb3AgXTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXHRcblx0XHRwb3A6ICAgICBfX2FycmF5UHJvdG8ucG9wLFxuXHRcblx0XG5cdFx0cHVzaDogICAgX19hcnJheVByb3RvLnB1c2gsXG5cdFxuXHRcblx0XHQvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXG5cdFx0cmVkdWNlOiBfX2FycmF5UHJvdG8ucmVkdWNlIHx8IGZ1bmN0aW9uICggZm4sIGluaXQgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCAwLCB0aGlzLmxlbmd0aCwgMSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRyZWR1Y2VSaWdodDogX19hcnJheVByb3RvLnJlZHVjZVJpZ2h0IHx8IGZ1bmN0aW9uICggZm4sIGluaXQgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCB0aGlzLmxlbmd0aC0xLCAtMSwgLTEgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0cmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXG5cdFxuXHRcblx0XHQvLyBPYmplY3Qgd2l0aCByb3dzLCBjb2x1bW5zIGFuZCBvcHRzXG5cdFx0c2VsZWN0b3I6IG51bGwsXG5cdFxuXHRcblx0XHRzaGlmdDogICBfX2FycmF5UHJvdG8uc2hpZnQsXG5cdFxuXHRcblx0XHRzbGljZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0c29ydDogICAgX19hcnJheVByb3RvLnNvcnQsIC8vID8gbmFtZSAtIG9yZGVyP1xuXHRcblx0XG5cdFx0c3BsaWNlOiAgX19hcnJheVByb3RvLnNwbGljZSxcblx0XG5cdFxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9fYXJyYXlQcm90by5zbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHRvJDogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR0b0pRdWVyeTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR1bmlxdWU6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIF91bmlxdWUodGhpcykgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dW5zaGlmdDogX19hcnJheVByb3RvLnVuc2hpZnRcblx0fSApO1xuXHRcblx0XG5cdF9BcGkuZXh0ZW5kID0gZnVuY3Rpb24gKCBzY29wZSwgb2JqLCBleHQgKVxuXHR7XG5cdFx0Ly8gT25seSBleHRlbmQgQVBJIGluc3RhbmNlcyBhbmQgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEFQSVxuXHRcdGlmICggISBleHQubGVuZ3RoIHx8ICEgb2JqIHx8ICggISAob2JqIGluc3RhbmNlb2YgX0FwaSkgJiYgISBvYmouX19kdF93cmFwcGVyICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGksIGllbixcblx0XHRcdHN0cnVjdCxcblx0XHRcdG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IGZuLmFwcGx5KCBzY29wZSwgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0XHRcdC8vIE1ldGhvZCBleHRlbnNpb25cblx0XHRcdFx0XHRfQXBpLmV4dGVuZCggcmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCApO1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cdFxuXHRcdFx0Ly8gVmFsdWVcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHN0cnVjdC50eXBlID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0bWV0aG9kU2NvcGluZyggc2NvcGUsIHN0cnVjdC52YWwsIHN0cnVjdCApIDpcblx0XHRcdFx0c3RydWN0LnR5cGUgPT09ICdvYmplY3QnID9cblx0XHRcdFx0XHR7fSA6XG5cdFx0XHRcdFx0c3RydWN0LnZhbDtcblx0XG5cdFx0XHRvYmpbIHN0cnVjdC5uYW1lIF0uX19kdF93cmFwcGVyID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBQcm9wZXJ0eSBleHRlbnNpb25cblx0XHRcdF9BcGkuZXh0ZW5kKCBzY29wZSwgb2JqWyBzdHJ1Y3QubmFtZSBdLCBzdHJ1Y3QucHJvcEV4dCApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvLyBAdG9kbyAtIElzIHRoZXJlIG5lZWQgZm9yIGFuIGF1Z21lbnQgZnVuY3Rpb24/XG5cdC8vIF9BcGkuYXVnbWVudCA9IGZ1bmN0aW9uICggaW5zdCwgbmFtZSApXG5cdC8vIHtcblx0Ly8gXHQvLyBGaW5kIHNyYyBvYmplY3QgaW4gdGhlIHN0cnVjdHVyZSBmcm9tIHRoZSBuYW1lXG5cdC8vIFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcblx0Ly8gXHRfQXBpLmV4dGVuZCggaW5zdCwgb2JqICk7XG5cdC8vIH07XG5cdFxuXHRcblx0Ly8gICAgIFtcblx0Ly8gICAgICAge1xuXHQvLyAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuXHQvLyAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG5cdC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuXHQvLyAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG5cdC8vICAgICAgIH0sXG5cdC8vICAgICAgIHtcblx0Ly8gICAgICAgICBuYW1lOiAgICAgJ3Jvdydcblx0Ly8gICAgICAgICB2YWw6ICAgICAgIHt9LFxuXHQvLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0Ly8gICAgICAgICBwcm9wRXh0OiAgIFtcblx0Ly8gICAgICAgICAgIHtcblx0Ly8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcblx0Ly8gICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcblx0Ly8gICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQvLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cblx0Ly8gICAgICAgICAgIH0sXG5cdC8vICAgICAgICAgICAuLi5cblx0Ly8gICAgICAgICBdXG5cdC8vICAgICAgIH1cblx0Ly8gICAgIF1cblx0XG5cdF9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKCBuYW1lLCB2YWwgKVxuXHR7XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49bmFtZS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0X0FwaS5yZWdpc3RlciggbmFtZVtqXSwgdmFsICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGksIGllbixcblx0XHRcdGhlaXIgPSBuYW1lLnNwbGl0KCcuJyksXG5cdFx0XHRzdHJ1Y3QgPSBfX2FwaVN0cnVjdCxcblx0XHRcdGtleSwgbWV0aG9kO1xuXHRcblx0XHR2YXIgZmluZCA9IGZ1bmN0aW9uICggc3JjLCBuYW1lICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNyYy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzcmNbaV0ubmFtZSA9PT0gbmFtZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1oZWlyLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0bWV0aG9kID0gaGVpcltpXS5pbmRleE9mKCcoKScpICE9PSAtMTtcblx0XHRcdGtleSA9IG1ldGhvZCA/XG5cdFx0XHRcdGhlaXJbaV0ucmVwbGFjZSgnKCknLCAnJykgOlxuXHRcdFx0XHRoZWlyW2ldO1xuXHRcblx0XHRcdHZhciBzcmMgPSBmaW5kKCBzdHJ1Y3QsIGtleSApO1xuXHRcdFx0aWYgKCAhIHNyYyApIHtcblx0XHRcdFx0c3JjID0ge1xuXHRcdFx0XHRcdG5hbWU6ICAgICAga2V5LFxuXHRcdFx0XHRcdHZhbDogICAgICAge30sXG5cdFx0XHRcdFx0bWV0aG9kRXh0OiBbXSxcblx0XHRcdFx0XHRwcm9wRXh0OiAgIFtdLFxuXHRcdFx0XHRcdHR5cGU6ICAgICAgJ29iamVjdCdcblx0XHRcdFx0fTtcblx0XHRcdFx0c3RydWN0LnB1c2goIHNyYyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggaSA9PT0gaWVuLTEgKSB7XG5cdFx0XHRcdHNyYy52YWwgPSB2YWw7XG5cdFx0XHRcdHNyYy50eXBlID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdFx0J2Z1bmN0aW9uJyA6XG5cdFx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCB2YWwgKSA/XG5cdFx0XHRcdFx0XHQnb2JqZWN0JyA6XG5cdFx0XHRcdFx0XHQnb3RoZXInO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHN0cnVjdCA9IG1ldGhvZCA/XG5cdFx0XHRcdFx0c3JjLm1ldGhvZEV4dCA6XG5cdFx0XHRcdFx0c3JjLnByb3BFeHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0X0FwaS5yZWdpc3RlclBsdXJhbCA9IF9hcGlfcmVnaXN0ZXJQbHVyYWwgPSBmdW5jdGlvbiAoIHBsdXJhbE5hbWUsIHNpbmd1bGFyTmFtZSwgdmFsICkge1xuXHRcdF9BcGkucmVnaXN0ZXIoIHBsdXJhbE5hbWUsIHZhbCApO1xuXHRcblx0XHRfQXBpLnJlZ2lzdGVyKCBzaW5ndWxhck5hbWUsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciByZXQgPSB2YWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcblx0XHRcdGlmICggcmV0ID09PSB0aGlzICkge1xuXHRcdFx0XHQvLyBSZXR1cm5lZCBpdGVtIGlzIHRoZSBBUEkgaW5zdGFuY2UgdGhhdCB3YXMgcGFzc2VkIGluLCByZXR1cm4gaXRcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcmV0IGluc3RhbmNlb2YgX0FwaSApIHtcblx0XHRcdFx0Ly8gTmV3IEFQSSBpbnN0YW5jZSByZXR1cm5lZCwgd2FudCB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlbVxuXHRcdFx0XHQvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXG5cdFx0XHRcdHJldHVybiByZXQubGVuZ3RoID9cblx0XHRcdFx0XHRBcnJheS5pc0FycmF5KCByZXRbMF0gKSA/XG5cdFx0XHRcdFx0XHRuZXcgX0FwaSggcmV0LmNvbnRleHQsIHJldFswXSApIDogLy8gQXJyYXkgcmVzdWx0cyBhcmUgJ2VuaGFuY2VkJ1xuXHRcdFx0XHRcdFx0cmV0WzBdIDpcblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTm9uLUFQSSByZXR1cm4gLSBqdXN0IGZpcmUgaXQgYmFja1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9ICk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNlbGVjdG9yIGZvciBIVE1MIHRhYmxlcy4gQXBwbHkgdGhlIGdpdmVuIHNlbGVjdG9yIHRvIHRoZSBnaXZlIGFycmF5IG9mXG5cdCAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW3NlbGVjdG9yXSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIG9yIGludGVnZXJcblx0ICogQHBhcmFtICB7YXJyYXl9IEFycmF5IG9mIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cyB0byBiZSBmaWx0ZXJlZFxuXHQgKiBAcmV0dXJuIHthcnJheX1cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fdGFibGVfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNlbGVjdG9yLCBhIClcblx0e1xuXHRcdGlmICggQXJyYXkuaXNBcnJheShzZWxlY3RvcikgKSB7XG5cdFx0XHRyZXR1cm4gJC5tYXAoIHNlbGVjdG9yLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gX190YWJsZV9zZWxlY3RvcihpdGVtLCBhKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdudW1iZXInICkge1xuXHRcdFx0cmV0dXJuIFsgYVsgc2VsZWN0b3IgXSBdO1xuXHRcdH1cblx0XG5cdFx0Ly8gUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgdGFibGUgbm9kZXNcblx0XHR2YXIgbm9kZXMgPSAkLm1hcCggYSwgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gZWwublRhYmxlO1xuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuICQobm9kZXMpXG5cdFx0XHQuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHQvLyBOZWVkIHRvIHRyYW5zbGF0ZSBiYWNrIGZyb20gdGhlIHRhYmxlIG5vZGUgdG8gdGhlIHNldHRpbmdzXG5cdFx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHRoaXMsIG5vZGVzICk7XG5cdFx0XHRcdHJldHVybiBhWyBpZHggXTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblx0fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnRleHQgc2VsZWN0b3IgZm9yIHRoZSBBUEkncyBjb250ZXh0IChpLmUuIHRoZSB0YWJsZXMgdGhlIEFQSSBpbnN0YW5jZVxuXHQgKiByZWZlcnMgdG8uXG5cdCAqXG5cdCAqIEBuYW1lICAgIERhdGFUYWJsZS5BcGkjdGFibGVzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXG5cdCAqICAgc2hvdWxkIG9wZXJhdGUgb24uIElmIG5vdCBnaXZlbiwgYWxsIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGFyZVxuXHQgKiAgIHVzZWQuIFRoaXMgY2FuIGJlIGdpdmVuIGFzIGEgalF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSBgJzpndCgwKSdgKSB0b1xuXHQgKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGUuQXBpfSBSZXR1cm5zIGEgbmV3IEFQSSBpbnN0YW5jZSBpZiBhIHNlbGVjdG9yIGlzIGdpdmVuLlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlcygpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0XHQvLyBBIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGlmIHRoZXJlIHdhcyBhIHNlbGVjdG9yIHNwZWNpZmllZFxuXHRcdHJldHVybiBzZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdG9yICE9PSBudWxsID9cblx0XHRcdG5ldyBfQXBpKCBfX3RhYmxlX3NlbGVjdG9yKCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkgKSA6XG5cdFx0XHR0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuXHRcdHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyggc2VsZWN0b3IgKTtcblx0XHR2YXIgY3R4ID0gdGFibGVzLmNvbnRleHQ7XG5cdFxuXHRcdC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggP1xuXHRcdFx0bmV3IF9BcGkoIGN0eFswXSApIDpcblx0XHRcdHRhYmxlcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ub2RlcygpJywgJ3RhYmxlKCkubm9kZSgpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UYWJsZTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuYm9keSgpJywgJ3RhYmxlKCkuYm9keSgpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UQm9keTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuaGVhZGVyKCknLCAndGFibGUoKS5oZWFkZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVEhlYWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmZvb3RlcigpJywgJ3RhYmxlKCkuZm9vdGVyKCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRGb290O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5jb250YWluZXJzKCknLCAndGFibGUoKS5jb250YWluZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVGFibGVXcmFwcGVyO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogUmVkcmF3IHRoZSB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdkcmF3KCknLCBmdW5jdGlvbiAoIHBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGlmICggcGFnaW5nID09PSAncGFnZScgKSB7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgcGFnaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRwYWdpbmcgPSBwYWdpbmcgPT09ICdmdWxsLWhvbGQnID9cblx0XHRcdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIHBhZ2luZz09PWZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cblx0ICpcblx0ICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkKVxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXG5cdCAqIG5vdCB0aHJvdyBhbiBlcnJvciwgYnV0IHJhdGhlciByZXNldCB0aGUgcGFnaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxuXHQgKiAgKiBgaW50ZWdlcmAgLSBUaGUgcGFnZSBpbmRleCB0byBqdW1wIHRvXG5cdCAqICAqIGBzdHJpbmdgIC0gQW4gYWN0aW9uIHRvIHRha2U6XG5cdCAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cblx0ICogICAgKiBgbmV4dGAgLSBKdW1wIHRvIHRoZSBuZXh0IHBhZ2Vcblx0ICogICAgKiBgcHJldmlvdXNgIC0gSnVtcCB0byBwcmV2aW91cyBwYWdlXG5cdCAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlKCknLCBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0XHRpZiAoIGFjdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFnZS5pbmZvKCkucGFnZTsgLy8gbm90IGFuIGV4cGVuc2l2ZSBjYWxsXG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlLCBoYXZlIGFuIGFjdGlvbiB0byB0YWtlIG9uIGFsbCB0YWJsZXNcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBhY3Rpb24gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogUGFnaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogSWYgeW91IHJlcXVpcmUgcGFnaW5nIGluZm9ybWF0aW9uIGZvciBhbm90aGVyIHRhYmxlLCB1c2UgdGhlIGB0YWJsZSgpYCBtZXRob2Rcblx0ICogd2l0aCBhIHN1aXRhYmxlIHNlbGVjdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBzZXQ6XG5cdCAqICAqIGBwYWdlYCAtIEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZCAtIGkuZS4gdGhlIGZpcnN0IHBhZ2UgaXMgYDBgKVxuXHQgKiAgKiBgcGFnZXNgIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzXG5cdCAqICAqIGBzdGFydGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgZmlyc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0ICogICogYGVuZGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgbGFzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuXHQgKiAgKiBgbGVuZ3RoYCAtIERpc3BsYXkgbGVuZ3RoIChudW1iZXIgb2YgcmVjb3JkcykuIE5vdGUgdGhhdCBnZW5lcmFsbHkgYHN0YXJ0XG5cdCAqICAgICsgbGVuZ3RoID0gZW5kYCwgYnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0cnVlLCBmb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmVcblx0ICogICAgb25seSAyIHJlY29yZHMgdG8gc2hvdyBvbiB0aGUgZmluYWwgcGFnZSwgd2l0aCBhIGxlbmd0aCBvZiAxMC5cblx0ICogICogYHJlY29yZHNUb3RhbGAgLSBGdWxsIGRhdGEgc2V0IGxlbmd0aFxuXHQgKiAgKiBgcmVjb3Jkc0Rpc3BsYXlgIC0gRGF0YSBzZXQgbGVuZ3RoIG9uY2UgdGhlIGN1cnJlbnQgZmlsdGVyaW5nIGNyaXRlcmlvblxuXHQgKiAgICBhcmUgYXBwbGllZC5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlLmluZm8oKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdHNldHRpbmdzICAgPSB0aGlzLmNvbnRleHRbMF0sXG5cdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3Mub0ZlYXR1cmVzLmJQYWdpbmF0ZSA/IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6IC0xLFxuXHRcdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0XCJwYWdlXCI6ICAgICAgICAgICBhbGwgPyAwIDogTWF0aC5mbG9vciggc3RhcnQgLyBsZW4gKSxcblx0XHRcdFwicGFnZXNcIjogICAgICAgICAgYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFx0XCJzdGFydFwiOiAgICAgICAgICBzdGFydCxcblx0XHRcdFwiZW5kXCI6ICAgICAgICAgICAgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRcImxlbmd0aFwiOiAgICAgICAgIGxlbixcblx0XHRcdFwicmVjb3Jkc1RvdGFsXCI6ICAgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcdFwicmVjb3Jkc0Rpc3BsYXlcIjogdmlzUmVjb3Jkcyxcblx0XHRcdFwic2VydmVyU2lkZVwiOiAgICAgX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCdcblx0XHR9O1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cblx0ICpcblx0ICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGxlbmd0aC4gTm90ZSBgLTFgIGluZGljYXRlcyB0aGF0IGFsbCByZWNvcmRzXG5cdCAqICAgYXJlIHRvIGJlIHNob3duLlxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAncGFnZS5sZW4oKScsIGZ1bmN0aW9uICggbGVuICkge1xuXHRcdC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoaXMgZnVuY3Rpb24gJ2xlbmd0aCgpJyBiZWNhdXNlIGBsZW5ndGhgXG5cdFx0Ly8gaXMgYSBKYXZhc2NyaXB0IHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmVzIGhvdyBtYW55IGFyZ3VtZW50c1xuXHRcdC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzLlxuXHRcdGlmICggbGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdHRoaXMuY29udGV4dFswXS5faURpc3BsYXlMZW5ndGggOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlLCBzZXQgdGhlIHBhZ2UgbGVuZ3RoXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCBsZW4gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0dmFyIF9fcmVsb2FkID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uLCBjYWxsYmFjayApIHtcblx0XHQvLyBVc2UgdGhlIGRyYXcgZXZlbnQgdG8gdHJpZ2dlciBhIGNhbGxiYWNrXG5cdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHRhcGkub25lKCAnZHJhdycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y2FsbGJhY2soIGFwaS5hamF4Lmpzb24oKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0Ly8gQ2FuY2VsIGFuIGV4aXN0aW5nIHJlcXVlc3Rcblx0XHRcdHZhciB4aHIgPSBzZXR0aW5ncy5qcVhIUjtcblx0XHRcdGlmICggeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUcmlnZ2VyIHhoclxuXHRcdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywgW10sIGZ1bmN0aW9uKCBqc29uICkge1xuXHRcdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0dmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBsYXN0IEFqYXggcmVxdWVzdCB0aGF0IERhdGFUYWJsZXMgbWFkZSB0byB0aGVcblx0ICogc2VydmVyLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBKU09OIGZyb20gdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50XG5cdCAqIGNvbnRleHQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gSlNPTiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRcdHJldHVybiBjdHhbMF0uanNvbjtcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgc3VibWl0dGVkIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgucGFyYW1zKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRcdHJldHVybiBjdHhbMF0ub0FqYXhEYXRhO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlbG9hZCB0YWJsZXMgZnJvbSB0aGUgQWpheCBkYXRhIHNvdXJjZS4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlLWRyYXcgdGhlIHRhYmxlIHdoZW4gdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9dHJ1ZV0gUmVzZXQgKGRlZmF1bHQpIG9yIGhvbGQgdGhlIGN1cnJlbnQgcGFnaW5nXG5cdCAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcblx0ICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgucmVsb2FkKCknLCBmdW5jdGlvbiAoIGNhbGxiYWNrLCByZXNldFBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG5cdFx0XHRfX3JlbG9hZCggc2V0dGluZ3MsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgVVJMIGZyb20gdGhlIGZpcnN0XG5cdCAqIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBBamF4IHNvdXJjZSBVUkxcblx0ICovLyoqXG5cdCAqIFNldCB0aGUgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2V0IHRoZSBVUkwgZm9yIGFsbCB0YWJsZXMgaW4gdGhlXG5cdCAqIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpJywgZnVuY3Rpb24gKCB1cmwgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGdldFxuXHRcdFx0aWYgKCBjdHgubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Y3R4ID0gY3R4WzBdO1xuXHRcblx0XHRcdHJldHVybiBjdHguYWpheCA/XG5cdFx0XHRcdCQuaXNQbGFpbk9iamVjdCggY3R4LmFqYXggKSA/XG5cdFx0XHRcdFx0Y3R4LmFqYXgudXJsIDpcblx0XHRcdFx0XHRjdHguYWpheCA6XG5cdFx0XHRcdGN0eC5zQWpheFNvdXJjZTtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKSApIHtcblx0XHRcdFx0c2V0dGluZ3MuYWpheC51cmwgPSB1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2V0dGluZ3MuYWpheCA9IHVybDtcblx0XHRcdH1cblx0XHRcdC8vIE5vIG5lZWQgdG8gY29uc2lkZXIgc0FqYXhTb3VyY2UgaGVyZSBzaW5jZSBEYXRhVGFibGVzIGdpdmVzIHByaW9yaXR5XG5cdFx0XHQvLyB0byBgYWpheGAgb3ZlciBgc0FqYXhTb3VyY2VgLiBTbyBzZXR0aW5nIGBhamF4YCBoZXJlLCByZW5kZXJzIGFueVxuXHRcdFx0Ly8gdmFsdWUgb2YgYHNBamF4U291cmNlYCByZWR1bmRhbnQuXG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIExvYWQgZGF0YSBmcm9tIHRoZSBuZXdseSBzZXQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5XG5cdCAqIGF2YWlsYWJsZSB3aGVuIGBhamF4LnVybCgpYCBpcyB1c2VkIHRvIHNldCBhIFVSTC4gQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZFxuXHQgKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGNhbGxpbmcgYGFqYXgucmVsb2FkKClgIGJ1dCBpcyBwcm92aWRlZCBmb3Jcblx0ICogY29udmVuaWVuY2Ugd2hlbiBzZXR0aW5nIGEgbmV3IFVSTC4gTGlrZSBgYWpheC5yZWxvYWQoKWAgaXQgd2lsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyB0aGUgdGFibGUgb25jZSB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpLmxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRcdC8vIFNhbWUgYXMgYSByZWxvYWQsIGJ1dCBtYWtlcyBzZW5zZSB0byBwcmVzZW50IGl0IGZvciBlYXN5IGFjY2VzcyBhZnRlciBhXG5cdFx0Ly8gdXJsIGNoYW5nZVxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdF9fcmVsb2FkKCBjdHgsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX3J1biA9IGZ1bmN0aW9uICggdHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cyApXG5cdHtcblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLCByZXMsXG5cdFx0XHRhLCBpLCBpZW4sIGosIGplbixcblx0XHRcdHNlbGVjdG9yVHlwZSA9IHR5cGVvZiBzZWxlY3Rvcjtcblx0XG5cdFx0Ly8gQ2FuJ3QganVzdCBjaGVjayBmb3IgaXNBcnJheSBoZXJlLCBhcyBhbiBBUEkgb3IgalF1ZXJ5IGluc3RhbmNlIG1pZ2h0IGJlXG5cdFx0Ly8gZ2l2ZW4gd2l0aCB0aGVpciBhcnJheSBsaWtlIGxvb2tcblx0XHRpZiAoICEgc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9IFsgc2VsZWN0b3IgXTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPXNlbGVjdG9yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Ly8gT25seSBzcGxpdCBvbiBzaW1wbGUgc3RyaW5ncyAtIGNvbXBsZXggZXhwcmVzc2lvbnMgd2lsbCBiZSBqUXVlcnkgc2VsZWN0b3JzXG5cdFx0XHRhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgJiYgISBzZWxlY3RvcltpXS5tYXRjaCgvW1xcW1xcKDpdLykgP1xuXHRcdFx0XHRzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcblx0XHRcdFx0WyBzZWxlY3RvcltpXSBdO1xuXHRcblx0XHRcdGZvciAoIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHJlcyA9IHNlbGVjdEZuKCB0eXBlb2YgYVtqXSA9PT0gJ3N0cmluZycgPyAoYVtqXSkudHJpbSgpIDogYVtqXSApO1xuXHRcblx0XHRcdFx0aWYgKCByZXMgJiYgcmVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRvdXQgPSBvdXQuY29uY2F0KCByZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gc2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHRcdHZhciBleHQgPSBfZXh0LnNlbGVjdG9yWyB0eXBlIF07XG5cdFx0aWYgKCBleHQubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaT0wLCBpZW49ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRvdXQgPSBleHRbaV0oIHNldHRpbmdzLCBvcHRzLCBvdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBfdW5pcXVlKCBvdXQgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAoIG9wdHMgKVxuXHR7XG5cdFx0aWYgKCAhIG9wdHMgKSB7XG5cdFx0XHRvcHRzID0ge307XG5cdFx0fVxuXHRcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXG5cdFx0Ly8gdGhhbiBzZWFyY2hcblx0XHRpZiAoIG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICQuZXh0ZW5kKCB7XG5cdFx0XHRzZWFyY2g6ICdub25lJyxcblx0XHRcdG9yZGVyOiAnY3VycmVudCcsXG5cdFx0XHRwYWdlOiAnYWxsJ1xuXHRcdH0sIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKCBpbnN0IClcblx0e1xuXHRcdC8vIFJlZHVjZSB0aGUgQVBJIGluc3RhbmNlIHRvIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWluc3QubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGluc3RbaV0ubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0Ly8gQXNzaWduIHRoZSBmaXJzdCBlbGVtZW50IHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBpbnN0YW5jZVxuXHRcdFx0XHQvLyBhbmQgdHJ1bmNhdGUgdGhlIGluc3RhbmNlIGFuZCBjb250ZXh0XG5cdFx0XHRcdGluc3RbMF0gPSBpbnN0W2ldO1xuXHRcdFx0XHRpbnN0WzBdLmxlbmd0aCA9IDE7XG5cdFx0XHRcdGluc3QubGVuZ3RoID0gMTtcblx0XHRcdFx0aW5zdC5jb250ZXh0ID0gWyBpbnN0LmNvbnRleHRbaV0gXTtcblx0XG5cdFx0XHRcdHJldHVybiBpbnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gTm90IGZvdW5kIC0gcmV0dXJuIGFuIGVtcHR5IGluc3RhbmNlXG5cdFx0aW5zdC5sZW5ndGggPSAwO1xuXHRcdHJldHVybiBpbnN0O1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3Jfcm93X2luZGV4ZXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSwgaWVuLCB0bXAsIGE9W10sXG5cdFx0XHRkaXNwbGF5RmlsdGVyZWQgPSBzZXR0aW5ncy5haURpc3BsYXksXG5cdFx0XHRkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHRcblx0XHR2YXJcblx0XHRcdHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuXHRcdFx0b3JkZXIgID0gb3B0cy5vcmRlciwgICAvLyBhcHBsaWVkLCBjdXJyZW50LCBpbmRleCAob3JpZ2luYWwgLSBjb21wYXRpYmlsaXR5IHdpdGggMS45KVxuXHRcdFx0cGFnZSAgID0gb3B0cy5wYWdlOyAgICAvLyBhbGwsIGN1cnJlbnRcblx0XG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdFx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlLCBtb3N0IG9wdGlvbnMgYXJlIGlycmVsZXZhbnQgc2luY2Vcblx0XHRcdC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcblx0XHRcdC8vIFJlbW92ZWQgaXMgYSBzcGVjaWFsIGNhc2UgLSBmb3IgY29uc2lzdGVuY3kganVzdCByZXR1cm4gYW4gZW1wdHlcblx0XHRcdC8vIGFycmF5XG5cdFx0XHRyZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuXHRcdFx0XHRbXSA6XG5cdFx0XHRcdF9yYW5nZSggMCwgZGlzcGxheU1hc3Rlci5sZW5ndGggKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHBhZ2UgPT0gJ2N1cnJlbnQnICkge1xuXHRcdFx0Ly8gQ3VycmVudCBwYWdlIGltcGxpZXMgdGhhdCBvcmRlcj1jdXJyZW50IGFuZCBmaXRsZXI9YXBwbGllZCwgc2luY2UgaXQgaXNcblx0XHRcdC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxuXHRcdFx0Ly8gYXJlXG5cdFx0XHRmb3IgKCBpPXNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LCBpZW49c2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YS5wdXNoKCBkaXNwbGF5RmlsdGVyZWRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcgKSB7XG5cdFx0XHRpZiAoIHNlYXJjaCA9PSAnbm9uZScpIHtcblx0XHRcdFx0YSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWFyY2ggPT0gJ2FwcGxpZWQnICkge1xuXHRcdFx0XHRhID0gZGlzcGxheUZpbHRlcmVkLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VhcmNoID09ICdyZW1vdmVkJyApIHtcblx0XHRcdFx0Ly8gTyhuK20pIHNvbHV0aW9uIGJ5IGNyZWF0aW5nIGEgaGFzaCBtYXBcblx0XHRcdFx0dmFyIGRpc3BsYXlGaWx0ZXJlZE1hcCA9IHt9O1xuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRpc3BsYXlGaWx0ZXJlZC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRkaXNwbGF5RmlsdGVyZWRNYXBbZGlzcGxheUZpbHRlcmVkW2ldXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGEgPSAkLm1hcCggZGlzcGxheU1hc3RlciwgZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEgZGlzcGxheUZpbHRlcmVkTWFwLmhhc093blByb3BlcnR5KGVsKSA/XG5cdFx0XHRcdFx0XHRlbCA6XG5cdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcmRlciA9PSAnaW5kZXgnIHx8IG9yZGVyID09ICdvcmlnaW5hbCcgKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2VhcmNoID09ICdub25lJyApIHtcblx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcblx0XHRcdFx0XHR0bXAgPSAkLmluQXJyYXkoIGksIGRpc3BsYXlGaWx0ZXJlZCApO1xuXHRcblx0XHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHRcdCh0bXAgPj0gMCAgICYmIHNlYXJjaCA9PSAnYXBwbGllZCcpIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcblx0XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBSb3dzXG5cdCAqXG5cdCAqIHt9ICAgICAgICAgIC0gbm8gc2VsZWN0b3IgLSB1c2UgYWxsIGF2YWlsYWJsZSByb3dzXG5cdCAqIHtpbnRlZ2VyfSAgIC0gcm93IGFvRGF0YSBpbmRleFxuXHQgKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcblx0ICoge3N0cmluZ30gICAgLSBqUXVlcnkgc2VsZWN0b3IgdG8gYXBwbHkgdG8gdGhlIFRSIGVsZW1lbnRzXG5cdCAqIHthcnJheX0gICAgIC0galF1ZXJ5IGFycmF5IG9mIG5vZGVzLCBvciBzaW1wbHkgYW4gYXJyYXkgb2YgVFIgbm9kZXNcblx0ICpcblx0ICovXG5cdHZhciBfX3Jvd19zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhciByb3dzO1xuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIHNlbCApIHtcblx0XHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzZWwgKTtcblx0XHRcdHZhciBpLCBpZW47XG5cdFx0XHR2YXIgYW9EYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcblx0XHRcdC8vIFNob3J0IGN1dCAtIHNlbGVjdG9yIGlzIGEgbnVtYmVyIGFuZCBubyBvcHRpb25zIHByb3ZpZGVkIChkZWZhdWx0IGlzXG5cdFx0XHQvLyBhbGwgcmVjb3Jkcywgc28gbm8gbmVlZCB0byBjaGVjayBpZiB0aGUgaW5kZXggaXMgaW4gdGhlcmUsIHNpbmNlIGl0XG5cdFx0XHQvLyBtdXN0IGJlIC0gZGV2IGVycm9yIGlmIHRoZSBpbmRleCBkb2Vzbid0IGV4aXN0KS5cblx0XHRcdGlmICggc2VsSW50ICE9PSBudWxsICYmICEgb3B0cyApIHtcblx0XHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCAhIHJvd3MgKSB7XG5cdFx0XHRcdHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgJC5pbkFycmF5KCBzZWxJbnQsIHJvd3MgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIFNlbGVjdG9yIC0gaW50ZWdlclxuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWwgPT09IG51bGwgfHwgc2VsID09PSB1bmRlZmluZWQgfHwgc2VsID09PSAnJyApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBub25lXG5cdFx0XHRcdHJldHVybiByb3dzO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cblx0XHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuICQubWFwKCByb3dzLCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdFx0dmFyIHJvdyA9IGFvRGF0YVsgaWR4IF07XG5cdFx0XHRcdFx0cmV0dXJuIHNlbCggaWR4LCByb3cuX2FEYXRhLCByb3cublRyICkgPyBpZHggOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBub2RlXG5cdFx0XHRpZiAoIHNlbC5ub2RlTmFtZSApIHtcblx0XHRcdFx0dmFyIHJvd0lkeCA9IHNlbC5fRFRfUm93SW5kZXg7ICAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcblx0XHRcdFx0dmFyIGNlbGxJZHggPSBzZWwuX0RUX0NlbGxJbmRleDtcblx0XG5cdFx0XHRcdGlmICggcm93SWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIHJvdyBpcyBhY3R1YWxseSBzdGlsbCBwcmVzZW50IGluIHRoZSB0YWJsZVxuXHRcdFx0XHRcdHJldHVybiBhb0RhdGFbIHJvd0lkeCBdICYmIGFvRGF0YVsgcm93SWR4IF0ublRyID09PSBzZWwgP1xuXHRcdFx0XHRcdFx0WyByb3dJZHggXSA6XG5cdFx0XHRcdFx0XHRbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggY2VsbElkeCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYW9EYXRhWyBjZWxsSWR4LnJvdyBdICYmIGFvRGF0YVsgY2VsbElkeC5yb3cgXS5uVHIgPT09IHNlbC5wYXJlbnROb2RlID9cblx0XHRcdFx0XHRcdFsgY2VsbElkeC5yb3cgXSA6XG5cdFx0XHRcdFx0XHRbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgaG9zdCA9ICQoc2VsKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0XHRcdHJldHVybiBob3N0Lmxlbmd0aCA/XG5cdFx0XHRcdFx0XHRbIGhvc3QuZGF0YSgnZHQtcm93JykgXSA6XG5cdFx0XHRcdFx0XHRbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIElEIHNlbGVjdG9yLiBXYW50IHRvIGFsd2F5cyBiZSBhYmxlIHRvIHNlbGVjdCByb3dzIGJ5IGlkLCByZWdhcmRsZXNzXG5cdFx0XHQvLyBvZiBpZiB0aGUgdHIgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIG5vdCwgc28gY2FuJ3QgcmVseSB1cG9uXG5cdFx0XHQvLyBqUXVlcnkgaGVyZSAtIGhlbmNlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLiBUaGlzIGRvZXMgbm90IG1hdGNoXG5cdFx0XHQvLyBTaXp6bGUncyBmYXN0IHNlbGVjdG9yIG9yIEhUTUw0IC0gaW4gSFRNTDUgdGhlIElEIGNhbiBiZSBhbnl0aGluZyxcblx0XHRcdC8vIGJ1dCB0byBzZWxlY3QgaXQgdXNpbmcgYSBDU1Mgc2VsZWN0b3IgZW5naW5lIChsaWtlIFNpenpsZSBvclxuXHRcdFx0Ly8gcXVlcnlTZWxlY3QpIGl0IHdvdWxkIG5lZWQgdG8gbmVlZCB0byBiZSBlc2NhcGVkIGZvciBzb21lIGNoYXJhY3RlcnMuXG5cdFx0XHQvLyBEYXRhVGFibGVzIHNpbXBsaWZpZXMgdGhpcyBmb3Igcm93IHNlbGVjdG9ycyBzaW5jZSB5b3UgY2FuIHNlbGVjdFxuXHRcdFx0Ly8gb25seSBhIHJvdy4gQSAjIGluZGljYXRlcyBhbiBpZCBhbnkgYW55dGhpbmcgdGhhdCBmb2xsb3dzIGlzIHRoZSBpZCAtXG5cdFx0XHQvLyB1bmVzY2FwZWQuXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWwgPT09ICdzdHJpbmcnICYmIHNlbC5jaGFyQXQoMCkgPT09ICcjJyApIHtcblx0XHRcdFx0Ly8gZ2V0IHJvdyBpbmRleCBmcm9tIGlkXG5cdFx0XHRcdHZhciByb3dPYmogPSBzZXR0aW5ncy5hSWRzWyBzZWwucmVwbGFjZSggL14jLywgJycgKSBdO1xuXHRcdFx0XHRpZiAoIHJvd09iaiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBbIHJvd09iai5pZHggXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gbmVlZCB0byBmYWxsIHRocm91Z2ggdG8galF1ZXJ5IGluIGNhc2UgdGhlcmUgaXMgRE9NIGlkIHRoYXRcblx0XHRcdFx0Ly8gbWF0Y2hlc1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcblx0XHRcdHZhciBub2RlcyA9IF9yZW1vdmVFbXB0eShcblx0XHRcdFx0X3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICduVHInIClcblx0XHRcdCk7XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nLCBhcnJheSBvZiBub2RlcyBvciBqUXVlcnkgb2JqZWN0L1xuXHRcdFx0Ly8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxuXHRcdFx0Ly8gaXQgYWxzbyBhbGxvd3MgYXJyYXlzLCBzbyB0aGlzIHdpbGwgY29wZSB3aXRoIGFsbCB0aHJlZSBvcHRpb25zXG5cdFx0XHRyZXR1cm4gJChub2Rlcylcblx0XHRcdFx0LmZpbHRlciggc2VsIClcblx0XHRcdFx0Lm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9EVF9Sb3dJbmRleDtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9ydW4oICdyb3cnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcblx0XHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblx0XG5cdFx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9fcm93X3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX19yb3dfc2VsZWN0b3I/XG5cdFx0aW5zdC5zZWxlY3Rvci5yb3dzID0gc2VsZWN0b3I7XG5cdFx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblx0XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdLm5UciB8fCB1bmRlZmluZWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cygpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggdHJ1ZSwgJ3Jvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3dzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnX2FEYXRhJyApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5jYWNoZSgpJywgJ3JvdygpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHR2YXIgciA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ3NlYXJjaCcgPyByLl9hRmlsdGVyRGF0YSA6IHIuX2FTb3J0RGF0YTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW52YWxpZGF0ZSgpJywgJ3JvdygpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uICggc3JjICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0X2ZuSW52YWxpZGF0ZSggc2V0dGluZ3MsIHJvdywgc3JjICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmluZGV4ZXMoKScsICdyb3coKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0cmV0dXJuIHJvdztcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaWRzKCknLCAncm93KCkuaWQoKScsIGZ1bmN0aW9uICggaGFzaCApIHtcblx0XHR2YXIgYSA9IFtdO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHQvLyBgaXRlcmF0b3JgIHdpbGwgZHJvcCB1bmRlZmluZWQgdmFsdWVzLCBidXQgaW4gdGhpcyBjYXNlIHdlIHdhbnQgdGhlbVxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgamVuPXRoaXNbaV0ubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHZhciBpZCA9IGNvbnRleHRbaV0ucm93SWRGbiggY29udGV4dFtpXS5hb0RhdGFbIHRoaXNbaV1bal0gXS5fYURhdGEgKTtcblx0XHRcdFx0YS5wdXNoKCAoaGFzaCA9PT0gdHJ1ZSA/ICcjJyA6ICcnICkrIGlkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbmV3IF9BcGkoIGNvbnRleHQsIGEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5yZW1vdmUoKScsICdyb3coKS5yZW1vdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFxuXHRcdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIHRoYXRJZHggKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHRcdHZhciByb3dEYXRhID0gZGF0YVsgcm93IF07XG5cdFx0XHR2YXIgaSwgaWVuLCBqLCBqZW47XG5cdFx0XHR2YXIgbG9vcFJvdywgbG9vcENlbGxzO1xuXHRcblx0XHRcdGRhdGEuc3BsaWNlKCByb3csIDEgKTtcblx0XG5cdFx0XHQvLyBVcGRhdGUgdGhlIGNhY2hlZCBpbmRleGVzXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRsb29wUm93ID0gZGF0YVtpXTtcblx0XHRcdFx0bG9vcENlbGxzID0gbG9vcFJvdy5hbkNlbGxzO1xuXHRcblx0XHRcdFx0Ly8gUm93c1xuXHRcdFx0XHRpZiAoIGxvb3BSb3cublRyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdGxvb3BSb3cublRyLl9EVF9Sb3dJbmRleCA9IGk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIENlbGxzXG5cdFx0XHRcdGlmICggbG9vcENlbGxzICE9PSBudWxsICkge1xuXHRcdFx0XHRcdGZvciAoIGo9MCwgamVuPWxvb3BDZWxscy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdGxvb3BDZWxsc1tqXS5fRFRfQ2VsbEluZGV4LnJvdyA9IGk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRGVsZXRlIGZyb20gdGhlIGRpc3BsYXkgYXJyYXlzXG5cdFx0XHRfZm5EZWxldGVJbmRleCggc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLCByb3cgKTtcblx0XHRcdF9mbkRlbGV0ZUluZGV4KCBzZXR0aW5ncy5haURpc3BsYXksIHJvdyApO1xuXHRcdFx0X2ZuRGVsZXRlSW5kZXgoIHRoYXRbIHRoYXRJZHggXSwgcm93LCBmYWxzZSApOyAvLyBtYWludGFpbiBsb2NhbCBpbmRleGVzXG5cdFxuXHRcdFx0Ly8gRm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzIC0gc3VidHJhY3QgdGhlIGRlbGV0ZWQgcm93IGZyb20gdGhlIGNvdW50XG5cdFx0XHRpZiAoIHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPiAwICkge1xuXHRcdFx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5LS07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGFuICdvdmVyZmxvdycgdGhleSBjYXNlIGZvciBkaXNwbGF5aW5nIHRoZSB0YWJsZVxuXHRcdFx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSByb3cncyBJRCByZWZlcmVuY2UgaWYgdGhlcmUgaXMgb25lXG5cdFx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCByb3dEYXRhLl9hRGF0YSApO1xuXHRcdFx0aWYgKCBpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgc2V0dGluZ3MuYUlkc1sgaWQgXTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRzZXR0aW5ncy5hb0RhdGFbaV0uaWR4ID0gaTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MuYWRkKCknLCBmdW5jdGlvbiAoIHJvd3MgKSB7XG5cdFx0dmFyIG5ld1Jvd3MgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0XHR2YXIgcm93LCBpLCBpZW47XG5cdFx0XHRcdHZhciBvdXQgPSBbXTtcblx0XG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0cm93ID0gcm93c1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCByb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicgKSB7XG5cdFx0XHRcdFx0XHRvdXQucHVzaCggX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBvdXQ7XG5cdFx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCBzbyByb3dzKCkubm9kZXMoKSBldGMgY2FuIGJlIHVzZWRcblx0XHR2YXIgbW9kUm93cyA9IHRoaXMucm93cyggLTEgKTtcblx0XHRtb2RSb3dzLnBvcCgpO1xuXHRcdCQubWVyZ2UoIG1vZFJvd3MsIG5ld1Jvd3MgKTtcblx0XG5cdFx0cmV0dXJuIG1vZFJvd3M7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0XG5cdFxuXHQvKipcblx0ICpcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5yb3dzKCBzZWxlY3Rvciwgb3B0cyApICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93KCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gR2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fYURhdGEgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBTZXRcblx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdO1xuXHRcdHJvdy5fYURhdGEgPSBkYXRhO1xuXHRcblx0XHQvLyBJZiB0aGUgRE9NIGhhcyBhbiBpZCwgYW5kIHRoZSBkYXRhIHNvdXJjZSBpcyBhbiBhcnJheVxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YSApICYmIHJvdy5uVHIgJiYgcm93Lm5Uci5pZCApIHtcblx0XHRcdF9mblNldE9iamVjdERhdGFGbiggY3R4WzBdLnJvd0lkICkoIGRhdGEsIHJvdy5uVHIuaWQgKTtcblx0XHR9XG5cdFxuXHRcdC8vIEF1dG9tYXRpY2FsbHkgaW52YWxpZGF0ZVxuXHRcdF9mbkludmFsaWRhdGUoIGN0eFswXSwgdGhpc1swXSwgJ2RhdGEnICk7XG5cdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3JvdygpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0ublRyIHx8IG51bGwgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3cuYWRkKCknLCBmdW5jdGlvbiAoIHJvdyApIHtcblx0XHQvLyBBbGxvdyBhIGpRdWVyeSBvYmplY3QgdG8gYmUgcGFzc2VkIGluIC0gb25seSBhIHNpbmdsZSByb3cgaXMgYWRkZWQgZnJvbVxuXHRcdC8vIGl0IHRob3VnaCAtIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcblx0XHRpZiAoIHJvdyBpbnN0YW5jZW9mICQgJiYgcm93Lmxlbmd0aCApIHtcblx0XHRcdHJvdyA9IHJvd1swXTtcblx0XHR9XG5cdFxuXHRcdHZhciByb3dzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGlmICggcm93Lm5vZGVOYW1lICYmIHJvdy5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVFInICkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICk7XG5cdFx0fSApO1xuXHRcblx0XHQvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgcm93IHNlbGVjdGVkXG5cdFx0cmV0dXJuIHRoaXMucm93KCByb3dzWzBdICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19hZGQgPSBmdW5jdGlvbiAoIGN0eCwgcm93LCBkYXRhLCBrbGFzcyApXG5cdHtcblx0XHQvLyBDb252ZXJ0IHRvIGFycmF5IG9mIFRSIGVsZW1lbnRzXG5cdFx0dmFyIHJvd3MgPSBbXTtcblx0XHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCByLCBrICkge1xuXHRcdFx0Ly8gUmVjdXJzaW9uIHRvIGFsbG93IGZvciBhcnJheXMgb2YgalF1ZXJ5IG9iamVjdHNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggciApIHx8IHIgaW5zdGFuY2VvZiAkICkge1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhZGRSb3coIHJbaV0sIGsgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHRcdC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcblx0XHRcdGlmICggci5ub2RlTmFtZSAmJiByLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicgKSB7XG5cdFx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdFx0dmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkPjwvdGQ+PC90cj4nKS5hZGRDbGFzcyggayApO1xuXHRcdFx0XHQkKCd0ZCcsIGNyZWF0ZWQpXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBrIClcblx0XHRcdFx0XHQuaHRtbCggciApXG5cdFx0XHRcdFx0WzBdLmNvbFNwYW4gPSBfZm5WaXNibGVDb2x1bW5zKCBjdHggKTtcblx0XG5cdFx0XHRcdHJvd3MucHVzaCggY3JlYXRlZFswXSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGFkZFJvdyggZGF0YSwga2xhc3MgKTtcblx0XG5cdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRyb3cuX2RldGFpbHMuZGV0YWNoKCk7XG5cdFx0fVxuXHRcblx0XHRyb3cuX2RldGFpbHMgPSAkKHJvd3MpO1xuXHRcblx0XHQvLyBJZiB0aGUgY2hpbGRyZW4gd2VyZSBhbHJlYWR5IHNob3duLCB0aGF0IHN0YXRlIHNob3VsZCBiZSByZXRhaW5lZFxuXHRcdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX3JlbW92ZSA9IGZ1bmN0aW9uICggYXBpLCBpZHggKVxuXHR7XG5cdFx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggKSB7XG5cdFx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgaWR4ICE9PSB1bmRlZmluZWQgPyBpZHggOiBhcGlbMF0gXTtcblx0XG5cdFx0XHRpZiAoIHJvdyAmJiByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRcdHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcblx0XG5cdFx0XHRcdHJvdy5fZGV0YWlsc1Nob3cgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJvdy5fZGV0YWlscyA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19kaXNwbGF5ID0gZnVuY3Rpb24gKCBhcGksIHNob3cgKSB7XG5cdFx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggJiYgYXBpLmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBhcGlbMF0gXTtcblx0XG5cdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHNob3c7XG5cdFxuXHRcdFx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfX2RldGFpbHNfZXZlbnRzKCBjdHhbMF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19ldmVudHMgPSBmdW5jdGlvbiAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblx0XHR2YXIgbmFtZXNwYWNlID0gJy5kdC5EVF9kZXRhaWxzJztcblx0XHR2YXIgZHJhd0V2ZW50ID0gJ2RyYXcnK25hbWVzcGFjZTtcblx0XHR2YXIgY29sdmlzRXZlbnQgPSAnY29sdW1uLXZpc2liaWxpdHknK25hbWVzcGFjZTtcblx0XHR2YXIgZGVzdHJveUV2ZW50ID0gJ2Rlc3Ryb3knK25hbWVzcGFjZTtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XG5cdFx0YXBpLm9mZiggZHJhd0V2ZW50ICsnICcrIGNvbHZpc0V2ZW50ICsnICcrIGRlc3Ryb3lFdmVudCApO1xuXHRcblx0XHRpZiAoIF9wbHVjayggZGF0YSwgJ19kZXRhaWxzJyApLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHQvLyBPbiBlYWNoIGRyYXcsIGluc2VydCB0aGUgcmVxdWlyZWQgZWxlbWVudHMgaW50byB0aGUgZG9jdW1lbnRcblx0XHRcdGFwaS5vbiggZHJhd0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YXBpLnJvd3MoIHtwYWdlOidjdXJyZW50J30gKS5lcSgwKS5lYWNoKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdFx0Ly8gSW50ZXJuYWwgZGF0YSBncmFiXG5cdFx0XHRcdFx0dmFyIHJvdyA9IGRhdGFbIGlkeCBdO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlsc1Nob3cgKSB7XG5cdFx0XHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHQvLyBDb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2UgLSB1cGRhdGUgdGhlIGNvbHNwYW5cblx0XHRcdGFwaS5vbiggY29sdmlzRXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4LCBpZHgsIHZpcyApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBjb2xzcGFuIGZvciB0aGUgZGV0YWlscyByb3dzIChub3RlLCBvbmx5IGlmIGl0IGFscmVhZHkgaGFzXG5cdFx0XHRcdC8vIGEgY29sc3Bhbilcblx0XHRcdFx0dmFyIHJvdywgdmlzaWJsZSA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0cm93ID0gZGF0YVtpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRcdFx0XHRyb3cuX2RldGFpbHMuY2hpbGRyZW4oJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIHZpc2libGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XG5cdFx0XHQvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXG5cdFx0XHRhcGkub24oIGRlc3Ryb3lFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVtpXS5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRcdF9fZGV0YWlsc19yZW1vdmUoIGFwaSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fTtcblx0XG5cdC8vIFN0cmluZ3MgZm9yIHRoZSBtZXRob2QgbmFtZXMgdG8gaGVscCBtaW5pZmljYXRpb25cblx0dmFyIF9lbXAgPSAnJztcblx0dmFyIF9jaGlsZF9vYmogPSBfZW1wKydyb3coKS5jaGlsZCc7XG5cdHZhciBfY2hpbGRfbXRoID0gX2NoaWxkX29iaisnKCknO1xuXHRcblx0Ly8gZGF0YSBjYW4gYmU6XG5cdC8vICB0clxuXHQvLyAgc3RyaW5nXG5cdC8vICBqUXVlcnkgb3IgYXJyYXkgb2YgYW55IG9mIHRoZSBhYm92ZVxuXHRfYXBpX3JlZ2lzdGVyKCBfY2hpbGRfbXRoLCBmdW5jdGlvbiAoIGRhdGEsIGtsYXNzICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlscyA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRhdGEgPT09IHRydWUgKSB7XG5cdFx0XHQvLyBzaG93XG5cdFx0XHR0aGlzLmNoaWxkLnNob3coKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRhdGEgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gcmVtb3ZlXG5cdFx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0Ly8gc2V0XG5cdFx0XHRfX2RldGFpbHNfYWRkKCBjdHhbMF0sIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXSwgZGF0YSwga2xhc3MgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5zaG93KCknLFxuXHRcdF9jaGlsZF9tdGgrJy5zaG93KCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCBzaG93ICkgeyAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIHRydWUgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHRfY2hpbGRfb2JqKycuaGlkZSgpJyxcblx0XHRfY2hpbGRfbXRoKycuaGlkZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5cdF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRcdF9fZGV0YWlsc19kaXNwbGF5KCB0aGlzLCBmYWxzZSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5yZW1vdmUoKScsXG5cdFx0X2NoaWxkX210aCsnLnJlbW92ZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5cdF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX3JlbW92ZSggdGhpcyApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggX2NoaWxkX29iaisnLmlzU2hvd24oKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0XHQvLyBfZGV0YWlsc1Nob3duIGFzIGZhbHNlIG9yIHVuZGVmaW5lZCB3aWxsIGZhbGwgdGhyb3VnaCB0byByZXR1cm4gZmFsc2Vcblx0XHRcdHJldHVybiBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0uX2RldGFpbHNTaG93IHx8IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIENvbHVtbnNcblx0ICpcblx0ICoge2ludGVnZXJ9ICAgICAgICAgICAtIGNvbHVtbiBpbmRleCAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcblx0ICogXCJ7aW50ZWdlcn06dmlzSWR4XCIgIC0gdmlzaWJsZSBjb2x1bW4gaW5kZXggKGkuZS4gdHJhbnNsYXRlIHRvIGNvbHVtbiBpbmRleCkgICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuXHQgKiBcIntpbnRlZ2VyfTp2aXNpYmxlXCIgLSBhbGlhcyBmb3Ige2ludGVnZXJ9OnZpc0lkeCAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG5cdCAqIFwie3N0cmluZ306bmFtZVwiICAgICAtIGNvbHVtbiBuYW1lXG5cdCAqIFwie3N0cmluZ31cIiAgICAgICAgICAtIGpRdWVyeSBzZWxlY3RvciBvbiBjb2x1bW4gaGVhZGVyIG5vZGVzXG5cdCAqXG5cdCAqL1xuXHRcblx0Ly8gY2FuIGJlIGFuIGFycmF5IG9mIHRoZXNlIGl0ZW1zLCBjb21tYSBzZXBhcmF0ZWQgbGlzdCwgb3IgYW4gYXJyYXkgb2YgY29tbWFcblx0Ly8gc2VwYXJhdGVkIGxpc3RzXG5cdFxuXHR2YXIgX19yZV9jb2x1bW5fc2VsZWN0b3IgPSAvXihbXjpdKyk6KG5hbWV8dmlzSWR4fHZpc2libGUpJC87XG5cdFxuXHRcblx0Ly8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXG5cdC8vIGl0ZXJhdG9yIGNhbGxiYWNrIGluIGNvbHVtbnMoKS5kYXRhKClcblx0dmFyIF9fY29sdW1uRGF0YSA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgcjEsIHIyLCByb3dzICkge1xuXHRcdHZhciBhID0gW107XG5cdFx0Zm9yICggdmFyIHJvdz0wLCBpZW49cm93cy5sZW5ndGggOyByb3c8aWVuIDsgcm93KysgKSB7XG5cdFx0XHRhLnB1c2goIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93c1tyb3ddLCBjb2x1bW4gKSApO1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX19jb2x1bW5fc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRuYW1lcyA9IF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApLFxuXHRcdFx0bm9kZXMgPSBfcGx1Y2soIGNvbHVtbnMsICduVGgnICk7XG5cdFxuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHR2YXIgc2VsSW50ID0gX2ludFZhbCggcyApO1xuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gYWxsXG5cdFx0XHRpZiAoIHMgPT09ICcnICkge1xuXHRcdFx0XHRyZXR1cm4gX3JhbmdlKCBjb2x1bW5zLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gaW5kZXhcblx0XHRcdGlmICggc2VsSW50ICE9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgPj0gMCA/XG5cdFx0XHRcdFx0c2VsSW50IDogLy8gQ291bnQgZnJvbSBsZWZ0XG5cdFx0XHRcdFx0Y29sdW1ucy5sZW5ndGggKyBzZWxJbnQgLy8gQ291bnQgZnJvbSByaWdodCAoKyBiZWNhdXNlIGl0cyBhIG5lZ2F0aXZlIHZhbHVlKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yID0gZnVuY3Rpb25cblx0XHRcdGlmICggdHlwZW9mIHMgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcblx0XHRcdFx0cmV0dXJuICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpZHgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcyhcblx0XHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0XHRfX2NvbHVtbkRhdGEoIHNldHRpbmdzLCBpZHgsIDAsIDAsIHJvd3MgKSxcblx0XHRcdFx0XHRcdFx0bm9kZXNbIGlkeCBdXG5cdFx0XHRcdFx0XHQpID8gaWR4IDogbnVsbDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3Jcblx0XHRcdHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdHMubWF0Y2goIF9fcmVfY29sdW1uX3NlbGVjdG9yICkgOlxuXHRcdFx0XHQnJztcblx0XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRzd2l0Y2goIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdGNhc2UgJ3Zpc0lkeCc6XG5cdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XG5cdFx0XHRcdFx0XHR2YXIgaWR4ID0gcGFyc2VJbnQoIG1hdGNoWzFdLCAxMCApO1xuXHRcdFx0XHRcdFx0Ly8gVmlzaWJsZSBpbmRleCBnaXZlbiwgY29udmVydCB0byBjb2x1bW4gaW5kZXhcblx0XHRcdFx0XHRcdGlmICggaWR4IDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgcmlnaHRcblx0XHRcdFx0XHRcdFx0dmFyIHZpc0NvbHVtbnMgPSAkLm1hcCggY29sdW1ucywgZnVuY3Rpb24gKGNvbCxpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbC5iVmlzaWJsZSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIHZpc0NvbHVtbnNbIHZpc0NvbHVtbnMubGVuZ3RoICsgaWR4IF0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENvdW50aW5nIGZyb20gdGhlIGxlZnRcblx0XHRcdFx0XHRcdHJldHVybiBbIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBzZXR0aW5ncywgaWR4ICkgXTtcblx0XG5cdFx0XHRcdFx0Y2FzZSAnbmFtZSc6XG5cdFx0XHRcdFx0XHQvLyBtYXRjaCBieSBuYW1lLiBgbmFtZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0XHRcdHJldHVybiAkLm1hcCggbmFtZXMsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuYW1lID09PSBtYXRjaFsxXSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ2VsbCBpbiB0aGUgdGFibGUgYm9keVxuXHRcdFx0aWYgKCBzLm5vZGVOYW1lICYmIHMuX0RUX0NlbGxJbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIFsgcy5fRFRfQ2VsbEluZGV4LmNvbHVtbiBdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgVEggZWxlbWVudHMgZm9yIHRoZSBjb2x1bW5zXG5cdFx0XHR2YXIganFSZXN1bHQgPSAkKCBub2RlcyApXG5cdFx0XHRcdC5maWx0ZXIoIHMgKVxuXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSggdGhpcywgbm9kZXMgKTsgLy8gYG5vZGVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQudG9BcnJheSgpO1xuXHRcblx0XHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE90aGVyd2lzZSBhIG5vZGUgd2hpY2ggbWlnaHQgaGF2ZSBhIGBkdC1jb2x1bW5gIGRhdGEgYXR0cmlidXRlLCBvciBiZVxuXHRcdFx0Ly8gYSBjaGlsZCBvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdHZhciBob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtY29sdW1uXScpO1xuXHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0WyBob3N0LmRhdGEoJ2R0LWNvbHVtbicpIF0gOlxuXHRcdFx0XHRbXTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NvbHVtbicsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fc2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKSB7XG5cdFx0dmFyXG5cdFx0XHRjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0Y29sICA9IGNvbHNbIGNvbHVtbiBdLFxuXHRcdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YSxcblx0XHRcdHJvdywgY2VsbHMsIGksIGllbiwgdHI7XG5cdFxuXHRcdC8vIEdldFxuXHRcdGlmICggdmlzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gY29sLmJWaXNpYmxlO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2V0XG5cdFx0Ly8gTm8gY2hhbmdlXG5cdFx0aWYgKCBjb2wuYlZpc2libGUgPT09IHZpcyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggdmlzICkge1xuXHRcdFx0Ly8gSW5zZXJ0IGNvbHVtblxuXHRcdFx0Ly8gTmVlZCB0byBkZWNpZGUgaWYgd2Ugc2hvdWxkIHVzZSBhcHBlbmRDaGlsZCBvciBpbnNlcnRCZWZvcmVcblx0XHRcdHZhciBpbnNlcnRCZWZvcmUgPSAkLmluQXJyYXkoIHRydWUsIF9wbHVjayhjb2xzLCAnYlZpc2libGUnKSwgY29sdW1uKzEgKTtcblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR0ciA9IGRhdGFbaV0ublRyO1xuXHRcdFx0XHRjZWxscyA9IGRhdGFbaV0uYW5DZWxscztcblx0XG5cdFx0XHRcdGlmICggdHIgKSB7XG5cdFx0XHRcdFx0Ly8gaW5zZXJ0QmVmb3JlIGNhbiBhY3QgbGlrZSBhcHBlbmRDaGlsZCBpZiAybmQgYXJnIGlzIG51bGxcblx0XHRcdFx0XHR0ci5pbnNlcnRCZWZvcmUoIGNlbGxzWyBjb2x1bW4gXSwgY2VsbHNbIGluc2VydEJlZm9yZSBdIHx8IG51bGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlbW92ZSBjb2x1bW5cblx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbHVtbiApICkuZGV0YWNoKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBDb21tb24gYWN0aW9uc1xuXHRcdGNvbC5iVmlzaWJsZSA9IHZpcztcblx0fTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1ucygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBhcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9ICcnO1xuXHRcdH1cblx0XG5cdFx0b3B0cyA9IF9zZWxlY3Rvcl9vcHRzKCBvcHRzICk7XG5cdFxuXHRcdHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHJldHVybiBfX2NvbHVtbl9zZWxlY3Rvciggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzICk7XG5cdFx0fSwgMSApO1xuXHRcblx0XHQvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9yb3dfc2VsZWN0b3I/XG5cdFx0aW5zdC5zZWxlY3Rvci5jb2xzID0gc2VsZWN0b3I7XG5cdFx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblx0XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UaDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UZjtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YSgpJywgJ2NvbHVtbigpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgX19jb2x1bW5EYXRhLCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YVNyYygpJywgJ2NvbHVtbigpLmRhdGFTcmMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5tRGF0YTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXG5cdFx0XHRcdHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxuXHRcdFx0KTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdhbkNlbGxzJywgY29sdW1uICkgO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS52aXNpYmxlKCknLCAnY29sdW1uKCkudmlzaWJsZSgpJywgZnVuY3Rpb24gKCB2aXMsIGNhbGMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciByZXQgPSB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1sgY29sdW1uIF0uYlZpc2libGU7XG5cdFx0XHR9IC8vIGVsc2Vcblx0XHRcdF9fc2V0Q29sdW1uVmlzKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKTtcblx0XHR9ICk7XG5cdFxuXHRcdC8vIEdyb3VwIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2VzXG5cdFx0aWYgKCB2aXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdC8vIFJlZHJhdyB0aGUgaGVhZGVyIGFmdGVyIGNoYW5nZXNcblx0XHRcdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdFx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyICk7XG5cdFx0XG5cdFx0XHRcdC8vIFVwZGF0ZSBjb2xzcGFuIGZvciBubyByZWNvcmRzIGRpc3BsYXkuIENoaWxkIHJvd3MgYW5kIGV4dGVuc2lvbnMgd2lsbCB1c2UgdGhlaXIgb3duXG5cdFx0XHRcdC8vIGxpc3RlbmVycyB0byBkbyB0aGlzIC0gb25seSBuZWVkIHRvIHVwZGF0ZSB0aGUgZW1wdHkgdGFibGUgaXRlbSBoZXJlXG5cdFx0XHRcdGlmICggISBzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoICkge1xuXHRcdFx0XHRcdCQoc2V0dGluZ3MublRCb2R5KS5maW5kKCd0ZFtjb2xzcGFuXScpLmF0dHIoJ2NvbHNwYW4nLCBfZm5WaXNibGVDb2x1bW5zKHNldHRpbmdzKSk7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0Ly8gU2Vjb25kIGxvb3Agb25jZSB0aGUgZmlyc3QgaXMgZG9uZSBmb3IgZXZlbnRzXG5cdFx0XHRcdHRoYXQuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi12aXNpYmlsaXR5JywgW3NldHRpbmdzLCBjb2x1bW4sIHZpcywgY2FsY10gKTtcblx0XHRcdFx0fSApO1xuXHRcblx0XHRcdFx0aWYgKCBjYWxjID09PSB1bmRlZmluZWQgfHwgY2FsYyApIHtcblx0XHRcdFx0XHR0aGF0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHJldDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5pbmRleGVzKCknLCAnY29sdW1uKCkuaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiB0eXBlID09PSAndmlzaWJsZScgP1xuXHRcdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApIDpcblx0XHRcdFx0Y29sdW1uO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NvbHVtbnMuYWRqdXN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1uLmluZGV4KCknLCBmdW5jdGlvbiAoIHR5cGUsIGlkeCApIHtcblx0XHRpZiAoIHRoaXMuY29udGV4dC5sZW5ndGggIT09IDAgKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcblx0XHRcdGlmICggdHlwZSA9PT0gJ2Zyb21WaXNpYmxlJyB8fCB0eXBlID09PSAndG9EYXRhJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBjdHgsIGlkeCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdmcm9tRGF0YScgfHwgdHlwZSA9PT0gJ3RvVmlzaWJsZScgKSB7XG5cdFx0XHRcdHJldHVybiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggY3R4LCBpZHggKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW4oKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jb2x1bW5zKCBzZWxlY3Rvciwgb3B0cyApICk7XG5cdH0gKTtcblx0XG5cdHZhciBfX2NlbGxfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG5cdHtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0XHR2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoIF9wbHVja19vcmRlciggZGF0YSwgcm93cywgJ2FuQ2VsbHMnICkgKTtcblx0XHR2YXIgYWxsQ2VsbHMgPSAkKF9mbGF0dGVuKCBbXSwgY2VsbHMgKSk7XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdFx0dmFyIGEsIGksIGllbiwgaiwgbywgaG9zdDtcblx0XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHZhciBmblNlbGVjdG9yID0gdHlwZW9mIHMgPT09ICdmdW5jdGlvbic7XG5cdFxuXHRcdFx0aWYgKCBzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCB8fCBmblNlbGVjdG9yICkge1xuXHRcdFx0XHQvLyBBbGwgY2VsbHMgYW5kIGZ1bmN0aW9uIHNlbGVjdG9yc1xuXHRcdFx0XHRhID0gW107XG5cdFxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cdFxuXHRcdFx0XHRcdGZvciAoIGo9MCA7IGo8Y29sdW1ucyA7IGorKyApIHtcblx0XHRcdFx0XHRcdG8gPSB7XG5cdFx0XHRcdFx0XHRcdHJvdzogcm93LFxuXHRcdFx0XHRcdFx0XHRjb2x1bW46IGpcblx0XHRcdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBmblNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdGhvc3QgPSBkYXRhWyByb3cgXTtcblx0XG5cdFx0XHRcdFx0XHRcdGlmICggcyggbywgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgaiksIGhvc3QuYW5DZWxscyA/IGhvc3QuYW5DZWxsc1tqXSA6IG51bGwgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRhLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlbGVjdG9yIC0gYWxsXG5cdFx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gaW5kZXhcblx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzICkgKSB7XG5cdFx0XHRcdC8vIFZhbGlkIGNlbGwgaW5kZXggYW5kIGl0cyBpbiB0aGUgYXJyYXkgb2Ygc2VsZWN0YWJsZSByb3dzXG5cdFx0XHRcdHJldHVybiBzLmNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIHMucm93ICE9PSB1bmRlZmluZWQgJiYgJC5pbkFycmF5KCBzLnJvdywgcm93cyApICE9PSAtMSA/XG5cdFx0XHRcdFx0W3NdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBmaWx0ZXJlZCBjZWxsc1xuXHRcdFx0dmFyIGpxUmVzdWx0ID0gYWxsQ2VsbHNcblx0XHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHRcdC5tYXAoIGZ1bmN0aW9uIChpLCBlbCkge1xuXHRcdFx0XHRcdHJldHVybiB7IC8vIHVzZSBhIG5ldyBvYmplY3QsIGluIGNhc2Ugc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZXNcblx0XHRcdFx0XHRcdHJvdzogICAgZWwuX0RUX0NlbGxJbmRleC5yb3csXG5cdFx0XHRcdFx0XHRjb2x1bW46IGVsLl9EVF9DZWxsSW5kZXguY29sdW1uXG5cdCBcdFx0XHRcdH07XG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQudG9BcnJheSgpO1xuXHRcblx0XHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE90aGVyd2lzZSB0aGUgc2VsZWN0b3IgaXMgYSBub2RlLCBhbmQgdGhlcmUgaXMgb25lIGxhc3Qgb3B0aW9uIC0gdGhlXG5cdFx0XHQvLyBlbGVtZW50IG1pZ2h0IGJlIGEgY2hpbGQgb2YgYW4gZWxlbWVudCB3aGljaCBoYXMgZHQtcm93IGFuZCBkdC1jb2x1bW5cblx0XHRcdC8vIGRhdGEgYXR0cmlidXRlc1xuXHRcdFx0aG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcblx0XHRcdHJldHVybiBob3N0Lmxlbmd0aCA/XG5cdFx0XHRcdFsge1xuXHRcdFx0XHRcdHJvdzogaG9zdC5kYXRhKCdkdC1yb3cnKSxcblx0XHRcdFx0XHRjb2x1bW46IGhvc3QuZGF0YSgnZHQtY29sdW1uJylcblx0XHRcdFx0fSBdIDpcblx0XHRcdFx0W107XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9ydW4oICdjZWxsJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxscygpJywgZnVuY3Rpb24gKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggcm93U2VsZWN0b3IgKSApIHtcblx0XHRcdC8vIEluZGV4ZXNcblx0XHRcdGlmICggcm93U2VsZWN0b3Iucm93ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIFNlbGVjdG9yIG9wdGlvbnMgaW4gZmlyc3QgcGFyYW1ldGVyXG5cdFx0XHRcdG9wdHMgPSByb3dTZWxlY3Rvcjtcblx0XHRcdFx0cm93U2VsZWN0b3IgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENlbGwgaW5kZXggb2JqZWN0cyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBjb2x1bW5TZWxlY3RvciApICkge1xuXHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2VsbCBzZWxlY3RvclxuXHRcdGlmICggY29sdW1uU2VsZWN0b3IgPT09IG51bGwgfHwgY29sdW1uU2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0XHRyZXR1cm4gX19jZWxsX3NlbGVjdG9yKCBzZXR0aW5ncywgcm93U2VsZWN0b3IsIF9zZWxlY3Rvcl9vcHRzKCBvcHRzICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdC8vIFRoZSBkZWZhdWx0IGJ1aWx0IGluIG9wdGlvbnMgbmVlZCB0byBhcHBseSB0byByb3cgYW5kIGNvbHVtbnNcblx0XHR2YXIgaW50ZXJuYWxPcHRzID0gb3B0cyA/IHtcblx0XHRcdHBhZ2U6IG9wdHMucGFnZSxcblx0XHRcdG9yZGVyOiBvcHRzLm9yZGVyLFxuXHRcdFx0c2VhcmNoOiBvcHRzLnNlYXJjaFxuXHRcdH0gOiB7fTtcblx0XG5cdFx0Ly8gUm93ICsgY29sdW1uIHNlbGVjdG9yXG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0XHR2YXIgcm93cyA9IHRoaXMucm93cyggcm93U2VsZWN0b3IsIGludGVybmFsT3B0cyApO1xuXHRcdHZhciBpLCBpZW4sIGosIGplbjtcblx0XG5cdFx0dmFyIGNlbGxzTm9PcHRzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaWR4ICkge1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzW2lkeF0ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGo9MCwgamVuPWNvbHVtbnNbaWR4XS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRcdHJvdzogICAgcm93c1tpZHhdW2ldLFxuXHRcdFx0XHRcdFx0Y29sdW1uOiBjb2x1bW5zW2lkeF1bal1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFRoZXJlIGlzIGN1cnJlbnRseSBvbmx5IG9uZSBleHRlbnNpb24gd2hpY2ggdXNlcyBhIGNlbGwgc2VsZWN0b3IgZXh0ZW5zaW9uXG5cdFx0Ly8gSXQgaXMgYSBfbWFqb3JfIHBlcmZvcm1hbmNlIGRyYWcgdG8gcnVuIHRoaXMgaWYgaXQgaXNuJ3QgbmVlZGVkLCBzbyB0aGlzIGlzXG5cdFx0Ly8gYW4gZXh0ZW5zaW9uIHNwZWNpZmljIGNoZWNrIGF0IHRoZSBtb21lbnRcblx0XHR2YXIgY2VsbHMgPSBvcHRzICYmIG9wdHMuc2VsZWN0ZWQgP1xuXHRcdFx0dGhpcy5jZWxscyggY2VsbHNOb09wdHMsIG9wdHMgKSA6XG5cdFx0XHRjZWxsc05vT3B0cztcblx0XG5cdFx0JC5leHRlbmQoIGNlbGxzLnNlbGVjdG9yLCB7XG5cdFx0XHRjb2xzOiBjb2x1bW5TZWxlY3Rvcixcblx0XHRcdHJvd3M6IHJvd1NlbGVjdG9yLFxuXHRcdFx0b3B0czogb3B0c1xuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGNlbGxzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkubm9kZXMoKScsICdjZWxsKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdO1xuXHRcblx0XHRcdHJldHVybiBkYXRhICYmIGRhdGEuYW5DZWxscyA/XG5cdFx0XHRcdGRhdGEuYW5DZWxsc1sgY29sdW1uIF0gOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jYWNoZSgpJywgJ2NlbGwoKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdWyB0eXBlIF1bIGNvbHVtbiBdO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvdywgY29sdW1uLCB0eXBlICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW5kZXhlcygpJywgJ2NlbGwoKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cm93OiByb3csXG5cdFx0XHRcdGNvbHVtbjogY29sdW1uLFxuXHRcdFx0XHRjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApXG5cdFx0XHR9O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMsIGNvbHVtbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2VsbCgpJywgZnVuY3Rpb24gKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jZWxscyggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxsKCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFx0dmFyIGNlbGwgPSB0aGlzWzBdO1xuXHRcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIEdldFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgY2VsbC5sZW5ndGggP1xuXHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4gKSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdF9mblNldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiwgZGF0YSApO1xuXHRcdF9mbkludmFsaWRhdGUoIGN0eFswXSwgY2VsbFswXS5yb3csICdkYXRhJywgY2VsbFswXS5jb2x1bW4gKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCBjdXJyZW50IG9yZGVyaW5nIChzb3J0aW5nKSB0aGF0IGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7YXJyYXl9IDJEIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvcnRpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdFxuXHQgKiAgIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuIEVhY2ggZWxlbWVudCBpbiB0aGUgcGFyZW50IGFycmF5IHJlcHJlc2VudHNcblx0ICogICBhIGNvbHVtbiBiZWluZyBzb3J0ZWQgdXBvbiAoaS5lLiBtdWx0aS1zb3J0aW5nIHdpdGggdHdvIGNvbHVtbnMgd291bGQgaGF2ZVxuXHQgKiAgIDIgaW5uZXIgYXJyYXlzKS4gVGhlIGlubmVyIGFycmF5cyBtYXkgaGF2ZSAyIG9yIDMgZWxlbWVudHMuIFRoZSBmaXJzdCBpc1xuXHQgKiAgIHRoZSBjb2x1bW4gaW5kZXggdGhhdCB0aGUgc29ydGluZyBjb25kaXRpb24gYXBwbGllcyB0bywgdGhlIHNlY29uZCBpcyB0aGVcblx0ICogICBkaXJlY3Rpb24gb2YgdGhlIHNvcnQgKGBkZXNjYCBvciBgYXNjYCkgYW5kLCBvcHRpb25hbGx5LCB0aGUgdGhpcmQgaXMgdGhlXG5cdCAqICAgaW5kZXggb2YgdGhlIHNvcnRpbmcgb3JkZXIgZnJvbSB0aGUgYGNvbHVtbi5zb3J0aW5nYCBpbml0aWFsaXNhdGlvbiBhcnJheS5cblx0ICovLyoqXG5cdCAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cblx0ICpcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBvcmRlciBDb2x1bW4gaW5kZXggdG8gc29ydCB1cG9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIERpcmVjdGlvbiBvZiB0aGUgc29ydCB0byBiZSBhcHBsaWVkIChgYXNjYCBvciBgZGVzY2ApXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAxRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG5cdCAqIEBwYXJhbSB7YXJyYXl9IFsuLi5dIE9wdGlvbmFsIGFkZGl0aW9uYWwgc29ydGluZyBjb25kaXRpb25zXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAyRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ29yZGVyKCknLCBmdW5jdGlvbiAoIG9yZGVyLCBkaXIgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBvcmRlciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdGN0eFswXS5hYVNvcnRpbmcgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBzZXRcblx0XHRpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHQvLyBTaW1wbGUgY29sdW1uIC8gZGlyZWN0aW9uIHBhc3NlZCBpblxuXHRcdFx0b3JkZXIgPSBbIFsgb3JkZXIsIGRpciBdIF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcmRlci5sZW5ndGggJiYgISBBcnJheS5pc0FycmF5KCBvcmRlclswXSApICkge1xuXHRcdFx0Ly8gQXJndW1lbnRzIHBhc3NlZCBpbiAobGlzdCBvZiAxRCBhcnJheXMpXG5cdFx0XHRvcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlIGEgMkQgYXJyYXkgd2FzIHBhc3NlZCBpblxuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IG9yZGVyLnNsaWNlKCk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudCBmb3IgYSBnaXZlbiBjb2x1bW5cblx0ICpcblx0ICogQHBhcmFtIHtub2RlfGpRdWVyeXxzdHJpbmd9IG5vZGUgSWRlbnRpZmllciBmb3IgdGhlIGVsZW1lbnQocykgdG8gYXR0YWNoIHRoZVxuXHQgKiAgIGxpc3RlbmVyIHRvLiBUaGlzIGNhbiB0YWtlIHRoZSBmb3JtIG9mIGEgc2luZ2xlIERPTSBub2RlLCBhIGpRdWVyeVxuXHQgKiAgIGNvbGxlY3Rpb24gb2Ygbm9kZXMgb3IgYSBqUXVlcnkgc2VsZWN0b3Igd2hpY2ggd2lsbCBpZGVudGlmeSB0aGUgbm9kZShzKS5cblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBjb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gc29ydCBpcyBydW5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIubGlzdGVuZXIoKScsIGZ1bmN0aW9uICggbm9kZSwgY29sdW1uLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lciggc2V0dGluZ3MsIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIuZml4ZWQoKScsIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdGlmICggISBzZXQgKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcdFx0dmFyIGZpeGVkID0gY3R4Lmxlbmd0aCA/XG5cdFx0XHRcdGN0eFswXS5hYVNvcnRpbmdGaXhlZCA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSggZml4ZWQgKSA/XG5cdFx0XHRcdHsgcHJlOiBmaXhlZCB9IDpcblx0XHRcdFx0Zml4ZWQ7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gJC5leHRlbmQoIHRydWUsIHt9LCBzZXQgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHQnY29sdW1ucygpLm9yZGVyKCknLFxuXHRcdCdjb2x1bW4oKS5vcmRlcigpJ1xuXHRdLCBmdW5jdGlvbiAoIGRpciApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpICkge1xuXHRcdFx0dmFyIHNvcnQgPSBbXTtcblx0XG5cdFx0XHQkLmVhY2goIHRoYXRbaV0sIGZ1bmN0aW9uIChqLCBjb2wpIHtcblx0XHRcdFx0c29ydC5wdXNoKCBbIGNvbCwgZGlyIF0gKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBzb3J0O1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc2VhcmNoKCknLCBmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCB7XG5cdFx0XHRcdFwic1NlYXJjaFwiOiBpbnB1dCtcIlwiLFxuXHRcdFx0XHRcImJSZWdleFwiOiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0fSApLCAxICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbChcblx0XHQnY29sdW1ucygpLnNlYXJjaCgpJyxcblx0XHQnY29sdW1uKCkuc2VhcmNoKCknLFxuXHRcdGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdHZhciBwcmVTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFxuXHRcdFx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0XG5cdFx0XHRcdFx0cmV0dXJuIHByZVNlYXJjaFsgY29sdW1uIF0uc1NlYXJjaDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gc2V0XG5cdFx0XHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCB7XG5cdFx0XHRcdFx0XCJzU2VhcmNoXCI6IGlucHV0K1wiXCIsXG5cdFx0XHRcdFx0XCJiUmVnZXhcIjogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCAxICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHQpO1xuXHRcblx0Lypcblx0ICogU3RhdGUgQVBJIG1ldGhvZHNcblx0ICovXG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5jbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gU2F2ZSBhbiBlbXB0eSBvYmplY3Rcblx0XHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywge30gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuXHRcdFx0dGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XG5cdFx0XHRudWxsO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlLnNhdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXG5cdCAqIHVzZWQsIGluIG9yZGVyIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cblx0ICogICAgTm90ZSB0aGF0IHRoZSBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG5cdCAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxuXHQgKiAgICBzdWl0YWJsZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uIClcblx0e1xuXHRcdHZhciBhVGhpcyA9IERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGFUaGF0ID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuXHRcdHZhciBpVGhpcywgaVRoYXQ7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YVRoYXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0aVRoaXMgPSBwYXJzZUludCggYVRoaXNbaV0sIDEwICkgfHwgMDtcblx0XHRcdGlUaGF0ID0gcGFyc2VJbnQoIGFUaGF0W2ldLCAxMCApIHx8IDA7XG5cdFxuXHRcdFx0Ly8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuXHRcdFx0aWYgKGlUaGlzID09PSBpVGhhdCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBQYXJ0cyBhcmUgZGlmZmVyZW50LCByZXR1cm4gaW1tZWRpYXRlbHlcblx0XHRcdHJldHVybiBpVGhpcyA+IGlUaGF0O1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXG5cdCAqXG5cdCAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcblx0ICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxuXHQgKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH1cblx0ICovXG5cdERhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IERhdGFUYWJsZS5mbklzRGF0YVRhYmxlID0gZnVuY3Rpb24gKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcblx0XHR2YXIgaXMgPSBmYWxzZTtcblx0XG5cdFx0aWYgKCB0YWJsZSBpbnN0YW5jZW9mIERhdGFUYWJsZS5BcGkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdCQuZWFjaCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAoaSwgbykge1xuXHRcdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0XHR2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcblx0XG5cdFx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdFx0aXMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGlzO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cblx0ICogc2VsZWN0IHRvIGdldCBvbmx5IGN1cnJlbnRseSB2aXNpYmxlIHRhYmxlcy5cblx0ICpcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxuXHQgKiAgICBvciB2aXNpYmxlIHRhYmxlcyBvbmx5LlxuXHQgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG5cdCAqICAgIERhdGFUYWJsZXNcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdERhdGFUYWJsZS50YWJsZXMgPSBEYXRhVGFibGUuZm5UYWJsZXMgPSBmdW5jdGlvbiAoIHZpc2libGUgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IGZhbHNlO1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmlzaWJsZSApICkge1xuXHRcdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0XHR2aXNpYmxlID0gdmlzaWJsZS52aXNpYmxlO1xuXHRcdH1cblx0XG5cdFx0dmFyIGEgPSAkLm1hcCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAobykge1xuXHRcdFx0aWYgKCAhdmlzaWJsZSB8fCAodmlzaWJsZSAmJiAkKG8ublRhYmxlKS5pcygnOnZpc2libGUnKSkgKSB7XG5cdFx0XHRcdHJldHVybiBvLm5UYWJsZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBhcGkgP1xuXHRcdFx0bmV3IF9BcGkoIGEgKSA6XG5cdFx0XHRhO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xuXHQgKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcblx0ICogZWl0aGVyIHRoZSAxLjkgc3R5bGUgSHVuZ2FyaWFuIG5vdGF0aW9uLCBvciB0aGUgMS4xMCsgc3R5bGUgY2FtZWxDYXNlXG5cdCAqIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqL1xuXHREYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJyQoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0dmFyXG5cdFx0XHRyb3dzICAgPSB0aGlzLnJvd3MoIG9wdHMgKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3Ncblx0XHRcdGpxUm93cyA9ICQocm93cyk7XG5cdFxuXHRcdHJldHVybiAkKCBbXS5jb25jYXQoXG5cdFx0XHRqcVJvd3MuZmlsdGVyKCBzZWxlY3RvciApLnRvQXJyYXkoKSxcblx0XHRcdGpxUm93cy5maW5kKCBzZWxlY3RvciApLnRvQXJyYXkoKVxuXHRcdCkgKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG5cdCQuZWFjaCggWyAnb24nLCAnb25lJywgJ29mZicgXSwgZnVuY3Rpb24gKGksIGtleSkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIGtleSsnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovICkge1xuXHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcblx0XHRcdC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdGFyZ3NbMF0gPSAkLm1hcCggYXJnc1swXS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRyZXR1cm4gISBlLm1hdGNoKC9cXC5kdFxcYi8pID9cblx0XHRcdFx0XHRlKycuZHQnIDpcblx0XHRcdFx0XHRlO1xuXHRcdFx0XHR9ICkuam9pbiggJyAnICk7XG5cdFxuXHRcdFx0dmFyIGluc3QgPSAkKCB0aGlzLnRhYmxlcygpLm5vZGVzKCkgKTtcblx0XHRcdGluc3Rba2V5XS5hcHBseSggaW5zdCwgYXJncyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzZXR0aW5ncygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdpbml0KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHRcdH0gKS5mbGF0dGVuKCk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGVzdHJveSgpJywgZnVuY3Rpb24gKCByZW1vdmUgKSB7XG5cdFx0cmVtb3ZlID0gcmVtb3ZlIHx8IGZhbHNlO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBvcmlnICAgICAgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgY2xhc3NlcyAgID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHR2YXIgdGFibGUgICAgID0gc2V0dGluZ3MublRhYmxlO1xuXHRcdFx0dmFyIHRib2R5ICAgICA9IHNldHRpbmdzLm5UQm9keTtcblx0XHRcdHZhciB0aGVhZCAgICAgPSBzZXR0aW5ncy5uVEhlYWQ7XG5cdFx0XHR2YXIgdGZvb3QgICAgID0gc2V0dGluZ3MublRGb290O1xuXHRcdFx0dmFyIGpxVGFibGUgICA9ICQodGFibGUpO1xuXHRcdFx0dmFyIGpxVGJvZHkgICA9ICQodGJvZHkpO1xuXHRcdFx0dmFyIGpxV3JhcHBlciA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cdFx0XHR2YXIgcm93cyAgICAgID0gJC5tYXAoIHNldHRpbmdzLmFvRGF0YSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIublRyOyB9ICk7XG5cdFx0XHR2YXIgaSwgaWVuO1xuXHRcblx0XHRcdC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXG5cdFx0XHQvLyBzaG91bGQgYmUgdGFrZW5cblx0XHRcdHNldHRpbmdzLmJEZXN0cm95aW5nID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSApO1xuXHRcblx0XHRcdC8vIElmIG5vdCBiZWluZyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LCBtYWtlIGFsbCBjb2x1bW5zIHZpc2libGVcblx0XHRcdGlmICggISByZW1vdmUgKSB7XG5cdFx0XHRcdG5ldyBfQXBpKCBzZXR0aW5ncyApLmNvbHVtbnMoKS52aXNpYmxlKCB0cnVlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQmxpdHogYWxsIGBEVGAgbmFtZXNwYWNlZCBldmVudHMgKHRoZXNlIGFyZSBpbnRlcm5hbCBldmVudHMsIHRoZVxuXHRcdFx0Ly8gbG93ZXJjYXNlLCBgZHRgIGV2ZW50cyBhcmUgdXNlciBzdWJzY3JpYmVkIGFuZCB0aGV5IGFyZSByZXNwb25zaWJsZVxuXHRcdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRcdGpxV3JhcHBlci5vZmYoJy5EVCcpLmZpbmQoJzpub3QodGJvZHkgKiknKS5vZmYoJy5EVCcpO1xuXHRcdFx0JCh3aW5kb3cpLm9mZignLkRULScrc2V0dGluZ3Muc0luc3RhbmNlKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxuXHRcdFx0aWYgKCB0YWJsZSAhPSB0aGVhZC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0XHRqcVRhYmxlLmFwcGVuZCggdGhlYWQgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHRmb290ICYmIHRhYmxlICE9IHRmb290LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3Rmb290JykuZGV0YWNoKCk7XG5cdFx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSBbXTtcblx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdCQoIHJvd3MgKS5yZW1vdmVDbGFzcyggc2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcblx0XHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKS5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zU29ydGFibGUrJyAnK1xuXHRcdFx0XHRjbGFzc2VzLnNTb3J0YWJsZUFzYysnICcrY2xhc3Nlcy5zU29ydGFibGVEZXNjKycgJytjbGFzc2VzLnNTb3J0YWJsZU5vbmVcblx0XHRcdCk7XG5cdFxuXHRcdFx0Ly8gQWRkIHRoZSBUUiBlbGVtZW50cyBiYWNrIGludG8gdGhlIHRhYmxlIGluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0XHRqcVRib2R5LmFwcGVuZCggcm93cyApO1xuXHRcblx0XHRcdC8vIFJlbW92ZSB0aGUgRGF0YVRhYmxlcyBnZW5lcmF0ZWQgbm9kZXMsIGV2ZW50cyBhbmQgY2xhc3Nlc1xuXHRcdFx0dmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuXHRcdFx0anFUYWJsZVsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFx0XHRqcVdyYXBwZXJbIHJlbW92ZWRNZXRob2QgXSgpO1xuXHRcblx0XHRcdC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0aWYgKCAhIHJlbW92ZSAmJiBvcmlnICkge1xuXHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSApO1xuXHRcblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXG5cdFx0XHRcdC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcblx0XHRcdFx0anFUYWJsZVxuXHRcdFx0XHRcdC5jc3MoICd3aWR0aCcsIHNldHRpbmdzLnNEZXN0cm95V2lkdGggKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zVGFibGUgKTtcblx0XG5cdFx0XHRcdC8vIElmIHRoZSB3ZXJlIG9yaWdpbmFsbHkgc3RyaXBlIGNsYXNzZXMgLSB0aGVuIHdlIGFkZCB0aGVtIGJhY2sgaGVyZS5cblx0XHRcdFx0Ly8gTm90ZSB0aGlzIGlzIG5vdCBmb29sIHByb29mIChmb3IgZXhhbXBsZSBpZiBub3QgYWxsIHJvd3MgaGFkIHN0cmlwZVxuXHRcdFx0XHQvLyBjbGFzc2VzIC0gYnV0IGl0J3MgYSBnb29kIGVmZm9ydCB3aXRob3V0IGdldHRpbmcgY2FycmllZCBhd2F5XG5cdFx0XHRcdGllbiA9IHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMubGVuZ3RoO1xuXHRcblx0XHRcdFx0aWYgKCBpZW4gKSB7XG5cdFx0XHRcdFx0anFUYm9keS5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKCBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzW2kgJSBpZW5dICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MgKTtcblx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0RGF0YVRhYmxlLnNldHRpbmdzLnNwbGljZSggaWR4LCAxICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuXHQkLmVhY2goIFsgJ2NvbHVtbicsICdyb3cnLCAnY2VsbCcgXSwgZnVuY3Rpb24gKCBpLCB0eXBlICkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xuXHRcdFx0dmFyIGFwaSA9IHRoaXM7XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoIHR5cGUsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKSB7XG5cdFx0XHRcdC8vIFJvd3MgYW5kIGNvbHVtbnM6XG5cdFx0XHRcdC8vICBhcmcxIC0gaW5kZXhcblx0XHRcdFx0Ly8gIGFyZzIgLSB0YWJsZSBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmczIC0gbG9vcCBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmc0IC0gdW5kZWZpbmVkXG5cdFx0XHRcdC8vIENlbGxzOlxuXHRcdFx0XHQvLyAgYXJnMSAtIHJvdyBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMiAtIGNvbHVtbiBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMyAtIHRhYmxlIGNvdW50ZXJcblx0XHRcdFx0Ly8gIGFyZzQgLSBsb29wIGNvdW50ZXJcblx0XHRcdFx0Zm4uY2FsbChcblx0XHRcdFx0XHRhcGlbIHR5cGUgXShcblx0XHRcdFx0XHRcdGFyZzEsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gYXJnMiA6IG9wdHMsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gb3B0cyA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0YXJnMSwgYXJnMiwgYXJnMywgYXJnNFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcblx0Ly8gRGF0YVRhYmxlXG5cdF9hcGlfcmVnaXN0ZXIoICdpMThuKCknLCBmdW5jdGlvbiAoIHRva2VuLCBkZWYsIHBsdXJhbCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXHRcblx0XHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXNvbHZlZCA9IGRlZjtcblx0XHR9XG5cdFxuXHRcdGlmICggcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdFx0cmVzb2x2ZWQgPSByZXNvbHZlZFsgcGx1cmFsIF0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRcdHJlc29sdmVkLl87XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHR9ICk7XG5cdC8qKlxuXHQgKiBWZXJzaW9uIHN0cmluZyBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgY29tcGF0aWJpbGl0eS4gQWxsb3dlZCBmb3JtYXQgaXNcblx0ICogYGEuYi5jLWRgIHdoZXJlOiBhOmludCwgYjppbnQsIGM6aW50LCBkOnN0cmluZyhkZXZ8YmV0YXxhbHBoYSkuIGBkYCBpcyB1c2VkXG5cdCAqIG9ubHkgZm9yIG5vbi1yZWxlYXNlIGJ1aWxkcy4gU2VlIGh0dHA6Ly9zZW12ZXIub3JnLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogIEBtZW1iZXJcblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgVmVyc2lvbiBudW1iZXJcblx0ICovXG5cdERhdGFUYWJsZS52ZXJzaW9uID0gXCIxLjEwLjIyXCI7XG5cblx0LyoqXG5cdCAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcblx0ICogY3JlYXRlZCBmb3IgdGhlIHRhYmxlcyBvbiBhIGdpdmVuIHBhZ2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIHRocm91Z2ggd2hpY2ggaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZFxuXHQgKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0RGF0YVRhYmxlLnNldHRpbmdzID0gW107XG5cblx0LyoqXG5cdCAqIE9iamVjdCBtb2RlbHMgY29udGFpbmVyLCBmb3IgdGhlIHZhcmlvdXMgbW9kZWxzIHRoYXQgRGF0YVRhYmxlcyBoYXNcblx0ICogYXZhaWxhYmxlIHRvIGl0LiBUaGVzZSBtb2RlbHMgZGVmaW5lIHRoZSBvYmplY3RzIHRoYXQgYXJlIHVzZWQgdG8gaG9sZFxuXHQgKiB0aGUgYWN0aXZlIHN0YXRlIGFuZCBjb25maWd1cmF0aW9uIG9mIHRoZSB0YWJsZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMgPSB7fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIHNlYXJjaCBpbmZvcm1hdGlvbiBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggPSB7XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogdHJ1ZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXBwbGllZCBzZWFyY2ggdGVybVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqL1xuXHRcdFwic1NlYXJjaFwiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuXHRcdCAqIHJlZ3VsYXIgZXhwcmVzc2lvbiAodHJ1ZSkgb3Igbm90IChmYWxzZSkgYW5kIHRoZXJlZm9yZSBhbmQgc3BlY2lhbFxuXHRcdCAqIHJlZ2V4IGNoYXJhY3RlcnMgZXNjYXBlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYlJlZ2V4XCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIERhdGFUYWJsZXMgaXMgdG8gdXNlIGl0cyBzbWFydCBmaWx0ZXJpbmcgb3Igbm90LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJTbWFydFwiOiB0cnVlXG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcblx0ICogZWFjaCBpbmRpdmlkdWFsIHJvdy4gVGhpcyBpcyB0aGUgb2JqZWN0IGZvcm1hdCB1c2VkIGZvciB0aGUgc2V0dGluZ3Ncblx0ICogYW9EYXRhIGFycmF5LlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vUm93ID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRSIGVsZW1lbnQgZm9yIHRoZSByb3dcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVHJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxuXHRcdCAqIGNyZWF0ZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5IG5vZGVzXG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhbkNlbGxzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGEgb2JqZWN0IGZyb20gdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93LiBUaGlzIGlzIGVpdGhlclxuXHRcdCAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuXHRcdCAqIHVzaW5nIG1EYXRhIG9wdGlvbnMuIFRoZSBleGFjdCB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBwYXNzZWQgaW5cblx0XHQgKiBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlLCBvciB3aWxsIGJlIGFuIGFycmF5IGlmIHVzaW5nIERPTSBhIGRhdGFcblx0XHQgKiBzb3VyY2UuXG5cdFx0ICogIEB0eXBlIGFycmF5fG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiX2FEYXRhXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIGRhdGEgY2FjaGUgLSB0aGlzIGFycmF5IGlzIG9zdGVuc2libHkgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuXHRcdCAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXG5cdFx0ICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcblx0XHQgKiByb3cuIFdlIGRvIHRoaXMgY2FjaGUgZ2VuZXJhdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNvcnQgaW4gb3JkZXIgdGhhdFxuXHRcdCAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXG5cdFx0ICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xuXHRcdCAqIG90aGVyIHRoYW4gdGhlIG1hc3RlciBzb3J0aW5nIG1ldGhvZHMuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9hU29ydERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVyIGNlbGwgZmlsdGVyaW5nIGRhdGEgY2FjaGUuIEFzIHBlciB0aGUgc29ydCBkYXRhIGNhY2hlLCB1c2VkIHRvXG5cdFx0ICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlc1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYUZpbHRlckRhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyaW5nIGRhdGEgY2FjaGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGNlbGwgZmlsdGVyaW5nIGNhY2hlLCBidXRcblx0XHQgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcblx0XHQgKiBhIGpvaW4gb24gYF9hRmlsdGVyRGF0YWAsIGJ1dCBpcyBwcm92aWRlZCBhcyBhIGNhY2hlIHNvIHRoZSBqb2luIGlzbid0XG5cdFx0ICogbmVlZGVkIG9uIGV2ZXJ5IHNlYXJjaCAobWVtb3J5IHRyYWRlZCBmb3IgcGVyZm9ybWFuY2UpXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9zRmlsdGVyUm93XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIG9mIHRoZSBjbGFzcyBuYW1lIHRoYXQgRGF0YVRhYmxlcyBoYXMgYXBwbGllZCB0byB0aGUgcm93LCBzbyB3ZVxuXHRcdCAqIGNhbiBxdWlja2x5IGxvb2sgYXQgdGhpcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBuZWVkaW5nIHRvIGRvIGEgRE9NIGNoZWNrXG5cdFx0ICogb24gY2xhc3NOYW1lIGZvciB0aGUgblRyIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NSb3dTdHJpcGVcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2Vcblx0XHQgKiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3IgaW52YWxpZGF0aW5nIGRhdGEsIHNvIERhdGFUYWJsZXMgY2FuXG5cdFx0ICogYXV0b21hdGljYWxseSByZWFkIGRhdGEgZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlLCB1bmxlc3MgdW5pbnN0cnVjdGVkXG5cdFx0ICogb3RoZXJ3aXNlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwic3JjXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IGluIHRoZSBhb0RhdGEgYXJyYXkuIFRoaXMgc2F2ZXMgYW4gaW5kZXhPZiBsb29rdXAgd2hlbiB3ZSBoYXZlIHRoZVxuXHRcdCAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IC0xXG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIGNvbHVtbiBpbmZvcm1hdGlvbiBvYmplY3QgaW4gRGF0YVRhYmxlcy4gVGhpcyBvYmplY3Rcblx0ICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcblx0ICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cblx0ICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cblx0ICogSXQgc2hvdWxkIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZFxuXHQgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogQ29sdW1uIGluZGV4LiBUaGlzIGNvdWxkIGJlIHdvcmtlZCBvdXQgb24tdGhlLWZseSB3aXRoICQuaW5BcnJheSwgYnV0IGl0XG5cdFx0ICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0XHQgKiBpcyBzb3J0ZWQuIFRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheSBhbGxvd3MgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHQgKiB0byBiZSBkZWZpbmVkIGZvciBhIGNvbHVtbiAoZm9yIGV4YW1wbGUgZmlyc3QgbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zXG5cdFx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0XHQgKiBjb2x1bW5zIHRvIGJlIHNvcnRlZCBvbiAodHlwaWNhbGx5IGl0IHdpbGwgYmUgYSBzaW5nbGUgaW50ZWdlciBwb2ludGluZ1xuXHRcdCAqIGF0IGl0c2VsZiwgYnV0IHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIHRoZSBjYXNlKS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgdGhlIHNvcnRpbmcgZGlyZWN0aW9ucyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBjb2x1bW4sIGluIHNlcXVlbmNlXG5cdFx0ICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuXHRcdCAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cblx0XHQgKiBTb3J0IGl0IGFnYWluIChjbGljayBhZ2FpbikgYW5kIGl0IHdpbGwgbW92ZSBvbiB0byB0aGUgbmV4dCBpbmRleC5cblx0XHQgKiBSZXBlYXQgdW50aWwgbG9vcC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc2VhcmNoYWJsZSwgYW5kIHRodXMgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdFx0ICogaW4gdGhlIGZpbHRlcmluZyBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTZWFyY2hhYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBmb3IgbWFudWFsIHR5cGUgYXNzaWdubWVudCB1c2luZyB0aGUgYGNvbHVtbi50eXBlYCBvcHRpb24uIFRoaXNcblx0XHQgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NNYW51YWxUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXG5cdFx0ICogc291cmNlIGZvciBmaWx0ZXJpbmcgb3Igc29ydGluZy4gVHJ1ZSBpcyBlaXRoZXIgYXJlLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IG5UZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcblx0XHQgKiAgQHBhcmFtIHsqfSBzRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHRcdCAqIGFjY2VzcyBkYXRhIGRpcmVjdGx5IHRocm91Z2ggX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xuXHRcdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxuXHRcdCAqICAgICdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0J1xuXHRcdCAqICBAcmV0dXJucyB7Kn0gVGhlIGRhdGEgZm9yIHRoZSBjZWxsIGZyb20gdGhlIGdpdmVuIHJvdydzIGRhdGFcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5HZXREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0XHQgKiBzZXQgdGhlIGRhdGEgZGlyZWN0bHkgdG8gX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXG5cdFx0ICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7Kn0gc1ZhbHVlIFZhbHVlIHRvIHNldFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmblNldERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcblx0XHQgKiBzb3VyY2UgYXJyYXkgLyBvYmplY3QuIElmIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgY29udGVudCBpcyB1c2VkLCBpZiBhXG5cdFx0ICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcblx0XHQgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcblx0XHQgKiAnc2V0JyBvcHRpb24sIGFuZCBhbHNvIHRoZSBkYXRhIGZlZCB0byBpdCBpcyB0aGUgcmVzdWx0IGZyb20gbURhdGEuXG5cdFx0ICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcblx0XHQgKiBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byAoaWYgc29ydGluZyBpcyBlbmFibGVkLilcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGhcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIGZvb3RlciBUSC9URCBlbGVtZW50IGZvciB0aGlzIGNvbHVtbiAoaWYgdGhlcmUgaXMgb25lKS4gTm90IHVzZWRcblx0XHQgKiBpbiBEYXRhVGFibGVzIGFzIHN1Y2gsIGJ1dCBjYW4gYmUgdXNlZCBmb3IgcGx1Zy1pbnMgdG8gcmVmZXJlbmNlIHRoZVxuXHRcdCAqIGZvb3RlciBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRmXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNDbGFzc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdFx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHRcdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHRcdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdFx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHRcdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0XHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdFx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXG5cdFx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIG1EYXRhXG5cdFx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOYW1lIGZvciB0aGUgY29sdW1uLCBhbGxvd2luZyByZWZlcmVuY2UgdG8gdGhlIGNvbHVtbiBieSBuYW1lIGFzIHdlbGwgYXNcblx0XHQgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzTmFtZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDdXN0b20gc29ydGluZyBkYXRhIHR5cGUgLSBkZWZpbmVzIHdoaWNoIG9mIHRoZSBhdmFpbGFibGUgcGx1Zy1pbnMgaW5cblx0XHQgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqL1xuXHRcdFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzU29ydGluZ0NsYXNzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXG5cdFx0ICogd2hlbiBqUXVlcnkgVUkgdGhlbWluZyBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1NvcnRpbmdDbGFzc0pVSVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb2x1bW4gc29ydGluZyBhbmQgZmlsdGVyaW5nIHR5cGVcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1dpZHRoT3JpZ1wiOiBudWxsXG5cdH07XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiwgdGhhdCB3YXMgdXNlZCBhcyB0aGUgaW50ZXJmYWNlIGZvciBEYXRhVGFibGVzIHByaW9yIHRvIHYxLjEwLCBob3dldmVyXG5cdCAqIGZyb20gdjEuMTAgb253YXJkcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgaXMgY2FtZWwgY2FzZS4gSW4gb3JkZXIgdG8gYXZvaWRcblx0ICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG5cdCAqIHZlcnNpb24gaXMgc3RpbGwsIGludGVybmFsbHkgdGhlIHByaW1hcnkgaW50ZXJmYWNlLCBidXQgaXMgaXMgbm90IGRvY3VtZW50ZWRcblx0ICogLSBoZW5jZSB0aGUgQG5hbWUgdGFncyBpbiBlYWNoIGRvYyBjb21tZW50LiBUaGlzIGFsbG93cyBhIEphdmFzY3JpcHQgZnVuY3Rpb25cblx0ICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cblx0ICogd291bGQgcmVxdWlyZSBlYWNoIHByb3BlcnR5IHRvIGJlIGxpc3RlZCwgd2hpY2ggd291bGQgYWRkIGFyb3VuZCAzSyB0byB0aGUgc2l6ZVxuXHQgKiBvZiBEYXRhVGFibGVzLCB3aGlsZSB0aGlzIG1ldGhvZCBpcyBhYm91dCBhIDAuNUsgaGl0KS5cblx0ICpcblx0ICogVWx0aW1hdGVseSB0aGlzIGRvZXMgcGF2ZSB0aGUgd2F5IGZvciBIdW5nYXJpYW4gbm90YXRpb24gdG8gYmUgZHJvcHBlZFxuXHQgKiBjb21wbGV0ZWx5LCBidXQgdGhhdCBpcyBhIG1hc3NpdmUgYW1vdW50IG9mIHdvcmsgYW5kIHdpbGwgYnJlYWsgY3VycmVudFxuXHQgKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXNhdGlvbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb25cblx0ICogdGltZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5kZWZhdWx0cyA9IHtcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBkYXRhIHRvIHVzZSBmb3IgdGhlIHRhYmxlLCBwYXNzZWQgaW4gYXQgaW5pdGlhbGlzYXRpb24gd2hpY2hcblx0XHQgKiB3aWxsIGJlIHVzZWQgaW4gcHJlZmVyZW5jZSB0byBhbnkgZGF0YSB3aGljaCBpcyBhbHJlYWR5IGluIHRoZSBET00uIFRoaXMgaXNcblx0XHQgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3Jcblx0XHQgKiBleGFtcGxlIHdpdGggYSBjdXN0b20gQWpheCBjYWxsLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGF0YVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYSAyRCBhcnJheSBkYXRhIHNvdXJjZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRhdGFcIjogW1xuXHRcdCAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA0LjAnLCAnV2luIDk1KycsIDQsICdYJ10sXG5cdFx0ICogICAgICAgICAgWydUcmlkZW50JywgJ0ludGVybmV0IEV4cGxvcmVyIDUuMCcsICdXaW4gOTUrJywgNSwgJ0MnXSxcblx0XHQgKiAgICAgICAgXSxcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYXMgYSBkYXRhIHNvdXJjZSAoYGRhdGFgKVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRhdGFcIjogW1xuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG5cdFx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNC4wXCIsXG5cdFx0ICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxuXHRcdCAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA0LFxuXHRcdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIlhcIlxuXHRcdCAqICAgICAgICAgIH0sXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJlbmdpbmVcIjogICBcIlRyaWRlbnRcIixcblx0XHQgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA1LjBcIixcblx0XHQgKiAgICAgICAgICAgIFwicGxhdGZvcm1cIjogXCJXaW4gOTUrXCIsXG5cdFx0ICogICAgICAgICAgICBcInZlcnNpb25cIjogIDUsXG5cdFx0ICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiQ1wiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkVuZ2luZVwiLCAgIFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiLCAgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiUGxhdGZvcm1cIiwgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlZlcnNpb25cIiwgIFwiZGF0YVwiOiBcInZlcnNpb25cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIsICAgIFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWFEYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiBvcmRlcmluZyBpcyBlbmFibGVkLCB0aGVuIERhdGFUYWJsZXMgd2lsbCBwZXJmb3JtIGEgZmlyc3QgcGFzcyBzb3J0IG9uXG5cdFx0ICogaW5pdGlhbGlzYXRpb24uIFlvdSBjYW4gZGVmaW5lIHdoaWNoIGNvbHVtbihzKSB0aGUgc29ydCBpcyBwZXJmb3JtZWRcblx0XHQgKiB1cG9uLCBhbmQgdGhlIHNvcnRpbmcgZGlyZWN0aW9uLCB3aXRoIHRoaXMgdmFyaWFibGUuIFRoZSBgc29ydGluZ2AgYXJyYXlcblx0XHQgKiBzaG91bGQgY29udGFpbiBhbiBhcnJheSBmb3IgZWFjaCBjb2x1bW4gdG8gYmUgc29ydGVkIGluaXRpYWxseSBjb250YWluaW5nXG5cdFx0ICogdGhlIGNvbHVtbidzIGluZGV4IGFuZCBhIGRpcmVjdGlvbiBzdHJpbmcgKCdhc2MnIG9yICdkZXNjJykuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtbMCwnYXNjJ11dXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNvcnQgYnkgM3JkIGNvbHVtbiBmaXJzdCwgYW5kIHRoZW4gNHRoIGNvbHVtblxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJcIjogW1syLCdhc2MnXSwgWzMsJ2Rlc2MnXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAvLyBObyBpbml0aWFsIHNvcnRpbmdcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyXCI6IFtdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nXCI6IFtbMCwnYXNjJ11dLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCB0byB0aGUgYHNvcnRpbmdgIHBhcmFtZXRlciwgYnV0XG5cdFx0ICogY2Fubm90IGJlIG92ZXJyaWRkZW4gYnkgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0YWJsZS4gV2hhdCB0aGlzIG1lYW5zXG5cdFx0ICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXG5cdFx0ICogd2lsbCBhbHdheXMgYmUgZm9yY2VkIG9uIGZpcnN0IC0gYW55IHNvcnRpbmcgYWZ0ZXIgdGhhdCAoZnJvbSB0aGUgdXNlcilcblx0XHQgKiB3aWxsIHRoZW4gYmUgcGVyZm9ybWVkIGFzIHJlcXVpcmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGdyb3VwaW5nIHJvd3Ncblx0XHQgKiB0b2dldGhlci5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyRml4ZWRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJGaXhlZFwiOiBbWzAsJ2FzYyddXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEYXRhVGFibGVzIGNhbiBiZSBpbnN0cnVjdGVkIHRvIGxvYWQgZGF0YSB0byBkaXNwbGF5IGluIHRoZSB0YWJsZSBmcm9tIGFcblx0XHQgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXG5cdFx0ICpcblx0XHQgKiBUaGUgYGFqYXhgIHByb3BlcnR5IGhhcyB0aHJlZSBkaWZmZXJlbnQgbW9kZXMgb2Ygb3BlcmF0aW9uLCBkZXBlbmRpbmcgb25cblx0XHQgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxuXHRcdCAqXG5cdFx0ICogKiBgc3RyaW5nYCAtIFNldCB0aGUgVVJMIGZyb20gd2hlcmUgdGhlIGRhdGEgc2hvdWxkIGJlIGxvYWRlZCBmcm9tLlxuXHRcdCAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSBDdXN0b20gZGF0YSBnZXQgZnVuY3Rpb25cblx0XHQgKlxuXHRcdCAqIGBzdHJpbmdgXG5cdFx0ICogLS0tLS0tLS1cblx0XHQgKlxuXHRcdCAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxuXHRcdCAqIERhdGFUYWJsZXMgd2lsbCBsb2FkIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBgb2JqZWN0YFxuXHRcdCAqIC0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xuXHRcdCAqIFtqUXVlcnkuYWpheF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4LykgYWxsb3dpbmcgZmluZSBjb250cm9sXG5cdFx0ICogb2YgdGhlIEFqYXggcmVxdWVzdC4gRGF0YVRhYmxlcyBoYXMgYSBudW1iZXIgb2YgZGVmYXVsdCBwYXJhbWV0ZXJzIHdoaWNoXG5cdFx0ICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcblx0XHQgKiBkb2N1bWVudGF0aW9uIGZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnMgYXZhaWxhYmxlLCBhbHRob3VnaFxuXHRcdCAqIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBwcm92aWRlIGFkZGl0aW9uYWwgb3B0aW9ucyBpbiBEYXRhVGFibGVzIG9yXG5cdFx0ICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG5cdFx0ICpcblx0XHQgKiAqIGBkYXRhYCAtIEFzIHdpdGggalF1ZXJ5LCBgZGF0YWAgY2FuIGJlIHByb3ZpZGVkIGFzIGFuIG9iamVjdCwgYnV0IGl0XG5cdFx0ICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG5cdFx0ICogICB0byB0aGUgc2VydmVyLiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLCBhbiBvYmplY3Qgb2Zcblx0XHQgKiAgIHBhcmFtZXRlcnMgd2l0aCB0aGUgdmFsdWVzIHRoYXQgRGF0YVRhYmxlcyBoYXMgcmVhZGllZCBmb3Igc2VuZGluZy4gQW5cblx0XHQgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuXHRcdCAqICAgZGVmYXVsdHMsIG9yIHlvdSBjYW4gYWRkIHRoZSBpdGVtcyB0byB0aGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpbiBhbmRcblx0XHQgKiAgIG5vdCByZXR1cm4gYW55dGhpbmcgZnJvbSB0aGUgZnVuY3Rpb24uIFRoaXMgc3VwZXJzZWRlcyBgZm5TZXJ2ZXJQYXJhbXNgXG5cdFx0ICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cblx0XHQgKlxuXHRcdCAqICogYGRhdGFTcmNgIC0gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3Jcblx0XHQgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG5cdFx0ICogICBmcm9tIGFuIEFqYXggc291cmNlIG9yIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdGhpcyBwYXJhbWV0ZXJcblx0XHQgKiAgIGFsbG93cyB0aGF0IHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkXG5cdFx0ICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuXHRcdCAqICAgaXQgbXkgYmUgdXNlZCBhcyBhIGZ1bmN0aW9uLiBBcyBhIGZ1bmN0aW9uIGl0IHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlcixcblx0XHQgKiAgIHRoZSBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciwgd2hpY2ggY2FuIGJlIG1hbmlwdWxhdGVkIGFzXG5cdFx0ICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG5cdFx0ICogICBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIHN1cGVyc2VkZXMgYHNBamF4RGF0YVByb3BgIGZyb21cblx0XHQgKiAgIERhdGFUYWJsZXMgMS45LS5cblx0XHQgKlxuXHRcdCAqICogYHN1Y2Nlc3NgIC0gU2hvdWxkIG5vdCBiZSBvdmVycmlkZGVuIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBpblxuXHRcdCAqICAgRGF0YVRhYmxlcy4gVG8gbWFuaXB1bGF0ZSAvIHRyYW5zZm9ybSB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG5cdFx0ICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cblx0XHQgKlxuXHRcdCAqIGBmdW5jdGlvbmBcblx0XHQgKiAtLS0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhIGZ1bmN0aW9uLCBtYWtpbmcgdGhlIEFqYXggY2FsbCBpcyBsZWZ0IHVwIHRvIHlvdXJzZWxmIGFsbG93aW5nXG5cdFx0ICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXG5cdFx0ICogdGhhbiBBamF4IGNvdWxkIGJlIHVzZWQgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhLCBzdWNoIGFzIFdlYiBzdG9yYWdlXG5cdFx0ICogb3IgYW4gQUlSIGRhdGFiYXNlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9uIGlzIGdpdmVuIGZvdXIgcGFyYW1ldGVycyBhbmQgbm8gcmV0dXJuIGlzIHJlcXVpcmVkLiBUaGVcblx0XHQgKiBwYXJhbWV0ZXJzIGFyZTpcblx0XHQgKlxuXHRcdCAqIDEuIF9vYmplY3RfIC0gRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAyLiBfZnVuY3Rpb25fIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBtdXN0IGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHJlcXVpcmVkXG5cdFx0ICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcblx0XHQgKiAgICBhcyB0aGUgb25seSBwYXJhbWV0ZXJcblx0XHQgKiAzLiBfb2JqZWN0XyAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyRGF0YWAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFxuXHRcdCAqICBAc2luY2UgMS4xMC4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheC5cblx0XHQgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXG5cdFx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICBcImFqYXhcIjogXCJkYXRhLmpzb25cIlxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2Vcblx0XHQgKiAgIC8vIGBkYXRhYCB0byBgdGFibGVEYXRhYCAoaS5lLiBgeyB0YWJsZURhdGE6IFsgLi4uZGF0YS4uLiBdIH1gKVxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBcInRhYmxlRGF0YVwiXG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gcmVhZCBkYXRhXG5cdFx0ICogICAvLyBmcm9tIGEgcGxhaW4gYXJyYXkgcmF0aGVyIHRoYW4gYW4gYXJyYXkgaW4gYW4gb2JqZWN0XG5cdFx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICBcImFqYXhcIjoge1xuXHRcdCAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXG5cdFx0ICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIE1hbmlwdWxhdGUgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIC0gYWRkIGEgbGluayB0byBkYXRhXG5cdFx0ICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xuXHRcdCAqICAgLy8gaXMganVzdCBhIHNpbXBsZSBleGFtcGxlIG9mIGhvdyB0aGUgZGF0YSBjYW4gYmUgbWFuaXB1bGF0ZWQpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0ICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHQgKiAgICAgICAgICAganNvbltpXVswXSA9ICc8YSBocmVmPVwiL21lc3NhZ2UvJytqc29uW2ldWzBdKyc+VmlldyBtZXNzYWdlPC9hPic7XG5cdFx0ICogICAgICAgICB9XG5cdFx0ICogICAgICAgICByZXR1cm4ganNvbjtcblx0XHQgKiAgICAgICB9XG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0ICogICAgICAgICByZXR1cm4ge1xuXHRcdCAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxuXHRcdCAqICAgICAgICAgfTtcblx0XHQgKiAgICAgICB9XG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBTZW5kIHJlcXVlc3QgYXMgUE9TVFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwidHlwZVwiOiBcIlBPU1RcIlxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gbG9jYWxTdG9yYWdlIChjb3VsZCBpbnRlcmZhY2Ugd2l0aCBhIGZvcm0gZm9yXG5cdFx0ICogICAvLyBhZGRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIHJvd3MpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaywgc2V0dGluZ3MpIHtcblx0XHQgKiAgICAgICBjYWxsYmFjayhcblx0XHQgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcblx0XHQgKiAgICAgICApO1xuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhamF4XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHJlYWRpbHkgc3BlY2lmeSB0aGUgZW50cmllcyBpbiB0aGUgbGVuZ3RoIGRyb3Bcblx0XHQgKiBkb3duIG1lbnUgdGhhdCBEYXRhVGFibGVzIHNob3dzIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLiBJdCBjYW4gYmVcblx0XHQgKiBlaXRoZXIgYSAxRCBhcnJheSBvZiBvcHRpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYm90aCB0aGUgZGlzcGxheWVkXG5cdFx0ICogb3B0aW9uIGFuZCB0aGUgdmFsdWUsIG9yIGEgMkQgYXJyYXkgd2hpY2ggd2lsbCB1c2UgdGhlIGFycmF5IGluIHRoZSBmaXJzdFxuXHRcdCAqIHBvc2l0aW9uIGFzIHRoZSB2YWx1ZSwgYW5kIHRoZSBhcnJheSBpbiB0aGUgc2Vjb25kIHBvc2l0aW9uIGFzIHRoZVxuXHRcdCAqIGRpc3BsYXllZCBvcHRpb25zICh1c2VmdWwgZm9yIGxhbmd1YWdlIHN0cmluZ3Mgc3VjaCBhcyAnQWxsJykuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhlIGBwYWdlTGVuZ3RoYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZVxuXHRcdCAqIGZpcnN0IHZhbHVlIGdpdmVuIGluIHRoaXMgYXJyYXksIHVubGVzcyBgcGFnZUxlbmd0aGAgaXMgYWxzbyBwcm92aWRlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgWyAxMCwgMjUsIDUwLCAxMDAgXVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aE1lbnVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGVuZ3RoTWVudVwiOiBbWzEwLCAyNSwgNTAsIC0xXSwgWzEwLCAyNSwgNTAsIFwiQWxsXCJdXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFMZW5ndGhNZW51XCI6IFsgMTAsIDI1LCA1MCwgMTAwIF0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgYGNvbHVtbnNgIG9wdGlvbiBpbiB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gZGVmaW5lXG5cdFx0ICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxuXHRcdCAqIGNvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCwgcGxlYXNlIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufS4gTm90ZSB0aGF0IGlmIHlvdSB1c2UgYGNvbHVtbnNgIHRvXG5cdFx0ICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxuXHRcdCAqIGNvbHVtbiB0aGF0IHlvdSBoYXZlIGluIHlvdXIgdGFibGUgKHRoZXNlIGNhbiBiZSBudWxsIGlmIHlvdSBkb24ndCB3aGljaFxuXHRcdCAqIHRvIHNwZWNpZnkgYW55IG9wdGlvbnMpLlxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtblxuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5zXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXG5cdFx0ICogY29sdW1uLCBtdWx0aXBsZSBjb2x1bW5zLCBvciBhbGwgY29sdW1ucywgdXNpbmcgdGhlIGB0YXJnZXRzYCBwcm9wZXJ0eSBvZlxuXHRcdCAqIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVGhpcyBhbGxvd3MgZ3JlYXQgZmxleGliaWxpdHkgd2hlbiBjcmVhdGluZ1xuXHRcdCAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcblx0XHQgKiBjb2x1bW5zIHlvdSBzcGVjaWZpY2FsbHkgd2FudC4gYGNvbHVtbkRlZnNgIG1heSB1c2UgYW55IG9mIHRoZSBjb2x1bW5cblx0XHQgKiBvcHRpb25zIGF2YWlsYWJsZToge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LCBidXQgaXQgX211c3RfXG5cdFx0ICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXG5cdFx0ICogYXJyYXkgbWF5IGJlOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxuXHRcdCAqICAgICA8bGk+MCBvciBhIHBvc2l0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgbGVmdDwvbGk+XG5cdFx0ICogICAgIDxsaT5hIG5lZ2F0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgcmlnaHQ8L2xpPlxuXHRcdCAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uRGVmc1xuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5EZWZzXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgYHNlYXJjaGAsIHRoaXMgcGFyYW1ldGVyIGRlZmluZXMgdGhlIGluZGl2aWR1YWwgY29sdW1uXG5cdFx0ICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcblx0XHQgKiBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMsIGFuZCBlYWNoIGVsZW1lbnQgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHBhcmFtZXRlcnNcblx0XHQgKiBgc2VhcmNoYCBhbmQgYGVzY2FwZVJlZ2V4YCAodGhlIGxhdHRlciBpcyBvcHRpb25hbCkuICdudWxsJyBpcyBhbHNvXG5cdFx0ICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hDb2xzXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaENvbHNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoXCI6IFwiXlswLTldXCIsIFwiZXNjYXBlUmVnZXhcIjogZmFsc2UgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJhb1NlYXJjaENvbHNcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBDU1MgY2xhc3NlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGRpc3BsYXllZCByb3dzLiBUaGlzXG5cdFx0ICogYXJyYXkgbWF5IGJlIG9mIGFueSBsZW5ndGgsIGFuZCBEYXRhVGFibGVzIHdpbGwgYXBwbHkgZWFjaCBjbGFzc1xuXHRcdCAqIHNlcXVlbnRpYWxseSwgbG9vcGluZyB3aGVuIHJlcXVpcmVkLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPldpbGwgdGFrZSB0aGUgdmFsdWVzIGRldGVybWluZWQgYnkgdGhlIGBvQ2xhc3Nlcy5zdHJpcGUqYFxuXHRcdCAqICAgIG9wdGlvbnM8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RyaXBlQ2xhc3Nlc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdHJpcGVDbGFzc2VzXCI6IFsgJ3N0cmlwMScsICdzdHJpcDInLCAnc3RyaXAzJyBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIGF1dG9tYXRpYyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24uIFRoaXMgY2FuIGJlIGRpc2FibGVkXG5cdFx0ICogYXMgYW4gb3B0aW1pc2F0aW9uIChpdCB0YWtlcyBzb21lIHRpbWUgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aHMpIGlmIHRoZVxuXHRcdCAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYXV0b1dpZHRoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhdXRvV2lkdGhcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiQXV0b1dpZHRoXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZlcnJlZCByZW5kZXJpbmcgY2FuIHByb3ZpZGUgRGF0YVRhYmxlcyB3aXRoIGEgaHVnZSBzcGVlZCBib29zdCB3aGVuIHlvdVxuXHRcdCAqIGFyZSB1c2luZyBhbiBBamF4IG9yIEpTIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuIFRoaXMgb3B0aW9uLCB3aGVuIHNldCB0b1xuXHRcdCAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxuXHRcdCAqIGVhY2ggcm93IHVudGlsIHRoZXkgYXJlIG5lZWRlZCBmb3IgYSBkcmF3IC0gc2F2aW5nIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mXG5cdFx0ICogdGltZS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJSZW5kZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImRlZmVyUmVuZGVyXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiRGVmZXJSZW5kZXJcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIGEgRGF0YVRhYmxlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCByZXBsYWNlIGl0IHdpdGhcblx0XHQgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cblx0XHQgKiB0YWJsZSBtYXRjaGVzIHRoZSBzZWxlY3RvciwgdGhlbiB0aGUgbmV3IERhdGFUYWJsZSB3aWxsIGJlIGNvbnN0cnVjdGVkIGFzXG5cdFx0ICogcGVyIG5vcm1hbC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZXN0cm95XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29tZSB0aW1lIGxhdGVyLi4uLlxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmaWx0ZXJcIjogZmFsc2UsXG5cdFx0ICogICAgICAgIFwiZGVzdHJveVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkRlc3Ryb3lcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXG5cdFx0ICogdGhhdCBpdCBhbGxvd3MgdGhlIGVuZCB1c2VyIHRvIGlucHV0IG11bHRpcGxlIHdvcmRzIChzcGFjZSBzZXBhcmF0ZWQpIGFuZFxuXHRcdCAqIHdpbGwgbWF0Y2ggYSByb3cgY29udGFpbmluZyB0aG9zZSB3b3JkcywgZXZlbiBpZiBub3QgaW4gdGhlIG9yZGVyIHRoYXQgd2FzXG5cdFx0ICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxuXHRcdCAqIHdpc2ggdG8gdXNlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzIHRoaXMgbXVzdCByZW1haW4gJ3RydWUnIC0gdG8gcmVtb3ZlIHRoZVxuXHRcdCAqIGRlZmF1bHQgZmlsdGVyaW5nIGlucHV0IGJveCBhbmQgcmV0YWluIGZpbHRlcmluZyBhYmlsaXRpZXMsIHBsZWFzZSB1c2Vcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiRmlsdGVyXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgdGFibGUgaW5mb3JtYXRpb24gZGlzcGxheS4gVGhpcyBzaG93cyBpbmZvcm1hdGlvblxuXHRcdCAqIGFib3V0IHRoZSBkYXRhIHRoYXQgaXMgY3VycmVudGx5IHZpc2libGUgb24gdGhlIHBhZ2UsIGluY2x1ZGluZyBpbmZvcm1hdGlvblxuXHRcdCAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImluZm9cIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiSW5mb1wiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHRoZSBlbmQgdXNlciB0byBzZWxlY3QgdGhlIHNpemUgb2YgYSBmb3JtYXR0ZWQgcGFnZSBmcm9tIGEgc2VsZWN0XG5cdFx0ICogbWVudSAoc2l6ZXMgYXJlIDEwLCAyNSwgNTAgYW5kIDEwMCkuIFJlcXVpcmVzIHBhZ2luYXRpb24gKGBwYWdpbmF0ZWApLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aENoYW5nZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGVuZ3RoQ2hhbmdlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgcGFnaW5hdGlvbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJQYWdpbmF0ZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgYSAncHJvY2Vzc2luZycgaW5kaWNhdG9yIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0ICogYmVpbmcgcHJvY2Vzc2VkIChlLmcuIGEgc29ydCkuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgdGFibGVzIHdpdGhcblx0XHQgKiBsYXJnZSBhbW91bnRzIG9mIGRhdGEgd2hlcmUgaXQgY2FuIHRha2UgYSBub3RpY2VhYmxlIGFtb3VudCBvZiB0aW1lIHRvIHNvcnRcblx0XHQgKiB0aGUgZW50cmllcy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJvY2Vzc2luZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicHJvY2Vzc2luZ1wiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXRyaWV2ZSB0aGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoZSBnaXZlbiBzZWxlY3Rvci4gTm90ZSB0aGF0IGlmIHRoZVxuXHRcdCAqIHRhYmxlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQsIHRoaXMgcGFyYW1ldGVyIHdpbGwgY2F1c2UgRGF0YVRhYmxlc1xuXHRcdCAqIHRvIHNpbXBseSByZXR1cm4gdGhlIG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2V0IHVwIC0gaXQgd2lsbCBub3QgdGFrZVxuXHRcdCAqIGFjY291bnQgb2YgYW55IGNoYW5nZXMgeW91IG1pZ2h0IGhhdmUgbWFkZSB0byB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0XG5cdFx0ICogcGFzc2VkIHRvIERhdGFUYWJsZXMgKHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpcyBhbiBhY2tub3dsZWRnZW1lbnRcblx0XHQgKiB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoaXMpLiBgZGVzdHJveWAgY2FuIGJlIHVzZWQgdG8gcmVpbml0aWFsaXNlIGEgdGFibGUgaWZcblx0XHQgKiB5b3UgbmVlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yZXRyaWV2ZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgaW5pdFRhYmxlKCk7XG5cdFx0ICogICAgICB0YWJsZUFjdGlvbnMoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICBmdW5jdGlvbiBpbml0VGFibGUgKClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwcHhcIixcblx0XHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcblx0XHQgKiAgICAgICAgXCJyZXRyaWV2ZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfVxuXHRcdCAqXG5cdFx0ICogICAgZnVuY3Rpb24gdGFibGVBY3Rpb25zICgpXG5cdFx0ICogICAge1xuXHRcdCAqICAgICAgdmFyIHRhYmxlID0gaW5pdFRhYmxlKCk7XG5cdFx0ICogICAgICAvLyBwZXJmb3JtIEFQSSBvcGVyYXRpb25zIHdpdGggb1RhYmxlXG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdFwiYlJldHJpZXZlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiB2ZXJ0aWNhbCAoeSkgc2Nyb2xsaW5nIGlzIGVuYWJsZWQsIERhdGFUYWJsZXMgd2lsbCBmb3JjZSB0aGUgaGVpZ2h0IG9mXG5cdFx0ICogdGhlIHRhYmxlJ3Mgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGhlaWdodCBhdCBhbGwgdGltZXMgKHVzZWZ1bCBmb3IgbGF5b3V0KS5cblx0XHQgKiBIb3dldmVyLCB0aGlzIGNhbiBsb29rIG9kZCB3aGVuIGZpbHRlcmluZyBkYXRhIGRvd24gdG8gYSBzbWFsbCBkYXRhIHNldCxcblx0XHQgKiBhbmQgdGhlIGZvb3RlciBpcyBsZWZ0IFwiZmxvYXRpbmdcIiBmdXJ0aGVyIGRvd24uIFRoaXMgcGFyYW1ldGVyICh3aGVuXG5cdFx0ICogZW5hYmxlZCkgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGNvbGxhcHNlIHRoZSB0YWJsZSdzIHZpZXdwb3J0IGRvd24gd2hlblxuXHRcdCAqIHRoZSByZXN1bHQgc2V0IHdpbGwgZml0IHdpdGhpbiB0aGUgZ2l2ZW4gWSBoZWlnaHQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsQ29sbGFwc2Vcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMFwiLFxuXHRcdCAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2Nyb2xsQ29sbGFwc2VcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxuXHRcdCAqIGBhamF4YCBwYXJhbWV0ZXIgbXVzdCBhbHNvIGJlIGdpdmVuIGluIG9yZGVyIHRvIGdpdmUgRGF0YVRhYmxlcyBhXG5cdFx0ICogc291cmNlIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgZWFjaCBkcmF3LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyU2lkZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJ4aHIucGhwXCJcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHNvcnRpbmcgb2YgY29sdW1ucy4gU29ydGluZyBvZiBpbmRpdmlkdWFsIGNvbHVtbnMgY2FuIGJlXG5cdFx0ICogZGlzYWJsZWQgYnkgdGhlIGBzb3J0YWJsZWAgb3B0aW9uIGZvciBlYWNoIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlcmluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydFwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc3BsYXkgRGF0YVRhYmxlcycgYWJpbGl0eSB0byBzb3J0IG11bHRpcGxlIGNvbHVtbnMgYXQgdGhlXG5cdFx0ICogc2FtZSB0aW1lIChhY3RpdmF0ZWQgYnkgc2hpZnQtY2xpY2sgYnkgdGhlIHVzZXIpLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJNdWx0aVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRGlzYWJsZSBtdWx0aXBsZSBjb2x1bW4gc29ydGluZyBhYmlsaXR5XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJNdWx0aVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0TXVsdGlcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBjb250cm9sIG92ZXIgd2hldGhlciBEYXRhVGFibGVzIHNob3VsZCB1c2UgdGhlIHRvcCAodHJ1ZSkgdW5pcXVlXG5cdFx0ICogY2VsbCB0aGF0IGlzIGZvdW5kIGZvciBhIHNpbmdsZSBjb2x1bW4sIG9yIHRoZSBib3R0b20gKGZhbHNlIC0gZGVmYXVsdCkuXG5cdFx0ICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJDZWxsc1RvcFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlckNlbGxzVG9wXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydENlbGxzVG9wXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGFkZGl0aW9uIG9mIHRoZSBjbGFzc2VzIGBzb3J0aW5nXFxfMWAsIGBzb3J0aW5nXFxfMmAgYW5kXG5cdFx0ICogYHNvcnRpbmdcXF8zYCB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGJlaW5nIHNvcnRlZCBvbi4gVGhpcyBpc1xuXHRcdCAqIHByZXNlbnRlZCBhcyBhIGZlYXR1cmUgc3dpdGNoIGFzIGl0IGNhbiBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUgKHdoaWxlXG5cdFx0ICogY2xhc3NlcyBhcmUgcmVtb3ZlZCBhbmQgYWRkZWQpIHNvIGZvciBsYXJnZSBkYXRhIHNldHMgeW91IG1pZ2h0IHdhbnQgdG9cblx0XHQgKiB0dXJuIHRoaXMgb2ZmLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2xhc3Nlc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJDbGFzc2VzXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRDbGFzc2VzXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzdGF0ZSBzYXZpbmcuIFdoZW4gZW5hYmxlZCBIVE1MNSBgbG9jYWxTdG9yYWdlYCB3aWxsIGJlXG5cdFx0ICogdXNlZCB0byBzYXZlIHRhYmxlIGRpc3BsYXkgaW5mb3JtYXRpb24gc3VjaCBhcyBwYWdpbmF0aW9uIGluZm9ybWF0aW9uLFxuXHRcdCAqIGRpc3BsYXkgbGVuZ3RoLCBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuIEFzIHN1Y2ggd2hlbiB0aGUgZW5kIHVzZXIgcmVsb2Fkc1xuXHRcdCAqIHRoZSBwYWdlIHRoZSBkaXNwbGF5IGRpc3BsYXkgd2lsbCBtYXRjaCB3aGF0IHRoeSBoYWQgcHJldmlvdXNseSBzZXQgdXAuXG5cdFx0ICpcblx0XHQgKiBEdWUgdG8gdGhlIHVzZSBvZiBgbG9jYWxTdG9yYWdlYCB0aGUgZGVmYXVsdCBzdGF0ZSBzYXZpbmcgaXMgbm90IHN1cHBvcnRlZFxuXHRcdCAqIGluIElFNiBvciA3LiBJZiBzdGF0ZSBzYXZpbmcgaXMgcmVxdWlyZWQgaW4gdGhvc2UgYnJvd3NlcnMsIHVzZVxuXHRcdCAqIGBzdGF0ZVNhdmVDYWxsYmFja2AgdG8gcHJvdmlkZSBhIHN0b3JhZ2Ugc29sdXRpb24gc3VjaCBhcyBjb29raWVzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlN0YXRlU2F2ZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYSBUUiBlbGVtZW50IGlzIGNyZWF0ZWQgKGFuZCBhbGwgVEQgY2hpbGRcblx0XHQgKiBlbGVtZW50cyBoYXZlIGJlZW4gaW5zZXJ0ZWQpLCBvciByZWdpc3RlcmVkIGlmIHVzaW5nIGEgRE9NIHNvdXJjZSwgYWxsb3dpbmdcblx0XHQgKiBtYW5pcHVsYXRpb24gb2YgdGhlIFRSIGVsZW1lbnQgKGFkZGluZyBjbGFzc2VzIGV0YykuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBSYXcgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhpcyByb3cgaW4gdGhlIGludGVybmFsIGFvRGF0YSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNyZWF0ZWRSb3dcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY3JlYXRlZFJvd1wiOiBmdW5jdGlvbiggcm93LCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgICAgLy8gQm9sZCB0aGUgZ3JhZGUgZm9yIGFsbCAnQScgZ3JhZGUgYnJvd3NlcnNcblx0XHQgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKVxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgICQoJ3RkOmVxKDQpJywgcm93KS5odG1sKCAnPGI+QTwvYj4nICk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5DcmVhdGVkUm93XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXG5cdFx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IGFueSBhc3BlY3QgeW91IHdhbnQgYWJvdXQgdGhlIGNyZWF0ZWQgRE9NLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kcmF3Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIHJlZHJhd24gdGhlIHRhYmxlJyApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5EcmF3Q2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElkZW50aWNhbCB0byBmbkhlYWRlckNhbGxiYWNrKCkgYnV0IGZvciB0aGUgdGFibGUgZm9vdGVyIHRoaXMgZnVuY3Rpb25cblx0XHQgKiBhbGxvd3MgeW91IHRvIG1vZGlmeSB0aGUgdGFibGUgZm9vdGVyIG9uIGV2ZXJ5ICdkcmF3JyBldmVudC5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBmb290IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgZm9vdGVyXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXG5cdFx0ICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0XHQgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZm9vdGVyQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZm9vdGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHRmb290LCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHRcdCAqICAgICAgICAgIHRmb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiU3RhcnRpbmcgaW5kZXggaXMgXCIrc3RhcnQ7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImZuRm9vdGVyQ2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gcmVuZGVyaW5nIGxhcmdlIG51bWJlcnMgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuXHRcdCAqIChpLmUuIFwiU2hvd2luZyAxIHRvIDEwIG9mIDU3IGVudHJpZXNcIikgRGF0YVRhYmxlcyB3aWxsIHJlbmRlciBsYXJnZSBudW1iZXJzXG5cdFx0ICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xuXHRcdCAqIHJlbmRlcmVkIGFzIFwiMSwwMDAsMDAwXCIpIHRvIGhlbHAgcmVhZGFiaWxpdHkgZm9yIHRoZSBlbmQgdXNlci4gVGhpc1xuXHRcdCAqIGZ1bmN0aW9uIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbWV0aG9kIERhdGFUYWJsZXMgdXNlcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge2ludH0gdG9Gb3JtYXQgbnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuXHRcdCAqICBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBEYXRhVGFibGVzIHRvIHNob3cgdGhlIG51bWJlclxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvcm1hdE51bWJlclxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIGEgc2luZ2xlIHF1b3RlIGZvciB0aGUgc2VwYXJhdG9yIChub3RlIHRoYXRcblx0XHQgKiAgICAvLyB0aGlzIGNhbiBhbHNvIGJlIGRvbmUgd2l0aCB0aGUgbGFuZ3VhZ2UudGhvdXNhbmRzIG9wdGlvbilcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0ICogICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCInXCJcblx0XHQgKiAgICAgICAgICApO1xuXHRcdCAqICAgICAgICB9O1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XG5cdFx0XHRyZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcblx0XHRcdFx0dGhpcy5vTGFuZ3VhZ2Uuc1Rob3VzYW5kc1xuXHRcdFx0KTtcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHRcdCAqIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgaGVhZGVyIHJvdy4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgYW5kXG5cdFx0ICogZGlzcGxheSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IGhlYWQgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBoZWFkZXJcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBGdWxsIHRhYmxlIGRhdGEgKGFzIGRlcml2ZWQgZnJvbSB0aGUgb3JpZ2luYWwgSFRNTClcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGVuZCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBlbmRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxuXHRcdCAqICAgIHRvIHRoZSBmdWxsIGRhdGEgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5oZWFkZXJDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmaGVhZGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIGhlYWQsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XG5cdFx0ICogICAgICAgICAgaGVhZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIkRpc3BsYXlpbmcgXCIrKGVuZC1zdGFydCkrXCIgcmVjb3Jkc1wiO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJmbkhlYWRlckNhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaW5mb3JtYXRpb24gZWxlbWVudCBjYW4gYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRcblx0XHQgKiBzdGF0ZSBvZiB0aGUgdGFibGUuIEFsdGhvdWdoIHRoZSBpbnRlcm5hdGlvbmFsaXNhdGlvbiBvcHRpb25zIHByZXNlbnRlZCBieVxuXHRcdCAqIERhdGFUYWJsZXMgYXJlIHF1aXRlIGNhcGFibGUgb2YgZGVhbGluZyB3aXRoIG1vc3QgY3VzdG9taXNhdGlvbnMsIHRoZXJlIG1heVxuXHRcdCAqIGJlIHRpbWVzIHdoZXJlIHlvdSB3aXNoIHRvIGN1c3RvbWlzZSB0aGUgc3RyaW5nIGZ1cnRoZXIuIFRoaXMgY2FsbGJhY2tcblx0XHQgKiBhbGxvd3MgeW91IHRvIGRvIGV4YWN0bHkgdGhhdC5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgU3RhcnRpbmcgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGVuZCBFbmQgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcblx0XHQgKiAgQHBhcmFtIHtpbnR9IG1heCBUb3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGFibGUgKHJlZ2FyZGxlc3Mgb2Zcblx0XHQgKiAgICBmaWx0ZXJpbmcpXG5cdFx0ICogIEBwYXJhbSB7aW50fSB0b3RhbCBUb3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgZGF0YSBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gcHJlIFRoZSBzdHJpbmcgdGhhdCBEYXRhVGFibGVzIGhhcyBmb3JtYXR0ZWQgdXNpbmcgaXQnc1xuXHRcdCAqICAgIG93biBydWxlc1xuXHRcdCAqICBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICBcImluZm9DYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIHByZSApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIHN0YXJ0ICtcIiB0byBcIisgZW5kO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsZWQgd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuIE5vcm1hbGx5IERhdGFUYWJsZXMgd2lsbFxuXHRcdCAqIGluaXRpYWxpc2Ugc2VxdWVudGlhbGx5IGFuZCB0aGVyZSB3aWxsIGJlIG5vIG5lZWQgZm9yIHRoaXMgZnVuY3Rpb24sXG5cdFx0ICogaG93ZXZlciwgdGhpcyBkb2VzIG5vdCBob2xkIHRydWUgd2hlbiB1c2luZyBleHRlcm5hbCBsYW5ndWFnZSBpbmZvcm1hdGlvblxuXHRcdCAqIHNpbmNlIHRoYXQgaXMgb2J0YWluZWQgdXNpbmcgYW4gYXN5bmMgWEhSIGNhbGwuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgSlNPTiBvYmplY3QgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIgLSBvbmx5XG5cdFx0ICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5pdENvbXBsZXRlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImluaXRDb21wbGV0ZVwiOiBmdW5jdGlvbihzZXR0aW5ncywganNvbikge1xuXHRcdCAqICAgICAgICAgIGFsZXJ0KCAnRGF0YVRhYmxlcyBoYXMgZmluaXNoZWQgaXRzIGluaXRpYWxpc2F0aW9uLicgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiZm5Jbml0Q29tcGxldGVcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxlZCBhdCB0aGUgdmVyeSBzdGFydCBvZiBlYWNoIHRhYmxlIGRyYXcgYW5kIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGVcblx0XHQgKiBkcmF3IGJ5IHJldHVybmluZyBmYWxzZSwgYW55IG90aGVyIHJldHVybiAoaW5jbHVkaW5nIHVuZGVmaW5lZCkgcmVzdWx0cyBpblxuXHRcdCAqIHRoZSBmdWxsIGRyYXcgb2NjdXJyaW5nKS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSBGYWxzZSB3aWxsIGNhbmNlbCB0aGUgZHJhdywgYW55dGhpbmcgZWxzZSAoaW5jbHVkaW5nIG5vXG5cdFx0ICogICAgcmV0dXJuKSB3aWxsIGFsbG93IGl0IHRvIGNvbXBsZXRlLlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByZURyYXdDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwcmVEcmF3Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdCAqICAgICAgICAgIGlmICggJCgnI3Rlc3QnKS52YWwoKSA9PSAxICkge1xuXHRcdCAqICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuUHJlRHJhd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gJ3Bvc3QgcHJvY2VzcycgZWFjaCByb3cgYWZ0ZXIgaXQgaGF2ZSBiZWVuXG5cdFx0ICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXG5cdFx0ICogZnVuY3Rpb24gbWlnaHQgYmUgdXNlZCBmb3Igc2V0dGluZyB0aGUgcm93IGNsYXNzIG5hbWUgZXRjLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkaXNwbGF5SW5kZXggVGhlIGRpc3BsYXkgaW5kZXggZm9yIHRoZSBjdXJyZW50IHRhYmxlIGRyYXdcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleEZ1bGwgVGhlIGluZGV4IG9mIHRoZSBkYXRhIGluIHRoZSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiAgICByb3dzIChhZnRlciBmaWx0ZXJpbmcpXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicm93Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGlzcGxheUluZGV4LCBkaXNwbGF5SW5kZXhGdWxsICkge1xuXHRcdCAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXG5cdFx0ICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiICkge1xuXHRcdCAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblJvd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIHdoaWNoIG9idGFpbnNcblx0XHQgKiB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgc28gc29tZXRoaW5nIG1vcmUgc3VpdGFibGUgZm9yIHlvdXIgYXBwbGljYXRpb24uXG5cdFx0ICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIHVzZSBQT1NUIGRhdGEsIG9yIHB1bGwgaW5mb3JtYXRpb24gZnJvbSBhIEdlYXJzIG9yXG5cdFx0ICogQUlSIGRhdGFiYXNlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgSFRUUCBzb3VyY2UgdG8gb2J0YWluIHRoZSBkYXRhIGZyb20gKGBhamF4YClcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBBIGtleS92YWx1ZSBwYWlyIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIHRvIHNlbmRcblx0XHQgKiAgICB0byB0aGUgc2VydmVyXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9mIHRoZSBkYXRhIGdldFxuXHRcdCAqICAgIHByb2Nlc3MgdGhhdCB3aWxsIGRyYXcgdGhlIGRhdGEgb24gdGhlIHBhZ2UuXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJEYXRhXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJmblNlcnZlckRhdGFcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqICBJdCBpcyBvZnRlbiB1c2VmdWwgdG8gc2VuZCBleHRyYSBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBtYWtpbmcgYW4gQWpheFxuXHRcdCAqIHJlcXVlc3QgLSBmb3IgZXhhbXBsZSBjdXN0b20gZmlsdGVyaW5nIGluZm9ybWF0aW9uLCBhbmQgdGhpcyBjYWxsYmFja1xuXHRcdCAqIGZ1bmN0aW9uIG1ha2VzIGl0IHRyaXZpYWwgdG8gc2VuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgc2VydmVyLiBUaGVcblx0XHQgKiBwYXNzZWQgaW4gcGFyYW1ldGVyIGlzIHRoZSBkYXRhIHNldCB0aGF0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGJ5XG5cdFx0ICogRGF0YVRhYmxlcywgYW5kIHlvdSBjYW4gYWRkIHRvIHRoaXMgb3IgbW9kaWZ5IGl0IGFzIHlvdSByZXF1aXJlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgYXJyYXkgKGFycmF5IG9mIG9iamVjdHMgd2hpY2ggYXJlIG5hbWUvdmFsdWVcblx0XHQgKiAgICBwYWlycykgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieSBEYXRhVGFibGVzIGFuZCB3aWxsIGJlIHNlbnQgdG8gdGhlXG5cdFx0ICogICAgc2VydmVyLiBJbiB0aGUgY2FzZSBvZiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHQgKiAgICB0aGlzIHdpbGwgYmUgYW4gZW1wdHkgYXJyYXksIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZXJlIHdpbGwgYmUgYVxuXHRcdCAqICAgIHNpZ25pZmljYW50IG51bWJlciBvZiBwYXJhbWV0ZXJzIVxuXHRcdCAqICBAcmV0dXJucyB7dW5kZWZpbmVkfSBFbnN1cmUgdGhhdCB5b3UgbW9kaWZ5IHRoZSBkYXRhIGFycmF5IHBhc3NlZCBpbixcblx0XHQgKiAgICBhcyB0aGlzIGlzIHBhc3NlZCBieSByZWZlcmVuY2UuXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclBhcmFtc1xuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwiZm5TZXJ2ZXJQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXG5cdFx0ICogc3RhdGUgb2YgYSB0YWJsZSBpcyBsb2FkZWQuIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvYWQgZnJvbSBgbG9jYWxTdG9yYWdlYFxuXHRcdCAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCBjYW4gYmUgZXhlY3V0ZWQgd2hlbiBkb25lLiBJdFxuXHRcdCAqICAgIHNob3VsZCBiZSBwYXNzZWQgdGhlIGxvYWRlZCBzdGF0ZSBvYmplY3QuXG5cdFx0ICogIEByZXR1cm4ge29iamVjdH0gVGhlIERhdGFUYWJsZXMgc3RhdGUgb2JqZWN0IHRvIGJlIGxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZENhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgY2FsbGJhY2spIHtcblx0XHQgKiAgICAgICAgICAkLmFqYXgoIHtcblx0XHQgKiAgICAgICAgICAgIFwidXJsXCI6IFwiL3N0YXRlX2xvYWRcIixcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0ICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcblx0XHQgKiAgICAgICAgICAgICAgY2FsbGJhY2soIGpzb24gKTtcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICB9ICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShcblx0XHRcdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXG5cdFx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgcHJpb3IgdG8gbG9hZGluZyB0aGF0IHN0YXRlLlxuXHRcdCAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkIGRhdGEsIGJ1dFxuXHRcdCAqIHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlLiBOb3RlIHRoYXQgZm9yXG5cdFx0ICogcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYHN0YXRlTG9hZFBhcmFtc2AgZXZlbnQgdG8gbG9hZCBwYXJhbWV0ZXJzIGZvclxuXHRcdCAqIGEgcGx1Zy1pbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCBpcyB0byBiZSBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIGxvYWRlZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIERpc2FsbG93IHN0YXRlIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzdGF0ZSBzYXZpbmcgbWV0aG9kXG5cdFx0ICogYW5kIHRoZSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBhcyBhIHJlc3VsdCBvZiB0aGUgbG9hZGVkIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IHdhcyBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gU2hvdyBhbiBhbGVydCB3aXRoIHRoZSBmaWx0ZXJpbmcgdmFsdWUgdGhhdCB3YXMgc2F2ZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZGVkXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGFsZXJ0KCAnU2F2ZWQgZmlsdGVyIHdhczogJytkYXRhLm9TZWFyY2guc1NlYXJjaCApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRlZFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2F2ZSB0aGUgdGFibGUgc3RhdGUuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBkZWZpbmUgd2hlcmUgYW5kIGhvdyB0aGUgc3RhdGVcblx0XHQgKiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlIGlzIHN0b3JlZCBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCB1c2UgYGxvY2FsU3RvcmFnZWBcblx0XHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZUNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIC8vIFNlbmQgYW4gQWpheCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgd2l0aCB0aGUgc3RhdGUgb2JqZWN0XG5cdFx0ICogICAgICAgICAgJC5hamF4KCB7XG5cdFx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9zYXZlXCIsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFcIjogZGF0YSxcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0ICogICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIlxuXHRcdCAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uICgpIHt9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzLCBkYXRhICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5zZXRJdGVtKFxuXHRcdFx0XHRcdCdEYXRhVGFibGVzXycrc2V0dGluZ3Muc0luc3RhbmNlKydfJytsb2NhdGlvbi5wYXRobmFtZSxcblx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeSggZGF0YSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXG5cdFx0ICogaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZC4gVGhpcyBtZXRob2QgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZlxuXHRcdCAqIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0IHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Jcblx0XHQgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcblx0XHQgKiB1c2UgdGhlIGBzdGF0ZVNhdmVQYXJhbXNgIGV2ZW50IHRvIHNhdmUgcGFyYW1ldGVycyBmb3IgYSBwbHVnLWluLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZVBhcmFtc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgc2F2ZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlU2F2ZVBhcmFtc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkLiBBZnRlciB0aGlzIHBlcmlvZFxuXHRcdCAqIGhhcyBlbGFwc2VkIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHRvIHRoZSBkZWZhdWx0LlxuXHRcdCAqIFZhbHVlIGlzIGdpdmVuIGluIHNlY29uZHMuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCA3MjAwIDxpPigyIGhvdXJzKTwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVEdXJhdGlvblxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZUR1cmF0aW9uXCI6IDYwKjYwKjI0OyAvLyAxIGRheVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiaVN0YXRlRHVyYXRpb25cIjogNzIwMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGwgbm90IG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgZm9yIHRoZSBmaXJzdFxuXHRcdCAqIHBhZ2UgZHJhdyAtIHJhdGhlciBpdCB3aWxsIHVzZSB0aGUgZGF0YSBhbHJlYWR5IG9uIHRoZSBwYWdlIChubyBzb3J0aW5nIGV0Y1xuXHRcdCAqIHdpbGwgYmUgYXBwbGllZCB0byBpdCksIHRodXMgc2F2aW5nIG9uIGFuIFhIUiBhdCBsb2FkIHRpbWUuIGBkZWZlckxvYWRpbmdgXG5cdFx0ICogaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGRlZmVycmVkIGxvYWRpbmcgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBhbHNvIHVzZWRcblx0XHQgKiB0byB0ZWxsIERhdGFUYWJsZXMgaG93IG1hbnkgcmVjb3JkcyB0aGVyZSBhcmUgaW4gdGhlIGZ1bGwgdGFibGUgKGFsbG93aW5nXG5cdFx0ICogdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgYW5kIHBhZ2luYXRpb24gdG8gYmUgZGlzcGxheWVkIGNvcnJlY3RseSkuIEluIHRoZSBjYXNlXG5cdFx0ICogd2hlcmUgYSBmaWx0ZXJpbmcgaXMgYXBwbGllZCB0byB0aGUgdGFibGUgb24gaW5pdGlhbCBsb2FkLCB0aGlzIGNhbiBiZVxuXHRcdCAqIGluZGljYXRlZCBieSBnaXZpbmcgdGhlIHBhcmFtZXRlciBhcyBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcblx0XHQgKiB0aGUgbnVtYmVyIG9mIHJlY29yZHMgYXZhaWxhYmxlIGFmdGVyIGZpbHRlcmluZyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZVxuXHRcdCAqIG51bWJlciBvZiByZWNvcmRzIHdpdGhvdXQgZmlsdGVyaW5nIChhbGxvd2luZyB0aGUgdGFibGUgaW5mb3JtYXRpb24gZWxlbWVudFxuXHRcdCAqIHRvIGJlIHNob3duIGNvcnJlY3RseSkuXG5cdFx0ICogIEB0eXBlIGludCB8IGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJMb2FkaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyA1NyByZWNvcmRzIGF2YWlsYWJsZSBpbiB0aGUgdGFibGUsIG5vIGZpbHRlcmluZyBhcHBsaWVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdFx0ICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IDU3XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gNTcgcmVjb3JkcyBhZnRlciBmaWx0ZXJpbmcsIDEwMCB3aXRob3V0IGZpbHRlcmluZyAoYW4gaW5pdGlhbCBmaWx0ZXIgYXBwbGllZClcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwic2NyaXB0cy9zZXJ2ZXJfcHJvY2Vzc2luZy5waHBcIixcblx0XHQgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogWyA1NywgMTAwIF0sXG5cdFx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcblx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIm15X2ZpbHRlclwiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJpRGVmZXJMb2FkaW5nXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IG9uIGEgc2luZ2xlIHBhZ2Ugd2hlbiB1c2luZyBwYWdpbmF0aW9uLiBJZlxuXHRcdCAqIGZlYXR1cmUgZW5hYmxlZCAoYGxlbmd0aENoYW5nZWApIHRoZW4gdGhlIGVuZCB1c2VyIHdpbGwgYmUgYWJsZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoaXMgdG8gYSBjdXN0b20gc2V0dGluZyB1c2luZyBhIHBvcC11cCBtZW51LlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMTBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnZUxlbmd0aFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdlTGVuZ3RoXCI6IDUwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJpRGlzcGxheUxlbmd0aFwiOiAxMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGRhdGEgZGlzcGxheSB3aGVuIHVzaW5nIERhdGFUYWJsZXMgd2l0aFxuXHRcdCAqIHBhZ2luYXRpb24uIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJhdGhlciB0aGFuXG5cdFx0ICogdGhlIHBhZ2UgbnVtYmVyLCBzbyBpZiB5b3UgaGF2ZSAxMCByZWNvcmRzIHBlciBwYWdlIGFuZCB3YW50IHRvIHN0YXJ0IG9uXG5cdFx0ICogdGhlIHRoaXJkIHBhZ2UsIGl0IHNob3VsZCBiZSBcIjIwXCIuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRpc3BsYXlTdGFydFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkaXNwbGF5U3RhcnRcIjogMjBcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImlEaXNwbGF5U3RhcnRcIjogMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcblx0XHQgKiBhbmQgZmlsdGVyaW5nKSBieSBhZGRpbmcgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSB0byB0aGUgcmVxdWlyZWQgZWxlbWVudHMuIFRoaXNcblx0XHQgKiBhbGxvd3MgeW91IHRvIHRhYiB0aHJvdWdoIHRoZSBjb250cm9scyBhbmQgcHJlc3MgdGhlIGVudGVyIGtleSB0byBhY3RpdmF0ZSB0aGVtLlxuXHRcdCAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqIFlvdSBjYW4gb3ZlcnJ1bGUgdGhpcyB1c2luZyB0aGlzIHBhcmFtZXRlciBpZiB5b3Ugd2lzaC4gVXNlIGEgdmFsdWUgb2YgLTEgdG9cblx0XHQgKiBkaXNhYmxlIGJ1aWx0LWluIGtleWJvYXJkIG5hdmlnYXRpb24uXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnRhYkluZGV4XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInRhYkluZGV4XCI6IDFcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJpVGFiSW5kZXhcIjogMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzZXMgdGhhdCBEYXRhVGFibGVzIGFzc2lnbnMgdG8gdGhlIHZhcmlvdXMgY29tcG9uZW50cyBhbmQgZmVhdHVyZXNcblx0XHQgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxuXHRcdCAqIGR1cmluZyBpbml0aWFsaXNhdGlvbiBpbiBhZGRpdGlvbiB0byB0aHJvdWdoIHRoZSBzdGF0aWNcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vU3RkQ2xhc3Nlc30gb2JqZWN0KS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY2xhc3Nlc1xuXHRcdCAqL1xuXHRcdFwib0NsYXNzZXNcIjoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGwgc3RyaW5ncyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbiB0aGUgdXNlciBpbnRlcmZhY2UgdGhhdCBpdCBjcmVhdGVzXG5cdFx0ICogYXJlIGRlZmluZWQgaW4gdGhpcyBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBtb2RpZmllZCB0aGVtIGluZGl2aWR1YWxseSBvclxuXHRcdCAqIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGVtIGFsbCBhcyByZXF1aXJlZC5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Vcblx0XHQgKi9cblx0XHRcIm9MYW5ndWFnZVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG5cdFx0XHQgKiBhY3R1YWxseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBidXQgd2lsbCBiZSByZWFkIGJ5IHNjcmVlbnJlYWRlcnMsIGFuZCB0aHVzXG5cdFx0XHQgKiBtdXN0IGJlIGludGVybmF0aW9uYWxpc2VkIGFzIHdlbGwpLlxuXHRcdFx0ICogIEBuYW1lc3BhY2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYVxuXHRcdFx0ICovXG5cdFx0XHRcIm9BcmlhXCI6IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXG5cdFx0XHRcdCAqIHNvcnRlZCBhc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG5cdFx0XHRcdCAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydEFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInNvcnRBc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBhc2NlbmRpbmdcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcIixcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIG1heSBiZVxuXHRcdFx0XHQgKiBzb3J0ZWQgZGVzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cblx0XHRcdFx0ICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0RGVzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInNvcnREZXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgZGVzY2VuZGluZ1wiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic1NvcnREZXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBkZXNjZW5kaW5nXCJcblx0XHRcdH0sXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYWdpbmF0aW9uIHN0cmluZyB1c2VkIGJ5IERhdGFUYWJsZXMgZm9yIHRoZSBidWlsdC1pbiBwYWdpbmF0aW9uXG5cdFx0XHQgKiBjb250cm9sIHR5cGVzLlxuXHRcdFx0ICogIEBuYW1lc3BhY2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGVcblx0XHRcdCAqL1xuXHRcdFx0XCJvUGFnaW5hdGVcIjoge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ2Z1bGxfbnVtYmVycycgdHlwZSBvZiBwYWdpbmF0aW9uIGZvciB0aGVcblx0XHRcdFx0ICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGZpcnN0IHBhZ2UuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IEZpcnN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5maXJzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJmaXJzdFwiOiBcIkZpcnN0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNGaXJzdFwiOiBcIkZpcnN0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG5cdFx0XHRcdCAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBsYXN0IHBhZ2UuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IExhc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmxhc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwibGFzdFwiOiBcIkxhc3QgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic0xhc3RcIjogXCJMYXN0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ25leHQnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvIHRoZVxuXHRcdFx0XHQgKiBuZXh0IHBhZ2UpLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBOZXh0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5uZXh0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcIm5leHRcIjogXCJOZXh0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNOZXh0XCI6IFwiTmV4dFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICdwcmV2aW91cycgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG9cblx0XHRcdFx0ICogdGhlIHByZXZpb3VzIHBhZ2UpLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBQcmV2aW91c1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUucHJldmlvdXNcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwicHJldmlvdXNcIjogXCJQcmV2aW91cyBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzUHJldmlvdXNcIjogXCJQcmV2aW91c1wiXG5cdFx0XHR9LFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBzdHJpbmcgaXMgc2hvd24gaW4gcHJlZmVyZW5jZSB0byBgemVyb1JlY29yZHNgIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0XHQgKiBlbXB0eSBvZiBkYXRhIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuIE5vdGUgdGhhdCB0aGlzIGlzIGFuIG9wdGlvbmFsXG5cdFx0XHQgKiBwYXJhbWV0ZXIgLSBpZiBpdCBpcyBub3QgZ2l2ZW4sIHRoZSB2YWx1ZSBvZiBgemVyb1JlY29yZHNgIHdpbGwgYmUgdXNlZFxuXHRcdFx0ICogaW5zdGVhZCAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGdpdmVuIHZhbHVlKS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZW1wdHlUYWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJlbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIHN0cmluZyBnaXZlcyBpbmZvcm1hdGlvbiB0byB0aGUgZW5kIHVzZXIgYWJvdXQgdGhlIGluZm9ybWF0aW9uXG5cdFx0XHQgKiB0aGF0IGlzIGN1cnJlbnQgb24gZGlzcGxheSBvbiB0aGUgcGFnZS4gVGhlIGZvbGxvd2luZyB0b2tlbnMgY2FuIGJlXG5cdFx0XHQgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXG5cdFx0XHQgKiBkaXNwbGF5IHVwZGF0ZXMuIFRoaXMgdG9rZW5zIGNhbiBiZSBwbGFjZWQgYW55d2hlcmUgaW4gdGhlIHN0cmluZywgb3Jcblx0XHRcdCAqIHJlbW92ZWQgYXMgbmVlZGVkIGJ5IHRoZSBsYW5ndWFnZSByZXF1aXJlczpcblx0XHRcdCAqXG5cdFx0XHQgKiAqIGBcXF9TVEFSVFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBmaXJzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdFx0ICogKiBgXFxfRU5EXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGxhc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRcdCAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcblx0XHRcdCAqICogYFxcX01BWFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgd2l0aG91dCBmaWx0ZXJpbmdcblx0XHRcdCAqICogYFxcX1BBR0VcXF9gIC0gQ3VycmVudCBwYWdlIG51bWJlclxuXHRcdFx0ICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb1wiOiBcIlNob3dpbmcgcGFnZSBfUEFHRV8gb2YgX1BBR0VTX1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9cIjogXCJTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGlzcGxheSBpbmZvcm1hdGlvbiBzdHJpbmcgZm9yIHdoZW4gdGhlIHRhYmxlIGlzIGVtcHR5LiBUeXBpY2FsbHkgdGhlXG5cdFx0XHQgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9FbXB0eVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvRW1wdHlcIjogXCJObyBlbnRyaWVzIHRvIHNob3dcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvRW1wdHlcIjogXCJTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxuXHRcdFx0ICogdG8gdGhlIGluZm9ybWF0aW9uIChgaW5mb2ApIHRvIGdpdmUgYW4gaWRlYSBvZiBob3cgc3Ryb25nIHRoZSBmaWx0ZXJpbmdcblx0XHRcdCAqIGlzLiBUaGUgdmFyaWFibGUgX01BWF8gaXMgZHluYW1pY2FsbHkgdXBkYXRlZC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCAoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0ZpbHRlcmVkXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9GaWx0ZXJlZFwiOiBcIiAtIGZpbHRlcmluZyBmcm9tIF9NQVhfIHJlY29yZHNcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvRmlsdGVyZWRcIjogXCIoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIElmIGNhbiBiZSB1c2VmdWwgdG8gYXBwZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBpbmZvIHN0cmluZyBhdCB0aW1lcyxcblx0XHRcdCAqIGFuZCB0aGlzIHZhcmlhYmxlIGRvZXMgZXhhY3RseSB0aGF0LiBUaGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgYXBwZW5kZWQgdG9cblx0XHRcdCAqIHRoZSBgaW5mb2AgKGBpbmZvRW1wdHlgIGFuZCBgaW5mb0ZpbHRlcmVkYCBpbiB3aGF0ZXZlciBjb21iaW5hdGlvbiB0aGV5IGFyZVxuXHRcdFx0ICogYmVpbmcgdXNlZCkgYXQgYWxsIHRpbWVzLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9Qb3N0Rml4XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9Qb3N0Rml4XCI6IFwiQWxsIHJlY29yZHMgc2hvd24gYXJlIGRlcml2ZWQgZnJvbSByZWFsIGluZm9ybWF0aW9uLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBkZWNpbWFsIHBsYWNlIG9wZXJhdG9yIGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlclxuXHRcdFx0ICogbGFuZ3VhZ2Ugb3B0aW9ucyBzaW5jZSBEYXRhVGFibGVzIGRvZXNuJ3Qgb3V0cHV0IGZsb2F0aW5nIHBvaW50XG5cdFx0XHQgKiBudW1iZXJzLCBzbyBpdCB3b24ndCBldmVyIHVzZSB0aGlzIGZvciBkaXNwbGF5IG9mIGEgbnVtYmVyLiBSYXRoZXIsXG5cdFx0XHQgKiB3aGF0IHRoaXMgcGFyYW1ldGVyIGRvZXMgaXMgbW9kaWZ5IHRoZSBzb3J0IG1ldGhvZHMgb2YgdGhlIHRhYmxlIHNvXG5cdFx0XHQgKiB0aGF0IG51bWJlcnMgd2hpY2ggYXJlIGluIGEgZm9ybWF0IHdoaWNoIGhhcyBhIGNoYXJhY3RlciBvdGhlciB0aGFuXG5cdFx0XHQgKiBhIHBlcmlvZCAoYC5gKSBhcyBhIGRlY2ltYWwgcGxhY2Ugd2lsbCBiZSBzb3J0ZWQgbnVtZXJpY2FsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogTm90ZSB0aGF0IG51bWJlcnMgd2l0aCBkaWZmZXJlbnQgZGVjaW1hbCBwbGFjZXMgY2Fubm90IGJlIHNob3duIGluXG5cdFx0XHQgKiB0aGUgc2FtZSB0YWJsZSBhbmQgc3RpbGwgYmUgc29ydGFibGUsIHRoZSB0YWJsZSBtdXN0IGJlIGNvbnNpc3RlbnQuXG5cdFx0XHQgKiBIb3dldmVyLCBtdWx0aXBsZSBkaWZmZXJlbnQgdGFibGVzIG9uIHRoZSBwYWdlIGNhbiB1c2UgZGlmZmVyZW50XG5cdFx0XHQgKiBkZWNpbWFsIHBsYWNlIGNoYXJhY3RlcnMuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5kZWNpbWFsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImRlY2ltYWxcIjogXCIsXCJcblx0XHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0RlY2ltYWxcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEYXRhVGFibGVzIGhhcyBhIGJ1aWxkIGluIG51bWJlciBmb3JtYXR0ZXIgKGBmb3JtYXROdW1iZXJgKSB3aGljaCBpc1xuXHRcdFx0ICogdXNlZCB0byBmb3JtYXQgbGFyZ2UgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0YWJsZSBpbmZvcm1hdGlvbi5cblx0XHRcdCAqIEJ5IGRlZmF1bHQgYSBjb21tYSBpcyB1c2VkLCBidXQgdGhpcyBjYW4gYmUgdHJpdmlhbGx5IGNoYW5nZWQgdG8gYW55XG5cdFx0XHQgKiBjaGFyYWN0ZXIgeW91IHdpc2ggd2l0aCB0aGlzIHBhcmFtZXRlci5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCAsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS50aG91c2FuZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiJ1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1Rob3VzYW5kc1wiOiBcIixcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXRhaWwgdGhlIGFjdGlvbiB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgZHJvcCBkb3duIG1lbnUgZm9yIHRoZVxuXHRcdFx0ICogcGFnaW5hdGlvbiBsZW5ndGggb3B0aW9uIGlzIGNoYW5nZWQuIFRoZSAnX01FTlVfJyB2YXJpYWJsZSBpcyByZXBsYWNlZFxuXHRcdFx0ICogd2l0aCBhIGRlZmF1bHQgc2VsZWN0IGxpc3Qgb2YgMTAsIDI1LCA1MCBhbmQgMTAwLCBhbmQgY2FuIGJlIHJlcGxhY2VkXG5cdFx0XHQgKiB3aXRoIGEgY3VzdG9tIHNlbGVjdCBib3ggaWYgcmVxdWlyZWQuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2hvdyBfTUVOVV8gZW50cmllc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubGVuZ3RoTWVudVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTGFuZ3VhZ2UgY2hhbmdlIG9ubHlcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiBcIkRpc3BsYXkgX01FTlVfIHJlY29yZHNcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTGFuZ3VhZ2UgYW5kIG9wdGlvbnMgY2hhbmdlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogJ0Rpc3BsYXkgPHNlbGVjdD4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjIwXCI+MjA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjMwXCI+MzA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjQwXCI+NDA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjUwXCI+NTA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIi0xXCI+QWxsPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzwvc2VsZWN0PiByZWNvcmRzJ1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNMZW5ndGhNZW51XCI6IFwiU2hvdyBfTUVOVV8gZW50cmllc1wiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZW4gdXNpbmcgQWpheCBzb3VyY2VkIGRhdGEgYW5kIGR1cmluZyB0aGUgZmlyc3QgZHJhdyB3aGVuIERhdGFUYWJsZXMgaXNcblx0XHRcdCAqIGdhdGhlcmluZyB0aGUgZGF0YSwgdGhpcyBtZXNzYWdlIGlzIHNob3duIGluIGFuIGVtcHR5IHJvdyBpbiB0aGUgdGFibGUgdG9cblx0XHRcdCAqIGluZGljYXRlIHRvIHRoZSBlbmQgdXNlciB0aGUgdGhlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLiBOb3RlIHRoYXQgdGhpc1xuXHRcdFx0ICogcGFyYW1ldGVyIGlzIG5vdCB1c2VkIHdoZW4gbG9hZGluZyBkYXRhIGJ5IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIGp1c3Rcblx0XHRcdCAqIEFqYXggc291cmNlZCBkYXRhIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBMb2FkaW5nLi4uXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sb2FkaW5nUmVjb3Jkc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJsb2FkaW5nUmVjb3Jkc1wiOiBcIlBsZWFzZSB3YWl0IC0gbG9hZGluZy4uLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTG9hZGluZy4uLlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRleHQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYmxlIGlzIHByb2Nlc3NpbmcgYSB1c2VyIGFjdGlvblxuXHRcdFx0ICogKHVzdWFsbHkgYSBzb3J0IGNvbW1hbmQgb3Igc2ltaWxhcikuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgUHJvY2Vzc2luZy4uLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucHJvY2Vzc2luZ1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJwcm9jZXNzaW5nXCI6IFwiRGF0YVRhYmxlcyBpcyBjdXJyZW50bHkgYnVzeVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1Byb2Nlc3NpbmdcIjogXCJQcm9jZXNzaW5nLi4uXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGV0YWlscyB0aGUgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgdXNlciB0eXBlcyBpbnRvIHRoZVxuXHRcdFx0ICogZmlsdGVyaW5nIGlucHV0IHRleHQgYm94LiBUaGUgdmFyaWFibGUgXCJfSU5QVVRfXCIsIGlmIHVzZWQgaW4gdGhlIHN0cmluZyxcblx0XHRcdCAqIGlzIHJlcGxhY2VkIHdpdGggdGhlIEhUTUwgdGV4dCBib3ggZm9yIHRoZSBmaWx0ZXJpbmcgaW5wdXQgYWxsb3dpbmdcblx0XHRcdCAqIGNvbnRyb2wgb3ZlciB3aGVyZSBpdCBhcHBlYXJzIGluIHRoZSBzdHJpbmcuIElmIFwiX0lOUFVUX1wiIGlzIG5vdCBnaXZlblxuXHRcdFx0ICogdGhlbiB0aGUgaW5wdXQgYm94IGlzIGFwcGVuZGVkIHRvIHRoZSBzdHJpbmcgYXV0b21hdGljYWxseS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTZWFyY2g6XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIElucHV0IHRleHQgYm94IHdpbGwgYmUgYXBwZW5kZWQgYXQgdGhlIGVuZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkZpbHRlciByZWNvcmRzOlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBTcGVjaWZ5IHdoZXJlIHRoZSBmaWx0ZXIgc2hvdWxkIGFwcGVhclxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJBcHBseSBmaWx0ZXIgX0lOUFVUXyB0byB0YWJsZVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1NlYXJjaFwiOiBcIlNlYXJjaDpcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoUGxhY2Vob2xkZXJcblx0XHRcdCAqL1xuXHRcdFx0XCJzU2VhcmNoUGxhY2Vob2xkZXJcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbGwgb2YgdGhlIGxhbmd1YWdlIGluZm9ybWF0aW9uIGNhbiBiZSBzdG9yZWQgaW4gYSBmaWxlIG9uIHRoZVxuXHRcdFx0ICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cblx0XHRcdCAqIEl0IG11c3Qgc3RvcmUgdGhlIFVSTCBvZiB0aGUgbGFuZ3VhZ2UgZmlsZSwgd2hpY2ggaXMgaW4gYSBKU09OIGZvcm1hdCxcblx0XHRcdCAqIGFuZCB0aGUgb2JqZWN0IGhhcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBvTGFuZ3VhZ2Ugb2JqZWN0IGluIHRoZVxuXHRcdFx0ICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxuXHRcdFx0ICogdGhlIGV4YW1wbGUgbGFuZ3VhZ2UgZmlsZXMgdG8gc2VlIGhvdyB0aGlzIHdvcmtzIGluIGFjdGlvbi5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudXJsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInVybFwiOiBcImh0dHA6Ly93d3cuc3ByeW1lZGlhLmNvLnVrL2RhdGFUYWJsZXMvbGFuZy50eHRcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNVcmxcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHNob3duIGluc2lkZSB0aGUgdGFibGUgcmVjb3JkcyB3aGVuIHRoZSBpcyBubyBpbmZvcm1hdGlvbiB0byBiZVxuXHRcdFx0ICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXG5cdFx0XHQgKiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFibGUgYXQgYWxsIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuemVyb1JlY29yZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiemVyb1JlY29yZHNcIjogXCJObyByZWNvcmRzIHRvIGRpc3BsYXlcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNaZXJvUmVjb3Jkc1wiOiBcIk5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcIlxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGhhdmUgZGVmaW5lIHRoZSBnbG9iYWwgZmlsdGVyaW5nIHN0YXRlIGF0XG5cdFx0ICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuXHRcdCAqIGRlZmluZWQsIGJ1dCBhbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFdoZW4gYHJlZ2V4YCBpcyB0cnVlLFxuXHRcdCAqIHRoZSBzZWFyY2ggc3RyaW5nIHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgd2hlbiBmYWxzZVxuXHRcdCAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuXHRcdCAqIERhdGFUYWJsZXMgd2lsbCB1c2UgaXQncyBzbWFydCBmaWx0ZXJpbmcgbWV0aG9kcyAodG8gd29yZCBtYXRjaCBhdFxuXHRcdCAqIGFueSBwb2ludCBpbiB0aGUgZGF0YSksIHdoZW4gZmFsc2UgdGhpcyB3aWxsIG5vdCBiZSBkb25lLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJvU2VhcmNoXCI6ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoICksXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvciBgYWFEYXRhYCBmb3Jcblx0XHQgKiBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhIGZyb20gYW4gQWpheFxuXHRcdCAqIHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyIGFsbG93cyB0aGF0XG5cdFx0ICogcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWQgb2JqZWN0IG5vdGF0aW9uIHRvXG5cdFx0ICogZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgZGF0YVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheERhdGFQcm9wXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJzQWpheERhdGFQcm9wXCI6IFwiZGF0YVwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogWW91IGNhbiBpbnN0cnVjdCBEYXRhVGFibGVzIHRvIGxvYWQgZGF0YSBmcm9tIGFuIGV4dGVybmFsXG5cdFx0ICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxuXHRcdCAqIGFscmVhZHkgaGF2ZSkuIFNpbXBseSBwcm92aWRlIGEgdXJsIGEgSlNPTiBvYmplY3QgY2FuIGJlIG9idGFpbmVkIGZyb20uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4U291cmNlXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJzQWpheFNvdXJjZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpbml0aWFsaXNhdGlvbiB2YXJpYWJsZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgZXhhY3RseSB3aGVyZSBpbiB0aGVcblx0XHQgKiBET00geW91IHdhbnQgRGF0YVRhYmxlcyB0byBpbmplY3QgdGhlIHZhcmlvdXMgY29udHJvbHMgaXQgYWRkcyB0byB0aGUgcGFnZVxuXHRcdCAqIChmb3IgZXhhbXBsZSB5b3UgbWlnaHQgd2FudCB0aGUgcGFnaW5hdGlvbiBjb250cm9scyBhdCB0aGUgdG9wIG9mIHRoZVxuXHRcdCAqIHRhYmxlKS4gRElWIGVsZW1lbnRzICh3aXRoIG9yIHdpdGhvdXQgYSBjdXN0b20gY2xhc3MpIGNhbiBhbHNvIGJlIGFkZGVkIHRvXG5cdFx0ICogYWlkIHN0eWxpbmcuIFRoZSBmb2xsb3cgc3ludGF4IGlzIHVzZWQ6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGFsbG93ZWQ6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSBhbGxvd2VkOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nSCcgLSBqUXVlcnlVSSB0aGVtZSBcImhlYWRlclwiIGNsYXNzZXMgKCdmZy10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10ciB1aS1oZWxwZXItY2xlYXJmaXgnKTwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J0YnIC0galF1ZXJ5VUkgdGhlbWUgXCJmb290ZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIHN5bnRheCBpcyBleHBlY3RlZDpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDsnIGFuZCAnJmd0OycgLSBkaXYgZWxlbWVudHM8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCJjbGFzc1wiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhIGNsYXNzPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wiI2lkXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGFuIElEPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgICA8bGk+RXhhbXBsZXM6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCJ3cmFwcGVyXCJmbGlwdCZndDsnPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O2xmJmx0O3QmZ3Q7aXAmZ3Q7JzwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBsZnJ0aXAgPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyBmYWxzZSk8L2k+IDxiPm9yPC9iPlxuXHRcdCAqICAgIDxcIkhcImxmcj50PFwiRlwiaXA+IDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgdHJ1ZSk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkb21cIjogJyZsdDtcInRvcFwiaSZndDtydCZsdDtcImJvdHRvbVwiZmxwJmd0OyZsdDtcImNsZWFyXCImZ3Q7J1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNEb21cIjogXCJsZnJ0aXBcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBkZWxheSBvcHRpb24uIFRoaXMgd2lsbCB0aHJvdHRsZSBmdWxsIHRhYmxlIHNlYXJjaGVzIHRoYXQgdXNlIHRoZVxuXHRcdCAqIERhdGFUYWJsZXMgcHJvdmlkZWQgc2VhcmNoIGlucHV0IGVsZW1lbnQgKGl0IGRvZXMgbm90IGVmZmVjdCBjYWxscyB0b1xuXHRcdCAqIGBkdC1hcGkgc2VhcmNoKClgLCBwcm92aWRpbmcgYSBkZWxheSBiZWZvcmUgdGhlIHNlYXJjaCBpcyBtYWRlLlxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoRGVsYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoRGVsYXlcIjogMjAwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBmZWF0dXJlcyBzaXggZGlmZmVyZW50IGJ1aWx0LWluIG9wdGlvbnMgZm9yIHRoZSBidXR0b25zIHRvXG5cdFx0ICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxuXHRcdCAqXG5cdFx0ICogKiBgbnVtYmVyc2AgLSBQYWdlIG51bWJlciBidXR0b25zIG9ubHlcblx0XHQgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxuXHRcdCAqICogJ3NpbXBsZV9udW1iZXJzYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHRcdCAqICogYGZ1bGxgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9uc1xuXHRcdCAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHRcdCAqICogYGZpcnN0X2xhc3RfbnVtYmVyc2AgLSAnRmlyc3QnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAgXG5cdFx0ICogRnVydGhlciBtZXRob2RzIGNhbiBiZSBhZGRlZCB1c2luZyB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vUGFnaW5hdGlvbn0uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBzaW1wbGVfbnVtYmVyc1xuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdUeXBlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInBhZ2luZ1R5cGVcIjogXCJmdWxsX251bWJlcnNcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwic1BhZ2luYXRpb25UeXBlXCI6IFwic2ltcGxlX251bWJlcnNcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZy4gV2hlbiBhIHRhYmxlIGlzIHRvbyB3aWRlIHRvIGZpdCBpbnRvIGFcblx0XHQgKiBjZXJ0YWluIGxheW91dCwgb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUsIHlvdVxuXHRcdCAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXG5cdFx0ICogc2Nyb2xsZWQuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGB0cnVlYCB3aGljaCB3aWxsIGFsbG93IHRoZSB0YWJsZSB0b1xuXHRcdCAqIHNjcm9sbCBob3Jpem9udGFsbHkgd2hlbiBuZWVkZWQsIG9yIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoXG5cdFx0ICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxuXHRcdCAqIGlzIHJlY29tbWVuZGVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFufHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTY3JvbGxYXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgRGF0YVRhYmxlIHRvIHVzZSBtb3JlIHdpZHRoIHRoYW4gaXRcblx0XHQgKiBtaWdodCBvdGhlcndpc2UgZG8gd2hlbiB4LXNjcm9sbGluZyBpcyBlbmFibGVkLiBGb3IgZXhhbXBsZSBpZiB5b3UgaGF2ZSBhXG5cdFx0ICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3Jcblx0XHQgKiBcIm92ZXItc2l6aW5nXCIgdGhlIHRhYmxlLCBhbmQgdGh1cyBmb3JjaW5nIHNjcm9sbGluZy4gVGhpcyBwcm9wZXJ0eSBjYW4gYnlcblx0XHQgKiBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsXG5cdFx0ICogbWVhc3VyZW1lbnQpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWElubmVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFhcIjogXCIxMDAlXCIsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsWElubmVyXCI6IFwiMTEwJVwiXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1Njcm9sbFhJbm5lclwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIHdpbGwgY29uc3RyYWluIHRoZSBEYXRhVGFibGVcblx0XHQgKiB0byB0aGUgZ2l2ZW4gaGVpZ2h0LCBhbmQgZW5hYmxlIHNjcm9sbGluZyBmb3IgYW55IGRhdGEgd2hpY2ggb3ZlcmZsb3dzIHRoZVxuXHRcdCAqIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFnaW5nIHRvIGRpc3BsYXlcblx0XHQgKiBhIGxvdCBvZiBkYXRhIGluIGEgc21hbGwgYXJlYSAoYWx0aG91Z2ggcGFnaW5nIGFuZCBzY3JvbGxpbmcgY2FuIGJvdGggYmVcblx0XHQgKiBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUpLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyXG5cdFx0ICogKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2Nyb2xsWVwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogU2V0IHRoZSBIVFRQIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gbWFrZSB0aGUgQWpheCBjYWxsIGZvciBzZXJ2ZXItc2lkZVxuXHRcdCAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBHRVRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlck1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBcIkdFVFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxuXHRcdCAqIGEgdGFibGUuIFRoZXNlIHJlbmRlcmVycyBjYW4gYmUgYWRkZWQgb3IgbW9kaWZpZWQgYnkgcGx1Zy1pbnMgdG9cblx0XHQgKiBnZW5lcmF0ZSBzdWl0YWJsZSBtYXJrLXVwIGZvciBhIHNpdGUuIEZvciBleGFtcGxlIHRoZSBCb290c3RyYXBcblx0XHQgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXG5cdFx0ICogZGlzcGxheSBwYWdpbmF0aW9uIGJ1dHRvbnMgaW4gdGhlIG1hcmstdXAgcmVxdWlyZWQgYnkgQm9vdHN0cmFwLlxuXHRcdCAqXG5cdFx0ICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXG5cdFx0ICogRGF0YVRhYmxlLmV4dC5yZW5kZXJlclxuXHRcdCAqICBAdHlwZSBzdHJpbmd8b2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmVuZGVyZXJcblx0XHQgKlxuXHRcdCAqL1xuXHRcdFwicmVuZGVyZXJcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgZGF0YSBwcm9wZXJ0eSBuYW1lIHRoYXQgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRvIGdldCBhIHJvdydzIGlkXG5cdFx0ICogdG8gc2V0IGFzIHRoZSBgaWRgIHByb3BlcnR5IGluIHRoZSBub2RlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgRFRfUm93SWRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93SWRcblx0XHQgKi9cblx0XHRcInJvd0lkXCI6IFwiRFRfUm93SWRcIlxuXHR9O1xuXHRcblx0X2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMgKTtcblx0XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGUgLSBTZWUgbm90ZSBpbiBtb2RlbC5kZWZhdWx0cy5qcyBhYm91dCB0aGUgdXNlIG9mIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiBhbmQgY2FtZWwgY2FzZS5cblx0ICovXG5cdFxuXHQvKipcblx0ICogQ29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiA9IHtcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXG5cdFx0ICogYWxsb3dzIGEgY29sdW1uJ3Mgb3JkZXJpbmcgdG8gdGFrZSBtdWx0aXBsZSBjb2x1bW5zIGludG8gYWNjb3VudCB3aGVuXG5cdFx0ICogZG9pbmcgYSBzb3J0IG9yIHVzZSB0aGUgZGF0YSBmcm9tIGEgZGlmZmVyZW50IGNvbHVtbi4gRm9yIGV4YW1wbGUgZmlyc3Rcblx0XHQgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXG5cdFx0ICogdHdvIGNvbHVtbnMuXG5cdFx0ICogIEB0eXBlIGFycmF5fGludFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPlRha2VzIHRoZSB2YWx1ZSBvZiB0aGUgY29sdW1uIGluZGV4IGF1dG9tYXRpY2FsbHk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyLCBcInRhcmdldHNcIjogWyAyIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMCwgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cdFx0XCJpRGF0YVNvcnRcIjogLTEsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBZb3UgY2FuIGNvbnRyb2wgdGhlIGRlZmF1bHQgb3JkZXJpbmcgZGlyZWN0aW9uLCBhbmQgZXZlbiBhbHRlciB0aGVcblx0XHQgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXG5cdFx0ICogdXNpbmcgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFsgJ2FzYycsICdkZXNjJyBdXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlclNlcXVlbmNlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAxIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMyBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBbICdhc2MnLCAnZGVzYycgXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvbiB0aGUgZGF0YSBpbiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5zZWFyY2hhYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2VhcmNoYWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgb3JkZXJpbmcgb24gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJhYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF0gfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyYWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRhYmxlXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi52aXNpYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG5cdFx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHRcdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdFx0ICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7ZWxlbWVudH0gdGQgVGhlIFREIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG5cdFx0ICogIEBwYXJhbSB7Kn0gY2VsbERhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSByb3dEYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSByb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXG5cdFx0ICogIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBpbmRleCBmb3IgYW9Db2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jcmVhdGVkQ2VsbFxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbM10sXG5cdFx0ICogICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhLCByb3csIGNvbCkge1xuXHRcdCAqICAgICAgICAgICAgaWYgKCBjZWxsRGF0YSA9PSBcIjEuN1wiICkge1xuXHRcdCAqICAgICAgICAgICAgICAkKHRkKS5jc3MoJ2NvbG9yJywgJ2JsdWUnKVxuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9KTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBoYXMgYmVlbiByZXBsYWNlZCBieSBgZGF0YWAgaW4gRGF0YVRhYmxlcyB0byBlbnN1cmUgbmFtaW5nXG5cdFx0ICogY29uc2lzdGVuY3kuIGBkYXRhUHJvcGAgY2FuIHN0aWxsIGJlIHVzZWQsIGFzIHRoZXJlIGlzIGJhY2t3YXJkc1xuXHRcdCAqIGNvbXBhdGliaWxpdHkgaW4gRGF0YVRhYmxlcyBmb3IgdGhpcyBvcHRpb24sIGJ1dCBpdCBpcyBzdHJvbmdseVxuXHRcdCAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBgZGF0YWAgaW4gcHJlZmVyZW5jZSB0byBgZGF0YVByb3BgLlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFQcm9wXG5cdFx0ICovXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHJlYWQgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSBwcm9wZXJ0eSxcblx0XHQgKiBpbmNsdWRpbmcgZGVlcGx5IG5lc3RlZCBvYmplY3RzIC8gcHJvcGVydGllcy4gYGRhdGFgIGNhbiBiZSBnaXZlbiBpbiBhXG5cdFx0ICogbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHdoaWNoIGVmZmVjdCBpdHMgYmVoYXZpb3VyOlxuXHRcdCAqXG5cdFx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdFx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHRcdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdFx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdFx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdFx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdFx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdFx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0XHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdFx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHRcdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHRcdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0XHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdFx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0XHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHRcdCAqICAgICAgcmV0dXJuZWQuXG5cdFx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHRcdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0XHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0XHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0XHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LiBOb3RlIHRoYXRcblx0XHQgKiAgICAgIGZ1bmN0aW9uIG5vdGF0aW9uIGlzIHJlY29tbWVuZGVkIGZvciB1c2UgaW4gYHJlbmRlcmAgcmF0aGVyIHRoYW5cblx0XHQgKiAgICAgIGBkYXRhYCBhcyBpdCBpcyBtdWNoIHNpbXBsZXIgdG8gdXNlIGFzIGEgcmVuZGVyZXIuXG5cdFx0ICogKiBgbnVsbGAgLSB1c2UgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IHJhdGhlciB0aGFuIHBsdWNraW5nXG5cdFx0ICogICBkYXRhIGRpcmVjdGx5IGZyb20gaXQuIFRoaXMgYWN0aW9uIGhhcyBlZmZlY3RzIG9uIHR3byBvdGhlclxuXHRcdCAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9uczpcblx0XHQgKiAgICAqIGBkZWZhdWx0Q29udGVudGAgLSBXaGVuIG51bGwgaXMgZ2l2ZW4gYXMgdGhlIGBkYXRhYCBvcHRpb24gYW5kXG5cdFx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHZhbHVlIGRlZmluZWQgYnlcblx0XHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgd2lsbCBiZSB1c2VkIGZvciB0aGUgY2VsbC5cblx0XHQgKiAgICAqIGByZW5kZXJgIC0gV2hlbiBudWxsIGlzIHVzZWQgZm9yIHRoZSBgZGF0YWAgb3B0aW9uIGFuZCB0aGUgYHJlbmRlcmBcblx0XHQgKiAgICAgIG9wdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB3aG9sZSBkYXRhIHNvdXJjZSBmb3IgdGhlXG5cdFx0ICogICAgICByb3cgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLlxuXHRcdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0XHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0XHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdFx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHRcdCAqICAgICAgKiBge2FycmF5fG9iamVjdH1gIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvd1xuXHRcdCAqICAgICAgKiBge3N0cmluZ31gIFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ3NldCcgd2hlblxuXHRcdCAqICAgICAgICBzZXR0aW5nIGRhdGEgb3IgJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnLCAnc29ydCcgb3IgdW5kZWZpbmVkXG5cdFx0ICogICAgICAgIHdoZW4gZ2F0aGVyaW5nIGRhdGEuIE5vdGUgdGhhdCB3aGVuIGB1bmRlZmluZWRgIGlzIGdpdmVuIGZvciB0aGVcblx0XHQgKiAgICAgICAgdHlwZSBEYXRhVGFibGVzIGV4cGVjdHMgdG8gZ2V0IHRoZSByYXcgZGF0YSBmb3IgdGhlIG9iamVjdCBiYWNrPFxuXHRcdCAqICAgICAgKiBgeyp9YCBEYXRhIHRvIHNldCB3aGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzICdzZXQnLlxuXHRcdCAqICAgICogUmV0dXJuOlxuXHRcdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuICdzZXQnIGlzXG5cdFx0ICogICAgICAgIHRoZSB0eXBlIG9mIGNhbGwsIGJ1dCBvdGhlcndpc2UgdGhlIHJldHVybiBpcyB3aGF0IHdpbGwgYmUgdXNlZFxuXHRcdCAqICAgICAgICBmb3IgdGhlIGRhdGEgcmVxdWVzdGVkLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGBkYXRhYCBpcyBhIGdldHRlciBhbmQgc2V0dGVyIG9wdGlvbi4gSWYgeW91IGp1c3QgcmVxdWlyZVxuXHRcdCAqIGZvcm1hdHRpbmcgb2YgZGF0YSBmb3Igb3V0cHV0LCB5b3Ugd2lsbCBsaWtlbHkgd2FudCB0byB1c2UgYHJlbmRlcmAgd2hpY2hcblx0XHQgKiBpcyBzaW1wbHkgYSBnZXR0ZXIgYW5kIHRodXMgc2ltcGxlciB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgcHJpb3IgdG8gRGF0YVRhYmxlcyAxLjkuMiBgZGF0YWAgd2FzIGNhbGxlZCBgbURhdGFQcm9wYC4gVGhlXG5cdFx0ICogbmFtZSBjaGFuZ2UgcmVmbGVjdHMgdGhlIGZsZXhpYmlsaXR5IG9mIHRoaXMgcHJvcGVydHkgYW5kIGlzIGNvbnNpc3RlbnRcblx0XHQgKiB3aXRoIHRoZSBuYW1pbmcgb2YgbVJlbmRlci4gSWYgJ21EYXRhUHJvcCcgaXMgZ2l2ZW4sIHRoZW4gaXQgd2lsbCBzdGlsbFxuXHRcdCAqIGJlIHVzZWQgYnkgRGF0YVRhYmxlcywgYXMgaXQgYXV0b21hdGljYWxseSBtYXBzIHRoZSBvbGQgbmFtZSB0byB0aGUgbmV3XG5cdFx0ICogaWYgcmVxdWlyZWQuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGludHxmdW5jdGlvbnxudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+VXNlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBjb2x1bW4gaW5kZXg8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSZWFkIHRhYmxlIGRhdGEgZnJvbSBvYmplY3RzXG5cdFx0ICogICAgLy8gSlNPTiBzdHJ1Y3R1cmUgZm9yIGVhY2ggcm93OlxuXHRcdCAqICAgIC8vICAge1xuXHRcdCAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwiYnJvd3NlclwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJwbGF0Zm9ybVwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJ2ZXJzaW9uXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImdyYWRlXCI6IHt2YWx1ZX1cblx0XHQgKiAgICAvLyAgIH1cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL29iamVjdHMudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVhZCBpbmZvcm1hdGlvbiBmcm9tIGRlZXBseSBuZXN0ZWQgb2JqZWN0c1xuXHRcdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0XHQgKiAgICAvLyAgIHtcblx0XHQgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge1xuXHRcdCAqICAgIC8vICAgICAgICAgXCJpbm5lclwiOiB7dmFsdWV9XG5cdFx0ICogICAgLy8gICAgICB9LFxuXHRcdCAqICAgIC8vICAgICAgXCJkZXRhaWxzXCI6IFtcblx0XHQgKiAgICAvLyAgICAgICAgIHt2YWx1ZX0sIHt2YWx1ZX1cblx0XHQgKiAgICAvLyAgICAgIF1cblx0XHQgKiAgICAvLyAgIH1cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybS5pbm5lclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJkZXRhaWxzLjBcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZGV0YWlscy4xXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGRhdGFgIGFzIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBkaWZmZXJlbnQgaW5mb3JtYXRpb24gZm9yXG5cdFx0ICogICAgLy8gc29ydGluZywgZmlsdGVyaW5nIGFuZCBkaXNwbGF5LiBJbiB0aGlzIGNhc2UsIGN1cnJlbmN5IChwcmljZSlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIHNvdXJjZSwgdHlwZSwgdmFsICkge1xuXHRcdCAqICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQnKSB7XG5cdFx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZSA9IHZhbDtcblx0XHQgKiAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvbXB1dGVkIGRpc2xheSBhbmQgZmlsdGVyIHZhbHVlcyBmb3IgZWZmaWNpZW5jeVxuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZGlzcGxheSA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKTtcblx0XHQgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlX2ZpbHRlciAgPSB2YWw9PVwiXCIgPyBcIlwiIDogXCIkXCIrbnVtYmVyRm9ybWF0KHZhbCkrXCIgXCIrdmFsO1xuXHRcdCAqICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZGlzcGxheScpIHtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9kaXNwbGF5O1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2ZpbHRlcicpIHtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9maWx0ZXI7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICAvLyAnc29ydCcsICd0eXBlJyBhbmQgdW5kZWZpbmVkIGFsbCBqdXN0IHVzZSB0aGUgaW50ZWdlclxuXHRcdCAqICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGRlZmF1bHQgY29udGVudFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkNsaWNrIHRvIGVkaXRcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBhcnJheSBub3RhdGlvbiAtIG91dHB1dHRpbmcgYSBsaXN0IGZyb20gYW4gYXJyYXlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBcIm5hbWVbLCBdXCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxuXHRcdCAqIHdoZW4geW91IHdhbnQgdG8gbWFuaXB1bGF0ZSBkYXRhIGZvciBkaXNwbGF5IChpbmNsdWRpbmcgZmlsdGVyaW5nLFxuXHRcdCAqIHNvcnRpbmcgZXRjKSB3aXRob3V0IGFsdGVyaW5nIHRoZSB1bmRlcmx5aW5nIGRhdGEgZm9yIHRoZSB0YWJsZSwgdXNlIHRoaXNcblx0XHQgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXG5cdFx0ICogYGRhdGFgIHdoaWNoIGlzIHJlYWQgLyB3cml0ZSAodGhlbiBhcyBzdWNoIG1vcmUgY29tcGxleCkuIExpa2UgYGRhdGFgXG5cdFx0ICogdGhpcyBvcHRpb24gY2FuIGJlIGdpdmVuIGluIGEgbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHRvIGVmZmVjdCBpdHNcblx0XHQgKiBiZWhhdmlvdXI6XG5cdFx0ICpcblx0XHQgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcblx0XHQgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG5cdFx0ICogKiBgc3RyaW5nYCAtIHJlYWQgYW4gb2JqZWN0IHByb3BlcnR5IGZyb20gdGhlIGRhdGEgc291cmNlLiBUaGVyZSBhcmVcblx0XHQgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcblx0XHQgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcblx0XHQgKiAgICAqIGAuYCAtIERvdHRlZCBKYXZhc2NyaXB0IG5vdGF0aW9uLiBKdXN0IGFzIHlvdSB1c2UgYSBgLmAgaW5cblx0XHQgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcblx0XHQgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuXHRcdCAqICAgICAgYGJyb3dzZXIubmFtZWAuIElmIHlvdXIgb2JqZWN0IHBhcmFtZXRlciBuYW1lIGNvbnRhaW5zIGEgcGVyaW9kLCB1c2Vcblx0XHQgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG5cdFx0ICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG5cdFx0ICogICAgICBmcm9tIGFuZCBhcnJheSBzb3VyY2UsIGpvaW5pbmcgdGhlIGRhdGEgd2l0aCB0aGUgY2hhcmFjdGVycyBwcm92aWRlZFxuXHRcdCAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcblx0XHQgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuXHRcdCAqICAgICAgYXJlIHByb3ZpZGVkIGJldHdlZW4gdGhlIGJyYWNrZXRzLCB0aGUgb3JpZ2luYWwgYXJyYXkgc291cmNlIGlzXG5cdFx0ICogICAgICByZXR1cm5lZC5cblx0XHQgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG5cdFx0ICogICAgICBleGVjdXRlIGEgZnVuY3Rpb24gb2YgdGhlIG5hbWUgZ2l2ZW4uIEZvciBleGFtcGxlOiBgYnJvd3NlcigpYCBmb3IgYVxuXHRcdCAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuXHRcdCAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuXHRcdCAqICAgICAgb2JqZWN0IHByb3BlcnR5IGlmIHRoZSBmdW5jdGlvbiBjYWxsZWQgcmV0dXJucyBhbiBvYmplY3QuXG5cdFx0ICogKiBgb2JqZWN0YCAtIHVzZSBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHJlcXVlc3RlZCBieVxuXHRcdCAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xuXHRcdCAqICAgb2YgdGhlIG9iamVjdCBpcyB0aGUgZGF0YSB0eXBlIHRoZSBwcm9wZXJ0eSByZWZlcnMgdG8gYW5kIHRoZSB2YWx1ZSBjYW5cblx0XHQgKiAgIGRlZmluZWQgdXNpbmcgYW4gaW50ZWdlciwgc3RyaW5nIG9yIGZ1bmN0aW9uIHVzaW5nIHRoZSBzYW1lIHJ1bGVzIGFzXG5cdFx0ICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxuXHRcdCAqICAgVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgeW91IGhhdmVuJ3Qgc3BlY2lmaWVkIGEgdmFsdWUgZm9yXG5cdFx0ICogICB0aGUgZGF0YSB0eXBlIHJlcXVlc3RlZCBieSBEYXRhVGFibGVzLlxuXHRcdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0XHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0XHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdFx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHRcdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKGJhc2VkIG9uIGBkYXRhYClcblx0XHQgKiAgICAgICoge3N0cmluZ30gVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnZmlsdGVyJyxcblx0XHQgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxuXHRcdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZnVsbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAobm90IGJhc2VkIG9uXG5cdFx0ICogICAgICAgIGBkYXRhYClcblx0XHQgKiAgICAqIFJldHVybjpcblx0XHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyB3aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlXG5cdFx0ICogICAgICAgIGRhdGEgcmVxdWVzdGVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258b2JqZWN0fG51bGxcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCBVc2UgdGhlIGRhdGEgc291cmNlIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ucmVuZGVyXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBDcmVhdGUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHNcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IFwicGxhdGZvcm1cIixcblx0XHQgKiAgICAgICAgICAgIFwicmVuZGVyXCI6IFwiWywgXS5uYW1lXCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLCAvLyBVc2UgdGhlIGZ1bGwgZGF0YSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgcmVuZGVyZXIncyBzb3VyY2Vcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiBcImJyb3dzZXJOYW1lKClcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBBcyBhbiBvYmplY3QsIGV4dHJhY3RpbmcgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgdHlwZXNcblx0XHQgKiAgICAvLyBUaGlzIHdvdWxkIGJlIHVzZWQgd2l0aCBhIGRhdGEgc291cmNlIHN1Y2ggYXM6XG5cdFx0ICogICAgLy8gICB7IFwicGhvbmVcIjogNTU1MjM2OCwgXCJwaG9uZV9maWx0ZXJcIjogXCI1NTUyMzY4IDU1NS0yMzY4XCIsIFwicGhvbmVfZGlzcGxheVwiOiBcIjU1NS0yMzY4XCIgfVxuXHRcdCAqICAgIC8vIEhlcmUgdGhlIGBwaG9uZWAgaW50ZWdlciBpcyB1c2VkIGZvciBzb3J0aW5nIGFuZCB0eXBlIGRldGVjdGlvbiwgd2hpbGUgYHBob25lX2ZpbHRlcmBcblx0XHQgKiAgICAvLyAod2hpY2ggaGFzIGJvdGggZm9ybXMpIGlzIHVzZWQgZm9yIGZpbHRlcmluZyBmb3IgaWYgYSB1c2VyIGlucHV0cyBlaXRoZXIgZm9ybWF0LCB3aGlsZVxuXHRcdCAqICAgIC8vIHRoZSBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyIGlzIHRoZSBvbmUgdGhhdCBpcyBzaG93biBpbiB0aGUgdGFibGUuXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjoge1xuXHRcdCAqICAgICAgICAgICAgXCJfXCI6IFwicGhvbmVcIixcblx0XHQgKiAgICAgICAgICAgIFwiZmlsdGVyXCI6IFwicGhvbmVfZmlsdGVyXCIsXG5cdFx0ICogICAgICAgICAgICBcImRpc3BsYXlcIjogXCJwaG9uZV9kaXNwbGF5XCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzZSBhcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGUgZGF0YSBzb3VyY2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBcImRvd25sb2FkX2xpbmtcIixcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoIGRhdGEsIHR5cGUsIGZ1bGwgKSB7XG5cdFx0ICogICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCInK2RhdGErJ1wiPkRvd25sb2FkPC9hPic7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIGNlbGwgdHlwZSBjcmVhdGVkIGZvciB0aGUgY29sdW1uIC0gZWl0aGVyIFREIGNlbGxzIG9yIFRIIGNlbGxzLiBUaGlzXG5cdFx0ICogY2FuIGJlIHVzZWZ1bCBhcyBUSCBjZWxscyBoYXZlIHNlbWFudGljIG1lYW5pbmcgaW4gdGhlIHRhYmxlIGJvZHksIGFsbG93aW5nIHRoZW1cblx0XHQgKiB0byBhY3QgYXMgYSBoZWFkZXIgZm9yIGEgcm93ICh5b3UgbWF5IHdpc2ggdG8gYWRkIHNjb3BlPSdyb3cnIHRvIHRoZSBUSCBlbGVtZW50cykuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCB0ZFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2VsbFR5cGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE1ha2UgdGhlIGZpcnN0IGNvbHVtbiB1c2UgVEggY2VsbHNcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiY2VsbFR5cGVcIjogXCJ0aFwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNDZWxsVHlwZVwiOiBcInRkXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzcyB0byBnaXZlIHRvIGVhY2ggY2VsbCBpbiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNsYXNzXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ2xhc3NcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuXHRcdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0XHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0XHQgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuXHRcdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0XHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdFx0ICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuXHRcdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdFx0ICogR2VuZXJhbGx5IHlvdSBzaG91bGRuJ3QgbmVlZCB0aGlzIVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPGk+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jb250ZW50UGFkZGluZ1xuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImNvbnRlbnRQYWRkaW5nXCI6IFwibW1tXCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHRcdCAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBgZGF0YWBcblx0XHQgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGVmYXVsdENvbnRlbnRcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgLTEgXVxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHVzZWQgaW4gRGF0YVRhYmxlcycgc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gSXQgY2FuXG5cdFx0ICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcblx0XHQgKiBjbGllbnQgc2lkZSwgYW5kIHRvIG1hcCB0aGVzZSB0byBkYXRhYmFzZSBmaWVsZHMuIFdoZW4gZGVmaW5lZCwgdGhlIG5hbWVzXG5cdFx0ICogYWxzbyBhbGxvdyBEYXRhVGFibGVzIHRvIHJlb3JkZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyIGlmIGl0IGNvbWVzXG5cdFx0ICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcblx0XHQgKiBjbGllbnQtc2lkZSwgeW91ciBzZXJ2ZXItc2lkZSBjb2RlIGRvZXMgbm90IGFsc28gbmVlZCB1cGRhdGluZykuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5uYW1lXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYnJvd3NlclwiLCBcInRhcmdldHNcIjogWyAxIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImdyYWRlXCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNOYW1lXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGEgZGF0YSBzb3VyY2UgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWRcblx0XHQgKiByZWFsLXRpbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdGFibGUgKHVwZGF0aW5nIHRoZSBpbnRlcm5hbGx5IGNhY2hlZFxuXHRcdCAqIHZlcnNpb24pIHByaW9yIHRvIG9yZGVyaW5nLiBUaGlzIGFsbG93cyBvcmRlcmluZyB0byBvY2N1ciBvbiB1c2VyXG5cdFx0ICogZWRpdGFibGUgZWxlbWVudHMgc3VjaCBhcyBmb3JtIGlucHV0cy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhVHlwZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidGFyZ2V0c1wiOiBbIDIsIDMgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwibnVtZXJpY1wiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1zZWxlY3RcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiwgXCJ0YXJnZXRzXCI6IFsgNSBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0eXBlXCI6IFwibnVtZXJpY1wiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTb3J0RGF0YVR5cGVcIjogXCJzdGRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0aXRsZSBvZiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+RGVyaXZlZCBmcm9tIHRoZSAnVEgnIHZhbHVlIGZvciB0aGlzIGNvbHVtbiBpbiB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBIVE1MIHRhYmxlLjwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnRpdGxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGhvdyB0aGUgZGF0YSBmb3IgdGhpcyBjb2x1bW4gd2lsbCBiZVxuXHRcdCAqIG9yZGVyZWQuIEZvdXIgdHlwZXMgKHN0cmluZywgbnVtZXJpYywgZGF0ZSBhbmQgaHRtbCAod2hpY2ggd2lsbCBzdHJpcFxuXHRcdCAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxuXHRcdCAqIGZvcm1hdHMgdW5kZXJzdG9vZCBieSBKYXZhc2NyaXB0J3MgRGF0ZSgpIG9iamVjdCB3aWxsIGJlIGFjY2VwdGVkIGFzIHR5cGVcblx0XHQgKiBkYXRlLiBGb3IgZXhhbXBsZTogXCJNYXIgMjYsIDIwMDggNTowMyBQTVwiLiBNYXkgdGFrZSB0aGUgdmFsdWVzOiAnc3RyaW5nJyxcblx0XHQgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcblx0XHQgKiB0aHJvdWdoIHBsdWctaW5zLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvLWRldGVjdGVkIGZyb20gcmF3IGRhdGE8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi50eXBlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiwgdGhpcyBwYXJhbWV0ZXIgbWF5IHRha2UgYW55IENTUyB2YWx1ZVxuXHRcdCAqICgzZW0sIDIwcHggZXRjKS4gRGF0YVRhYmxlcyBhcHBsaWVzICdzbWFydCcgd2lkdGhzIHRvIGNvbHVtbnMgd2hpY2ggaGF2ZSBub3Rcblx0XHQgKiBiZWVuIGdpdmVuIGEgc3BlY2lmaWMgd2lkdGggdGhyb3VnaCB0aGlzIGludGVyZmFjZSBlbnN1cmluZyB0aGF0IHRoZSB0YWJsZVxuXHRcdCAqIHJlbWFpbnMgcmVhZGFibGUuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPkF1dG9tYXRpYzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLndpZHRoXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsXG5cdH07XG5cdFxuXHRfZm5IdW5nYXJpYW5NYXAoIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IC0gdGhpcyBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYVxuXHQgKiBnaXZlbiB0YWJsZSwgaW5jbHVkaW5nIGNvbmZpZ3VyYXRpb24sIGRhdGEgYW5kIGN1cnJlbnQgYXBwbGljYXRpb24gb2YgdGhlXG5cdCAqIHRhYmxlIG9wdGlvbnMuIERhdGFUYWJsZXMgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgZWFjaCBEYXRhVGFibGVcblx0ICogd2l0aCB0aGUgc2V0dGluZ3MgYXR0YWNoZWQgdG8gdGhhdCBpbnN0YW5jZSwgYnV0IHJhdGhlciBpbnN0YW5jZXMgb2YgdGhlXG5cdCAqIERhdGFUYWJsZSBcImNsYXNzXCIgYXJlIGNyZWF0ZWQgb24tdGhlLWZseSBhcyBuZWVkZWQgKHR5cGljYWxseSBieSBhXG5cdCAqICQoKS5kYXRhVGFibGUoKSBjYWxsKSBhbmQgdGhlIHNldHRpbmdzIG9iamVjdCBpcyB0aGVuIGFwcGxpZWQgdG8gdGhhdFxuXHQgKiBpbnN0YW5jZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30gYnV0IHRoaXNcblx0ICogb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy4gSXQgc2hvdWxkXG5cdCAqIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBkb25lXG5cdCAqIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqICBAdG9kbyBSZWFsbHkgc2hvdWxkIGF0dGFjaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRvIGluZGl2aWR1YWwgaW5zdGFuY2VzIHNvIHdlXG5cdCAqICAgIGRvbid0IG5lZWQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb24gZWFjaCAkKCkuZGF0YVRhYmxlKCkgY2FsbCAoaWYgdGhlXG5cdCAqICAgIHRhYmxlIGFscmVhZHkgZXhpc3RzKS4gSXQgd291bGQgYWxzbyBzYXZlIHBhc3Npbmcgb1NldHRpbmdzIGFyb3VuZCBhbmRcblx0ICogICAgaW50byBldmVyeSBzaW5nbGUgZnVuY3Rpb24uIEhvd2V2ZXIsIHRoaXMgaXMgYSB2ZXJ5IHNpZ25pZmljYW50XG5cdCAqICAgIGFyY2hpdGVjdHVyZSBjaGFuZ2UgZm9yIERhdGFUYWJsZXMgYW5kIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBicmVha1xuXHQgKiAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMuIFRoaXMgaXMgc29tZXRoaW5nIHRoYXRcblx0ICogICAgd2lsbCBiZSBkb25lIGluIDIuMC5cblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzID0ge1xuXHRcdC8qKlxuXHRcdCAqIFByaW1hcnkgZmVhdHVyZXMgb2YgRGF0YVRhYmxlcyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0ZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib0ZlYXR1cmVzXCI6IHtcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEZsYWcgdG8gc2F5IGlmIERhdGFUYWJsZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGNhbGN1bGF0ZSB0aGVcblx0XHRcdCAqIG9wdGltdW0gdGFibGUgYW5kIGNvbHVtbnMgd2lkdGhzICh0cnVlKSBvciBub3QgKGZhbHNlKS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiQXV0b1dpZHRoXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZWxheSB0aGUgY3JlYXRpb24gb2YgVFIgYW5kIFREIGVsZW1lbnRzIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5XG5cdFx0XHQgKiBuZWVkZWQgYnkgYSBkcml2ZW4gcGFnZSBkcmF3LiBUaGlzIGNhbiBnaXZlIGEgc2lnbmlmaWNhbnQgc3BlZWRcblx0XHRcdCAqIGluY3JlYXNlIGZvciBBamF4IHNvdXJjZSBhbmQgSmF2YXNjcmlwdCBzb3VyY2UgZGF0YSwgYnV0IG1ha2VzIG5vXG5cdFx0XHQgKiBkaWZmZXJlbmNlIGF0IGFsbCBmcm8gRE9NIGFuZCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiRGVmZXJSZW5kZXJcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSBmaWx0ZXJpbmcgb24gdGhlIHRhYmxlIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWRcblx0XHRcdCAqIHRoZW4gdGhlcmUgaXMgbm8gZmlsdGVyaW5nIGF0IGFsbCBvbiB0aGUgdGFibGUsIGluY2x1ZGluZyBmbkZpbHRlci5cblx0XHRcdCAqIFRvIGp1c3QgcmVtb3ZlIHRoZSBmaWx0ZXJpbmcgaW5wdXQgdXNlIHNEb20gYW5kIHJlbW92ZSB0aGUgJ2YnIG9wdGlvbi5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiRmlsdGVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50ICh0aGUgJ1Nob3dpbmcgeCBvZiB5IHJlY29yZHMnIGRpdikgZW5hYmxlXG5cdFx0XHQgKiBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJJbmZvXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQcmVzZW50IGEgdXNlciBjb250cm9sIGFsbG93aW5nIHRoZSBlbmQgdXNlciB0byBjaGFuZ2UgdGhlIHBhZ2Ugc2l6ZVxuXHRcdFx0ICogd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkxlbmd0aENoYW5nZVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUGFnaW5hdGlvbiBlbmFibGVkIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWQgdGhlbiBsZW5ndGhcblx0XHRcdCAqIGNoYW5naW5nIG11c3QgYWxzbyBiZSBkaXNhYmxlZC5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiUGFnaW5hdGVcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFByb2Nlc3NpbmcgaW5kaWNhdG9yIGVuYWJsZSBmbGFnIHdoZW5ldmVyIERhdGFUYWJsZXMgaXMgZW5hY3RpbmcgYVxuXHRcdFx0ICogdXNlciByZXF1ZXN0IC0gdHlwaWNhbGx5IGFuIEFqYXggcmVxdWVzdCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiUHJvY2Vzc2luZ1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBlbmFibGVkIGZsYWcgLSB3aGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsXG5cdFx0XHQgKiBnZXQgYWxsIGRhdGEgZnJvbSB0aGUgc2VydmVyIGZvciBldmVyeSBkcmF3IC0gdGhlcmUgaXMgbm8gZmlsdGVyaW5nLFxuXHRcdFx0ICogc29ydGluZyBvciBwYWdpbmcgZG9uZSBvbiB0aGUgY2xpZW50LXNpZGUuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNlcnZlclNpZGVcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFNvcnRpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0XCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0TXVsdGlcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGx5IGEgY2xhc3MgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGJlaW5nIHNvcnRlZCB0byBwcm92aWRlIGFcblx0XHRcdCAqIHZpc3VhbCBoaWdobGlnaHQgb3Igbm90LiBUaGlzIGNhbiBzbG93IHRoaW5ncyBkb3duIHdoZW4gZW5hYmxlZCBzaW5jZVxuXHRcdFx0ICogdGhlcmUgaXMgYSBsb3Qgb2YgRE9NIGludGVyYWN0aW9uLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0Q2xhc3Nlc1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RhdGUgc2F2aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU3RhdGVTYXZlXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2Nyb2xsaW5nIHNldHRpbmdzIGZvciBhIHRhYmxlLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvU2Nyb2xsXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiB0aGUgdGFibGUgaXMgc2hvcnRlciBpbiBoZWlnaHQgdGhhbiBzU2Nyb2xsWSwgY29sbGFwc2UgdGhlXG5cdFx0XHQgKiB0YWJsZSBjb250YWluZXIgZG93biB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSAod2hlbiB0cnVlKS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiQ29sbGFwc2VcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdpZHRoIG9mIHRoZSBzY3JvbGxiYXIgZm9yIHRoZSB3ZWItYnJvd3NlcidzIHBsYXRmb3JtLiBDYWxjdWxhdGVkXG5cdFx0XHQgKiBkdXJpbmcgdGFibGUgaW5pdGlhbGlzYXRpb24uXG5cdFx0XHQgKiAgQHR5cGUgaW50XG5cdFx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdFx0ICovXG5cdFx0XHRcImlCYXJXaWR0aFwiOiAwLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVmlld3BvcnQgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nLiBIb3Jpem9udGFsIHNjcm9sbGluZyBpc1xuXHRcdFx0ICogZGlzYWJsZWQgaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdFwic1hcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdpZHRoIHRvIGV4cGFuZCB0aGUgdGFibGUgdG8gd2hlbiB1c2luZyB4LXNjcm9sbGluZy4gVHlwaWNhbGx5IHlvdVxuXHRcdFx0ICogc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHRcdCAqL1xuXHRcdFx0XCJzWElubmVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBWaWV3cG9ydCBoZWlnaHQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG5cdFx0XHQgKiBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0XCJzWVwiOiBudWxsXG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGFuZ3VhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlXG5cdFx0ICovXG5cdFx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbmZvcm1hdGlvbiBjYWxsYmFjayBmdW5jdGlvbi4gU2VlXG5cdFx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmZuSW5mb0NhbGxiYWNrfVxuXHRcdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBCcm93c2VyIHN1cHBvcnQgcGFyYW1ldGVyc1xuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvQnJvd3NlclwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEluZGljYXRlIGlmIHRoZSBicm93c2VyIGluY29ycmVjdGx5IGNhbGN1bGF0ZXMgd2lkdGg6MTAwJSBpbnNpZGUgYVxuXHRcdFx0ICogc2Nyb2xsaW5nIGVsZW1lbnQgKElFNi83KVxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJTY3JvbGxPdmVyc2l6ZVwiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERldGVybWluZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSByaWdodCBvciBsZWZ0IG9mIHRoZVxuXHRcdFx0ICogc2Nyb2xsaW5nIGNvbnRhaW5lciAtIG5lZWRlZCBmb3IgcnRsIGxhbmd1YWdlIGxheW91dCwgYWx0aG91Z2ggbm90XG5cdFx0XHQgKiBhbGwgYnJvd3NlcnMgbW92ZSB0aGUgc2Nyb2xsYmFyIChTYWZhcmkpLlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJTY3JvbGxiYXJMZWZ0XCI6IGZhbHNlLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRmxhZyBmb3IgaWYgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgaXMgZnVsbHkgc3VwcG9ydGVkIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJCb3VuZGluZ1wiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEJyb3dzZXIgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdFx0ICogIEBkZWZhdWx0IDBcblx0XHRcdCAqL1xuXHRcdFx0XCJiYXJXaWR0aFwiOiAwXG5cdFx0fSxcblx0XG5cdFxuXHRcdFwiYWpheFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgcmVmZXJlbmNpbmcgdGhlIG5vZGVzIHdoaWNoIGFyZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMuIFRoZVxuXHRcdCAqIHBhcmFtZXRlcnMgb2YgdGhpcyBvYmplY3QgbWF0Y2ggd2hhdCBpcyBhbGxvd2VkIGJ5IHNEb20gLSBpLmUuXG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxuXHRcdCAqICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0XHQgKiAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxuXHRcdCAqICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxuXHRcdCAqICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdFx0ICogICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhYW5GZWF0dXJlc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcblx0XHQgKiBpbmZvcm1hdGlvbi5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGF0YVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgaW5kZXhlcyB3aGljaCBhcmUgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSAoYWZ0ZXIgZmlsdGVyaW5nIGV0Yylcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFpRGlzcGxheVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgaW5kZXhlcyBmb3IgZGlzcGxheSAtIG5vIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWlEaXNwbGF5TWFzdGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBNYXAgb2Ygcm93IGlkcyB0byBkYXRhIGluZGV4ZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJhSWRzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIGNvbHVtbiB0aGF0IGlzIGluIHVzZVxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBoZWFkZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSGVhZGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBmb290ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRm9vdGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSB0aGUgYXBwbGllZCBnbG9iYWwgc2VhcmNoIGluZm9ybWF0aW9uIGluIGNhc2Ugd2Ugd2FudCB0byBmb3JjZSBhXG5cdFx0ICogcmVzZWFyY2ggb3IgY29tcGFyZSB0aGUgb2xkIHNlYXJjaCB0byBhIG5ldyBvbmUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxuXHRcdCAqL1xuXHRcdFwib1ByZXZpb3VzU2VhcmNoXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSB0aGUgYXBwbGllZCBzZWFyY2ggZm9yIGVhY2ggY29sdW1uIC0gc2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaH0gZm9yIHRoZSBmb3JtYXQgdGhhdCBpcyB1c2VkIGZvciB0aGVcblx0XHQgKiBmaWx0ZXJpbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9QcmVTZWFyY2hDb2xzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxuXHRcdCAqIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBtYW5uZXI6XG5cdFx0ICogPHVsPlxuXHRcdCAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cblx0XHQgKiAgIDxsaT5JbmRleCAxIC0gY3VycmVudCBzb3J0aW5nIGRpcmVjdGlvbjwvbGk+XG5cdFx0ICogPC91bD5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIHRoYXQgaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIChpLmUuIHByZWZpeGVkIGluIGZyb250IG9mXG5cdFx0ICogYWFTb3J0aW5nKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhYVNvcnRpbmdGaXhlZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3NlcyB0byB1c2UgZm9yIHRoZSBzdHJpcGluZyBvZiBhIHRhYmxlLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFzU3RyaXBlQ2xhc3Nlc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFzRGVzdHJveVN0cmlwZXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHdpZHRoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJzRGVzdHJveVdpZHRoXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBhcnJheSBmb3IgZXZlcnkgdGltZSBhIHJvdyBpcyBpbnNlcnRlZCAoaS5lLiBvbiBhIGRyYXcpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Sb3dDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSGVhZGVyQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZm9vdGVyIG9uIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRm9vdGVyQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZHJhdyBjYWxsYmFjayBmdW5jdGlvbnNcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRHJhd0NhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1Jvd0NyZWF0ZWRDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciBqdXN0IGJlZm9yZSB0aGUgdGFibGUgaXMgcmVkcmF3bi4gQSByZXR1cm4gb2Zcblx0XHQgKiBmYWxzZSB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9QcmVEcmF3Q2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0luaXRDb21wbGV0ZVwiOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0byBiZSBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZywgcHJpb3IgdG9cblx0XHQgKiBzYXZpbmcgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlU2F2ZVBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRoYXQgaGF2ZSBiZWVuIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nXG5cdFx0ICogcHJpb3IgdG8gdXNpbmcgdGhlIHN0b3JlZCB2YWx1ZXMgdG8gcmVzdG9yZSB0aGUgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlTG9hZFBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxuXHRcdCAqIGxvYWRlZFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRlZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgdGhlIHRhYmxlIElEIGZvciBxdWljayBhY2Nlc3Ncblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKi9cblx0XHRcInNUYWJsZUlkXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBUQUJMRSBub2RlIGZvciB0aGUgbWFpbiB0YWJsZVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UYWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0aGVhZCBlbGVtZW50XG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRIZWFkXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRmb290IGVsZW1lbnQgLSBpZiBpdCBleGlzdHNcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVEZvb3RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGJvZHkgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UQm9keVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWNoZSB0aGUgd3JhcHBlciBub2RlIChjb250YWlucyBhbGwgRGF0YVRhYmxlcyBjb250cm9sbGVkIGVsZW1lbnRzKVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UYWJsZVdyYXBwZXJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgd2hlbiB1c2luZyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZSBsb2FkaW5nIG9mIGRhdGFcblx0XHQgKiBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIHNlY29uZCBkcmF3LlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkRlZmVyTG9hZGluZ1wiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGhhcyBiZWVuIHJlYWQgaW5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkluaXRpYWxpc2VkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmZvcm1hdGlvbiBhYm91dCBvcGVuIHJvd3MuIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSBoYXMgdGhlIHBhcmFtZXRlcnNcblx0XHQgKiAnblRyJyBhbmQgJ25QYXJlbnQnXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb09wZW5Sb3dzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBEaWN0YXRlIHRoZSBwb3NpdGlvbmluZyBvZiBEYXRhVGFibGVzJyBjb250cm9sIGVsZW1lbnRzIC0gc2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbC5vSW5pdC5zRG9tfS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzRG9tXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBkZWxheSAoaW4gbVMpXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hpY2ggdHlwZSBvZiBwYWdpbmF0aW9uIHNob3VsZCBiZSB1c2VkLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHR3b19idXR0b25cblx0XHQgKi9cblx0XHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInR3b19idXR0b25cIixcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0YXRlIGR1cmF0aW9uIChmb3IgYHN0YXRlU2F2ZWApIGluIHNlY29uZHMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwiaVN0YXRlRHVyYXRpb25cIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBzYXZpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHRcdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHRcdCAqICAgICAgIGFuZCB0aGUgSlNPTiBzdHJpbmcgdG8gc2F2ZSB0aGF0IGhhcyBiZWVuIHRodXMgZmFyIGNyZWF0ZWQuIFJldHVybnNcblx0XHQgKiAgICAgICBhIEpTT04gc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gYSBqc29uIG9iamVjdFxuXHRcdCAqICAgICAgIChpLmUuICdcInBhcmFtXCI6IFsgMCwgMSwgMl0nKTwvbGk+XG5cdFx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlU2F2ZVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBsb2FkaW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0XHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0XHQgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxuXHRcdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0YXRlIHRoYXQgd2FzIHNhdmVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJvU2F2ZWRTdGF0ZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdGF0ZSB0aGF0IHdhcyBsb2FkZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2Vcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9Mb2FkZWRTdGF0ZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3VyY2UgdXJsIGZvciBBSkFYIGRhdGEgZm9yIHRoZSB0YWJsZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzQWpheFNvdXJjZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVhZCB0aGUgdGFibGUgZGF0YSBmcm9tLiBUaGlzXG5cdFx0ICogY2FuIGJlIGFuIGVtcHR5IHN0cmluZyAod2hlbiBub3Qgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyksIGluIHdoaWNoIGNhc2Vcblx0XHQgKiBpdCBpcyAgYXNzdW1lZCBhbiBhbiBhcnJheSBpcyBnaXZlbiBkaXJlY3RseS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic0FqYXhEYXRhUHJvcFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOb3RlIGlmIGRyYXcgc2hvdWxkIGJlIGJsb2NrZWQgd2hpbGUgZ2V0dGluZyBkYXRhXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFwiYkFqYXhEYXRhR2V0XCI6IHRydWUsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IGpRdWVyeSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgZm9yIHNlcnZlci1zaWRlIGRhdGEgZ2F0aGVyaW5nLlxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHdvcmtpbmcgd2l0aCB0aGUgWEhSIGluZm9ybWF0aW9uIGluIG9uZSBvZiB0aGVcblx0XHQgKiBjYWxsYmFja3Ncblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImpxWEhSXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0XCJqc29uXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBwcmlvciB0byBzZW5kaW5nIGFuIEFqYXggcmVxdWVzdCBzbyBleHRyYVxuXHRcdCAqIHBhcmFtZXRlcnMgY2FuIGVhc2lseSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU2VydmVyUGFyYW1zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZW5kIHRoZSBYSFIgSFRUUCBtZXRob2QgLSBHRVQgb3IgUE9TVCAoY291bGQgYmUgUFVUIG9yIERFTEVURSBpZlxuXHRcdCAqIHJlcXVpcmVkKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGb3JtYXQgbnVtYmVycyBmb3IgZGlzcGxheS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHVzZXIgc2VsZWN0YWJsZSBsZW5ndGggbWVudS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3Jcblx0XHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJpRHJhd1wiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSBpZiBhIHJlZHJhdyBpcyBiZWluZyBkb25lIC0gdXNlZnVsIGZvciBBamF4XG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJEcmF3aW5nXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBEcmF3IGluZGV4IChpRHJhdykgb2YgdGhlIGxhc3QgZXJyb3Igd2hlbiBwYXJzaW5nIHRoZSByZXR1cm5lZCBkYXRhXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdFwiaURyYXdFcnJvclwiOiAtMSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFnaW5nIGRpc3BsYXkgbGVuZ3RoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAxMFxuXHRcdCAqL1xuXHRcdFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYWdpbmcgc3RhcnQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgcmVzdWx0IHNldFxuXHRcdCAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cblx0XHQgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG5cdFx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxuXHRcdCAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2lSZWNvcmRzRGlzcGxheVwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY2xhc3NlcyB0byB1c2UgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRcIm9DbGFzc2VzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHRcdCAqIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqICBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0XHQgKiBldmVudHMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJTb3J0ZWRcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIHRoYXQgaWYgbXVsdGlwbGUgcm93cyBhcmUgaW4gdGhlIGhlYWRlciBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuXG5cdFx0ICogb25lIHVuaXF1ZSBjZWxsIHBlciBjb2x1bW4sIGlmIHRoZSB0b3Agb25lICh0cnVlKSBvciBib3R0b20gb25lIChmYWxzZSlcblx0XHQgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU29ydENlbGxzVG9wXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luaXRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBjYWxsYmFjayBmdW5jdGlvbnMgLSBmb3IgcGx1Zy1pbnMgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG8gdGhlXG5cdFx0ICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XG5cdFx0XHRcdHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcblx0XHRcdFx0dGhpcy5haURpc3BsYXkubGVuZ3RoO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZGlzcGxheSBlbmQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuRGlzcGxheUVuZFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhclxuXHRcdFx0XHRsZW4gICAgICA9IHRoaXMuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRzdGFydCAgICA9IHRoaXMuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRcdHJlY29yZHMgID0gdGhpcy5haURpc3BsYXkubGVuZ3RoLFxuXHRcdFx0XHRmZWF0dXJlcyA9IHRoaXMub0ZlYXR1cmVzLFxuXHRcdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRcdHN0YXJ0ICsgcmVjb3JkcyA6XG5cdFx0XHRcdFx0TWF0aC5taW4oIHN0YXJ0K2xlbiwgdGhpcy5faVJlY29yZHNEaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuICEgcGFnaW5hdGUgfHwgY2FsYz5yZWNvcmRzIHx8IGxlbj09PS0xID9cblx0XHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0XHRjYWxjO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcblx0XHQgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cblx0XHQgKiBpbmNyZW1lbnRpbmcgaW50ZXJuYWwgY291bnRlciBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcblx0XHQgKiBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSBhbmQgaXRzIGNvbnRyb2xzLlxuXHRcdCAqL1xuXHRcdFwiaVRhYkluZGV4XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHRcdCAqL1xuXHRcdFwiblNjcm9sbEhlYWRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXG5cdFx0ICovXG5cdFx0XCJuU2Nyb2xsRm9vdFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMYXN0IGFwcGxpZWQgc29ydFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYUxhc3RTb3J0XCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJvUGx1Z2luc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdXNlZCB0byBnZXQgYSByb3cncyBpZCBmcm9tIHRoZSByb3cncyBkYXRhXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInJvd0lkRm5cIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSBhIHJvdydzIGlkXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJyb3dJZFwiOiBudWxsXG5cdH07XG5cblx0LyoqXG5cdCAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGUuZXh0YCB3aGVyZSBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkLiBJdCBpc1xuXHQgKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5leHRcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgZXh0ZW5zaW9uc1xuXHQgKiBcblx0ICogVGhpcyBuYW1lc3BhY2UgYWN0cyBhcyBhIGNvbGxlY3Rpb24gYXJlYSBmb3IgcGx1Zy1pbnMgdGhhdCBjYW4gYmUgdXNlZCB0b1xuXHQgKiBleHRlbmQgRGF0YVRhYmxlcyBjYXBhYmlsaXRpZXMuIEluZGVlZCBtYW55IG9mIHRoZSBidWlsZCBpbiBtZXRob2RzXG5cdCAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3Jcblx0ICogZXhhbXBsZSkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XG5cdCAqIHJlYXNvbnNcblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5leHQgPSBfZXh0ID0ge1xuXHRcdC8qKlxuXHRcdCAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcblx0XHQgKiBkZWZpbmVkIGhlcmUgc28gb3RoZXIgZXh0ZW5zaW9ucyBjYW4gZGVmaW5lIGJ1dHRvbnMgcmVnYXJkbGVzcyBvZiBsb2FkXG5cdFx0ICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGJ1dHRvbnM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRWxlbWVudCBjbGFzcyBuYW1lc1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGNsYXNzZXM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBidWlsZCB0eXBlIChleHBhbmRlZCBieSB0aGUgZG93bmxvYWQgYnVpbGRlcilcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRidWlsZGVyOiBcIi1zb3VyY2UtXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdFx0ICogXG5cdFx0ICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXG5cdFx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdFx0ICovXG5cdFx0ZXJyTW9kZTogXCJhbGVydFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggZGVzY3JpYmUgdGhlIGZlYXR1cmUgcGx1Zy1pbnMgdGhhdCBhcmVcblx0XHQgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG5cdFx0ICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cblx0XHQgKiBcblx0XHQgKiBFYWNoIGZlYXR1cmUgcGx1Zy1pbiBpcyBkZXNjcmliZWQgYnkgYW4gb2JqZWN0IHdoaWNoIG11c3QgaGF2ZSB0aGVcblx0XHQgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBcblx0XHQgKiAqIGBmbkluaXRgIC0gZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHBsdWctaW4sXG5cdFx0ICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXG5cdFx0ICogICBpbnN0aWxsYXRpb24gb3B0aW9uLiBUaGlzIGlzIGNhc2Ugc2Vuc2l0aXZlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICpcblx0XHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdFx0ICogXG5cdFx0ICogKiB7bm9kZXxudWxsfSBUaGUgZWxlbWVudCB3aGljaCBjb250YWlucyB5b3VyIGZlYXR1cmUuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcblx0XHQgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxuXHRcdCAqICAgYmUgdXNlZnVsIHdoZW4gZGV2ZWxvcGluZyBhIHBsdWctaW4gd2hpY2ggYWxsb3dzIHRhYmxlIGNvbnRyb2wgdmlhXG5cdFx0ICogICBrZXlib2FyZCBlbnRyeVxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQuZmVhdHVyZXMucHVzaCgge1xuXHRcdCAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdGZlYXR1cmU6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUm93IHNlYXJjaGluZy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdFx0ICogc2VhcmNoaW5nLCBhbmQgYSBsb3QgbW9yZSBjb21wcmVoZW5zaXZlIGFzIGl0IGFsbG93cyB5b3UgY29tcGxldGUgY29udHJvbFxuXHRcdCAqIG92ZXIgdGhlIHNlYXJjaGluZyBsb2dpYy4gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXMgYSBmdW5jdGlvblxuXHRcdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdFx0ICogYW5kIHlvdXIgbG9naWMgZGVjaWRlcyBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaGluZyBkYXRhIHNldFxuXHRcdCAqIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIFNlYXJjaGluZyBmdW5jdGlvbnMgaGF2ZSB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogMi4gYHthcnJheXxvYmplY3R9YCBEYXRhIGZvciB0aGUgcm93IHRvIGJlIHByb2Nlc3NlZCAoc2FtZSBhcyB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0XHQgKiAgICBmcm9tIGEgRE9NIGRhdGEgc291cmNlXG5cdFx0ICogMy4gYHtpbnR9YCBSb3cgaW5kZXggKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncy5hb0RhdGF9KSwgd2hpY2hcblx0XHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHRcdCAqXG5cdFx0ICogKiB7Ym9vbGVhbn0gSW5jbHVkZSB0aGUgcm93IGluIHRoZSBzZWFyY2hlZCByZXN1bHQgc2V0ICh0cnVlKSBvciBub3Rcblx0XHQgKiAgIChmYWxzZSlcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBhcyB3aXRoIHRoZSBtYWluIHNlYXJjaCBhYmlsaXR5IGluIERhdGFUYWJsZXMsIHRlY2huaWNhbGx5IHRoaXNcblx0XHQgKiBpcyBcImZpbHRlcmluZ1wiLCBzaW5jZSBpdCBpcyBzdWJ0cmFjdGl2ZS4gSG93ZXZlciwgZm9yIGNvbnNpc3RlbmN5IGluXG5cdFx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdFx0ICogICAgLy8gZm91cnRoIGNvbHVtbiAoaS5lLiB0aGUgZGF0YVszXSBpbmRleCkgYmFzZWQgb24gdHdvIGlucHV0IHZhbHVlc1xuXHRcdCAqICAgIC8vIGZyb20gdGhlIGVuZC11c2VyLCBtYXRjaGluZyB0aGUgZGF0YSBpbiBhIGNlcnRhaW4gcmFuZ2UuXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHRcdCAqICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgIHZhciBtaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluJykudmFsdWUgKiAxO1xuXHRcdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0XHQgKiAgICAgICAgdmFyIHZlcnNpb24gPSBkYXRhWzNdID09IFwiLVwiID8gMCA6IGRhdGFbM10qMTtcblx0XHQgKlxuXHRcdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0c2VhcmNoOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcblx0XHQgKlxuXHRcdCAqIFRoZSBgc2VsZWN0b3JgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGVcblx0XHQgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcblx0XHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHRcdCAqIHRoZWlyIHBsdXJhbCBjb3VudGVycGFydHMpLiBGb3IgZXhhbXBsZSB0aGUgU2VsZWN0IGV4dGVuc2lvbiB1c2VzIHRoaXNcblx0XHQgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIGJ1aWx0IGluIHNlbGVjdG9yXG5cdFx0ICogb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggcHJvcGVydHkgaXMgYW4gYXJyYXkgdG8gd2hpY2ggZnVuY3Rpb25zIGNhbiBiZSBwdXNoZWQuIFRoZSBmdW5jdGlvbnNcblx0XHQgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XG5cdFx0ICpcblx0XHQgKiAqIFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcblx0XHQgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxuXHRcdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdFx0ICpcblx0XHQgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cblx0XHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqL1xuXHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRjZWxsOiBbXSxcblx0XHRcdGNvbHVtbjogW10sXG5cdFx0XHRyb3c6IFtdXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGZ1bmN0aW9ucywgZXhwb3NlZCBmb3IgdXNlZCBpbiBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoZSBpbnRlcm5hbCBtZXRob2RzIGZvclxuXHRcdCAqIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbHVnLWluIChhbmQgZXZlbiB0aGVuLCB0cnkgdG8gYXZvaWQgaWYgcG9zc2libGUpLlxuXHRcdCAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0aW50ZXJuYWw6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTGVnYWN5IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gRW5hYmxlIGFuZCBkaXNhYmxlIGxlZ2FjeSBvcHRpb25zIHRoYXRcblx0XHQgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICovXG5cdFx0bGVnYWN5OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0XHQgKiByZXF1ZXN0c1xuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRhamF4OiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxuXHRcdCAqIFxuXHRcdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHRcdCAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnZUJ1dHRvbn0uIFRoZSByZW5kZXJlciBhZGRyZXNzZXMgaG93IHRoZVxuXHRcdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdFx0ICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXG5cdFx0ICogZGVzY3JpcHRpb25zICh3aGF0IGVhY2ggYnV0dG9uIHdpbGwgZG8pLlxuXHRcdCAqXG5cdFx0ICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxuXHRcdCAqIG9wdGlvbnMgZGVmaW5lZCBoZXJlKSBjYW4gYmUgdXNlZCB0aHJvdWdoIHRoZSBgcGFnaW5hdGlvblR5cGVgXG5cdFx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxuXHRcdCAqIDIuIGB7aW50fSBwYWdlc2AgVGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcblx0XHQgKiBhcnJheSBjYW4gYmUgb25lIG9mOlxuXHRcdCAqXG5cdFx0ICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdFx0ICogKiBgbGFzdGAgLSBKdW1wIHRvIGxhc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGB7aW50fWAgLSBTaG93IHBhZ2Ugb2YgdGhlIGluZGV4IGdpdmVuXG5cdFx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHRcdCAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdFx0ICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcblx0XHQgKiBhYmlsaXR5IGlzIHN0aWxsIHN1cHBvcnRlZCBieSBEYXRhVGFibGVzIDEuMTArIHRvIHByb3ZpZGUgYmFja3dhcmRzXG5cdFx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHRcdCAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZUV4dC5vUGFnaW5hdGlvbi5jdXJyZW50ID0gZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHRcdCAqICAgIH07XG5cdFx0ICovXG5cdFx0cGFnZXI6IHt9LFxuXHRcblx0XG5cdFx0cmVuZGVyZXI6IHtcblx0XHRcdHBhZ2VCdXR0b246IHt9LFxuXHRcdFx0aGVhZGVyOiB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBPcmRlcmluZyBwbHVnLWlucyAtIGN1c3RvbSBkYXRhIHNvdXJjZVxuXHRcdCAqIFxuXHRcdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdFx0ICogdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvcmRlcmluZyB0aGF0IERhdGFUYWJsZXMgdHlwaWNhbGx5IHVzZXMuIEl0XG5cdFx0ICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuXHRcdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcblx0XHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdFx0ICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cblx0XHQgKiBcblx0XHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdFx0ICogd2lzaCB0byBiZSBvcmRlcmluZyBmb3IgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhhdFxuXHRcdCAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cblx0XHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdFx0ICogZnVuY3Rpb24gaXMgcnVuIGhlcmUgZGVwZW5kcyBvbiB0aGUgYGR0LWluaXQgY29sdW1ucy5vcmRlckRhdGFUeXBlYFxuXHRcdCAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHRcdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5OlxuXHRcdCAqXG5cdFx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0b3JkZXI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBwbHVnLWlucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xuXHRcdCAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cblx0XHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0XHQgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdHR5cGU6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuXHRcdFx0ICogYSBjb2x1bW4ncyB0eXBlLCBtYWtpbmcgaW5pdGlhbGlzYXRpb24gb2YgRGF0YVRhYmxlcyBzdXBlciBlYXN5LCBldmVuXG5cdFx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxuXHRcdCAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0XHQgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXG5cdFx0ICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG5cdFx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuXHRcdFx0ICogICBwYXNzIGl0IG9uIHRvIHRoZSBvdGhlciB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuXHRcdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnB1c2goXG5cdFx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuXHRcdFx0ICogICAgICAgIGlmICggISBkYXRhLnN1YnN0cmluZygxKS5tYXRjaCgvWzAtOV0vKSApIHtcblx0XHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHRcdCAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gJ2N1cnJlbmN5Jztcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgICk7XG5cdFx0XHQgKi9cblx0XHRcdGRldGVjdDogW10sXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXG5cdFx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHRcdCAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdFx0ICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG5cdFx0XHQgKiBcblx0XHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdFx0ICogZm9yIGEgY29sdW1uIChvciBoYXZlIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIHlvdSBieSBEYXRhVGFibGVzXG5cdFx0XHQgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3Jcblx0XHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHRcdCAqIGJ5IGFsbG93aW5nIHlvdSB0byBwcmUtcHJvY2Vzc2luZyB0aGUgZGF0YSBhbmQgcmV0dXJuaW5nIHRoZSBkYXRhIGluXG5cdFx0XHQgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcblx0XHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHRcdCAqIGZvciB0aGF0IHRhcmdldCBjb2x1bW4uIFRoaXMgaXMgdGhlIGNvcm9sbGFyeSBvZiA8aT5hZm5Tb3J0RGF0YTwvaT5cblx0XHRcdCAqIGZvciBzZWFyY2hpbmcgZGF0YS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0XHQgKiAgQGRlZmF1bHQge31cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0ICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqL1xuXHRcdFx0c2VhcmNoOiB7fSxcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXG5cdFx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0XHQgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdFx0ICogdGhpcyBvYmplY3Q6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdFx0ICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXG5cdFx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHRcdCAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuXHRcdFx0ICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbmQgcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHsqfWAgRGF0YSB0byBiZSBzb3J0ZWQgdXBvblxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdFx0ICogZnVuY3Rpb25zLCB0YWtpbmcgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdFx0ICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0ICpcblx0XHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcblx0XHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdFx0ICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuXHRcdFx0ICogICBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBcblx0XHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuXHRcdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuXHRcdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2Rcblx0XHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRvcmRlcjoge31cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBpbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF91bmlxdWU6IDAsXG5cdFxuXHRcblx0XHQvL1xuXHRcdC8vIERlcHJlY2lhdGVkXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBvbmx5LlxuXHRcdC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcblx0XHQvLyB2ZXJzaW9uXG5cdFx0Ly9cblx0XG5cdFx0LyoqXG5cdFx0ICogVmVyc2lvbiBjaGVjayBmdW5jdGlvbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcblx0XHQgKi9cblx0XHRmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZXggZm9yIHdoYXQgJ3RoaXMnIGluZGV4IEFQSSBmdW5jdGlvbnMgc2hvdWxkIHVzZVxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKi9cblx0XHRpQXBpSW5kZXg6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBqUXVlcnkgVUkgY2xhc3MgY29udGFpbmVyXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqL1xuXHRcdG9KVUlDbGFzc2VzOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvZnR3YXJlIHZlcnNpb25cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICovXG5cdFx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG5cdH07XG5cdFxuXHRcblx0Ly9cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEFsaWFzIHRvIHByZSAxLjEwIEh1bmdhcmlhbiBub3RhdGlvbiBjb3VudGVyIHBhcnRzXG5cdC8vXG5cdCQuZXh0ZW5kKCBfZXh0LCB7XG5cdFx0YWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcblx0XHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdFx0b2ZuU2VhcmNoOiAgICBfZXh0LnR5cGUuc2VhcmNoLFxuXHRcdG9Tb3J0OiAgICAgICAgX2V4dC50eXBlLm9yZGVyLFxuXHRcdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0XHRhb0ZlYXR1cmVzOiAgIF9leHQuZmVhdHVyZSxcblx0XHRvQXBpOiAgICAgICAgIF9leHQuaW50ZXJuYWwsXG5cdFx0b1N0ZENsYXNzZXM6ICBfZXh0LmNsYXNzZXMsXG5cdFx0b1BhZ2luYXRpb246ICBfZXh0LnBhZ2VyXG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdFx0XCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcblx0XHRcInNOb0Zvb3RlclwiOiBcIm5vLWZvb3RlclwiLFxuXHRcblx0XHQvKiBQYWdpbmcgYnV0dG9ucyAqL1xuXHRcdFwic1BhZ2VCdXR0b25cIjogXCJwYWdpbmF0ZV9idXR0b25cIixcblx0XHRcInNQYWdlQnV0dG9uQWN0aXZlXCI6IFwiY3VycmVudFwiLFxuXHRcdFwic1BhZ2VCdXR0b25EaXNhYmxlZFwiOiBcImRpc2FibGVkXCIsXG5cdFxuXHRcdC8qIFN0cmlwaW5nIGNsYXNzZXMgKi9cblx0XHRcInNTdHJpcGVPZGRcIjogXCJvZGRcIixcblx0XHRcInNTdHJpcGVFdmVuXCI6IFwiZXZlblwiLFxuXHRcblx0XHQvKiBFbXB0eSByb3cgKi9cblx0XHRcInNSb3dFbXB0eVwiOiBcImRhdGFUYWJsZXNfZW1wdHlcIixcblx0XG5cdFx0LyogRmVhdHVyZXMgKi9cblx0XHRcInNXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc193cmFwcGVyXCIsXG5cdFx0XCJzRmlsdGVyXCI6IFwiZGF0YVRhYmxlc19maWx0ZXJcIixcblx0XHRcInNJbmZvXCI6IFwiZGF0YVRhYmxlc19pbmZvXCIsXG5cdFx0XCJzUGFnaW5nXCI6IFwiZGF0YVRhYmxlc19wYWdpbmF0ZSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cblx0XHRcInNMZW5ndGhcIjogXCJkYXRhVGFibGVzX2xlbmd0aFwiLFxuXHRcdFwic1Byb2Nlc3NpbmdcIjogXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmdcIixcblx0XG5cdFx0LyogU29ydGluZyAqL1xuXHRcdFwic1NvcnRBc2NcIjogXCJzb3J0aW5nX2FzY1wiLFxuXHRcdFwic1NvcnREZXNjXCI6IFwic29ydGluZ19kZXNjXCIsXG5cdFx0XCJzU29ydGFibGVcIjogXCJzb3J0aW5nXCIsIC8qIFNvcnRhYmxlIGluIGJvdGggZGlyZWN0aW9ucyAqL1xuXHRcdFwic1NvcnRhYmxlQXNjXCI6IFwic29ydGluZ19hc2NfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0YWJsZURlc2NcIjogXCJzb3J0aW5nX2Rlc2NfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0YWJsZU5vbmVcIjogXCJzb3J0aW5nX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydENvbHVtblwiOiBcInNvcnRpbmdfXCIsIC8qIE5vdGUgdGhhdCBhbiBpbnQgaXMgcG9zdGZpeGVkIGZvciB0aGUgc29ydGluZyBvcmRlciAqL1xuXHRcblx0XHQvKiBGaWx0ZXJpbmcgKi9cblx0XHRcInNGaWx0ZXJJbnB1dFwiOiBcIlwiLFxuXHRcblx0XHQvKiBQYWdlIGxlbmd0aCAqL1xuXHRcdFwic0xlbmd0aFNlbGVjdFwiOiBcIlwiLFxuXHRcblx0XHQvKiBTY3JvbGxpbmcgKi9cblx0XHRcInNTY3JvbGxXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxcIixcblx0XHRcInNTY3JvbGxIZWFkXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkXCIsXG5cdFx0XCJzU2Nyb2xsSGVhZElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkSW5uZXJcIixcblx0XHRcInNTY3JvbGxCb2R5XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxCb2R5XCIsXG5cdFx0XCJzU2Nyb2xsRm9vdFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdFwiLFxuXHRcdFwic1Njcm9sbEZvb3RJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdElubmVyXCIsXG5cdFxuXHRcdC8qIE1pc2MgKi9cblx0XHRcInNIZWFkZXJUSFwiOiBcIlwiLFxuXHRcdFwic0Zvb3RlclRIXCI6IFwiXCIsXG5cdFxuXHRcdC8vIERlcHJlY2F0ZWRcblx0XHRcInNTb3J0SlVJQXNjXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSURlc2NcIjogXCJcIixcblx0XHRcInNTb3J0SlVJXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSUFzY0FsbG93ZWRcIjogXCJcIixcblx0XHRcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogXCJcIixcblx0XHRcInNTb3J0SlVJV3JhcHBlclwiOiBcIlwiLFxuXHRcdFwic1NvcnRJY29uXCI6IFwiXCIsXG5cdFx0XCJzSlVJSGVhZGVyXCI6IFwiXCIsXG5cdFx0XCJzSlVJRm9vdGVyXCI6IFwiXCJcblx0fSApO1xuXHRcblx0XG5cdHZhciBleHRQYWdpbmF0aW9uID0gRGF0YVRhYmxlLmV4dC5wYWdlcjtcblx0XG5cdGZ1bmN0aW9uIF9udW1iZXJzICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0dmFyXG5cdFx0XHRudW1iZXJzID0gW10sXG5cdFx0XHRidXR0b25zID0gZXh0UGFnaW5hdGlvbi5udW1iZXJzX2xlbmd0aCxcblx0XHRcdGhhbGYgPSBNYXRoLmZsb29yKCBidXR0b25zIC8gMiApLFxuXHRcdFx0aSA9IDE7XG5cdFxuXHRcdGlmICggcGFnZXMgPD0gYnV0dG9ucyApIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UoIDAsIHBhZ2VzICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlIDw9IGhhbGYgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBidXR0b25zLTIgKTtcblx0XHRcdG51bWJlcnMucHVzaCggJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlID49IHBhZ2VzIC0gMSAtIGhhbGYgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlcy0oYnV0dG9ucy0yKSwgcGFnZXMgKTtcblx0XHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAnZWxsaXBzaXMnICk7IC8vIG5vIHVuc2hpZnQgaW4gaWU2XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UoIHBhZ2UtaGFsZisyLCBwYWdlK2hhbGYtMSApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCAnZWxsaXBzaXMnICk7XG5cdFx0XHRudW1iZXJzLnB1c2goIHBhZ2VzLTEgKTtcblx0XHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAnZWxsaXBzaXMnICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHRcdH1cblx0XG5cdFx0bnVtYmVycy5EVF9lbCA9ICdzcGFuJztcblx0XHRyZXR1cm4gbnVtYmVycztcblx0fVxuXHRcblx0XG5cdCQuZXh0ZW5kKCBleHRQYWdpbmF0aW9uLCB7XG5cdFx0c2ltcGxlOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ3ByZXZpb3VzJywgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbDogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICAnZmlyc3QnLCAncHJldmlvdXMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdG51bWJlcnM6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyBfbnVtYmVycyhwYWdlLCBwYWdlcykgXTtcblx0XHR9LFxuXHRcblx0XHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFx0XG5cdFx0Zmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcblx0IFx0XHRyZXR1cm4gWydmaXJzdCcsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ2xhc3QnXTtcblx0IFx0fSxcblx0XG5cdFx0Ly8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxuXHRcdF9udW1iZXJzOiBfbnVtYmVycyxcblx0XG5cdFx0Ly8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIChpbmNsdWRpbmcgZWxsaXBzaXMpIHRvIHNob3cuIF9NdXN0IGJlIG9kZCFfXG5cdFx0bnVtYmVyc19sZW5ndGg6IDdcblx0fSApO1xuXHRcblx0XG5cdCQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XG5cdFx0cGFnZUJ1dHRvbjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9zdCwgaWR4LCBidXR0b25zLCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFx0dmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHRcdFx0XHR2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcblx0XHRcdFx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cdFxuXHRcdFx0XHR2YXIgYXR0YWNoID0gZnVuY3Rpb24oIGNvbnRhaW5lciwgYnV0dG9ucyApIHtcblx0XHRcdFx0XHR2YXIgaSwgaWVuLCBub2RlLCBidXR0b24sIHRhYkluZGV4O1xuXHRcdFx0XHRcdHZhciBkaXNhYmxlZENsYXNzID0gY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkO1xuXHRcdFx0XHRcdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRcdFx0XHRfZm5QYWdlQ2hhbmdlKCBzZXR0aW5ncywgZS5kYXRhLmFjdGlvbiwgdHJ1ZSApO1xuXHRcdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRidXR0b24gPSBidXR0b25zW2ldO1xuXHRcblx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggYnV0dG9uICkgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpbm5lciA9ICQoICc8JysoYnV0dG9uLkRUX2VsIHx8ICdkaXYnKSsnLz4nIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXHRcdFx0XHRcdFx0XHRhdHRhY2goIGlubmVyLCBidXR0b24gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b247XG5cdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gc2V0dGluZ3MuaVRhYkluZGV4O1xuXHRcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggYnV0dG9uICkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2VsbGlwc2lzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj4mI3gyMDI2Ozwvc3Bhbj4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2UgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbmV4dCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTmV4dDtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTGFzdDtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlciggYnV0dG9uICsgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBwYWdlID09PSBidXR0b24gP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNQYWdlQnV0dG9uQWN0aXZlIDogJyc7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0aWYgKCBidG5EaXNwbGF5ICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSAkKCc8YT4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24rJyAnK2J0bkNsYXNzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1jb250cm9scyc6IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFbIGJ1dHRvbiBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnZGF0YS1kdC1pZHgnOiBjb3VudGVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQndGFiaW5kZXgnOiB0YWJJbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5zVGFibGVJZCArJ18nKyBidXR0b24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0Lmh0bWwoIGJ0bkRpc3BsYXkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0X2ZuQmluZEFjdGlvbihcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUsIHthY3Rpb246IGJ1dHRvbn0sIGNsaWNrSGFuZGxlclxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLiBUcnkgLyBjYXRjaCB0aGUgZXJyb3IuIE5vdCBnb29kIGZvclxuXHRcdFx0XHQvLyBhY2Nlc3NpYmlsaXR5LCBidXQgbmVpdGhlciBhcmUgZnJhbWVzLlxuXHRcdFx0XHR2YXIgYWN0aXZlRWw7XG5cdFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHRcdFx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0XHRcdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0XHRcdFx0Ly8gY29tcGxldGVkXG5cdFx0XHRcdFx0YWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHt9XG5cdFxuXHRcdFx0XHRhdHRhY2goICQoaG9zdCkuZW1wdHkoKSwgYnV0dG9ucyApO1xuXHRcblx0XHRcdFx0aWYgKCBhY3RpdmVFbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdCQoaG9zdCkuZmluZCggJ1tkYXRhLWR0LWlkeD0nK2FjdGl2ZUVsKyddJyApLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0Ly8gQnVpbHQgaW4gdHlwZSBkZXRlY3Rpb24uIFNlZSBtb2RlbC5leHQuYVR5cGVzIGZvciBpbmZvcm1hdGlvbiBhYm91dFxuXHQvLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhpcyBtZXRob2RzLlxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdCwgW1xuXHRcdC8vIFBsYWluIG51bWJlcnMgLSBmaXJzdCBzaW5jZSBWOCBkZXRlY3RzIHNvbWUgcGxhaW4gbnVtYmVycyBhcyBkYXRlc1xuXHRcdC8vIGUuZy4gRGF0ZS5wYXJzZSgnNTUnKSAoYnV0IG5vdCBhbGwsIGUuZy4gRGF0ZS5wYXJzZSgnMjInKS4uLikuXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsICkgPyAnbnVtJytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBEYXRlcyAob25seSB0aG9zZSByZWNvZ25pc2VkIGJ5IHRoZSBicm93c2VyJ3MgRGF0ZS5wYXJzZSlcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHQvLyBWOCB0cmllcyBfdmVyeV8gaGFyZCB0byBtYWtlIGEgc3RyaW5nIHBhc3NlZCBpbnRvIGBEYXRlLnBhcnNlKClgXG5cdFx0XHQvLyB2YWxpZCwgc28gd2UgbmVlZCB0byB1c2UgYSByZWdleCB0byByZXN0cmljdCBkYXRlIGZvcm1hdHMuIFVzZSBhXG5cdFx0XHQvLyBwbHVnLWluIGZvciBhbnl0aGluZyBvdGhlciB0aGFuIElTTzg2MDEgc3R5bGUgc3RyaW5nc1xuXHRcdFx0aWYgKCBkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICEgX3JlX2RhdGUudGVzdChkKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcblx0XHRcdHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCkgPyAnZGF0ZScgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEZvcm1hdHRlZCBudW1iZXJzXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnbnVtLWZtdCcrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gSFRNTCBudW1lcmljXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsICkgPyAnaHRtbC1udW0nK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnaHRtbC1udW0tZm10JytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBIVE1MICh0aGlzIGlzIHN0cmljdCBjaGVja2luZyAtIHRoZXJlIG11c3QgYmUgaHRtbClcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgKHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTEpID9cblx0XHRcdFx0J2h0bWwnIDogbnVsbDtcblx0XHR9XG5cdF0gKTtcblx0XG5cdFxuXHRcblx0Ly8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcblx0Ly8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoZXNlIG1ldGhvZHMuXG5cdC8vIFxuXHQvLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXG5cdC8vIGh0bWwgZm9ybWF0dGVkIG51bWJlcnMgYnkgYF9hZGROdW1lcmljU29ydCgpYCB3aGVuIHdlIGtub3cgd2hhdCB0aGUgZGVjaW1hbFxuXHQvLyBwbGFjZSBpc1xuXHRcblx0XG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoLCB7XG5cdFx0aHRtbDogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShkYXRhKSA/XG5cdFx0XHRcdGRhdGEgOlxuXHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGRhdGFcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggX3JlX2h0bWwsIFwiXCIgKSA6XG5cdFx0XHRcdFx0Jyc7XG5cdFx0fSxcblx0XG5cdFx0c3RyaW5nOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KGRhdGEpID9cblx0XHRcdFx0ZGF0YSA6XG5cdFx0XHRcdHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0ZGF0YS5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdH1cblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0XHRpZiAoIGQgIT09IDAgJiYgKCFkIHx8IGQgPT09ICctJykgKSB7XG5cdFx0XHRyZXR1cm4gLUluZmluaXR5O1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgYSBkZWNpbWFsIHBsYWNlIG90aGVyIHRoYW4gYC5gIGlzIHVzZWQsIGl0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZVxuXHRcdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHRcdC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cblx0XHRpZiAoIGRlY2ltYWxQbGFjZSApIHtcblx0XHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZC5yZXBsYWNlICkge1xuXHRcdFx0aWYgKCByZTEgKSB7XG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMSwgJycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHJlMiApIHtcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGQgKiAxO1xuXHR9O1xuXHRcblx0XG5cdC8vIEFkZCB0aGUgbnVtZXJpYyAnZGVmb3JtYXR0aW5nJyBmdW5jdGlvbnMgZm9yIHNvcnRpbmcgYW5kIHNlYXJjaC4gVGhpcyBpcyBkb25lXG5cdC8vIGluIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBhbiBlYXN5IGFiaWxpdHkgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb25zIHRvIGFkZFxuXHQvLyBhZGRpdGlvbmFsIG1ldGhvZHMgaWYgYSBub24tcGVyaW9kIGRlY2ltYWwgcGxhY2UgaXMgdXNlZC5cblx0ZnVuY3Rpb24gX2FkZE51bWVyaWNTb3J0ICggZGVjaW1hbFBsYWNlICkge1xuXHRcdCQuZWFjaChcblx0XHRcdHtcblx0XHRcdFx0Ly8gUGxhaW4gbnVtYmVyc1xuXHRcdFx0XHRcIm51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gRm9ybWF0dGVkIG51bWJlcnNcblx0XHRcdFx0XCJudW0tZm10XCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fSxcblx0XG5cdFx0XHRcdC8vIEhUTUwgbnVtZXJpY1xuXHRcdFx0XHRcImh0bWwtbnVtXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcblx0XHRcdFx0XCJodG1sLW51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uICgga2V5LCBmbiApIHtcblx0XHRcdFx0Ly8gQWRkIHRoZSBvcmRlcmluZyBtZXRob2Rcblx0XHRcdFx0X2V4dC50eXBlLm9yZGVyWyBrZXkrZGVjaW1hbFBsYWNlKyctcHJlJyBdID0gZm47XG5cdFxuXHRcdFx0XHQvLyBGb3IgSFRNTCB0eXBlcyBhZGQgYSBzZWFyY2ggZm9ybWF0dGVyIHRoYXQgd2lsbCBzdHJpcCB0aGUgSFRNTFxuXHRcdFx0XHRpZiAoIGtleS5tYXRjaCgvXmh0bWxcXC0vKSApIHtcblx0XHRcdFx0XHRfZXh0LnR5cGUuc2VhcmNoWyBrZXkrZGVjaW1hbFBsYWNlIF0gPSBfZXh0LnR5cGUuc2VhcmNoLmh0bWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cdFxuXHRcblx0Ly8gRGVmYXVsdCBzb3J0IG1ldGhvZHNcblx0JC5leHRlbmQoIF9leHQudHlwZS5vcmRlciwge1xuXHRcdC8vIERhdGVzXG5cdFx0XCJkYXRlLXByZVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHR2YXIgdHMgPSBEYXRlLnBhcnNlKCBkICk7XG5cdFx0XHRyZXR1cm4gaXNOYU4odHMpID8gLUluZmluaXR5IDogdHM7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHRtbFxuXHRcdFwiaHRtbC1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0YS5yZXBsYWNlID9cblx0XHRcdFx0XHRhLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICkudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0YSsnJztcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmdcblx0XHRcInN0cmluZy1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgZmFzdGVyIHRoYW4gYWx3YXlzIGNhbGxpbmcgdG9TdHJpbmcsXG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS90b3N0cmluZy12LWNoZWNrXG5cdFx0XHRyZXR1cm4gX2VtcHR5KGEpID9cblx0XHRcdFx0JycgOlxuXHRcdFx0XHR0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGEudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHRcdCcnIDpcblx0XHRcdFx0XHRcdGEudG9TdHJpbmcoKTtcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmctYXNjIGFuZCAtZGVzYyBhcmUgcmV0YWluZWQgb25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGRcblx0XHQvLyBzb3J0IG1ldGhvZHNcblx0XHRcInN0cmluZy1hc2NcIjogZnVuY3Rpb24gKCB4LCB5ICkge1xuXHRcdFx0cmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0fSxcblx0XG5cdFx0XCJzdHJpbmctZGVzY1wiOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cdFx0XHRyZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBOdW1lcmljIHNvcnRpbmcgdHlwZXMgLSBvcmRlciBkb2Vzbid0IG1hdHRlciBoZXJlXG5cdF9hZGROdW1lcmljU29ydCggJycgKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdGhlYWRlcjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydCAtIG5vdGUgdGhhdCB1c2luZyB0aGVcblx0XHRcdFx0Ly8gYERUYCBuYW1lc3BhY2Ugd2lsbCBhbGxvdyB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHRcdC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcblx0XHRcdFx0Ly8gbGlzdGVuaW5nIGZvclxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRcdHJldHVybjsgICAgICAgICAgICAgICAvLyB0YWJsZSwgbm90IGEgbmVzdGVkIG9uZVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0dmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3MgKycgJytcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEFzYyArJyAnK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzY1xuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnREZXNjIDpcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XG5cdFx0XHRqcXVlcnl1aTogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIgKVxuXHRcdFx0XHRcdC5hcHBlbmQoIGNlbGwuY29udGVudHMoKSApXG5cdFx0XHRcdFx0LmFwcGVuZCggJCgnPHNwYW4vPicpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRJY29uKycgJytjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSSApXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggY2VsbCApO1xuXHRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydFxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzZXMuc1NvcnRBc2MgK1wiIFwiK2NsYXNzZXMuc1NvcnREZXNjIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5maW5kKCAnc3Bhbi4nK2NsYXNzZXMuc1NvcnRJY29uIClcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSSArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2MgOlxuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzSlVJXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHQvKlxuXHQgKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxuXHQgKiBjYWxsZWQgYnkgYW55IG9mIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIERhdGFUYWJsZXMsIGJ1dCB0aGV5IGNhbiBiZSB1c2VkXG5cdCAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xuXHQgKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXG5cdCAqL1xuXHRcblx0dmFyIF9faHRtbEVzY2FwZUVudGl0aWVzID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdHJldHVybiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgP1xuXHRcdFx0ZFxuXHRcdFx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSA6XG5cdFx0XHRkO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEhlbHBlcnMgZm9yIGBjb2x1bW5zLnJlbmRlcmAuXG5cdCAqXG5cdCAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXG5cdCAqIG9wdGlvbiB0byBwcm92aWRlIGEgZGlzcGxheSByZW5kZXJlci4gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGRlZmluZWQ6XG5cdCAqXG5cdCAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxuXHQgKiAgIGRpc3BsYXksIHJldGFpbmluZyB0aGUgb3JpZ2luYWwgdW5mb3JtYXR0ZWQgZGF0YSBmb3Igc29ydGluZyBhbmQgZmlsdGVyaW5nLlxuXHQgKiAgIEl0IHRha2VzIDUgcGFyYW1ldGVyczpcblx0ICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxuXHQgKiAgICogYHN0cmluZ2AgLSBEZWNpbWFsIHBvaW50IGluZGljYXRvclxuXHQgKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcblx0ICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXG5cdCAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUG9zdGZpeCAoL3N1ZmZpeCkuXG5cdCAqICogYHRleHRgIC0gRXNjYXBlIEhUTUwgdG8gaGVscCBwcmV2ZW50IFhTUyBhdHRhY2tzLiBJdCBoYXMgbm8gb3B0aW9uYWxcblx0ICogICBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIENvbHVtbiBkZWZpbml0aW9uIHVzaW5nIHRoZSBudW1iZXIgcmVuZGVyZXJcblx0ICogICB7XG5cdCAqICAgICBkYXRhOiBcInNhbGFyeVwiLFxuXHQgKiAgICAgcmVuZGVyOiAkLmZuLmRhdGFUYWJsZS5yZW5kZXIubnVtYmVyKCAnXFwnJywgJy4nLCAwLCAnJCcgKVxuXHQgKiAgIH1cblx0ICpcblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLnJlbmRlciA9IHtcblx0XHRudW1iZXI6IGZ1bmN0aW9uICggdGhvdXNhbmRzLCBkZWNpbWFsLCBwcmVjaXNpb24sIHByZWZpeCwgcG9zdGZpeCApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3BsYXk6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBkICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBuZWdhdGl2ZSA9IGQgPCAwID8gJy0nIDogJyc7XG5cdFx0XHRcdFx0dmFyIGZsbyA9IHBhcnNlRmxvYXQoIGQgKTtcblx0XG5cdFx0XHRcdFx0Ly8gSWYgTmFOIHRoZW4gdGhlcmUgaXNuJ3QgbXVjaCBmb3JtYXR0aW5nIHRoYXQgd2UgY2FuIGRvIC0ganVzdFxuXHRcdFx0XHRcdC8vIHJldHVybiBpbW1lZGlhdGVseSwgZXNjYXBpbmcgYW55IEhUTUwgKHRoaXMgd2FzIHN1cHBvc2VkIHRvXG5cdFx0XHRcdFx0Ly8gYmUgYSBudW1iZXIgYWZ0ZXIgYWxsKVxuXHRcdFx0XHRcdGlmICggaXNOYU4oIGZsbyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9faHRtbEVzY2FwZUVudGl0aWVzKCBkICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmbG8gPSBmbG8udG9GaXhlZCggcHJlY2lzaW9uICk7XG5cdFx0XHRcdFx0ZCA9IE1hdGguYWJzKCBmbG8gKTtcblx0XG5cdFx0XHRcdFx0dmFyIGludFBhcnQgPSBwYXJzZUludCggZCwgMTAgKTtcblx0XHRcdFx0XHR2YXIgZmxvYXRQYXJ0ID0gcHJlY2lzaW9uID9cblx0XHRcdFx0XHRcdGRlY2ltYWwrKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKCBwcmVjaXNpb24gKS5zdWJzdHJpbmcoIDIgKTpcblx0XHRcdFx0XHRcdCcnO1xuXHRcblx0XHRcdFx0XHRyZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4fHwnJykgK1xuXHRcdFx0XHRcdFx0aW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCB0aG91c2FuZHNcblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdFx0ZmxvYXRQYXJ0ICtcblx0XHRcdFx0XHRcdChwb3N0Zml4fHwnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0XG5cdFx0dGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGlzcGxheTogX19odG1sRXNjYXBlRW50aXRpZXMsXG5cdFx0XHRcdGZpbHRlcjogX19odG1sRXNjYXBlRW50aXRpZXNcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qXG5cdCAqIFRoaXMgaXMgcmVhbGx5IGEgZ29vZCBiaXQgcnViYmlzaCB0aGlzIG1ldGhvZCBvZiBleHBvc2luZyB0aGUgaW50ZXJuYWwgbWV0aG9kc1xuXHQgKiBwdWJsaWNseS4uLiAtIFRvIGJlIGZpeGVkIGluIDIuMCB1c2luZyBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGVcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGV4cG9ydGluZyBhbiBpbnRlcm5hbCBmdW5jdGlvbnMgdG8gYW4gZXh0ZXJuYWwgQVBJLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGZuIEFQSSBmdW5jdGlvbiBuYW1lXG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjaW50ZXJuYWxcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkV4dGVybkFwaUZ1bmMgKGZuKVxuXHR7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBbX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0gKV0uY29uY2F0KFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIERhdGFUYWJsZS5leHQuaW50ZXJuYWxbZm5dLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0fTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcblx0ICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXG5cdCAqIHByaXZhdGUuIElmIHlvdSB1c2UgdGhlc2UgbWV0aG9kcywgYmUgYXdhcmUgdGhhdCB0aGV5IGFyZSBsaWFibGUgdG8gY2hhbmdlXG5cdCAqIGJldHdlZW4gdmVyc2lvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xuXHRcdF9mbkV4dGVybkFwaUZ1bmM6IF9mbkV4dGVybkFwaUZ1bmMsXG5cdFx0X2ZuQnVpbGRBamF4OiBfZm5CdWlsZEFqYXgsXG5cdFx0X2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcblx0XHRfZm5BamF4UGFyYW1ldGVyczogX2ZuQWpheFBhcmFtZXRlcnMsXG5cdFx0X2ZuQWpheFVwZGF0ZURyYXc6IF9mbkFqYXhVcGRhdGVEcmF3LFxuXHRcdF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcblx0XHRfZm5BZGRDb2x1bW46IF9mbkFkZENvbHVtbixcblx0XHRfZm5Db2x1bW5PcHRpb25zOiBfZm5Db2x1bW5PcHRpb25zLFxuXHRcdF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxuXHRcdF9mblZpc2libGVUb0NvbHVtbkluZGV4OiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsXG5cdFx0X2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcblx0XHRfZm5HZXRDb2x1bW5zOiBfZm5HZXRDb2x1bW5zLFxuXHRcdF9mbkNvbHVtblR5cGVzOiBfZm5Db2x1bW5UeXBlcyxcblx0XHRfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcblx0XHRfZm5IdW5nYXJpYW5NYXA6IF9mbkh1bmdhcmlhbk1hcCxcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuOiBfZm5DYW1lbFRvSHVuZ2FyaWFuLFxuXHRcdF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcblx0XHRfZm5Ccm93c2VyRGV0ZWN0OiBfZm5Ccm93c2VyRGV0ZWN0LFxuXHRcdF9mbkFkZERhdGE6IF9mbkFkZERhdGEsXG5cdFx0X2ZuQWRkVHI6IF9mbkFkZFRyLFxuXHRcdF9mbk5vZGVUb0RhdGFJbmRleDogX2ZuTm9kZVRvRGF0YUluZGV4LFxuXHRcdF9mbk5vZGVUb0NvbHVtbkluZGV4OiBfZm5Ob2RlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXG5cdFx0X2ZuU2V0Q2VsbERhdGE6IF9mblNldENlbGxEYXRhLFxuXHRcdF9mblNwbGl0T2JqTm90YXRpb246IF9mblNwbGl0T2JqTm90YXRpb24sXG5cdFx0X2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuU2V0T2JqZWN0RGF0YUZuOiBfZm5TZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuR2V0RGF0YU1hc3RlcjogX2ZuR2V0RGF0YU1hc3Rlcixcblx0XHRfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxuXHRcdF9mbkRlbGV0ZUluZGV4OiBfZm5EZWxldGVJbmRleCxcblx0XHRfZm5JbnZhbGlkYXRlOiBfZm5JbnZhbGlkYXRlLFxuXHRcdF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcblx0XHRfZm5DcmVhdGVUcjogX2ZuQ3JlYXRlVHIsXG5cdFx0X2ZuQnVpbGRIZWFkOiBfZm5CdWlsZEhlYWQsXG5cdFx0X2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxuXHRcdF9mbkRyYXc6IF9mbkRyYXcsXG5cdFx0X2ZuUmVEcmF3OiBfZm5SZURyYXcsXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxuXHRcdF9mbkRldGVjdEhlYWRlcjogX2ZuRGV0ZWN0SGVhZGVyLFxuXHRcdF9mbkdldFVuaXF1ZVRoczogX2ZuR2V0VW5pcXVlVGhzLFxuXHRcdF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcblx0XHRfZm5GaWx0ZXJDb21wbGV0ZTogX2ZuRmlsdGVyQ29tcGxldGUsXG5cdFx0X2ZuRmlsdGVyQ3VzdG9tOiBfZm5GaWx0ZXJDdXN0b20sXG5cdFx0X2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXG5cdFx0X2ZuRmlsdGVyOiBfZm5GaWx0ZXIsXG5cdFx0X2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsXG5cdFx0X2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxuXHRcdF9mbkZpbHRlckRhdGE6IF9mbkZpbHRlckRhdGEsXG5cdFx0X2ZuRmVhdHVyZUh0bWxJbmZvOiBfZm5GZWF0dXJlSHRtbEluZm8sXG5cdFx0X2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcblx0XHRfZm5JbmZvTWFjcm9zOiBfZm5JbmZvTWFjcm9zLFxuXHRcdF9mbkluaXRpYWxpc2U6IF9mbkluaXRpYWxpc2UsXG5cdFx0X2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXG5cdFx0X2ZuTGVuZ3RoQ2hhbmdlOiBfZm5MZW5ndGhDaGFuZ2UsXG5cdFx0X2ZuRmVhdHVyZUh0bWxMZW5ndGg6IF9mbkZlYXR1cmVIdG1sTGVuZ3RoLFxuXHRcdF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXG5cdFx0X2ZuUGFnZUNoYW5nZTogX2ZuUGFnZUNoYW5nZSxcblx0XHRfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXG5cdFx0X2ZuRmVhdHVyZUh0bWxUYWJsZTogX2ZuRmVhdHVyZUh0bWxUYWJsZSxcblx0XHRfZm5TY3JvbGxEcmF3OiBfZm5TY3JvbGxEcmF3LFxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxuXHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRoczogX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzLFxuXHRcdF9mblRocm90dGxlOiBfZm5UaHJvdHRsZSxcblx0XHRfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXG5cdFx0X2ZuR2V0V2lkZXN0Tm9kZTogX2ZuR2V0V2lkZXN0Tm9kZSxcblx0XHRfZm5HZXRNYXhMZW5TdHJpbmc6IF9mbkdldE1heExlblN0cmluZyxcblx0XHRfZm5TdHJpbmdUb0NzczogX2ZuU3RyaW5nVG9Dc3MsXG5cdFx0X2ZuU29ydEZsYXR0ZW46IF9mblNvcnRGbGF0dGVuLFxuXHRcdF9mblNvcnQ6IF9mblNvcnQsXG5cdFx0X2ZuU29ydEFyaWE6IF9mblNvcnRBcmlhLFxuXHRcdF9mblNvcnRMaXN0ZW5lcjogX2ZuU29ydExpc3RlbmVyLFxuXHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lcjogX2ZuU29ydEF0dGFjaExpc3RlbmVyLFxuXHRcdF9mblNvcnRpbmdDbGFzc2VzOiBfZm5Tb3J0aW5nQ2xhc3Nlcyxcblx0XHRfZm5Tb3J0RGF0YTogX2ZuU29ydERhdGEsXG5cdFx0X2ZuU2F2ZVN0YXRlOiBfZm5TYXZlU3RhdGUsXG5cdFx0X2ZuTG9hZFN0YXRlOiBfZm5Mb2FkU3RhdGUsXG5cdFx0X2ZuU2V0dGluZ3NGcm9tTm9kZTogX2ZuU2V0dGluZ3NGcm9tTm9kZSxcblx0XHRfZm5Mb2c6IF9mbkxvZyxcblx0XHRfZm5NYXA6IF9mbk1hcCxcblx0XHRfZm5CaW5kQWN0aW9uOiBfZm5CaW5kQWN0aW9uLFxuXHRcdF9mbkNhbGxiYWNrUmVnOiBfZm5DYWxsYmFja1JlZyxcblx0XHRfZm5DYWxsYmFja0ZpcmU6IF9mbkNhbGxiYWNrRmlyZSxcblx0XHRfZm5MZW5ndGhPdmVyZmxvdzogX2ZuTGVuZ3RoT3ZlcmZsb3csXG5cdFx0X2ZuUmVuZGVyZXI6IF9mblJlbmRlcmVyLFxuXHRcdF9mbkRhdGFTb3VyY2U6IF9mbkRhdGFTb3VyY2UsXG5cdFx0X2ZuUm93QXR0cmlidXRlczogX2ZuUm93QXR0cmlidXRlcyxcblx0XHRfZm5FeHRlbmQ6IF9mbkV4dGVuZCxcblx0XHRfZm5DYWxjdWxhdGVFbmQ6IGZ1bmN0aW9uICgpIHt9IC8vIFVzZWQgYnkgYSBsb3Qgb2YgcGx1Zy1pbnMsIGJ1dCByZWR1bmRhbnRcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIDEuMTAsIHNvIHRoaXMgZGVhZC1lbmQgZnVuY3Rpb24gaXNcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGVkIHRvIHByZXZlbnQgZXJyb3JzXG5cdH0gKTtcblx0XG5cblx0Ly8galF1ZXJ5IGFjY2Vzc1xuXHQkLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcblxuXHQvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG5cdERhdGFUYWJsZS4kID0gJDtcblxuXHQvLyBMZWdhY3kgYWxpYXNlc1xuXHQkLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHQkLmZuLmRhdGFUYWJsZUV4dCA9IERhdGFUYWJsZS5leHQ7XG5cblx0Ly8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcblx0Ly8galF1ZXJ5IG9iamVjdFxuXHQkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uICggb3B0cyApIHtcblx0XHRyZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUoIG9wdHMgKS5hcGkoKTtcblx0fTtcblxuXHQvLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcblx0Ly8gYXZhaWxhYmxlIG9uICQuZm4uRGF0YVRhYmxlXG5cdCQuZWFjaCggRGF0YVRhYmxlLCBmdW5jdGlvbiAoIHByb3AsIHZhbCApIHtcblx0XHQkLmZuLkRhdGFUYWJsZVsgcHJvcCBdID0gdmFsO1xuXHR9ICk7XG5cblxuXHQvLyBJbmZvcm1hdGlvbiBhYm91dCBldmVudHMgZmlyZWQgYnkgRGF0YVRhYmxlcyAtIGZvciBkb2N1bWVudGF0aW9uLlxuXHQvKipcblx0ICogRHJhdyBldmVudCwgZmlyZWQgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIHJlZHJhd24gb24gdGhlIHBhZ2UsIGF0IHRoZSBzYW1lXG5cdCAqIHBvaW50IGFzIGZuRHJhd0NhbGxiYWNrLiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIGJpbmRpbmcgZXZlbnRzIG9yXG5cdCAqIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zIHdoZW4gdGhlIHRhYmxlIGlzIGFsdGVyZWQgYXQgYWxsLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2RyYXcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHNlYXJjaGluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAodXNpbmcgdGhlXG5cdCAqIGJ1aWx0LWluIGdsb2JhbCBzZWFyY2gsIG9yIGNvbHVtbiBmaWx0ZXJzKSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3NlYXJjaC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFBhZ2UgY2hhbmdlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBwYWdpbmcgb2YgdGhlIHRhYmxlIGlzIGFsdGVyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjcGFnZS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIE9yZGVyIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBvcmRlcmluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI29yZGVyLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiBjb21wbGV0ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgZnVsbHlcblx0ICogZHJhd24sIGluY2x1ZGluZyBBamF4IGRhdGEgbG9hZGVkLCBpZiBBamF4IGRhdGEgaXMgcmVxdWlyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjaW5pdC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcblx0ICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkPC9saT48L29sPlxuXHQgKi9cblxuXHQvKipcblx0ICogU3RhdGUgc2F2ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZVxuXHQgKiBpcyByZXF1aXJlZC4gVGhpcyBldmVudCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0XG5cdCAqIHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Igb3RoZXIgc3RhdGVcblx0ICogcHJvcGVydGllcyAoZm9yIHBsdWctaW5zKSBvciBtb2RpZmljYXRpb24gb2YgYSBEYXRhVGFibGVzIGNvcmUgcHJvcGVydHkuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVTYXZlUGFyYW1zLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHN0YXRlIGluZm9ybWF0aW9uIHRvIGJlIHNhdmVkXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTdGF0ZSBsb2FkIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZFxuXHQgKiBkYXRhLCBidXQgcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGVcblx0ICogLSBhbGxvd2luZyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIGlzIHJlcXVpcmVkIG9yIGxvYWRpbmcgb2Zcblx0ICogc3RhdGUgZm9yIGEgcGx1Zy1pbi5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRQYXJhbXMuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIFN0YXRlIGxvYWRlZCBldmVudCwgZmlyZWQgd2hlbiBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSBzdG9yZWQgZGF0YSBhbmRcblx0ICogdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBieSB0aGUgbG9hZGVkIGRhdGEuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkZWQuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIFByb2Nlc3NpbmcgZXZlbnQsIGZpcmVkIHdoZW4gRGF0YVRhYmxlcyBpcyBkb2luZyBzb21lIGtpbmQgb2YgcHJvY2Vzc2luZ1xuXHQgKiAoYmUgaXQsIG9yZGVyLCBzZWFyY2ggb3IgYW55dGhpbmcgZWxzZSkuIEl0IGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRvXG5cdCAqIHRoZSBlbmQgdXNlciB0aGF0IHRoZXJlIGlzIHNvbWV0aGluZyBoYXBwZW5pbmcsIG9yIHRoYXQgc29tZXRoaW5nIGhhc1xuXHQgKiBmaW5pc2hlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNwcm9jZXNzaW5nLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBiU2hvdyBGbGFnIGZvciBpZiBEYXRhVGFibGVzIGlzIGRvaW5nIHByb2Nlc3Npbmcgb3Igbm90XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBamF4IChYSFIpIGV2ZW50LCBmaXJlZCB3aGVuZXZlciBhbiBBamF4IHJlcXVlc3QgaXMgY29tcGxldGVkIGZyb20gYVxuXHQgKiByZXF1ZXN0IHRvIG1hZGUgdG8gdGhlIHNlcnZlciBmb3IgbmV3IGRhdGEuIFRoaXMgZXZlbnQgaXMgY2FsbGVkIGJlZm9yZVxuXHQgKiBEYXRhVGFibGVzIHByb2Nlc3NlZCB0aGUgcmV0dXJuZWQgZGF0YSwgc28gaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcmUtXG5cdCAqIHByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCBpZiBuZWVkZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHRyaWdnZXIgaXMgY2FsbGVkIGluIGBmblNlcnZlckRhdGFgLCBpZiB5b3Ugb3ZlcnJpZGVcblx0ICogYGZuU2VydmVyRGF0YWAgYW5kIHdoaWNoIHRvIHVzZSB0aGlzIGV2ZW50LCB5b3UgbmVlZCB0byB0cmlnZ2VyIGl0IGluIHlvdVxuXHQgKiBzdWNjZXNzIGZ1bmN0aW9uLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3hoci5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAgLy8gVXNlIGEgY3VzdG9tIHByb3BlcnR5IHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiBhbm90aGVyIERPTSBlbGVtZW50XG5cdCAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XG5cdCAqICAgICAgICQoJyNzdGF0dXMnKS5odG1sKCBqc29uLnN0YXR1cyApO1xuXHQgKiAgICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgIC8vIFByZS1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuXHQgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuXHQgKiAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5hYURhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdCAqICAgICAgICAganNvbi5hYURhdGFbaV0uc3VtID0ganNvbi5hYURhdGFbaV0ub25lICsganNvbi5hYURhdGFbaV0udHdvO1xuXHQgKiAgICAgICB9XG5cdCAqICAgICAgIC8vIE5vdGUgbm8gcmV0dXJuIC0gbWFuaXB1bGF0ZSB0aGUgZGF0YSBkaXJlY3RseSBpbiB0aGUgSlNPTiBvYmplY3QuXG5cdCAqICAgICB9ICk7XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBEYXRhVGFibGUgaXMgZGVzdHJveWVkIGJ5IGNhbGxpbmcgZm5EZXN0cm95XG5cdCAqIG9yIHBhc3NpbmcgdGhlIGJEZXN0cm95OnRydWUgcGFyYW1ldGVyIGluIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QuIFRoaXNcblx0ICogY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGJvdW5kIGV2ZW50cywgYWRkZWQgRE9NIG5vZGVzLCBldGMuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjZGVzdHJveS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFBhZ2UgbGVuZ3RoIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiBudW1iZXIgb2YgcmVjb3JkcyB0byBzaG93IG9uIGVhY2hcblx0ICogcGFnZSAodGhlIGxlbmd0aCkgaXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNsZW5ndGguZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqICBAcGFyYW0ge2ludGVnZXJ9IGxlbiBOZXcgbGVuZ3RoXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb2x1bW4gc2l6aW5nIGhhcyBjaGFuZ2VkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi1zaXppbmcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb2x1bW4gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tdmlzaWJpbGl0eS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7aW50fSBjb2x1bW4gQ29sdW1uIGluZGV4XG5cdCAqICBAcGFyYW0ge2Jvb2x9IHZpcyBgZmFsc2VgIGlmIGNvbHVtbiBub3cgaGlkZGVuLCBvciBgdHJ1ZWAgaWYgdmlzaWJsZVxuXHQgKi9cblxuXHRyZXR1cm4gJC5mbi5kYXRhVGFibGU7XG59KSk7XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgZHQgZnJvbSAnZGF0YXRhYmxlcy5uZXQnO1xyXG5cclxuJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuICAgICQoJyMnICsgd293cGlSb3N0ZXJBamF4LmRhdGF0YWJsZV9pZCkuRGF0YVRhYmxlKHtcclxuICAgICAgICAgICAgXCJwcm9jZXNzaW5nXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImFqYXhcIjogd293cGlSb3N0ZXJBamF4LmFqYXh1cmwsXHJcbiAgICAgICAgICAgIFwicGFnaW5nXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAvL1wibGVuZ3RoXCI6IHBhcnNlSW50KHdvd3BpUm9zdGVyQWpheC5kYXRhdGFibGVfbGVuZ3RoKSxcclxuICAgICAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICduYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICAnc29ydGFibGUnOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICdyYWNlJyxcclxuICAgICAgICAgICAgICAgICAgICAncmVuZGVyJzogZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJpY29uXCI+PGltZyBzcmM9XCIvd3AtY29udGVudC9wbHVnaW5zL3dvd3BpLWd1aWxkL2Fzc2V0cy9pY29uLycgKyBkYXRhLmljb24gKyAnXCIgYWx0PVwiJyArIGRhdGEubmFtZSArICdcIiAvPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAnc29ydGFibGUnOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAnY2xhc3MnLFxyXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXInOiBmdW5jdGlvbihkYXRhLCB0eXBlLCByb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiaWNvblwiPjxpbWcgc3JjPVwiL3dwLWNvbnRlbnQvcGx1Z2lucy93b3dwaS1ndWlsZC9hc3NldHMvaWNvbi8nICsgZGF0YS5pY29uICsgJ1wiIGFsdD1cIicgKyBkYXRhLm5hbWUgKyAnXCIgLz48L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NvcnRhYmxlJzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogJ3JvbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXInOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImljb25cIj48aW1nIHNyYz1cIi93cC1jb250ZW50L3BsdWdpbnMvd293cGktZ3VpbGQvYXNzZXRzL2ljb24vcm9sZV8nICsgZGF0YS50eXBlICsgJy5wbmdcIiBhbHQ9XCInICsgZGF0YS5uYW1lICsgJ1wiIC8+PC9kaXY+JztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdzb3J0YWJsZSc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICdsZXZlbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NvcnRhYmxlJzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAncmFuaycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NvcnRhYmxlJzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufSApOyIsIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5OyJdLCJzb3VyY2VSb290IjoiIn0=