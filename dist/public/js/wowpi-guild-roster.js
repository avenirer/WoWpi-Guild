/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/datatables.net/js/jquery.dataTables.js":
/*!*************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.22
 * Â©2008-2020 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.22
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2020 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */

/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
(function (factory) {
  "use strict";

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
      return factory($, window, document);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($, window, document, undefined) {
  "use strict";
  /**
   * DataTables is a plug-in for the jQuery Javascript library. It is a highly
   * flexible tool, based upon the foundations of progressive enhancement,
   * which will add advanced interaction controls to any HTML table. For a
   * full list of features please refer to
   * [DataTables.net](href="http://datatables.net).
   *
   * Note that the `DataTable` object is not a global variable but is aliased
   * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
   * be  accessed.
   *
   *  @class
   *  @param {object} [init={}] Configuration object for DataTables. Options
   *    are defined by {@link DataTable.defaults}
   *  @requires jQuery 1.7+
   *
   *  @example
   *    // Basic initialisation
   *    $(document).ready( function {
   *      $('#example').dataTable();
   *    } );
   *
   *  @example
   *    // Initialisation with configuration options - in this case, disable
   *    // pagination and sorting.
   *    $(document).ready( function {
   *      $('#example').dataTable( {
   *        "paginate": false,
   *        "sort": false
   *      } );
   *    } );
   */

  var DataTable = function (options) {
    /**
     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
     * return the resulting jQuery object.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     *    criterion ("applied") or all TR elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {object} jQuery object, filtered by the given selector.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Highlight every second row
     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to rows with 'Webkit' in them, add a background colour and then
     *      // remove the filter, thus highlighting the 'Webkit' rows only.
     *      oTable.fnFilter('Webkit');
     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
     *      oTable.fnFilter('');
     *    } );
     */
    this.$ = function (sSelector, oOpts) {
      return this.api(true).$(sSelector, oOpts);
    };
    /**
     * Almost identical to $ in operation, but in this case returns the data for the matched
     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
     * rather than any descendants, so the data can be obtained for the row/cell. If matching
     * rows are found, the data returned is the original data array/object that was used to
     * create the row (or a generated array if from a DOM source).
     *
     * This method is often useful in-combination with $ where both functions are given the
     * same parameters and the array indexes will match identically.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
     *    criterion ("applied") or all elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {array} Data for the matched elements. If any elements, as a result of the
     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
     *    entry in the array.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the data from the first row in the table
     *      var data = oTable._('tr:first');
     *
     *      // Do something useful with the data
     *      alert( "First cell is: "+data[0] );
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to 'Webkit' and get all data for
     *      oTable.fnFilter('Webkit');
     *      var data = oTable._('tr', {"search": "applied"});
     *
     *      // Do something with the data
     *      alert( data.length+" rows matched the search" );
     *    } );
     */


    this._ = function (sSelector, oOpts) {
      return this.api(true).rows(sSelector, oOpts).data();
    };
    /**
     * Create a DataTables Api instance, with the currently selected tables for
     * the Api's context.
     * @param {boolean} [traditional=false] Set the API instance's context to be
     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
     *   or if all tables captured in the jQuery object should be used.
     * @return {DataTables.Api}
     */


    this.api = function (traditional) {
      return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this);
    };
    /**
     * Add a single new row or multiple rows of data to the table. Please note
     * that this is suitable for client-side processing only - if you are using
     * server-side processing (i.e. "bServerSide": true), then to add data, you
     * must add it to the data source, i.e. the server-side, through an Ajax call.
     *  @param {array|object} data The data to be added to the table. This can be:
     *    <ul>
     *      <li>1D array of data - add a single row with the data provided</li>
     *      <li>2D array of arrays - add multiple rows in a single call</li>
     *      <li>object - data object when using <i>mData</i></li>
     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
     *    </ul>
     *  @param {bool} [redraw=true] redraw the table or not
     *  @returns {array} An array of integers, representing the list of indexes in
     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
     *    the table.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Global var for counter
     *    var giCount = 2;
     *
     *    $(document).ready(function() {
     *      $('#example').dataTable();
     *    } );
     *
     *    function fnClickAddRow() {
     *      $('#example').dataTable().fnAddData( [
     *        giCount+".1",
     *        giCount+".2",
     *        giCount+".3",
     *        giCount+".4" ]
     *      );
     *
     *      giCount++;
     *    }
     */


    this.fnAddData = function (data, redraw) {
      var api = this.api(true);
      /* Check if we want to add multiple rows or not */

      var rows = Array.isArray(data) && (Array.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);

      if (redraw === undefined || redraw) {
        api.draw();
      }

      return rows.flatten().toArray();
    };
    /**
     * This function will make DataTables recalculate the column sizes, based on the data
     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
     * through the sWidth parameter). This can be useful when the width of the table's
     * parent element changes (for example a window resize).
     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable( {
     *        "sScrollY": "200px",
     *        "bPaginate": false
     *      } );
     *
     *      $(window).on('resize', function () {
     *        oTable.fnAdjustColumnSizing();
     *      } );
     *    } );
     */


    this.fnAdjustColumnSizing = function (bRedraw) {
      var api = this.api(true).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;

      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      } else if (scroll.sX !== "" || scroll.sY !== "") {
        /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
        _fnScrollDraw(settings);
      }
    };
    /**
     * Quickly and simply clear a table
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
     *      oTable.fnClearTable();
     *    } );
     */


    this.fnClearTable = function (bRedraw) {
      var api = this.api(true).clear();

      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }
    };
    /**
     * The exact opposite of 'opening' a row, this function will close any rows which
     * are currently 'open'.
     *  @param {node} nTr the table row to 'close'
     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnClose = function (nTr) {
      this.api(true).row(nTr).child.hide();
    };
    /**
     * Remove a row for the table
     *  @param {mixed} target The index of the row from aoData to be deleted, or
     *    the TR element you want to delete
     *  @param {function|null} [callBack] Callback function
     *  @param {bool} [redraw=true] Redraw the table or not
     *  @returns {array} The row that was deleted
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately remove the first row
     *      oTable.fnDeleteRow( 0 );
     *    } );
     */


    this.fnDeleteRow = function (target, callback, redraw) {
      var api = this.api(true);
      var rows = api.rows(target);
      var settings = rows.settings()[0];
      var data = settings.aoData[rows[0][0]];
      rows.remove();

      if (callback) {
        callback.call(this, settings, data);
      }

      if (redraw === undefined || redraw) {
        api.draw();
      }

      return data;
    };
    /**
     * Restore the table to it's original state in the DOM by removing all of DataTables
     * enhancements, alterations to the DOM structure of the table and event listeners.
     *  @param {boolean} [remove=false] Completely remove the table from the DOM
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
     *      var oTable = $('#example').dataTable();
     *      oTable.fnDestroy();
     *    } );
     */


    this.fnDestroy = function (remove) {
      this.api(true).destroy(remove);
    };
    /**
     * Redraw the table
     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
     *      oTable.fnDraw();
     *    } );
     */


    this.fnDraw = function (complete) {
      // Note that this isn't an exact match to the old call to _fnDraw - it takes
      // into account the new data, but can hold position.
      this.api(true).draw(complete);
    };
    /**
     * Filter the input based on data
     *  @param {string} sInput String to filter the table on
     *  @param {int|null} [iColumn] Column to limit filtering to
     *  @param {bool} [bRegex=false] Treat as regular expression or not
     *  @param {bool} [bSmart=true] Perform smart filtering or not
     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sometime later - filter...
     *      oTable.fnFilter( 'test string' );
     *    } );
     */


    this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
      var api = this.api(true);

      if (iColumn === null || iColumn === undefined) {
        api.search(sInput, bRegex, bSmart, bCaseInsensitive);
      } else {
        api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
      }

      api.draw();
    };
    /**
     * Get the data for the whole table, an individual row or an individual cell based on the
     * provided parameters.
     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
     *    a TR node then the data source for the whole row will be returned. If given as a
     *    TD/TH cell node then iCol will be automatically calculated and the data for the
     *    cell returned. If given as an integer, then this is treated as the aoData internal
     *    data index for the row (see fnGetPosition) and the data for that row used.
     *  @param {int} [col] Optional column index that you want the data of.
     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
     *    returned. If mRow is defined, just data for that row, and is iCol is
     *    defined, only data for the designated cell is returned.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Row data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('tr').click( function () {
     *        var data = oTable.fnGetData( this );
     *        // ... do something with the array / object of data for the row
     *      } );
     *    } );
     *
     *  @example
     *    // Individual cell data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('td').click( function () {
     *        var sData = oTable.fnGetData( this );
     *        alert( 'The cell clicked on had the value of '+sData );
     *      } );
     *    } );
     */


    this.fnGetData = function (src, col) {
      var api = this.api(true);

      if (src !== undefined) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : '';
        return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
      }

      return api.data().toArray();
    };
    /**
     * Get an array of the TR nodes that are used in the table's body. Note that you will
     * typically want to use the '$' API method in preference to this as it is more
     * flexible.
     *  @param {int} [iRow] Optional row index for the TR element you want
     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
     *    in the table's body, or iRow is defined, just the TR element requested.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the nodes from the table
     *      var nNodes = oTable.fnGetNodes( );
     *    } );
     */


    this.fnGetNodes = function (iRow) {
      var api = this.api(true);
      return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
    };
    /**
     * Get the array indexes of a particular cell from it's DOM element
     * and column index including hidden columns
     *  @param {node} node this can either be a TR, TD or TH in the table's body
     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
     *    if given as a cell, an array of [row index, column index (visible),
     *    column index (all)] is given.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      $('#example tbody td').click( function () {
     *        // Get the position of the current data from the node
     *        var aPos = oTable.fnGetPosition( this );
     *
     *        // Get the data array for this row
     *        var aData = oTable.fnGetData( aPos[0] );
     *
     *        // Update the data array and return the value
     *        aData[ aPos[1] ] = 'clicked';
     *        this.innerHTML = 'clicked';
     *      } );
     *
     *      // Init DataTables
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnGetPosition = function (node) {
      var api = this.api(true);
      var nodeName = node.nodeName.toUpperCase();

      if (nodeName == 'TR') {
        return api.row(node).index();
      } else if (nodeName == 'TD' || nodeName == 'TH') {
        var cell = api.cell(node).index();
        return [cell.row, cell.columnVisible, cell.column];
      }

      return null;
    };
    /**
     * Check to see if a row is 'open' or not.
     *  @param {node} nTr the table row to check
     *  @returns {boolean} true if the row is currently open, false otherwise
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnIsOpen = function (nTr) {
      return this.api(true).row(nTr).child.isShown();
    };
    /**
     * This function will place a new row directly after a row which is currently
     * on display on the page, with the HTML contents that is passed into the
     * function. This can be used, for example, to ask for confirmation that a
     * particular record should be deleted.
     *  @param {node} nTr The table row to 'open'
     *  @param {string|node|jQuery} mHtml The HTML to put into the row
     *  @param {string} sClass Class to give the new TD cell
     *  @returns {node} The row opened. Note that if the table row passed in as the
     *    first parameter, is not found in the table, this method will silently
     *    return.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnOpen = function (nTr, mHtml, sClass) {
      return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
    };
    /**
     * Change the pagination - provides the internal logic for pagination in a simple API
     * function. With this function you can have a DataTables table go to the next,
     * previous, first or last pages.
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer), note that page 0 is the first page.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnPageChange( 'next' );
     *    } );
     */


    this.fnPageChange = function (mAction, bRedraw) {
      var api = this.api(true).page(mAction);

      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      }
    };
    /**
     * Show a particular column
     *  @param {int} iCol The column whose display should be changed
     *  @param {bool} bShow Show (true) or hide (false) the column
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Hide the second column after initialisation
     *      oTable.fnSetColumnVis( 1, false );
     *    } );
     */


    this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
      var api = this.api(true).column(iCol).visible(bShow);

      if (bRedraw === undefined || bRedraw) {
        api.columns.adjust().draw();
      }
    };
    /**
     * Get the settings for a particular table for external manipulation
     *  @returns {object} DataTables settings object. See
     *    {@link DataTable.models.oSettings}
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      var oSettings = oTable.fnSettings();
     *
     *      // Show an example parameter from the settings
     *      alert( oSettings._iDisplayStart );
     *    } );
     */


    this.fnSettings = function () {
      return _fnSettingsFromNode(this[_ext.iApiIndex]);
    };
    /**
     * Sort the table by a particular column
     *  @param {int} iCol the data index to sort on. Note that this will not match the
     *    'display index' if you have hidden data entries
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort immediately with columns 0 and 1
     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
     *    } );
     */


    this.fnSort = function (aaSort) {
      this.api(true).order(aaSort).draw();
    };
    /**
     * Attach a sort listener to an element for a given column
     *  @param {node} nNode the element to attach the sort listener to
     *  @param {int} iColumn the column that a click on this node will sort on
     *  @param {function} [fnCallback] callback function when sort is run
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort on column 1, when 'sorter' is clicked on
     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
     *    } );
     */


    this.fnSortListener = function (nNode, iColumn, fnCallback) {
      this.api(true).order.listener(nNode, iColumn, fnCallback);
    };
    /**
     * Update a table cell or row - this method will accept either a single value to
     * update the cell with, an array of values with one element for each column or
     * an object in the same format as the original data source. The function is
     * self-referencing in order to make the multi column updates easier.
     *  @param {object|array|string} mData Data to update the cell/row with
     *  @param {node|int} mRow TR element you want to update or the aoData index
     *  @param {int} [iColumn] The column to update, give as null or undefined to
     *    update a whole row.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @param {bool} [bAction=true] Perform pre-draw actions or not
     *  @returns {int} 0 on success, 1 on error
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
     *    } );
     */


    this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
      var api = this.api(true);

      if (iColumn === undefined || iColumn === null) {
        api.row(mRow).data(mData);
      } else {
        api.cell(mRow, iColumn).data(mData);
      }

      if (bAction === undefined || bAction) {
        api.columns.adjust();
      }

      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }

      return 0;
    };
    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @method
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
     *    } );
     */


    this.fnVersionCheck = _ext.fnVersionCheck;

    var _that = this;

    var emptyInit = options === undefined;
    var len = this.length;

    if (emptyInit) {
      options = {};
    }

    this.oApi = this.internal = _ext.internal; // Extend with old style plug-in API methods

    for (var fn in DataTable.ext.internal) {
      if (fn) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }

    this.each(function () {
      // For each initialisation we want to give it a clean initialisation
      // object that can be bashed around
      var o = {};
      var oInit = len > 1 ? // optimisation for single table case
      _fnExtend(o, options, true) : options;
      /*global oInit,_that,emptyInit*/

      var i = 0,
          iLen,
          j,
          jLen,
          k,
          kLen;
      var sId = this.getAttribute('id');
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $(this);
      /* Sanity check */

      if (this.nodeName.toLowerCase() != 'table') {
        _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);

        return;
      }
      /* Backwards compatibility for the defaults */


      _fnCompatOpts(defaults);

      _fnCompatCols(defaults.column);
      /* Convert the camel-case defaults to Hungarian */


      _fnCamelToHungarian(defaults, defaults, true);

      _fnCamelToHungarian(defaults.column, defaults.column, true);
      /* Setting up the initialisation object */


      _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()), true);
      /* Check to see if we are re-initialising a table */


      var allSettings = DataTable.settings;

      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        /* Base check on table node */

        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            s.oInstance.fnDestroy();
            break;
          } else {
            _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);

            return;
          }
        }
        /* If the element we are initialising has the same ID as a table which was previously
         * initialised, but the table nodes don't match (from before) then we destroy the old
         * instance by simply deleting it. This is under the assumption that the table has been
         * destroyed by other methods. Anyone using non-id selectors will need to do this manually
         */


        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      /* Ensure the table has an ID - required for accessibility */


      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      /* Create the settings object for this table and set some of the default parameters */


      var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId
      });
      oSettings.nTable = this;
      oSettings.oApi = _that.internal;
      oSettings.oInit = oInit;
      allSettings.push(oSettings); // Need to add the instance after the instance after the settings object has been added
      // to the settings array, so we can self reference the table instance if more than one

      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable(); // Backwards compatibility, before we apply all the defaults

      _fnCompatOpts(oInit);

      _fnLanguageCompat(oInit.oLanguage); // If the length menu is given, but the init display length is not, use the length menu


      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      } // Apply the defaults and init options to make a single init object will all
      // options defined from defaults and instance options.


      oInit = _fnExtend($.extend(true, {}, defaults), oInit); // Map the initialisation options onto the settings object

      _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);

      _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"], // backwards compat
      ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"]]);

      _fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);

      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      /* Callback functions which are array driven */


      _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');

      _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');

      _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');

      _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');

      _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');

      _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');

      _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');

      _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      /* Browser support detection */

      _fnBrowserDetect(oSettings);

      var oClasses = oSettings.oClasses;
      $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.sTable);

      if (oSettings.iInitDisplayStart === undefined) {
        /* Display start point, taking into account the save saving */
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }

      if (oInit.iDeferLoading !== null) {
        oSettings.bDeferLoading = true;
        var tmp = Array.isArray(oInit.iDeferLoading);
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      /* Language definitions */


      var oLanguage = oSettings.oLanguage;
      $.extend(true, oLanguage, oInit.oLanguage);

      if (oLanguage.sUrl) {
        /* Get the language definitions from a file - because this Ajax call makes the language
         * get async to the remainder of this function we use bInitHandedOff to indicate that
         * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
         */
        $.ajax({
          dataType: 'json',
          url: oLanguage.sUrl,
          success: function (json) {
            _fnLanguageCompat(json);

            _fnCamelToHungarian(defaults.oLanguage, json);

            $.extend(true, oLanguage, json);

            _fnInitialise(oSettings);
          },
          error: function () {
            // Error occurred loading language file, continue on as best we can
            _fnInitialise(oSettings);
          }
        });
        bInitHandedOff = true;
      }
      /*
       * Stripes
       */


      if (oInit.asStripeClasses === null) {
        oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
      }
      /* Remove row stripe classes if they are already on the table row */


      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children('tbody').find('tr').eq(0);

      if ($.inArray(true, $.map(stripeClasses, function (el, i) {
        return rowOne.hasClass(el);
      })) !== -1) {
        $('tbody tr', this).removeClass(stripeClasses.join(' '));
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      /*
       * Columns
       * See if we should load columns automatically or use defined ones
       */


      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName('thead');

      if (nThead.length !== 0) {
        _fnDetectHeader(oSettings.aoHeader, nThead[0]);

        anThs = _fnGetUniqueThs(oSettings);
      }
      /* If not given a column array, generate one with nulls */


      if (oInit.aoColumns === null) {
        aoColumnsInit = [];

        for (i = 0, iLen = anThs.length; i < iLen; i++) {
          aoColumnsInit.push(null);
        }
      } else {
        aoColumnsInit = oInit.aoColumns;
      }
      /* Add the columns */


      for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
        _fnAddColumn(oSettings, anThs ? anThs[i] : null);
      }
      /* Apply the column definitions */


      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      /* HTML5 attribute detection - build an mData object automatically if the
       * attributes are found
       */


      if (rowOne.length) {
        var a = function (cell, name) {
          return cell.getAttribute('data-' + name) !== null ? name : null;
        };

        $(rowOne[0]).children('th, td').each(function (i, cell) {
          var col = oSettings.aoColumns[i];

          if (col.mData === i) {
            var sort = a(cell, 'sort') || a(cell, 'order');
            var filter = a(cell, 'filter') || a(cell, 'search');

            if (sort !== null || filter !== null) {
              col.mData = {
                _: i + '.display',
                sort: sort !== null ? i + '.@data-' + sort : undefined,
                type: sort !== null ? i + '.@data-' + sort : undefined,
                filter: filter !== null ? i + '.@data-' + filter : undefined
              };

              _fnColumnOptions(oSettings, i);
            }
          }
        });
      }

      var features = oSettings.oFeatures;

      var loadedInit = function () {
        /*
         * Sorting
         * @todo For modularisation (1.11) this needs to do into a sort start up handler
         */
        // If aaSorting is not defined, then we use the first indicator in asSorting
        // in case that has been altered, so the default sort reflects that option
        if (oInit.aaSorting === undefined) {
          var sorting = oSettings.aaSorting;

          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        /* Do a first pass on the sorting classes (allows any size changes to be taken into
         * account, and also will apply sorting disabled classes if disabled
         */


        _fnSortingClasses(oSettings);

        if (features.bSort) {
          _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);

              var sortedColumns = {};
              $.each(aSort, function (i, val) {
                sortedColumns[val.src] = val.dir;
              });

              _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);

              _fnSortAria(oSettings);
            }
          });
        }

        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
          if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, 'sc');
        /*
         * Final init
         * Cache the header, body and footer as required, creating them if needed
         */
        // Work around for Webkit bug 83867 - store the caption-side before removing from doc


        var captions = $this.children('caption').each(function () {
          this._captionSide = $(this).css('caption-side');
        });
        var thead = $this.children('thead');

        if (thead.length === 0) {
          thead = $('<thead/>').appendTo($this);
        }

        oSettings.nTHead = thead[0];
        var tbody = $this.children('tbody');

        if (tbody.length === 0) {
          tbody = $('<tbody/>').appendTo($this);
        }

        oSettings.nTBody = tbody[0];
        var tfoot = $this.children('tfoot');

        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
          // If we are a scrolling table, and no footer has been given, then we need to create
          // a tfoot element for the caption element to be appended to
          tfoot = $('<tfoot/>').appendTo($this);
        }

        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];

          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        /* Check if there is data passing into the constructor */


        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData(oSettings, oInit.aaData[i]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
          /* Grab the data from the page - only do this when deferred loading or no Ajax
           * source since there is no point in reading the DOM data if we are then going
           * to replace it with Ajax data
           */
          _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
        }
        /* Copy the data index array */


        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        /* Initialisation complete - table can be drawn */

        oSettings.bInitialised = true;
        /* Check if we need to initialise the table (it might not have been handed off to the
         * language processor)
         */

        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      };
      /* Must be done after everything which can be overridden by the state saving! */


      if (oInit.bStateSave) {
        features.bStateSave = true;

        _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');

        _fnLoadState(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  /*
   * It is useful to have variables which are scoped locally so only the
   * DataTables functions can access them and they don't leak into global space.
   * At the same time these functions are often useful over multiple files in the
   * core and API, so we list, or at least document, all variables which are used
   * by DataTables as private variables here. This also ensures that there is no
   * clashing of variable names and that they can easily referenced for reuse.
   */
  // Defined else where
  //  _selector_run
  //  _selector_opts
  //  _selector_first
  //  _selector_row_indexes


  var _ext; // DataTable.ext


  var _Api; // DataTable.Api


  var _api_register; // DataTable.Api.register


  var _api_registerPlural; // DataTable.Api.registerPlural


  var _re_dic = {};
  var _re_new_lines = /[\r\n\u2028]/g;
  var _re_html = /<.*?>/g; // This is not strict ISO8601 - Date.parse() is quite lax, although
  // implementations differ between browsers.

  var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/; // Escape regular expression special characters

  var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g'); // http://en.wikipedia.org/wiki/Foreign_exchange_market
  // - \u20BD - Russian ruble.
  // - \u20a9 - South Korean Won
  // - \u20BA - Turkish Lira
  // - \u20B9 - Indian Rupee
  // - R - Brazil (R$) and South Africa
  // - fr - Swiss Franc
  // - kr - Swedish krona, Norwegian krone and Danish krone
  // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
  // - É - Bitcoin
  // - Î - Ethereum
  //   standards as thousands separators.


  var _re_formatted_numeric = /['\u00A0,$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfkÉÎ]/gi;

  var _empty = function (d) {
    return !d || d === true || d === '-' ? true : false;
  };

  var _intVal = function (s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  }; // Convert from a formatted number with characters other than `.` as the
  // decimal place, to a Javascript number


  var _numToDecimal = function (num, decimalPoint) {
    // Cache created regular expressions for speed as this function is called often
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
    }

    return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
  };

  var _isNumber = function (d, decimalPoint, formatted) {
    var strType = typeof d === 'string'; // If empty return immediately so there must be a number if it is a
    // formatted string (this stops the string "k", or "kr", etc being detected
    // as a formatted number for currency

    if (_empty(d)) {
      return true;
    }

    if (decimalPoint && strType) {
      d = _numToDecimal(d, decimalPoint);
    }

    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric, '');
    }

    return !isNaN(parseFloat(d)) && isFinite(d);
  }; // A string without HTML in it can be considered to be HTML still


  var _isHtml = function (d) {
    return _empty(d) || typeof d === 'string';
  };

  var _htmlNumeric = function (d, decimalPoint, formatted) {
    if (_empty(d)) {
      return true;
    }

    var html = _isHtml(d);

    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
  };

  var _pluck = function (a, prop, prop2) {
    var out = [];
    var i = 0,
        ien = a.length; // Could have the test in the loop for slightly smaller code, but speed
    // is essential here

    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }

    return out;
  }; // Basically the same as _pluck, but rather than looping over `a` we use `order`
  // as the indexes to pick from `a`


  var _pluck_order = function (a, order, prop, prop2) {
    var out = [];
    var i = 0,
        ien = order.length; // Could have the test in the loop for slightly smaller code, but speed
    // is essential here

    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        out.push(a[order[i]][prop]);
      }
    }

    return out;
  };

  var _range = function (len, start) {
    var out = [];
    var end;

    if (start === undefined) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }

    for (var i = start; i < end; i++) {
      out.push(i);
    }

    return out;
  };

  var _removeEmpty = function (a) {
    var out = [];

    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        // careful - will remove all falsy values!
        out.push(a[i]);
      }
    }

    return out;
  };

  var _stripHtml = function (d) {
    return d.replace(_re_html, '');
  };
  /**
   * Determine if all values in the array are unique. This means we can short
   * cut the _unique method at the cost of a single loop. A sorted array is used
   * to easily check the values.
   *
   * @param  {array} src Source array
   * @return {boolean} true if all unique, false otherwise
   * @ignore
   */


  var _areAllUnique = function (src) {
    if (src.length < 2) {
      return true;
    }

    var sorted = src.slice().sort();
    var last = sorted[0];

    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }

      last = sorted[i];
    }

    return true;
  };
  /**
   * Find the unique elements in a source array.
   *
   * @param  {array} src Source array
   * @return {array} Array of unique items
   * @ignore
   */


  var _unique = function (src) {
    if (_areAllUnique(src)) {
      return src.slice();
    } // A faster unique method is to use object keys to identify used values,
    // but this doesn't work with arrays or objects, which we must also
    // consider. See jsperf.com/compare-array-unique-versions/4 for more
    // information.


    var out = [],
        val,
        i,
        ien = src.length,
        j,
        k = 0;

    again: for (i = 0; i < ien; i++) {
      val = src[i];

      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }

      out.push(val);
      k++;
    }

    return out;
  }; // Surprisingly this is faster than [].concat.apply
  // https://jsperf.com/flatten-an-array-loop-vs-reduce/2


  var _flatten = function (out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten(out, val[i]);
      }
    } else {
      out.push(val);
    }

    return out;
  }; // Array.isArray polyfill.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray


  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  } // .trim() polyfill
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim


  if (!String.prototype.trim) {
    String.prototype.trim = function () {
      return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
  }
  /**
   * DataTables utility methods
   * 
   * This namespace provides helper methods that DataTables uses internally to
   * create a DataTable, but which are not exclusively used only for DataTables.
   * These methods can be used by extension authors to save the duplication of
   * code.
   *
   *  @namespace
   */


  DataTable.util = {
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function (fn, freq) {
      var frequency = freq !== undefined ? freq : 200,
          last,
          timer;
      return function () {
        var that = this,
            now = +new Date(),
            args = arguments;

        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function () {
            last = undefined;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },

    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function (val) {
      return val.replace(_re_escape_regex, '\\$1');
    }
  };
  /**
   * Create a mapping object that allows camel case parameters to be looked up
   * for their Hungarian counterparts. The mapping is stored in a private
   * parameter called `_hungarianMap` which can be accessed on the source object.
   *  @param {object} o
   *  @memberof DataTable#oApi
   */

  function _fnHungarianMap(o) {
    var hungarian = 'a aa ai ao as b fn i m o s ',
        match,
        newKey,
        map = {};
    $.each(o, function (key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);

      if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map[newKey] = key;

        if (match[1] === 'o') {
          _fnHungarianMap(o[key]);
        }
      }
    });
    o._hungarianMap = map;
  }
  /**
   * Convert from camel case parameters to Hungarian, based on a Hungarian map
   * created by _fnHungarianMap.
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   *  @memberof DataTable#oApi
   */


  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }

    var hungarianKey;
    $.each(user, function (key, val) {
      hungarianKey = src._hungarianMap[key];

      if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
        // For objects, we need to buzz down into the object to copy parameters
        if (hungarianKey.charAt(0) === 'o') {
          // Copy the camelCase options over to the hungarian
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }

          $.extend(true, user[hungarianKey], user[key]);

          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  /**
   * Language compatibility - when certain options are given, and others aren't, we
   * need to duplicate the values over, in order to provide backwards compatibility
   * with older language files.
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnLanguageCompat(lang) {
    // Note the use of the Hungarian notation for the parameters in this method as
    // this is called after the mapping of camelCase to Hungarian
    var defaults = DataTable.defaults.oLanguage; // Default mapping

    var defaultDecimal = defaults.sDecimal;

    if (defaultDecimal) {
      _addNumericSort(defaultDecimal);
    }

    if (lang) {
      var zeroRecords = lang.sZeroRecords; // Backwards compatibility - if there is no sEmptyTable given, then use the same as
      // sZeroRecords - assuming that is given.

      if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
        _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
      } // Likewise with loading records


      if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
        _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
      } // Old parameter name of the thousands separator mapped onto the new


      if (lang.sInfoThousands) {
        lang.sThousands = lang.sInfoThousands;
      }

      var decimal = lang.sDecimal;

      if (decimal && defaultDecimal !== decimal) {
        _addNumericSort(decimal);
      }
    }
  }
  /**
   * Map one parameter onto another
   *  @param {object} o Object to map
   *  @param {*} knew The new parameter name
   *  @param {*} old The old parameter name
   */


  var _fnCompatMap = function (o, knew, old) {
    if (o[knew] !== undefined) {
      o[old] = o[knew];
    }
  };
  /**
   * Provide backwards compatibility for the main DT options. Note that the new
   * options are mapped onto the old parameters, so this is an external interface
   * change only.
   *  @param {object} init Object to map
   */


  function _fnCompatOpts(init) {
    _fnCompatMap(init, 'ordering', 'bSort');

    _fnCompatMap(init, 'orderMulti', 'bSortMulti');

    _fnCompatMap(init, 'orderClasses', 'bSortClasses');

    _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');

    _fnCompatMap(init, 'order', 'aaSorting');

    _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');

    _fnCompatMap(init, 'paging', 'bPaginate');

    _fnCompatMap(init, 'pagingType', 'sPaginationType');

    _fnCompatMap(init, 'pageLength', 'iDisplayLength');

    _fnCompatMap(init, 'searching', 'bFilter'); // Boolean initialisation of x-scrolling


    if (typeof init.sScrollX === 'boolean') {
      init.sScrollX = init.sScrollX ? '100%' : '';
    }

    if (typeof init.scrollX === 'boolean') {
      init.scrollX = init.scrollX ? '100%' : '';
    } // Column search objects are in an array, so it needs to be converted
    // element by element


    var searchCols = init.aoSearchCols;

    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
        }
      }
    }
  }
  /**
   * Provide backwards compatibility for column options. Note that the new options
   * are mapped onto the old parameters, so this is an external interface change
   * only.
   *  @param {object} init Object to map
   */


  function _fnCompatCols(init) {
    _fnCompatMap(init, 'orderable', 'bSortable');

    _fnCompatMap(init, 'orderData', 'aDataSort');

    _fnCompatMap(init, 'orderSequence', 'asSorting');

    _fnCompatMap(init, 'orderDataType', 'sortDataType'); // orderData can be given as an integer


    var dataSort = init.aDataSort;

    if (typeof dataSort === 'number' && !Array.isArray(dataSort)) {
      init.aDataSort = [dataSort];
    }
  }
  /**
   * Browser feature detection for capabilities, quirks
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnBrowserDetect(settings) {
    // We don't need to do this every time DataTables is constructed, the values
    // calculated are specific to the browser and OS configuration which we
    // don't expect to change between initialisations
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser; // Scrolling feature / quirks detection

      var n = $('<div/>').css({
        position: 'fixed',
        top: 0,
        left: $(window).scrollLeft() * -1,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: 'hidden'
      }).append($('<div/>').css({
        position: 'absolute',
        top: 1,
        left: 1,
        width: 100,
        overflow: 'scroll'
      }).append($('<div/>').css({
        width: '100%',
        height: 10
      }))).appendTo('body');
      var outer = n.children();
      var inner = outer.children(); // Numbers below, in order, are:
      // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
      //
      // IE6 XP:                           100 100 100  83
      // IE7 Vista:                        100 100 100  83
      // IE 8+ Windows:                     83  83 100  83
      // Evergreen Windows:                 83  83 100  83
      // Evergreen Mac with scrollbars:     85  85 100  85
      // Evergreen Mac without scrollbars: 100 100 100 100
      // Get scrollbar width

      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth; // IE6/7 will oversize a width 100% element inside a scrolling element, to
      // include the width of the scrollbar, while other browsers ensure the inner
      // element is contained without forcing scrolling

      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100; // In rtl text layout, some browsers (most, but not all) will place the
      // scrollbar on the left, rather than the right.

      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1; // IE8- don't provide height and width for getBoundingClientRect

      browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
      n.remove();
    }

    $.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  /**
   * Array.prototype reduce[Right] method, used for browsers which don't support
   * JS 1.6. Done this way to reduce code size, since we iterate either way
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnReduce(that, fn, init, start, end, inc) {
    var i = start,
        value,
        isSet = false;

    if (init !== undefined) {
      value = init;
      isSet = true;
    }

    while (i !== end) {
      if (!that.hasOwnProperty(i)) {
        continue;
      }

      value = isSet ? fn(value, that[i], i, that) : that[i];
      isSet = true;
      i += inc;
    }

    return value;
  }
  /**
   * Add a column to the list used for the table with default values
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nTh The th element for this column
   *  @memberof DataTable#oApi
   */


  function _fnAddColumn(oSettings, nTh) {
    // Add column to aoColumns array
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement('th'),
      "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    });
    oSettings.aoColumns.push(oCol); // Add search object for column specific search. Note that the `searchCols[ iCol ]`
    // passed into extend can be undefined. This allows the user to give a default
    // with only some of the parameters defined, and also not give a default

    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]); // Use the default column options function to initialise classes etc

    _fnColumnOptions(oSettings, iCol, $(nTh).data());
  }
  /**
   * Apply options for a column
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iCol column index to consider
   *  @param {object} oOptions object with sType, bVisible and bSearchable etc
   *  @memberof DataTable#oApi
   */


  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    var oClasses = oSettings.oClasses;
    var th = $(oCol.nTh); // Try to get width information from the DOM. We can't get it from CSS
    // as we'd need to parse the CSS stylesheet. `width` option can override

    if (!oCol.sWidthOrig) {
      // Width attribute
      oCol.sWidthOrig = th.attr('width') || null; // Style attribute

      var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);

      if (t) {
        oCol.sWidthOrig = t[1];
      }
    }
    /* User specified column options */


    if (oOptions !== undefined && oOptions !== null) {
      // Backwards compatibility
      _fnCompatCols(oOptions); // Map camel case parameters to their Hungarian counterparts


      _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
      /* Backwards compatibility for mDataProp */


      if (oOptions.mDataProp !== undefined && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }

      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      } // `class` is a reserved word in Javascript, so we need to provide
      // the ability to use a valid name for the camel case input


      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }

      if (oOptions.sClass) {
        th.addClass(oOptions.sClass);
      }

      $.extend(oCol, oOptions);

      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      /* iDataSort to be applied (backwards compatibility), but aDataSort will take
       * priority if defined
       */


      if (oOptions.iDataSort !== undefined) {
        oCol.aDataSort = [oOptions.iDataSort];
      }

      _fnMap(oCol, oOptions, "aDataSort");
    }
    /* Cache the data get and set functions for speed */


    var mDataSrc = oCol.mData;

    var mData = _fnGetObjectDataFn(mDataSrc);

    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

    var attrTest = function (src) {
      return typeof src === 'string' && src.indexOf('@') !== -1;
    };

    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;

    oCol.fnGetData = function (rowData, type, meta) {
      var innerData = mData(rowData, type, undefined, meta);
      return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
    };

    oCol.fnSetData = function (rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    }; // Indicate if DataTables should read DOM data as an object or array
    // Used in _fnGetRowElements


    if (typeof mDataSrc !== 'number') {
      oSettings._rowReadObject = true;
    }
    /* Feature sorting overrides column specific when off */


    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
      th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
    }
    /* Check that the class assignment is correct for sorting */


    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;

    if (!oCol.bSortable || !bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    } else if (bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    } else if (!bAsc && bDesc) {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    } else {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }
  /**
   * Adjust the table column widths for new data. Note: you would probably want to
   * do a redraw after calling this function!
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnAdjustColumnSizing(settings) {
    /* Not interested in doing column width calculation if auto-width is disabled */
    if (settings.oFeatures.bAutoWidth !== false) {
      var columns = settings.aoColumns;

      _fnCalculateColumnWidths(settings);

      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }

    var scroll = settings.oScroll;

    if (scroll.sY !== '' || scroll.sX !== '') {
      _fnScrollDraw(settings);
    }

    _fnCallbackFire(settings, null, 'column-sizing', [settings]);
  }
  /**
   * Covert the index of a visible column to the index in the data array (take account
   * of hidden columns)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iMatch Visible column index to lookup
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */


  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, 'bVisible');

    return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
  }
  /**
   * Covert the index of an index in the data array and convert it to the visible
   *   column index (take account of hidden columns)
   *  @param {int} iMatch Column index to lookup
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */


  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, 'bVisible');

    var iPos = $.inArray(iMatch, aiVis);
    return iPos !== -1 ? iPos : null;
  }
  /**
   * Get the number of visible columns
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the number of visible columns
   *  @memberof DataTable#oApi
   */


  function _fnVisbleColumns(oSettings) {
    var vis = 0; // No reduce in IE8, use a loop for now

    $.each(oSettings.aoColumns, function (i, col) {
      if (col.bVisible && $(col.nTh).css('display') !== 'none') {
        vis++;
      }
    });
    return vis;
  }
  /**
   * Get an array of column indexes that match a given property
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sParam Parameter in aoColumns to look for - typically
   *    bVisible or bSearchable
   *  @returns {array} Array of indexes with matched properties
   *  @memberof DataTable#oApi
   */


  function _fnGetColumns(oSettings, sParam) {
    var a = [];
    $.map(oSettings.aoColumns, function (val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  /**
   * Calculate the 'type' of a column
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache; // For each column, spin over the 

    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];

      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            // Use a cache array so we only need to get the type data
            // from the formatter once (when using multiple detectors)
            if (cache[k] === undefined) {
              cache[k] = _fnGetCellData(settings, k, i, 'type');
            }

            detectedType = types[j](cache[k], settings); // If null, then this type can't apply to this column, so
            // rather than testing all cells, break out. There is an
            // exception for the last type which is `html`. We need to
            // scan all rows since it is possible to mix string and HTML
            // types

            if (!detectedType && j !== types.length - 1) {
              break;
            } // Only a single match is needed for html type since it is
            // bottom of the pile and very similar to string


            if (detectedType === 'html') {
              break;
            }
          } // Type is valid for all data points in the column - use this
          // type


          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        } // Fall back - if no type was detected, always use string


        if (!col.sType) {
          col.sType = 'string';
        }
      }
    }
  }
  /**
   * Take the column definitions and static columns arrays and calculate how
   * they relate to column indexes. The callback function will then apply the
   * definition found for a column to a suitable configuration object.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
   *  @param {array} aoCols The aoColumns array that defines columns individually
   *  @param {function} fn Callback function - takes two parameters, the calculated
   *    column index and the definition for that column.
   *  @memberof DataTable#oApi
   */


  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns; // Column definitions with aTargets

    if (aoColDefs) {
      /* Loop over the definitions array - loop in reverse so first instance has priority */
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        /* Each definition can target multiple columns, as it is an array */

        var aTargets = def.targets !== undefined ? def.targets : def.aTargets;

        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }

        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
            /* Add columns that we don't yet know about */
            while (columns.length <= aTargets[j]) {
              _fnAddColumn(oSettings);
            }
            /* Integer, basic index */


            fn(aTargets[j], def);
          } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
            /* Negative integer, right to left column counting */
            fn(columns.length + aTargets[j], def);
          } else if (typeof aTargets[j] === 'string') {
            /* Class name matching on TH element */
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
                fn(k, def);
              }
            }
          }
        }
      }
    } // Statically defined columns array


    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  /**
   * Add a data array to the table, creating DOM node etc. This is the parallel to
   * _fnGatherData, but for adding rows from a Javascript source, rather than a
   * DOM source.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aData data array to be added
   *  @param {node} [nTr] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
   *  @memberof DataTable#oApi
   */


  function _fnAddData(oSettings, aDataIn, nTr, anTds) {
    /* Create the object for storing information about this new row */
    var iRow = oSettings.aoData.length;
    var oData = $.extend(true, {}, DataTable.models.oRow, {
      src: nTr ? 'dom' : 'data',
      idx: iRow
    });
    oData._aData = aDataIn;
    oSettings.aoData.push(oData);
    /* Create the cells */

    var nTd, sThisType;
    var columns = oSettings.aoColumns; // Invalidate the column types as the new data needs to be revalidated

    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    /* Add to the display array */


    oSettings.aiDisplayMaster.push(iRow);
    var id = oSettings.rowIdFn(aDataIn);

    if (id !== undefined) {
      oSettings.aIds[id] = oData;
    }
    /* Create the DOM information, or register it if already present */


    if (nTr || !oSettings.oFeatures.bDeferRender) {
      _fnCreateTr(oSettings, iRow, nTr, anTds);
    }

    return iRow;
  }
  /**
   * Add one or more TR elements to the table. Generally we'd expect to
   * use this for reading data from a DOM sourced table, but it could be
   * used for an TR element. Note that if a TR is given, it is used (i.e.
   * it is not cloned).
   *  @param {object} settings dataTables settings object
   *  @param {array|node|jQuery} trs The TR element(s) to add to the table
   *  @returns {array} Array of indexes for the added rows
   *  @memberof DataTable#oApi
   */


  function _fnAddTr(settings, trs) {
    var row; // Allow an individual node to be passed in

    if (!(trs instanceof $)) {
      trs = $(trs);
    }

    return trs.map(function (i, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  /**
   * Take a TR element and convert it to an index in aoData
   *  @param {object} oSettings dataTables settings object
   *  @param {node} n the TR element to find
   *  @returns {int} index if the node is found, null if not
   *  @memberof DataTable#oApi
   */


  function _fnNodeToDataIndex(oSettings, n) {
    return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
  }
  /**
   * Take a TD element and convert it into a column data index (not the visible index)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow The row number the TD/TH can be found in
   *  @param {node} n The TD/TH element to find
   *  @returns {int} index if the node is found, -1 if not
   *  @memberof DataTable#oApi
   */


  function _fnNodeToColumnIndex(oSettings, iRow, n) {
    return $.inArray(n, oSettings.aoData[iRow].anCells);
  }
  /**
   * Get the data for a given cell from the internal cache, taking into account data mapping
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
   *  @returns {*} Cell data
   *  @memberof DataTable#oApi
   */


  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings: settings,
      row: rowIdx,
      col: colIdx
    });

    if (cellData === undefined) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);

        settings.iDrawError = draw;
      }

      return defaultContent;
    } // When the data source is null and a specific data type is requested (i.e.
    // not the original data), we can use default column data


    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
      cellData = defaultContent;
    } else if (typeof cellData === 'function') {
      // If the data source is a function, then we run it and use the return,
      // executing in the scope of the data object (for instances)
      return cellData.call(rowData);
    }

    if (cellData === null && type == 'display') {
      return '';
    }

    return cellData;
  }
  /**
   * Set the value for a specific cell, into the internal data cache
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {*} val Value to set
   *  @memberof DataTable#oApi
   */


  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings: settings,
      row: rowIdx,
      col: colIdx
    });
  } // Private variable that is used to match action syntax in the data property object


  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  /**
   * Split string on periods, taking into account escaped periods
   * @param  {string} str String to split
   * @return {array} Split string
   */

  function _fnSplitObjNotation(str) {
    return $.map(str.match(/(\\.|[^\.])+/g) || [''], function (s) {
      return s.replace(/\\\./g, '.');
    });
  }
  /**
   * Return a function that can be used to get data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data get function
   *  @memberof DataTable#oApi
   */


  function _fnGetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      /* Build an object of get functions, and wrap them in a single call */
      var o = {};
      $.each(mSource, function (key, val) {
        if (val) {
          o[key] = _fnGetObjectDataFn(val);
        }
      });
      return function (data, type, row, meta) {
        var t = o[type] || o._;
        return t !== undefined ? t(data, type, row, meta) : data;
      };
    } else if (mSource === null) {
      /* Give an empty string for rendering / sorting etc */
      return function (data) {
        // type, row and meta also passed, but not used
        return data;
      };
    } else if (typeof mSource === 'function') {
      return function (data, type, row, meta) {
        return mSource(data, type, row, meta);
      };
    } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
      /* If there is a . in the source string then the data source is in a
       * nested object so we loop over the data for each level to get the next
       * level down. On each loop we test for undefined, and if found immediately
       * return. This allows entire objects to be missing and sDefaultContent to
       * be used if defined, rather than throwing an error
       */
      var fetchData = function (data, type, src) {
        var arrayNotation, funcNotation, out, innerSrc;

        if (src !== "") {
          var a = _fnSplitObjNotation(src);

          for (var i = 0, iLen = a.length; i < iLen; i++) {
            // Check if we are dealing with special notation
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);

            if (arrayNotation) {
              // Array notation
              a[i] = a[i].replace(__reArray, ''); // Condition allows simply [] to be passed in

              if (a[i] !== "") {
                data = data[a[i]];
              }

              out = []; // Get the remainder of the nested object to get

              a.splice(0, i + 1);
              innerSrc = a.join('.'); // Traverse each entry in the array getting the properties requested

              if (Array.isArray(data)) {
                for (var j = 0, jLen = data.length; j < jLen; j++) {
                  out.push(fetchData(data[j], type, innerSrc));
                }
              } // If a string is given in between the array notation indicators, that
              // is used to join the strings together, otherwise an array is returned


              var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
              data = join === "" ? out : out.join(join); // The inner call to fetchData has already traversed through the remainder
              // of the source requested, so we exit from the loop

              break;
            } else if (funcNotation) {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[a[i]]();
              continue;
            }

            if (data === null || data[a[i]] === undefined) {
              return undefined;
            }

            data = data[a[i]];
          }
        }

        return data;
      };

      return function (data, type) {
        // row and meta also passed, but not used
        return fetchData(data, type, mSource);
      };
    } else {
      /* Array or flat object mapping */
      return function (data, type) {
        // row and meta also passed, but not used
        return data[mSource];
      };
    }
  }
  /**
   * Return a function that can be used to set data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data set function
   *  @memberof DataTable#oApi
   */


  function _fnSetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      /* Unlike get, only the underscore (global) option is used for for
       * setting data since we don't know the type here. This is why an object
       * option is not documented for `mData` (which is read/write), but it is
       * for `mRender` which is read only.
       */
      return _fnSetObjectDataFn(mSource._);
    } else if (mSource === null) {
      /* Nothing to do when the data source is null */
      return function () {};
    } else if (typeof mSource === 'function') {
      return function (data, val, meta) {
        mSource(data, 'set', val, meta);
      };
    } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
      /* Like the get, we need to get data from a nested object */
      var setData = function (data, val, src) {
        var a = _fnSplitObjNotation(src),
            b;

        var aLast = a[a.length - 1];
        var arrayNotation, funcNotation, o, innerSrc;

        for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
          // Protect against prototype pollution
          if (a[i] === '__proto__') {
            throw new Error('Cannot set prototype values');
          } // Check if we are dealing with an array notation request


          arrayNotation = a[i].match(__reArray);
          funcNotation = a[i].match(__reFn);

          if (arrayNotation) {
            a[i] = a[i].replace(__reArray, '');
            data[a[i]] = []; // Get the remainder of the nested object to set so we can recurse

            b = a.slice();
            b.splice(0, i + 1);
            innerSrc = b.join('.'); // Traverse each entry in the array setting the properties requested

            if (Array.isArray(val)) {
              for (var j = 0, jLen = val.length; j < jLen; j++) {
                o = {};
                setData(o, val[j], innerSrc);
                data[a[i]].push(o);
              }
            } else {
              // We've been asked to save data to an array, but it
              // isn't array data to be saved. Best that can be done
              // is to just save the value.
              data[a[i]] = val;
            } // The inner call to setData has already traversed through the remainder
            // of the source and has set the data, thus we can exit here


            return;
          } else if (funcNotation) {
            // Function call
            a[i] = a[i].replace(__reFn, '');
            data = data[a[i]](val);
          } // If the nested object doesn't currently exist - since we are
          // trying to set the value - create it


          if (data[a[i]] === null || data[a[i]] === undefined) {
            data[a[i]] = {};
          }

          data = data[a[i]];
        } // Last item in the input - i.e, the actual set


        if (aLast.match(__reFn)) {
          // Function call
          data = data[aLast.replace(__reFn, '')](val);
        } else {
          // If array notation is used, we just want to strip it and use the property name
          // and assign the value. If it isn't used, then we get the result we want anyway
          data[aLast.replace(__reArray, '')] = val;
        }
      };

      return function (data, val) {
        // meta is also passed in, but not used
        return setData(data, val, mSource);
      };
    } else {
      /* Array or flat object mapping */
      return function (data, val) {
        // meta is also passed in, but not used
        data[mSource] = val;
      };
    }
  }
  /**
   * Return an array with the full table data
   *  @param {object} oSettings dataTables settings object
   *  @returns array {array} aData Master data array
   *  @memberof DataTable#oApi
   */


  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, '_aData');
  }
  /**
   * Nuke the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  /**
  * Take an array of integers (index array) and remove a target integer (value - not
  * the key!)
  *  @param {array} a Index array to target
  *  @param {int} iTarget value to find
  *  @memberof DataTable#oApi
  */


  function _fnDeleteIndex(a, iTarget, splice) {
    var iTargetIndex = -1;

    for (var i = 0, iLen = a.length; i < iLen; i++) {
      if (a[i] == iTarget) {
        iTargetIndex = i;
      } else if (a[i] > iTarget) {
        a[i]--;
      }
    }

    if (iTargetIndex != -1 && splice === undefined) {
      a.splice(iTargetIndex, 1);
    }
  }
  /**
   * Mark cached data as invalid such that a re-read of the data will occur when
   * the cached data is next requested. Also update from the data source object.
   *
   * @param {object} settings DataTables settings object
   * @param {int}    rowIdx   Row index to invalidate
   * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
   *     or 'data'
   * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
   *     row will be invalidated
   * @memberof DataTable#oApi
   *
   * @todo For the modularisation of v1.11 this will need to become a callback, so
   *   the sort and filter methods can subscribe to it. That will required
   *   initialisation options for sorting, which is why it is not already baked in
   */


  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;

    var cellWrite = function (cell, col) {
      // This is very frustrating, but in IE if you just write directly
      // to innerHTML, and elements that are overwritten are GC'ed,
      // even if there is a reference to them elsewhere
      while (cell.childNodes.length) {
        cell.removeChild(cell.firstChild);
      }

      cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
    }; // Are we reading last data from DOM or the data object?


    if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
      // Read the data from the DOM
      row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
    } else {
      // Reading from data object, update the DOM
      var cells = row.anCells;

      if (cells) {
        if (colIdx !== undefined) {
          cellWrite(cells[colIdx], colIdx);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            cellWrite(cells[i], i);
          }
        }
      }
    } // For both row and cell invalidation, the cached data for sorting and
    // filtering is nulled out


    row._aSortData = null;
    row._aFilterData = null; // Invalidate the type for a specific column (if given) or all columns since
    // the data might have changed

    var cols = settings.aoColumns;

    if (colIdx !== undefined) {
      cols[colIdx].sType = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
      } // Update DataTables special `DT_*` attributes for the row


      _fnRowAttributes(settings, row);
    }
  }
  /**
   * Build a data source object from an HTML row, reading the contents of the
   * cells that are in the row.
   *
   * @param {object} settings DataTables settings object
   * @param {node|object} TR element from which to read data or existing row
   *   object from which to re-read the data from the cells
   * @param {int} [colIdx] Optional column index
   * @param {array|object} [d] Data source object. If `colIdx` is given then this
   *   parameter should also be given and will be used to write the data into.
   *   Only the column in question will be written
   * @returns {object} Object with two parameters: `data` the data read, in
   *   document order, and `cells` and array of nodes (they can be useful to the
   *   caller, so rather than needing a second traversal to get them, just return
   *   them from here).
   * @memberof DataTable#oApi
   */


  function _fnGetRowElements(settings, row, colIdx, d) {
    var tds = [],
        td = row.firstChild,
        name,
        col,
        o,
        i = 0,
        contents,
        columns = settings.aoColumns,
        objectRead = settings._rowReadObject; // Allow the data object to be passed in, or construct

    d = d !== undefined ? d : objectRead ? {} : [];

    var attr = function (str, td) {
      if (typeof str === 'string') {
        var idx = str.indexOf('@');

        if (idx !== -1) {
          var attr = str.substring(idx + 1);

          var setter = _fnSetObjectDataFn(str);

          setter(d, td.getAttribute(attr));
        }
      }
    }; // Read data from a cell and store into the data object


    var cellProcess = function (cell) {
      if (colIdx === undefined || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();

        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);

          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          // Depending on the `data` option for the columns the data can
          // be read to either an object or an array.
          if (objectRead) {
            if (!col._setter) {
              // Cache the setter function
              col._setter = _fnSetObjectDataFn(col.mData);
            }

            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }

      i++;
    };

    if (td) {
      // `tr` element was passed in
      while (td) {
        name = td.nodeName.toUpperCase();

        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }

        td = td.nextSibling;
      }
    } else {
      // Existing row object passed in
      tds = row.anCells;

      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    } // Read the ID from the DOM if present


    var rowNode = row.firstChild ? row : row.nTr;

    if (rowNode) {
      var id = rowNode.getAttribute('id');

      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d, id);
      }
    }

    return {
      data: d,
      cells: tds
    };
  }
  /**
   * Create a new TR element (and it's TD children) for a row
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow Row to consider
   *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @memberof DataTable#oApi
   */


  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow],
        rowData = row._aData,
        cells = [],
        nTr,
        nTd,
        oCol,
        i,
        iLen,
        create;

    if (row.nTr === null) {
      nTr = nTrIn || document.createElement('tr');
      row.nTr = nTr;
      row.anCells = cells;
      /* Use a private property on the node to allow reserve mapping from the node
       * to the aoData array for fast look up
       */

      nTr._DT_RowIndex = iRow;
      /* Special parameters can be given by the data source to be used on the row */

      _fnRowAttributes(oSettings, row);
      /* Process each column */


      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd); // Need to create the HTML if new, or if a rendering function is defined

        if (create || (!nTrIn || oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')) {
          nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
        }
        /* Add user defined class */


        if (oCol.sClass) {
          nTd.className += ' ' + oCol.sClass;
        } // Visibility - add or remove as required


        if (oCol.bVisible && !nTrIn) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && nTrIn) {
          nTd.parentNode.removeChild(nTd);
        }

        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
        }
      }

      _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells]);
    } // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
    // and deployed


    row.nTr.setAttribute('role', 'row');
  }
  /**
   * Add attributes to a row based on the special `DT_*` parameters in a data
   * source object.
   *  @param {object} settings DataTables settings object
   *  @param {object} DataTables row object for the row to be modified
   *  @memberof DataTable#oApi
   */


  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;

    if (tr) {
      var id = settings.rowIdFn(data);

      if (id) {
        tr.id = id;
      }

      if (data.DT_RowClass) {
        // Remove any classes added by DT_RowClass before
        var a = data.DT_RowClass.split(' ');
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
        $(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
      }

      if (data.DT_RowAttr) {
        $(tr).attr(data.DT_RowAttr);
      }

      if (data.DT_RowData) {
        $(tr).data(data.DT_RowData);
      }
    }
  }
  /**
   * Create the HTML header for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnBuildHead(oSettings) {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $('th, td', thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;

    if (createHeader) {
      row = $('<tr/>').appendTo(thead);
    }

    for (i = 0, ien = columns.length; i < ien; i++) {
      column = columns[i];
      cell = $(column.nTh).addClass(column.sClass);

      if (createHeader) {
        cell.appendTo(row);
      } // 1.11 move into sorting


      if (oSettings.oFeatures.bSort) {
        cell.addClass(column.sSortingClass);

        if (column.bSortable !== false) {
          cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);

          _fnSortAttachListener(oSettings, column.nTh, i);
        }
      }

      if (column.sTitle != cell[0].innerHTML) {
        cell.html(column.sTitle);
      }

      _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
    }

    if (createHeader) {
      _fnDetectHeader(oSettings.aoHeader, thead);
    }
    /* ARIA role for the rows */


    $(thead).children('tr').attr('role', 'row');
    /* Deal with the footer - add classes if required */

    $(thead).children('tr').children('th, td').addClass(classes.sHeaderTH);
    $(tfoot).children('tr').children('th, td').addClass(classes.sFooterTH); // Cache the footer cells. Note that we only take the cells from the first
    // row in the footer. If there is more than one row the user wants to
    // interact with, they need to use the table().foot() method. Note also this
    // allows cells to be used for multiple columns using colspan

    if (tfoot !== null) {
      var cells = oSettings.aoFooter[0];

      for (i = 0, ien = cells.length; i < ien; i++) {
        column = columns[i];
        column.nTf = cells[i].cell;

        if (column.sClass) {
          $(column.nTf).addClass(column.sClass);
        }
      }
    }
  }
  /**
   * Draw the header (or footer) element based on the column visibility states. The
   * methodology here is to use the layout array from _fnDetectHeader, modified for
   * the instantaneous column visibility, to construct the new layout. The grid is
   * traversed over cell at a time in a rows x columns grid fashion, although each
   * cell insert can cover multiple elements in the grid - which is tracks using the
   * aApplied array. Cell inserts in the grid will only occur where there isn't
   * already a cell in that position.
   *  @param {object} oSettings dataTables settings object
   *  @param array {objects} aoSource Layout array from _fnDetectHeader
   *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
   *  @memberof DataTable#oApi
   */


  function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;

    if (!aoSource) {
      return;
    }

    if (bIncludeHidden === undefined) {
      bIncludeHidden = false;
    }
    /* Make a copy of the master layout array, but without the visible columns in it */


    for (i = 0, iLen = aoSource.length; i < iLen; i++) {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;
      /* Remove any columns which are currently hidden */

      for (j = iColumns - 1; j >= 0; j--) {
        if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
          aoLocal[i].splice(j, 1);
        }
      }
      /* Prep the applied array - it needs an element for each row */


      aApplied.push([]);
    }

    for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
      nLocalTr = aoLocal[i].nTr;
      /* All cells are going to be replaced, so empty out the row */

      if (nLocalTr) {
        while (n = nLocalTr.firstChild) {
          nLocalTr.removeChild(n);
        }
      }

      for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
        iRowspan = 1;
        iColspan = 1;
        /* Check to see if there is already a cell (row/colspan) covering our target
         * insert point. If there is, then there is nothing to do.
         */

        if (aApplied[i][j] === undefined) {
          nLocalTr.appendChild(aoLocal[i][j].cell);
          aApplied[i][j] = 1;
          /* Expand the cell to cover as many rows as needed */

          while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
            aApplied[i + iRowspan][j] = 1;
            iRowspan++;
          }
          /* Expand the cell to cover as many columns as needed */


          while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
            /* Must update the applied array over the rows for the columns */
            for (k = 0; k < iRowspan; k++) {
              aApplied[i + k][j + iColspan] = 1;
            }

            iColspan++;
          }
          /* Do the actual expansion in the DOM */


          $(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
        }
      }
    }
  }
  /**
   * Insert the required TR nodes into the table for display
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnDraw(oSettings) {
    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
    var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);

    if ($.inArray(false, aPreDraw) !== -1) {
      _fnProcessingDisplay(oSettings, false);

      return;
    }

    var i, iLen, n;
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var iOpenRows = oSettings.aoOpenRows.length;
    var oLang = oSettings.oLanguage;
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    var bServerSide = _fnDataSource(oSettings) == 'ssp';
    var aiDisplay = oSettings.aiDisplay;
    oSettings.bDrawing = true;
    /* Check and see if we have an initial draw position from state saving */

    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }

    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    /* Server-side processing draw intercept */

    if (oSettings.bDeferLoading) {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;

      _fnProcessingDisplay(oSettings, false);
    } else if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
      return;
    }

    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];

        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }

        var nRow = aoData.nTr;
        /* Remove the old striping classes and then add the new one */

        if (iStripes !== 0) {
          var sStripe = asStripeClasses[iRowCount % iStripes];

          if (aoData._sRowStripe != sStripe) {
            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
            aoData._sRowStripe = sStripe;
          }
        } // Row callback functions - might want to manipulate the row
        // iRowCount and j are not currently documented. Are they at all
        // useful?


        _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j, iDataIndex]);

        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      /* Table is empty - create a row with an empty message in it */
      var sZero = oLang.sZeroRecords;

      if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
        sZero = oLang.sLoadingRecords;
      } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
        sZero = oLang.sEmptyTable;
      }

      anRows[0] = $('<tr/>', {
        'class': iStripes ? asStripeClasses[0] : ''
      }).append($('<td />', {
        'valign': 'top',
        'colSpan': _fnVisbleColumns(oSettings),
        'class': oSettings.oClasses.sRowEmpty
      }).html(sZero))[0];
    }
    /* Header and footer callbacks */


    _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

    _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

    var body = $(oSettings.nTBody);
    body.children().detach();
    body.append($(anRows));
    /* Call all required callback functions for the end of a draw */

    _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
    /* Draw is complete, sorting and filtering must be as well */


    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  /**
   * Redraw the table - taking account of the various features which are enabled
   *  @param {object} oSettings dataTables settings object
   *  @param {boolean} [holdPosition] Keep the current paging position. By default
   *    the paging is reset to the first page
   *  @memberof DataTable#oApi
   */


  function _fnReDraw(settings, holdPosition) {
    var features = settings.oFeatures,
        sort = features.bSort,
        filter = features.bFilter;

    if (sort) {
      _fnSort(settings);
    }

    if (filter) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      // No filtering, so we want to just use the display master
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }

    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    } // Let any modules know about the draw hold position state (used by
    // scrolling internally)


    settings._drawHold = holdPosition;

    _fnDraw(settings);

    settings._drawHold = false;
  }
  /**
   * Add the options to the page HTML for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnAddOptionsHtml(oSettings) {
    var classes = oSettings.oClasses;
    var table = $(oSettings.nTable);
    var holding = $('<div/>').insertBefore(table); // Holding element for speed

    var features = oSettings.oFeatures; // All DataTables are wrapped in a div

    var insert = $('<div/>', {
      id: oSettings.sTableId + '_wrapper',
      'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
    });
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
    /* Loop over the user set positioning and place the elements as needed */

    var aDom = oSettings.sDom.split('');
    var featureNode, cOption, nNewNode, cNext, sAttr, j;

    for (var i = 0; i < aDom.length; i++) {
      featureNode = null;
      cOption = aDom[i];

      if (cOption == '<') {
        /* New container div */
        nNewNode = $('<div/>')[0];
        /* Check to see if we should append an id and/or a class name to the container */

        cNext = aDom[i + 1];

        if (cNext == "'" || cNext == '"') {
          sAttr = "";
          j = 2;

          while (aDom[i + j] != cNext) {
            sAttr += aDom[i + j];
            j++;
          }
          /* Replace jQuery UI constants @todo depreciated */


          if (sAttr == "H") {
            sAttr = classes.sJUIHeader;
          } else if (sAttr == "F") {
            sAttr = classes.sJUIFooter;
          }
          /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
           * breaks the string into parts and applies them as needed
           */


          if (sAttr.indexOf('.') != -1) {
            var aSplit = sAttr.split('.');
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
            nNewNode.className = aSplit[1];
          } else if (sAttr.charAt(0) == "#") {
            nNewNode.id = sAttr.substr(1, sAttr.length - 1);
          } else {
            nNewNode.className = sAttr;
          }

          i += j;
          /* Move along the position array */
        }

        insert.append(nNewNode);
        insert = $(nNewNode);
      } else if (cOption == '>') {
        /* End container div */
        insert = insert.parent();
      } // @todo Move options into their own plugins?
      else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
          /* Length */
          featureNode = _fnFeatureHtmlLength(oSettings);
        } else if (cOption == 'f' && features.bFilter) {
          /* Filter */
          featureNode = _fnFeatureHtmlFilter(oSettings);
        } else if (cOption == 'r' && features.bProcessing) {
          /* pRocessing */
          featureNode = _fnFeatureHtmlProcessing(oSettings);
        } else if (cOption == 't') {
          /* Table */
          featureNode = _fnFeatureHtmlTable(oSettings);
        } else if (cOption == 'i' && features.bInfo) {
          /* Info */
          featureNode = _fnFeatureHtmlInfo(oSettings);
        } else if (cOption == 'p' && features.bPaginate) {
          /* Pagination */
          featureNode = _fnFeatureHtmlPaginate(oSettings);
        } else if (DataTable.ext.feature.length !== 0) {
          /* Plug-in features */
          var aoFeatures = DataTable.ext.feature;

          for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
            if (cOption == aoFeatures[k].cFeature) {
              featureNode = aoFeatures[k].fnInit(oSettings);
              break;
            }
          }
        }
      /* Add to the 2D features array */


      if (featureNode) {
        var aanFeatures = oSettings.aanFeatures;

        if (!aanFeatures[cOption]) {
          aanFeatures[cOption] = [];
        }

        aanFeatures[cOption].push(featureNode);
        insert.append(featureNode);
      }
    }
    /* Built our DOM structure - replace the holding div with what we want */


    holding.replaceWith(insert);
    oSettings.nHolding = null;
  }
  /**
   * Use the DOM source to create up an array of header cells. The idea here is to
   * create a layout grid (array) of rows x columns, which contains a reference
   * to the cell that that point in the grid (regardless of col/rowspan), such that
   * any column / row could be removed and the new grid constructed
   *  @param array {object} aLayout Array to store the calculated layout in
   *  @param {node} nThead The header/footer element for the table
   *  @memberof DataTable#oApi
   */


  function _fnDetectHeader(aLayout, nThead) {
    var nTrs = $(nThead).children('tr');
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;

    var fnShiftCol = function (a, i, j) {
      var k = a[i];

      while (k[j]) {
        j++;
      }

      return j;
    };

    aLayout.splice(0, aLayout.length);
    /* We know how many rows there are in the layout - so prep it */

    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      aLayout.push([]);
    }
    /* Calculate a layout array */


    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      nTr = nTrs[i];
      iColumn = 0;
      /* For every cell in the row... */

      nCell = nTr.firstChild;

      while (nCell) {
        if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
          /* Get the col and rowspan attributes from the DOM and sanitise them */
          iColspan = nCell.getAttribute('colspan') * 1;
          iRowspan = nCell.getAttribute('rowspan') * 1;
          iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
          iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
          /* There might be colspan cells already in this row, so shift our target
           * accordingly
           */

          iColShifted = fnShiftCol(aLayout, i, iColumn);
          /* Cache calculation for unique columns */

          bUnique = iColspan === 1 ? true : false;
          /* If there is col / rowspan, copy the information into the layout grid */

          for (l = 0; l < iColspan; l++) {
            for (k = 0; k < iRowspan; k++) {
              aLayout[i + k][iColShifted + l] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i + k].nTr = nTr;
            }
          }
        }

        nCell = nCell.nextSibling;
      }
    }
  }
  /**
   * Get an array of unique th elements, one for each column
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nHeader automatically detect the layout from this node - optional
   *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
   *  @returns array {node} aReturn list of unique th's
   *  @memberof DataTable#oApi
   */


  function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
    var aReturn = [];

    if (!aLayout) {
      aLayout = oSettings.aoHeader;

      if (nHeader) {
        aLayout = [];

        _fnDetectHeader(aLayout, nHeader);
      }
    }

    for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
      for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
        if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }

    return aReturn;
  }
  /**
   * Create an Ajax call based on the table's settings, taking into account that
   * parameters can have multiple forms, and backwards compatibility.
   *
   * @param {object} oSettings dataTables settings object
   * @param {array} data Data to send to the server, required by
   *     DataTables - may be augmented by developer callbacks
   * @param {function} fn Callback function to run when data is obtained
   */


  function _fnBuildAjax(oSettings, data, fn) {
    // Compatibility with 1.9-, allow fnServerData and event to manipulate
    _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]); // Convert to object based for 1.10+ if using the old array scheme which can
    // come from server-side processing or serverParams


    if (data && Array.isArray(data)) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
      $.each(data, function (key, val) {
        var match = val.name.match(rbracket);

        if (match) {
          // Support for arrays
          var name = match[0];

          if (!tmp[name]) {
            tmp[name] = [];
          }

          tmp[name].push(val.value);
        } else {
          tmp[val.name] = val.value;
        }
      });
      data = tmp;
    }

    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;

    var callback = function (json) {
      _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);

      fn(json);
    };

    if ($.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === 'function' ? ajaxData(data, oSettings) : // fn can manipulate data or return
      ajaxData; // an object object or array to merge
      // If the function returned something, use that alone

      data = typeof ajaxData === 'function' && newData ? newData : $.extend(true, data, newData); // Remove the data property as we've resolved it already and don't want
      // jQuery to do it again (it is restored at the end of the function)

      delete ajax.data;
    }

    var baseAjax = {
      "data": data,
      "success": function (json) {
        var error = json.error || json.sError;

        if (error) {
          _fnLog(oSettings, 0, error);
        }

        oSettings.json = json;
        callback(json);
      },
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function (xhr, error, thrown) {
        var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

        if ($.inArray(true, ret) === -1) {
          if (error == "parsererror") {
            _fnLog(oSettings, 0, 'Invalid JSON response', 1);
          } else if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, 'Ajax error', 7);
          }
        }

        _fnProcessingDisplay(oSettings, false);
      }
    }; // Store the data submitted for the API

    oSettings.oAjaxData = data; // Allow plug-ins and external processes to modify the data

    _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

    if (oSettings.fnServerData) {
      // DataTables 1.9- compatibility
      oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
        // Need to convert back to 1.9 trad format
        return {
          name: key,
          value: val
        };
      }), callback, oSettings);
    } else if (oSettings.sAjaxSource || typeof ajax === 'string') {
      // DataTables 1.9- compatibility
      oSettings.jqXHR = $.ajax($.extend(baseAjax, {
        url: ajax || oSettings.sAjaxSource
      }));
    } else if (typeof ajax === 'function') {
      // Is a function - let the caller define what needs to be done
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else {
      // Object to extend the base settings
      oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax)); // Restore for next time around

      ajax.data = ajaxData;
    }
  }
  /**
   * Update the table using an Ajax call
   *  @param {object} settings dataTables settings object
   *  @returns {boolean} Block the table drawing or not
   *  @memberof DataTable#oApi
   */


  function _fnAjaxUpdate(settings) {
    if (settings.bAjaxDataGet) {
      settings.iDraw++;

      _fnProcessingDisplay(settings, true);

      _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
        _fnAjaxUpdateDraw(settings, json);
      });

      return false;
    }

    return true;
  }
  /**
   * Build up the parameters in an object needed for a server-side processing
   * request. Note that this is basically done twice, is different ways - a modern
   * method which is used by default in DataTables 1.10 which uses objects and
   * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
   * the sAjaxSource option is used in the initialisation, or the legacyAjax
   * option is set.
   *  @param {object} oSettings dataTables settings object
   *  @returns {bool} block the table drawing or not
   *  @memberof DataTable#oApi
   */


  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns,
        columnCount = columns.length,
        features = settings.oFeatures,
        preSearch = settings.oPreviousSearch,
        preColSearch = settings.aoPreSearchCols,
        i,
        data = [],
        dataProp,
        column,
        columnSearch,
        sort = _fnSortFlatten(settings),
        displayStart = settings._iDisplayStart,
        displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;

    var param = function (name, value) {
      data.push({
        'name': name,
        'value': value
      });
    }; // DataTables 1.9- compatible method


    param('sEcho', settings.iDraw);
    param('iColumns', columnCount);
    param('sColumns', _pluck(columns, 'sName').join(','));
    param('iDisplayStart', displayStart);
    param('iDisplayLength', displayLength); // DataTables 1.10+ method

    var d = {
      draw: settings.iDraw,
      columns: [],
      order: [],
      start: displayStart,
      length: displayLength,
      search: {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };

    for (i = 0; i < columnCount; i++) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData == "function" ? 'function' : column.mData;
      d.columns.push({
        data: dataProp,
        name: column.sName,
        searchable: column.bSearchable,
        orderable: column.bSortable,
        search: {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      });
      param("mDataProp_" + i, dataProp);

      if (features.bFilter) {
        param('sSearch_' + i, columnSearch.sSearch);
        param('bRegex_' + i, columnSearch.bRegex);
        param('bSearchable_' + i, column.bSearchable);
      }

      if (features.bSort) {
        param('bSortable_' + i, column.bSortable);
      }
    }

    if (features.bFilter) {
      param('sSearch', preSearch.sSearch);
      param('bRegex', preSearch.bRegex);
    }

    if (features.bSort) {
      $.each(sort, function (i, val) {
        d.order.push({
          column: val.col,
          dir: val.dir
        });
        param('iSortCol_' + i, val.col);
        param('sSortDir_' + i, val.dir);
      });
      param('iSortingCols', sort.length);
    } // If the legacy.ajax parameter is null, then we automatically decide which
    // form to use, based on sAjaxSource


    var legacy = DataTable.ext.legacy.ajax;

    if (legacy === null) {
      return settings.sAjaxSource ? data : d;
    } // Otherwise, if legacy has been specified then we use that to decide on the
    // form


    return legacy ? data : d;
  }
  /**
   * Data the data from the server (nuking the old) and redraw the table
   *  @param {object} oSettings dataTables settings object
   *  @param {object} json json data return from the server.
   *  @param {string} json.sEcho Tracking flag for DataTables to match requests
   *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
   *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
   *  @param {array} json.aaData The data to display on this page
   *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
   *  @memberof DataTable#oApi
   */


  function _fnAjaxUpdateDraw(settings, json) {
    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
    // Support both
    var compat = function (old, modern) {
      return json[old] !== undefined ? json[old] : json[modern];
    };

    var data = _fnAjaxDataSrc(settings, json);

    var draw = compat('sEcho', 'draw');
    var recordsTotal = compat('iTotalRecords', 'recordsTotal');
    var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

    if (draw !== undefined) {
      // Protect against out of sequence returns
      if (draw * 1 < settings.iDraw) {
        return;
      }

      settings.iDraw = draw * 1;
    }

    _fnClearTable(settings);

    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData(settings, data[i]);
    }

    settings.aiDisplay = settings.aiDisplayMaster.slice();
    settings.bAjaxDataGet = false;

    _fnDraw(settings);

    if (!settings._bInitComplete) {
      _fnInitComplete(settings, json);
    }

    settings.bAjaxDataGet = true;

    _fnProcessingDisplay(settings, false);
  }
  /**
   * Get the data from the JSON data source to use for drawing a table. Using
   * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
   * source object, or from a processing function.
   *  @param {object} oSettings dataTables settings object
   *  @param  {object} json Data source object / array from the server
   *  @return {array} Array of data to use
   */


  function _fnAjaxDataSrc(oSettings, json) {
    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp; // Compatibility with 1.9-.
    // Compatibility with 1.9-. In order to read from aaData, check if the
    // default has been changed, if not, check for aaData

    if (dataSrc === 'data') {
      return json.aaData || json[dataSrc];
    }

    return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
  }
  /**
   * Generate the node required for filtering text
   *  @returns {node} Filter control element
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlFilter(settings) {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
    var str = language.sSearch;
    str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;
    var filter = $('<div/>', {
      'id': !features.f ? tableId + '_filter' : null,
      'class': classes.sFilter
    }).append($('<label/>').append(str));

    var searchFn = function () {
      /* Update all other filter input elements for the new display */
      var n = features.f;
      var val = !this.value ? "" : this.value; // mental IE8 fix :-(

      /* Now do the filter */

      if (val != previousSearch.sSearch) {
        _fnFilterComplete(settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart,
          "bCaseInsensitive": previousSearch.bCaseInsensitive
        }); // Need to redraw, without resorting


        settings._iDisplayStart = 0;

        _fnDraw(settings);
      }
    };

    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;
    var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).on('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).on('mouseup', function (e) {
      // Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
      // on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
      // checks the value to see if it has changed. In other browsers it won't have.
      setTimeout(function () {
        searchFn.call(jqFilter[0]);
      }, 10);
    }).on('keypress.DT', function (e) {
      /* Prevent form submission */
      if (e.keyCode == 13) {
        return false;
      }
    }).attr('aria-controls', tableId); // Update the input elements whenever the table is filtered

    $(settings.nTable).on('search.dt.DT', function (ev, s) {
      if (settings === s) {
        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame...
        try {
          if (jqFilter[0] !== document.activeElement) {
            jqFilter.val(previousSearch.sSearch);
          }
        } catch (e) {}
      }
    });
    return filter[0];
  }
  /**
   * Filter the table using both the global filter and column based filtering
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oSearch search information
   *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
   *  @memberof DataTable#oApi
   */


  function _fnFilterComplete(oSettings, oInput, iForce) {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;

    var fnSaveFilter = function (oFilter) {
      /* Save the filtering values */
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
    };

    var fnRegex = function (o) {
      // Backwards compatibility with the bEscapeRegex option
      return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
    }; // Resolve any column types that are unknown due to addition or invalidation
    // @todo As per sort - can this be moved into an event handler?


    _fnColumnTypes(oSettings);
    /* In server-side processing all filtering is done by the server, so no point hanging around here */


    if (_fnDataSource(oSettings) != 'ssp') {
      /* Global filter */
      _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);

      fnSaveFilter(oInput);
      /* Now do the individual column filter */

      for (var i = 0; i < aoPrevSearch.length; i++) {
        _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
      }
      /* Custom filtering */


      _fnFilterCustom(oSettings);
    } else {
      fnSaveFilter(oInput);
    }
    /* Tell the draw function we have been filtering */


    oSettings.bFiltered = true;

    _fnCallbackFire(oSettings, null, 'search', [oSettings]);
  }
  /**
   * Apply custom filtering functions
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;

    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = []; // Loop over each row and see if it should be included

      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];

        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      } // So the array reference doesn't break set the results into the
      // existing array


      displayRows.length = 0;
      $.merge(displayRows, rows);
    }
  }
  /**
   * Filter the table on a per-column basis
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sInput string to filter on
   *  @param {int} iColumn column to filter
   *  @param {bool} bRegex treat search string as a regular expression or not
   *  @param {bool} bSmart use smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */


  function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
    if (searchStr === '') {
      return;
    }

    var data;
    var out = [];
    var display = settings.aiDisplay;

    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

    for (var i = 0; i < display.length; i++) {
      data = settings.aoData[display[i]]._aFilterData[colIdx];

      if (rpSearch.test(data)) {
        out.push(display[i]);
      }
    }

    settings.aiDisplay = out;
  }
  /**
   * Filter the data table based on user input and draw the table
   *  @param {object} settings dataTables settings object
   *  @param {string} input string to filter on
   *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
   *  @param {bool} regex treat as a regular expression or not
   *  @param {bool} smart perform smart filtering or not
   *  @param {bool} caseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */


  function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);

    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
    var filtered = []; // Need to take account of custom filtering functions - always filter

    if (DataTable.ext.search.length !== 0) {
      force = true;
    } // Check if any of the rows were invalidated


    invalidated = _fnFilterData(settings); // If the input is blank - we just want the full data set

    if (input.length <= 0) {
      settings.aiDisplay = displayMaster.slice();
    } else {
      // New search - start from the master array
      if (invalidated || force || regex || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted // On resort, the display master needs to be
      // re-filtered since indexes will have changed
      ) {
          settings.aiDisplay = displayMaster.slice();
        } // Search the display array


      display = settings.aiDisplay;

      for (i = 0; i < display.length; i++) {
        if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
          filtered.push(display[i]);
        }
      }

      settings.aiDisplay = filtered;
    }
  }
  /**
   * Build a regular expression object suitable for searching a table
   *  @param {string} sSearch string to search for
   *  @param {bool} bRegex treat as a regular expression or not
   *  @param {bool} bSmart perform smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insensitive matching or not
   *  @returns {RegExp} constructed object
   *  @memberof DataTable#oApi
   */


  function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
    search = regex ? search : _fnEscapeRegex(search);

    if (smart) {
      /* For smart filtering we want to allow the search to work regardless of
       * word order. We also want double quoted text to be preserved, so word
       * order is important - a la google. So this is what we want to
       * generate:
       * 
       * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
       */
      var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
        if (word.charAt(0) === '"') {
          var m = word.match(/^"(.*)"$/);
          word = m ? m[1] : word;
        }

        return word.replace('"', '');
      });
      search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
    }

    return new RegExp(search, caseInsensitive ? 'i' : '');
  }
  /**
   * Escape a string such that it can be used in a regular expression
   *  @param {string} sVal string to escape
   *  @returns {string} escaped string
   *  @memberof DataTable#oApi
   */


  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $('<div>')[0];

  var __filter_div_textContent = __filter_div.textContent !== undefined; // Update the filtering data for each row if needed (by invalidation or first run)


  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var fomatters = DataTable.ext.type.search;
    var wasInvalidated = false;

    for (i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];

      if (!row._aFilterData) {
        filterData = [];

        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];

          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, i, j, 'filter');

            if (fomatters[column.sType]) {
              cellData = fomatters[column.sType](cellData);
            } // Search in DataTables 1.10 is string based. In 1.11 this
            // should be altered to also allow strict type checking.


            if (cellData === null) {
              cellData = '';
            }

            if (typeof cellData !== 'string' && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = '';
          } // If it looks like there is an HTML entity in the string,
          // attempt to decode it so sorting works as expected. Note that
          // we could use a single line of jQuery to do this, but the DOM
          // method used here is much faster http://jsperf.com/html-decode


          if (cellData.indexOf && cellData.indexOf('&') !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }

          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, '');
          }

          filterData.push(cellData);
        }

        row._aFilterData = filterData;
        row._sFilterRow = filterData.join('  ');
        wasInvalidated = true;
      }
    }

    return wasInvalidated;
  }
  /**
   * Convert from the internal Hungarian notation to camelCase for external
   * interaction
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */


  function _fnSearchToCamel(obj) {
    return {
      search: obj.sSearch,
      smart: obj.bSmart,
      regex: obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }
  /**
   * Convert from camelCase notation to the internal Hungarian. We could use the
   * Hungarian convert function here, but this is cleaner
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */


  function _fnSearchToHung(obj) {
    return {
      sSearch: obj.search,
      bSmart: obj.smart,
      bRegex: obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }
  /**
   * Generate the node required for the info display
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Information element
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlInfo(settings) {
    var tid = settings.sTableId,
        nodes = settings.aanFeatures.i,
        n = $('<div/>', {
      'class': settings.oClasses.sInfo,
      'id': !nodes ? tid + '_info' : null
    });

    if (!nodes) {
      // Update display on each draw
      settings.aoDrawCallback.push({
        "fn": _fnUpdateInfo,
        "sName": "information"
      });
      n.attr('role', 'status').attr('aria-live', 'polite'); // Table is described by our info div

      $(settings.nTable).attr('aria-describedby', tid + '_info');
    }

    return n[0];
  }
  /**
   * Update the information elements in the display
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnUpdateInfo(settings) {
    /* Show information about the table */
    var nodes = settings.aanFeatures.i;

    if (nodes.length === 0) {
      return;
    }

    var lang = settings.oLanguage,
        start = settings._iDisplayStart + 1,
        end = settings.fnDisplayEnd(),
        max = settings.fnRecordsTotal(),
        total = settings.fnRecordsDisplay(),
        out = total ? lang.sInfo : lang.sInfoEmpty;

    if (total !== max) {
      /* Record set after filtering */
      out += ' ' + lang.sInfoFiltered;
    } // Convert the macros


    out += lang.sInfoPostFix;
    out = _fnInfoMacros(settings, out);
    var callback = lang.fnInfoCallback;

    if (callback !== null) {
      out = callback.call(settings.oInstance, settings, start, end, max, total, out);
    }

    $(nodes).html(out);
  }

  function _fnInfoMacros(settings, str) {
    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
    // internally
    var formatter = settings.fnFormatNumber,
        start = settings._iDisplayStart + 1,
        len = settings._iDisplayLength,
        vis = settings.fnRecordsDisplay(),
        all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
  }
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnInitialise(settings) {
    var i,
        iLen,
        iAjaxStart = settings.iInitDisplayStart;
    var columns = settings.aoColumns,
        column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading; // value modified by the draw

    /* Ensure that the table data is fully initialised */

    if (!settings.bInitialised) {
      setTimeout(function () {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    /* Show the display HTML options */


    _fnAddOptionsHtml(settings);
    /* Build and draw the header / footer for the table */


    _fnBuildHead(settings);

    _fnDrawHead(settings, settings.aoHeader);

    _fnDrawHead(settings, settings.aoFooter);
    /* Okay to show that something is going on now */


    _fnProcessingDisplay(settings, true);
    /* Calculate sizes for columns */


    if (features.bAutoWidth) {
      _fnCalculateColumnWidths(settings);
    }

    for (i = 0, iLen = columns.length; i < iLen; i++) {
      column = columns[i];

      if (column.sWidth) {
        column.nTh.style.width = _fnStringToCss(column.sWidth);
      }
    }

    _fnCallbackFire(settings, null, 'preInit', [settings]); // If there is default sorting required - let's do it. The sort function
    // will do the drawing for us. Otherwise we draw the table regardless of the
    // Ajax source - this allows the table to look initialised for Ajax sourcing
    // data (show 'loading' message possibly)


    _fnReDraw(settings); // Server-side processing init complete is done by _fnAjaxUpdateDraw


    var dataSrc = _fnDataSource(settings);

    if (dataSrc != 'ssp' || deferLoading) {
      // if there is an ajax source load the data
      if (dataSrc == 'ajax') {
        _fnBuildAjax(settings, [], function (json) {
          var aData = _fnAjaxDataSrc(settings, json); // Got the data - add it to the table


          for (i = 0; i < aData.length; i++) {
            _fnAddData(settings, aData[i]);
          } // Reset the init display for cookie saving. We've already done
          // a filter, and therefore cleared it before. So we need to make
          // it appear 'fresh'


          settings.iInitDisplayStart = iAjaxStart;

          _fnReDraw(settings);

          _fnProcessingDisplay(settings, false);

          _fnInitComplete(settings, json);
        }, settings);
      } else {
        _fnProcessingDisplay(settings, false);

        _fnInitComplete(settings);
      }
    }
  }
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} oSettings dataTables settings object
   *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
   *    with client-side processing (optional)
   *  @memberof DataTable#oApi
   */


  function _fnInitComplete(settings, json) {
    settings._bInitComplete = true; // When data was added after the initialisation (data or Ajax) we need to
    // calculate the column sizing

    if (json || settings.oInit.aaData) {
      _fnAdjustColumnSizing(settings);
    }

    _fnCallbackFire(settings, null, 'plugin-init', [settings, json]);

    _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
  }

  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;

    _fnLengthOverflow(settings); // Fire length change event


    _fnCallbackFire(settings, null, 'length', [settings, len]);
  }
  /**
   * Generate the node required for user display length changing
   *  @param {object} settings dataTables settings object
   *  @returns {node} Display length feature node
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlLength(settings) {
    var classes = settings.oClasses,
        tableId = settings.sTableId,
        menu = settings.aLengthMenu,
        d2 = Array.isArray(menu[0]),
        lengths = d2 ? menu[0] : menu,
        language = d2 ? menu[1] : menu;
    var select = $('<select/>', {
      'name': tableId + '_length',
      'aria-controls': tableId,
      'class': classes.sLengthSelect
    });

    for (var i = 0, ien = lengths.length; i < ien; i++) {
      select[0][i] = new Option(typeof language[i] === 'number' ? settings.fnFormatNumber(language[i]) : language[i], lengths[i]);
    }

    var div = $('<div><label/></div>').addClass(classes.sLength);

    if (!settings.aanFeatures.l) {
      div[0].id = tableId + '_length';
    }

    div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)); // Can't use `select` variable as user might provide their own and the
    // reference is broken by the use of outerHTML

    $('select', div).val(settings._iDisplayLength).on('change.DT', function (e) {
      _fnLengthChange(settings, $(this).val());

      _fnDraw(settings);
    }); // Update node value whenever anything changes the table's length

    $(settings.nTable).on('length.dt.DT', function (e, s, len) {
      if (settings === s) {
        $('select', div).val(len);
      }
    });
    return div[0];
  }
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Note that most of the paging logic is done in
   * DataTable.ext.pager
   */

  /**
   * Generate the node required for default pagination
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Pagination feature node
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlPaginate(settings) {
    var type = settings.sPaginationType,
        plugin = DataTable.ext.pager[type],
        modern = typeof plugin === 'function',
        redraw = function (settings) {
      _fnDraw(settings);
    },
        node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
        features = settings.aanFeatures;

    if (!modern) {
      plugin.fnInit(settings, node, redraw);
    }
    /* Add a draw callback for the pagination on first instance, to update the paging display */


    if (!features.p) {
      node.id = settings.sTableId + '_paginate';
      settings.aoDrawCallback.push({
        "fn": function (settings) {
          if (modern) {
            var start = settings._iDisplayStart,
                len = settings._iDisplayLength,
                visRecords = settings.fnRecordsDisplay(),
                all = len === -1,
                page = all ? 0 : Math.ceil(start / len),
                pages = all ? 1 : Math.ceil(visRecords / len),
                buttons = plugin(page, pages),
                i,
                ien;

            for (i = 0, ien = features.p.length; i < ien; i++) {
              _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
            }
          } else {
            plugin.fnUpdate(settings, redraw);
          }
        },
        "sName": "pagination"
      });
    }

    return node;
  }
  /**
   * Alter the display settings to change the page
   *  @param {object} settings DataTables settings object
   *  @param {string|int} action Paging action to take: "first", "previous",
   *    "next" or "last" or page number to jump to (integer)
   *  @param [bool] redraw Automatically draw the update or not
   *  @returns {bool} true page has changed, false - no change
   *  @memberof DataTable#oApi
   */


  function _fnPageChange(settings, action, redraw) {
    var start = settings._iDisplayStart,
        len = settings._iDisplayLength,
        records = settings.fnRecordsDisplay();

    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;

      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;

      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else {
      _fnLog(settings, 0, "Unknown paging action: " + action, 5);
    }

    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;

    if (changed) {
      _fnCallbackFire(settings, null, 'page', [settings]);

      if (redraw) {
        _fnDraw(settings);
      }
    }

    return changed;
  }
  /**
   * Generate the node required for the processing node
   *  @param {object} settings dataTables settings object
   *  @returns {node} Processing element
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlProcessing(settings) {
    return $('<div/>', {
      'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
      'class': settings.oClasses.sProcessing
    }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
  }
  /**
   * Display or hide the processing indicator
   *  @param {object} settings dataTables settings object
   *  @param {bool} show Show the processing indicator (true) or not (false)
   *  @memberof DataTable#oApi
   */


  function _fnProcessingDisplay(settings, show) {
    if (settings.oFeatures.bProcessing) {
      $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
    }

    _fnCallbackFire(settings, null, 'processing', [settings, show]);
  }
  /**
   * Add any control elements for the table - specifically scrolling
   *  @param {object} settings dataTables settings object
   *  @returns {node} Node to add to the DOM
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlTable(settings) {
    var table = $(settings.nTable); // Add the ARIA grid role to the table

    table.attr('role', 'grid'); // Scrolling from here on in

    var scroll = settings.oScroll;

    if (scroll.sX === '' && scroll.sY === '') {
      return settings.nTable;
    }

    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children('caption');
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $(table[0].cloneNode(false));
    var footerClone = $(table[0].cloneNode(false));
    var footer = table.children('tfoot');
    var _div = '<div/>';

    var size = function (s) {
      return !s ? null : _fnStringToCss(s);
    };

    if (!footer.length) {
      footer = null;
    }
    /*
     * The HTML structure that we want to generate in this function is:
     *  div - scroller
     *    div - scroll head
     *      div - scroll head inner
     *        table - scroll head table
     *          thead - thead
     *    div - scroll body
     *      table - table (master table)
     *        thead - thead clone for sizing
     *        tbody - tbody
     *    div - scroll foot
     *      div - scroll foot inner
     *        table - scroll foot table
     *          tfoot - tfoot
     */


    var scroller = $(_div, {
      'class': classes.sScrollWrapper
    }).append($(_div, {
      'class': classes.sScrollHead
    }).css({
      overflow: 'hidden',
      position: 'relative',
      border: 0,
      width: scrollX ? size(scrollX) : '100%'
    }).append($(_div, {
      'class': classes.sScrollHeadInner
    }).css({
      'box-sizing': 'content-box',
      width: scroll.sXInner || '100%'
    }).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, {
      'class': classes.sScrollBody
    }).css({
      position: 'relative',
      overflow: 'auto',
      width: size(scrollX)
    }).append(table));

    if (footer) {
      scroller.append($(_div, {
        'class': classes.sScrollFoot
      }).css({
        overflow: 'hidden',
        border: 0,
        width: scrollX ? size(scrollX) : '100%'
      }).append($(_div, {
        'class': classes.sScrollFootInner
      }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
    }

    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null; // When the body is scrolled, then we also want to scroll the headers

    if (scrollX) {
      $(scrollBody).on('scroll.DT', function (e) {
        var scrollLeft = this.scrollLeft;
        scrollHead.scrollLeft = scrollLeft;

        if (footer) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      });
    }

    $(scrollBody).css('max-height', scrollY);

    if (!scroll.bCollapse) {
      $(scrollBody).css('height', scrollY);
    }

    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot; // On redraw - align columns

    settings.aoDrawCallback.push({
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    });
    return scroller[0];
  }
  /**
   * Update the header, footer and body tables for resizing - i.e. column
   * alignment.
   *
   * Welcome to the most horrible function DataTables. The process that this
   * function follows is basically:
   *   1. Re-create the table inside the scrolling div
   *   2. Take live measurements from the DOM
   *   3. Apply the measurements to align the columns
   *   4. Clean up
   *
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnScrollDraw(settings) {
    // Given that this is such a monster function, a lot of variables are use
    // to try and keep the minimised size as small as possible
    var scroll = settings.oScroll,
        scrollX = scroll.sX,
        scrollXInner = scroll.sXInner,
        scrollY = scroll.sY,
        barWidth = scroll.iBarWidth,
        divHeader = $(settings.nScrollHead),
        divHeaderStyle = divHeader[0].style,
        divHeaderInner = divHeader.children('div'),
        divHeaderInnerStyle = divHeaderInner[0].style,
        divHeaderTable = divHeaderInner.children('table'),
        divBodyEl = settings.nScrollBody,
        divBody = $(divBodyEl),
        divBodyStyle = divBodyEl.style,
        divFooter = $(settings.nScrollFoot),
        divFooterInner = divFooter.children('div'),
        divFooterTable = divFooterInner.children('table'),
        header = $(settings.nTHead),
        table = $(settings.nTable),
        tableEl = table[0],
        tableStyle = tableEl.style,
        footer = settings.nTFoot ? $(settings.nTFoot) : null,
        browser = settings.oBrowser,
        ie67 = browser.bScrollOversize,
        dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
        headerTrgEls,
        footerTrgEls,
        headerSrcEls,
        footerSrcEls,
        headerCopy,
        footerCopy,
        headerWidths = [],
        footerWidths = [],
        headerContent = [],
        footerContent = [],
        idx,
        correction,
        sanityWidth,
        zeroOut = function (nSizer) {
      var style = nSizer.style;
      style.paddingTop = "0";
      style.paddingBottom = "0";
      style.borderTopWidth = "0";
      style.borderBottomWidth = "0";
      style.height = 0;
    }; // If the scrollbar visibility has changed from the last draw, we need to
    // adjust the column sizes as the table width will have changed to account
    // for the scrollbar


    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
      settings.scrollBarVis = scrollBarVis;

      _fnAdjustColumnSizing(settings);

      return; // adjust column sizing will call this function again
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    /*
     * 1. Re-create the table inside the scrolling div
     */
    // Remove the old minimised thead and tfoot elements in the inner table


    table.children('thead, tfoot').remove();

    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized

      footerSrcEls = footerCopy.find('tr');
    } // Clone the current header and footer elements and then place it into the inner table


    headerCopy = header.clone().prependTo(table);
    headerTrgEls = header.find('tr'); // original header is in its own table

    headerSrcEls = headerCopy.find('tr');
    headerCopy.find('th, td').removeAttr('tabindex');
    /*
     * 2. Take live measurements from the DOM - do not alter the DOM itself!
     */
    // Remove old sizing and apply the calculated column widths
    // Get the unique column headers in the newly created (cloned) header. We want to apply the
    // calculated sizes to this header

    if (!scrollX) {
      divBodyStyle.width = '100%';
      divHeader[0].style.width = '100%';
    }

    $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
      idx = _fnVisibleToColumnIndex(settings, i);
      el.style.width = settings.aoColumns[idx].sWidth;
    });

    if (footer) {
      _fnApplyToChildren(function (n) {
        n.style.width = "";
      }, footerSrcEls);
    } // Size the table as a whole


    sanityWidth = table.outerWidth();

    if (scrollX === "") {
      // No x scrolling
      tableStyle.width = "100%"; // IE7 will make the width of the table when 100% include the scrollbar
      // - which is shouldn't. When there is a scrollbar we need to take this
      // into account.

      if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
        tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
      } // Recalculate the sanity width


      sanityWidth = table.outerWidth();
    } else if (scrollXInner !== "") {
      // legacy x scroll inner has been given - use it
      tableStyle.width = _fnStringToCss(scrollXInner); // Recalculate the sanity width

      sanityWidth = table.outerWidth();
    } // Hidden header should have zero height, so remove padding and borders. Then
    // set the width based on the real headers
    // Apply all styles in one pass


    _fnApplyToChildren(zeroOut, headerSrcEls); // Read all widths in next pass


    _fnApplyToChildren(function (nSizer) {
      headerContent.push(nSizer.innerHTML);
      headerWidths.push(_fnStringToCss($(nSizer).css('width')));
    }, headerSrcEls); // Apply all widths in final pass


    _fnApplyToChildren(function (nToSize, i) {
      // Only apply widths to the DataTables detected header cells - this
      // prevents complex headers from having contradictory sizes applied
      if ($.inArray(nToSize, dtHeaderCells) !== -1) {
        nToSize.style.width = headerWidths[i];
      }
    }, headerTrgEls);

    $(headerSrcEls).height(0);
    /* Same again with the footer if we have one */

    if (footer) {
      _fnApplyToChildren(zeroOut, footerSrcEls);

      _fnApplyToChildren(function (nSizer) {
        footerContent.push(nSizer.innerHTML);
        footerWidths.push(_fnStringToCss($(nSizer).css('width')));
      }, footerSrcEls);

      _fnApplyToChildren(function (nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls);

      $(footerSrcEls).height(0);
    }
    /*
     * 3. Apply the measurements
     */
    // "Hide" the header and footer that we used for the sizing. We need to keep
    // the content of the cell so that the width applied to the header and body
    // both match, but we want to hide it completely. We want to also fix their
    // width to what they currently are


    _fnApplyToChildren(function (nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i] + '</div>';
      nSizer.childNodes[0].style.height = "0";
      nSizer.childNodes[0].style.overflow = "hidden";
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls);

    if (footer) {
      _fnApplyToChildren(function (nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i] + '</div>';
        nSizer.childNodes[0].style.height = "0";
        nSizer.childNodes[0].style.overflow = "hidden";
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls);
    } // Sanity check that the table is of a sensible width. If not then we are going to get
    // misalignment - try to prevent this by not allowing the table to shrink below its min width


    if (table.outerWidth() < sanityWidth) {
      // The min width depends upon if we have a vertical scrollbar visible or not */
      correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll" ? sanityWidth + barWidth : sanityWidth; // IE6/7 are a law unto themselves...

      if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
        tableStyle.width = _fnStringToCss(correction - barWidth);
      } // And give the user a warning that we've stopped the table getting too small


      if (scrollX === "" || scrollXInner !== "") {
        _fnLog(settings, 1, 'Possible column misalignment', 6);
      }
    } else {
      correction = '100%';
    } // Apply to the container elements


    divBodyStyle.width = _fnStringToCss(correction);
    divHeaderStyle.width = _fnStringToCss(correction);

    if (footer) {
      settings.nScrollFoot.style.width = _fnStringToCss(correction);
    }
    /*
     * 4. Clean up
     */


    if (!scrollY) {
      /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
       * the scrollbar height from the visible display, rather than adding it on. We need to
       * set the height in order to sort this. Don't want to do it in any other browsers.
       */
      if (ie67) {
        divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
      }
    }
    /* Finally set the width's of the header and footer tables */


    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth); // Figure out if there are scrollbar present - if so then we need a the header and footer to
    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)

    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

    if (footer) {
      divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
    } // Correct DOM ordering for colgroup - comes before the thead


    table.children('colgroup').insertBefore(table.children('thead'));
    /* Adjust the position of the header in case we loose the y-scrollbar */

    divBody.trigger('scroll'); // If sorting or filtering has occurred, jump the scrolling back to the top
    // only if we aren't holding the position

    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  /**
   * Apply a given function to the display child nodes of an element array (typically
   * TD children of TR rows
   *  @param {function} fn Method to apply to the objects
   *  @param array {nodes} an1 List of elements to look through for display children
   *  @param array {nodes} an2 Another list (identical structure to the first) - optional
   *  @memberof DataTable#oApi
   */


  function _fnApplyToChildren(fn, an1, an2) {
    var index = 0,
        i = 0,
        iLen = an1.length;
    var nNode1, nNode2;

    while (i < iLen) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;

      while (nNode1) {
        if (nNode1.nodeType === 1) {
          if (an2) {
            fn(nNode1, nNode2, index);
          } else {
            fn(nNode1, index);
          }

          index++;
        }

        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }

      i++;
    }
  }

  var __re_html_remove = /<.*?>/g;
  /**
   * Calculate the width of columns for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */

  function _fnCalculateColumnWidths(oSettings) {
    var table = oSettings.nTable,
        columns = oSettings.aoColumns,
        scroll = oSettings.oScroll,
        scrollY = scroll.sY,
        scrollX = scroll.sX,
        scrollXInner = scroll.sXInner,
        columnCount = columns.length,
        visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
        headerCells = $('th', oSettings.nTHead),
        tableWidthAttr = table.getAttribute('width'),
        // from DOM element
    tableContainer = table.parentNode,
        userInputs = false,
        i,
        column,
        columnIdx,
        width,
        outerWidth,
        browser = oSettings.oBrowser,
        ie67 = browser.bScrollOversize;

    var styleWidth = table.style.width;

    if (styleWidth && styleWidth.indexOf('%') !== -1) {
      tableWidthAttr = styleWidth;
    }
    /* Convert any user input sizes into pixel sizes */


    for (i = 0; i < visibleColumns.length; i++) {
      column = columns[visibleColumns[i]];

      if (column.sWidth !== null) {
        column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
        userInputs = true;
      }
    }
    /* If the number of columns in the DOM equals the number that we have to
     * process in DataTables, then we can use the offsets that are created by
     * the web- browser. No custom sizes can be set in order for this to happen,
     * nor scrolling used
     */


    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
      for (i = 0; i < columnCount; i++) {
        var colIdx = _fnVisibleToColumnIndex(oSettings, i);

        if (colIdx !== null) {
          columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      }
    } else {
      // Otherwise construct a single row, worst case, table with the widest
      // node in the data, assign any user defined widths, then insert it into
      // the DOM and allow the browser to do all the hard work of calculating
      // table widths
      var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
      .css('visibility', 'hidden').removeAttr('id'); // Clean up the table body

      tmpTable.find('tbody tr').remove();
      var tr = $('<tr/>').appendTo(tmpTable.find('tbody')); // Clone the table header and footer - we can't use the header / footer
      // from the cloned table, since if scrolling is active, the table's
      // real header and footer are contained in different table tags

      tmpTable.find('thead, tfoot').remove();
      tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone()); // Remove any assigned widths from the footer (from scrolling)

      tmpTable.find('tfoot th, tfoot td').css('width', ''); // Apply custom sizing to the cloned header

      headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];
        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''; // For scrollX we need to force the column width otherwise the
        // browser will collapse it. If this width is smaller than the
        // width the column requires, then it will have no effect

        if (column.sWidthOrig && scrollX) {
          $(headerCells[i]).append($('<div/>').css({
            width: column.sWidthOrig,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } // Find the widest cell for each column and put it into the table


      if (oSettings.aoData.length) {
        for (i = 0; i < visibleColumns.length; i++) {
          columnIdx = visibleColumns[i];
          column = columns[columnIdx];
          $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
        }
      } // Tidy the temporary table - remove name attributes so there aren't
      // duplicated in the dom (radio elements for example)


      $('[name]', tmpTable).removeAttr('name'); // Table has been built, attach to the document so we can work with it.
      // A holding element is used, positioned at the top of the container
      // with minimal height, so it has no effect on if the container scrolls
      // or not. Otherwise it might trigger scrolling when it actually isn't
      // needed

      var holder = $('<div/>').css(scrollX || scrollY ? {
        position: 'absolute',
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: 'hidden'
      } : {}).append(tmpTable).appendTo(tableContainer); // When scrolling (X or Y) we want to set the width of the table as 
      // appropriate. However, when not scrolling leave the table width as it
      // is. This results in slightly different, but I think correct behaviour

      if (scrollX && scrollXInner) {
        tmpTable.width(scrollXInner);
      } else if (scrollX) {
        tmpTable.css('width', 'auto');
        tmpTable.removeAttr('width'); // If there is no width attribute or style, then allow the table to
        // collapse

        if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
          tmpTable.width(tableContainer.clientWidth);
        }
      } else if (scrollY) {
        tmpTable.width(tableContainer.clientWidth);
      } else if (tableWidthAttr) {
        tmpTable.width(tableWidthAttr);
      } // Get the width of each column in the constructed table - we need to
      // know the inner width (so it can be assigned to the other table's
      // cells) and the outer width so we can calculate the full width of the
      // table. This is safe since DataTables requires a unique cell for each
      // column, but if ever a header can span multiple columns, this will
      // need to be modified.


      var total = 0;

      for (i = 0; i < visibleColumns.length; i++) {
        var cell = $(headerCells[i]);
        var border = cell.outerWidth() - cell.width(); // Use getBounding... where possible (not IE8-) because it can give
        // sub-pixel accuracy, which we then want to round up!

        var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth(); // Total is tracked to remove any sub-pixel errors as the outerWidth
        // of the table might not equal the total given here (IE!).

        total += bounding; // Width for each column to use

        columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
      }

      table.style.width = _fnStringToCss(total); // Finished with the table - ditch it

      holder.remove();
    } // If there is a width attr, we want to attach an event listener which
    // allows the table sizing to automatically adjust when the window is
    // resized. Use the width attr rather than CSS, since we can't know if the
    // CSS is a relative value or absolute - DOM read is always px.


    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }

    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
      var bindResize = function () {
        $(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
          _fnAdjustColumnSizing(oSettings);
        }));
      }; // IE6/7 will crash if we bind a resize event handler on page load.
      // To be removed in 1.11 which drops IE6/7 support


      if (ie67) {
        setTimeout(bindResize, 1000);
      } else {
        bindResize();
      }

      oSettings._reszEvt = true;
    }
  }
  /**
   * Throttle the calls to a function. Arguments and context are maintained for
   * the throttled function
   *  @param {function} fn Function to be called
   *  @param {int} [freq=200] call frequency in mS
   *  @returns {function} wrapped function
   *  @memberof DataTable#oApi
   */


  var _fnThrottle = DataTable.util.throttle;
  /**
   * Convert a CSS unit width to pixels (e.g. 2em)
   *  @param {string} width width to be converted
   *  @param {node} parent parent to get the with for (required for relative widths) - optional
   *  @returns {int} width in pixels
   *  @memberof DataTable#oApi
   */

  function _fnConvertToWidth(width, parent) {
    if (!width) {
      return 0;
    }

    var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);
    var val = n[0].offsetWidth;
    n.remove();
    return val;
  }
  /**
   * Get the widest node
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {node} widest table node
   *  @memberof DataTable#oApi
   */


  function _fnGetWidestNode(settings, colIdx) {
    var idx = _fnGetMaxLenString(settings, colIdx);

    if (idx < 0) {
      return null;
    }

    var data = settings.aoData[idx];
    return !data.nTr ? // Might not have been created when deferred rendering
    $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
  }
  /**
   * Get the maximum strlen for each data column
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {string} max string length for each column
   *  @memberof DataTable#oApi
   */


  function _fnGetMaxLenString(settings, colIdx) {
    var s,
        max = -1,
        maxIdx = -1;

    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      s = _fnGetCellData(settings, i, colIdx, 'display') + '';
      s = s.replace(__re_html_remove, '');
      s = s.replace(/&nbsp;/g, ' ');

      if (s.length > max) {
        max = s.length;
        maxIdx = i;
      }
    }

    return maxIdx;
  }
  /**
   * Append a CSS unit (only if required) to a string
   *  @param {string} value to css-ify
   *  @returns {string} value with css unit
   *  @memberof DataTable#oApi
   */


  function _fnStringToCss(s) {
    if (s === null) {
      return '0px';
    }

    if (typeof s == 'number') {
      return s < 0 ? '0px' : s + 'px';
    } // Check it has a unit character already


    return s.match(/\d$/) ? s + 'px' : s;
  }

  function _fnSortFlatten(settings) {
    var i,
        iLen,
        k,
        kLen,
        aSort = [],
        aiOrig = [],
        aoColumns = settings.aoColumns,
        aDataSort,
        iCol,
        sType,
        srcCol,
        fixed = settings.aaSortingFixed,
        fixedObj = $.isPlainObject(fixed),
        nestedSort = [],
        add = function (a) {
      if (a.length && !Array.isArray(a[0])) {
        // 1D array
        nestedSort.push(a);
      } else {
        // 2D array
        $.merge(nestedSort, a);
      }
    }; // Build the sort array, with pre-fix and post-fix options if they have been
    // specified


    if (Array.isArray(fixed)) {
      add(fixed);
    }

    if (fixedObj && fixed.pre) {
      add(fixed.pre);
    }

    add(settings.aaSorting);

    if (fixedObj && fixed.post) {
      add(fixed.post);
    }

    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[srcCol].aDataSort;

      for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
        iCol = aDataSort[k];
        sType = aoColumns[iCol].sType || 'string';

        if (nestedSort[i]._idx === undefined) {
          nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
        }

        aSort.push({
          src: srcCol,
          col: iCol,
          dir: nestedSort[i][1],
          index: nestedSort[i]._idx,
          type: sType,
          formatter: DataTable.ext.type.order[sType + "-pre"]
        });
      }
    }

    return aSort;
  }
  /**
   * Change the order of the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   *  @todo This really needs split up!
   */


  function _fnSort(oSettings) {
    var i,
        ien,
        iLen,
        j,
        jLen,
        k,
        kLen,
        sDataType,
        nTh,
        aiOrig = [],
        oExtSort = DataTable.ext.type.order,
        aoData = oSettings.aoData,
        aoColumns = oSettings.aoColumns,
        aDataSort,
        data,
        iCol,
        sType,
        oSort,
        formatters = 0,
        sortCol,
        displayMaster = oSettings.aiDisplayMaster,
        aSort; // Resolve any column types that are unknown due to addition or invalidation
    // @todo Can this be moved into a 'data-ready' handler which is called when
    //   data is going to be used in the table?

    _fnColumnTypes(oSettings);

    aSort = _fnSortFlatten(oSettings);

    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i]; // Track if we can use the fast sort algorithm

      if (sortCol.formatter) {
        formatters++;
      } // Load the data needed for the sort, for each cell


      _fnSortData(oSettings, sortCol.col);
    }
    /* No sorting required if server-side or no sorting array */


    if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
      // Create a value - key array of the current row positions such that we can use their
      // current position during the sort, if values match, in order to perform stable sorting
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[displayMaster[i]] = i;
      }
      /* Do the sort - here we want multi-column sorting based on a given data source (column)
       * and sorting function (from oSort) in a certain direction. It's reasonably complex to
       * follow on it's own, but this is what we want (example two column sorting):
       *  fnLocalSorting = function(a,b){
       *    var iTest;
       *    iTest = oSort['string-asc']('data11', 'data12');
       *      if (iTest !== 0)
       *        return iTest;
       *    iTest = oSort['numeric-desc']('data21', 'data22');
       *    if (iTest !== 0)
       *      return iTest;
       *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
       *  }
       * Basically we have a test for each sorting column, if the data in that column is equal,
       * test the next column. If all columns match, then we use a numeric sort on the row
       * positions in the original data array to provide a stable sort.
       *
       * Note - I know it seems excessive to have two sorting methods, but the first is around
       * 15% faster, so the second is only maintained for backwards compatibility with sorting
       * methods which do not have a pre-sort formatting function.
       */


      if (formatters === aSort.length) {
        // All sort types have formatting functions
        displayMaster.sort(function (a, b) {
          var x,
              y,
              k,
              test,
              sort,
              len = aSort.length,
              dataA = aoData[a]._aSortData,
              dataB = aoData[b]._aSortData;

          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            test = x < y ? -1 : x > y ? 1 : 0;

            if (test !== 0) {
              return sort.dir === 'asc' ? test : -test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      } else {
        // Depreciated - remove in 1.11 (providing a plug-in option)
        // Not all sort types have formatting methods, so we have to call their sorting
        // methods.
        displayMaster.sort(function (a, b) {
          var x,
              y,
              k,
              l,
              test,
              sort,
              fn,
              len = aSort.length,
              dataA = aoData[a]._aSortData,
              dataB = aoData[b]._aSortData;

          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
            test = fn(x, y);

            if (test !== 0) {
              return test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      }
    }
    /* Tell the draw function that we have sorted the data */


    oSettings.bSorted = true;
  }

  function _fnSortAria(settings) {
    var label;
    var nextSort;
    var columns = settings.aoColumns;

    var aSort = _fnSortFlatten(settings);

    var oAria = settings.oLanguage.oAria; // ARIA attributes - need to loop all columns, to update all (removing old
    // attributes as needed)

    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.sTitle.replace(/<.*?>/g, "");
      var th = col.nTh; // IE7 is throwing an error when setting these properties with jQuery's
      // attr() and removeAttr() methods...

      th.removeAttribute('aria-sort');
      /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */

      if (col.bSortable) {
        if (aSort.length > 0 && aSort[0].col == i) {
          th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
          nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
        } else {
          nextSort = asSorting[0];
        }

        label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
      } else {
        label = sTitle;
      }

      th.setAttribute('aria-label', label);
    }
  }
  /**
   * Function to run on user sort request
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {boolean} [append=false] Append the requested sort to the existing
   *    sort if true (i.e. multi-column sort)
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */


  function _fnSortListener(settings, colIdx, append, callback) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;

    var next = function (a, overflow) {
      var idx = a._idx;

      if (idx === undefined) {
        idx = $.inArray(a[1], asSorting);
      }

      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    }; // Convert to 2D array if needed


    if (typeof sorting[0] === 'number') {
      sorting = settings.aaSorting = [sorting];
    } // If appending the sort then we are multi-column sorting


    if (append && settings.oFeatures.bSortMulti) {
      // Are we already doing some kind of sort on this column?
      var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

      if (sortIdx !== -1) {
        // Yes, modify the sort
        nextSortIdx = next(sorting[sortIdx], true);

        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0; // can't remove sorting completely
        }

        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else {
        // No sort on this column yet
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      // Single column - already sorting on this column, modify the sort
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      // Single column - sort only on this column
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    } // Run the sort by calling a full redraw


    _fnReDraw(settings); // callback used for async user interaction


    if (typeof callback == 'function') {
      callback(settings);
    }
  }
  /**
   * Attach a sort handler (click) to a node
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */


  function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
    var col = settings.aoColumns[colIdx];

    _fnBindAction(attachTo, {}, function (e) {
      /* If the column is not sortable - don't to anything */
      if (col.bSortable === false) {
        return;
      } // If processing is enabled use a timeout to allow the processing
      // display to be shown - otherwise to it synchronously


      if (settings.oFeatures.bProcessing) {
        _fnProcessingDisplay(settings, true);

        setTimeout(function () {
          _fnSortListener(settings, colIdx, e.shiftKey, callback); // In server-side processing, the draw callback will remove the
          // processing display


          if (_fnDataSource(settings) !== 'ssp') {
            _fnProcessingDisplay(settings, false);
          }
        }, 0);
      } else {
        _fnSortListener(settings, colIdx, e.shiftKey, callback);
      }
    });
  }
  /**
   * Set the sorting classes on table's body, Note: it is safe to call this function
   * when bSort and bSortClasses are false
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;

    var sort = _fnSortFlatten(settings);

    var features = settings.oFeatures;
    var i, ien, colIdx;

    if (features.bSort && features.bSortClasses) {
      // Remove old sorting classes
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src; // Remove column sorting

        $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      } // Add new column sorting


      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }

    settings.aLastSort = sort;
  } // Get the data to sort a column, be it from cache, fresh (populating the
  // cache), or from a sort formatter


  function _fnSortData(settings, idx) {
    // Custom sorting function - provided by the sort data type
    var column = settings.aoColumns[idx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;

    if (customSort) {
      customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
    } // Use / populate cache


    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];

    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];

      if (!row._aSortData) {
        row._aSortData = [];
      }

      if (!row._aSortData[idx] || customSort) {
        cellData = customSort ? customData[i] : // If there was a custom sort function, use data from there
        _fnGetCellData(settings, i, idx, 'sort');
        row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
      }
    }
  }
  /**
   * Save the state of a table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnSaveState(settings) {
    if (!settings.oFeatures.bStateSave || settings.bDestroying) {
      return;
    }
    /* Store the interesting variables */


    var state = {
      time: +new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $.extend(true, [], settings.aaSorting),
      search: _fnSearchToCamel(settings.oPreviousSearch),
      columns: $.map(settings.aoColumns, function (col, i) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel(settings.aoPreSearchCols[i])
        };
      })
    };

    _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

    settings.oSavedState = state;
    settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
  }
  /**
   * Attempt to load a saved table state
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oInit DataTables init object so we can override settings
   *  @param {function} callback Callback to execute when the state has been loaded
   *  @memberof DataTable#oApi
   */


  function _fnLoadState(settings, oInit, callback) {
    var i, ien;
    var columns = settings.aoColumns;

    var loaded = function (s) {
      if (!s || !s.time) {
        callback();
        return;
      } // Allow custom and plug-in manipulation functions to alter the saved data set and
      // cancelling of loading by returning false


      var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);

      if ($.inArray(false, abStateLoad) !== -1) {
        callback();
        return;
      } // Reject old data


      var duration = settings.iStateDuration;

      if (duration > 0 && s.time < +new Date() - duration * 1000) {
        callback();
        return;
      } // Number of columns have changed - all bets are off, no restore of settings


      if (s.columns && columns.length !== s.columns.length) {
        callback();
        return;
      } // Store the saved state so it might be accessed at any time


      settings.oLoadedState = $.extend(true, {}, s); // Restore key features - todo - for 1.11 this needs to be done by
      // subscribed events

      if (s.start !== undefined) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      }

      if (s.length !== undefined) {
        settings._iDisplayLength = s.length;
      } // Order


      if (s.order !== undefined) {
        settings.aaSorting = [];
        $.each(s.order, function (i, col) {
          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
        });
      } // Search


      if (s.search !== undefined) {
        $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
      } // Columns
      //


      if (s.columns) {
        for (i = 0, ien = s.columns.length; i < ien; i++) {
          var col = s.columns[i]; // Visibility

          if (col.visible !== undefined) {
            columns[i].bVisible = col.visible;
          } // Search


          if (col.search !== undefined) {
            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
          }
        }
      }

      _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);

      callback();
    };

    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }

    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);

    if (state !== undefined) {
      loaded(state);
    } // otherwise, wait for the loaded callback to be executed

  }
  /**
   * Return the settings object for a particular table
   *  @param {node} table table we are using as a dataTable
   *  @returns {object} Settings object - or null if not found
   *  @memberof DataTable#oApi
   */


  function _fnSettingsFromNode(table) {
    var settings = DataTable.settings;
    var idx = $.inArray(table, _pluck(settings, 'nTable'));
    return idx !== -1 ? settings[idx] : null;
  }
  /**
   * Log an error message
   *  @param {object} settings dataTables settings object
   *  @param {int} level log error messages, or display them to the user
   *  @param {string} msg error message
   *  @param {int} tn Technical note id to get more information about the error.
   *  @memberof DataTable#oApi
   */


  function _fnLog(settings, level, msg, tn) {
    msg = 'DataTables warning: ' + (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

    if (tn) {
      msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
    }

    if (!level) {
      // Backwards compatibility pre 1.10
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;

      if (settings) {
        _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
      }

      if (type == 'alert') {
        alert(msg);
      } else if (type == 'throw') {
        throw new Error(msg);
      } else if (typeof type == 'function') {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  /**
   * See if a property is defined on one object, if so assign it to the other object
   *  @param {object} ret target object
   *  @param {object} src source object
   *  @param {string} name property
   *  @param {string} [mappedName] name to map too - optional, name used if not given
   *  @memberof DataTable#oApi
   */


  function _fnMap(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $.each(name, function (i, val) {
        if (Array.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }

    if (mappedName === undefined) {
      mappedName = name;
    }

    if (src[name] !== undefined) {
      ret[mappedName] = src[name];
    }
  }
  /**
   * Extend objects - very similar to jQuery.extend, but deep copy objects, and
   * shallow copy arrays. The reason we need to do this, is that we don't want to
   * deep copy array init values (such as aaSorting) since the dev wouldn't be
   * able to override them, but we do want to deep copy arrays.
   *  @param {object} out Object to extend
   *  @param {object} extender Object from which the properties will be applied to
   *      out
   *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
   *      independent copy with the exception of the `data` or `aaData` parameters
   *      if they are present. This is so you can pass in a collection to
   *      DataTables and have that used as your data source without breaking the
   *      references
   *  @returns {object} out Reference, just for convenience - out === the return.
   *  @memberof DataTable#oApi
   *  @todo This doesn't take account of arrays inside the deep copied objects.
   */


  function _fnExtend(out, extender, breakRefs) {
    var val;

    for (var prop in extender) {
      if (extender.hasOwnProperty(prop)) {
        val = extender[prop];

        if ($.isPlainObject(val)) {
          if (!$.isPlainObject(out[prop])) {
            out[prop] = {};
          }

          $.extend(true, out[prop], val);
        } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }

    return out;
  }
  /**
   * Bind an event handers to allow a click or return key to activate the callback.
   * This is good for accessibility since a return on the keyboard will have the
   * same effect as a click, if the element has focus.
   *  @param {element} n Element to bind the action to
   *  @param {object} oData Data object to pass to the triggered function
   *  @param {function} fn Callback function for when the event is triggered
   *  @memberof DataTable#oApi
   */


  function _fnBindAction(n, oData, fn) {
    $(n).on('click.DT', oData, function (e) {
      $(n).trigger('blur'); // Remove focus outline for mouse users

      fn(e);
    }).on('keypress.DT', oData, function (e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on('selectstart.DT', function () {
      /* Take the brutal approach to cancelling text selection */
      return false;
    });
  }
  /**
   * Register a callback function. Easily allows a callback function to be added to
   * an array store of callback functions that can then all be called together.
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sStore Name of the array storage for the callbacks in oSettings
   *  @param {function} fn Function to be called back
   *  @param {string} sName Identifying name for the callback (i.e. a label)
   *  @memberof DataTable#oApi
   */


  function _fnCallbackReg(oSettings, sStore, fn, sName) {
    if (fn) {
      oSettings[sStore].push({
        "fn": fn,
        "sName": sName
      });
    }
  }
  /**
   * Fire callback functions and trigger events. Note that the loop over the
   * callback array store is done backwards! Further note that you do not want to
   * fire off triggers in time sensitive applications (for example cell creation)
   * as its slow.
   *  @param {object} settings dataTables settings object
   *  @param {string} callbackArr Name of the array storage for the callbacks in
   *      oSettings
   *  @param {string} eventName Name of the jQuery custom event to trigger. If
   *      null no trigger is fired
   *  @param {array} args Array of arguments to pass to the callback function /
   *      trigger
   *  @memberof DataTable#oApi
   */


  function _fnCallbackFire(settings, callbackArr, eventName, args) {
    var ret = [];

    if (callbackArr) {
      ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
        return val.fn.apply(settings.oInstance, args);
      });
    }

    if (eventName !== null) {
      var e = $.Event(eventName + '.dt');
      $(settings.nTable).trigger(e, args);
      ret.push(e.result);
    }

    return ret;
  }

  function _fnLengthOverflow(settings) {
    var start = settings._iDisplayStart,
        end = settings.fnDisplayEnd(),
        len = settings._iDisplayLength;
    /* If we have space to show extra rows (backing up from the end point - then do so */

    if (start >= end) {
      start = end - len;
    } // Keep the start record on the current page


    start -= start % len;

    if (len === -1 || start < 0) {
      start = 0;
    }

    settings._iDisplayStart = start;
  }

  function _fnRenderer(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];

    if ($.isPlainObject(renderer) && renderer[type]) {
      // Specific renderer for this type. If available use it, otherwise use
      // the default.
      return host[renderer[type]] || host._;
    } else if (typeof renderer === 'string') {
      // Common renderer - if there is one available for this type use it,
      // otherwise use the default
      return host[renderer] || host._;
    } // Use the default


    return host._;
  }
  /**
   * Detect the data source being used for the table. Used to simplify the code
   * a little (ajax) and to make it compress a little smaller.
   *
   *  @param {object} settings dataTables settings object
   *  @returns {string} Data source
   *  @memberof DataTable#oApi
   */


  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return 'ssp';
    } else if (settings.ajax || settings.sAjaxSource) {
      return 'ajax';
    }

    return 'dom';
  }
  /**
   * Computed structure of the DataTables API, defined by the options passed to
   * `DataTable.Api.register()` when building the API.
   *
   * The structure is built in order to speed creation and extension of the Api
   * objects since the extensions are effectively pre-parsed.
   *
   * The array is an array of objects with the following structure, where this
   * base array represents the Api prototype base:
   *
   *     [
   *       {
   *         name:      'data'                -- string   - Property name
   *         val:       function () {},       -- function - Api method (or undefined if just an object
   *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
   *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
   *       },
   *       {
   *         name:     'row'
   *         val:       {},
   *         methodExt: [ ... ],
   *         propExt:   [
   *           {
   *             name:      'data'
   *             val:       function () {},
   *             methodExt: [ ... ],
   *             propExt:   [ ... ]
   *           },
   *           ...
   *         ]
   *       }
   *     ]
   *
   * @type {Array}
   * @ignore
   */


  var __apiStruct = [];
  /**
   * `Array.prototype` reference.
   *
   * @type object
   * @ignore
   */

  var __arrayProto = Array.prototype;
  /**
   * Abstraction for `context` parameter of the `Api` constructor to allow it to
   * take several different forms for ease of use.
   *
   * Each of the input parameter types will be converted to a DataTables settings
   * object where possible.
   *
   * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
   *   of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   *   * `DataTables.Api` - API instance
   * @return {array|null} Matching DataTables settings objects. `null` or
   *   `undefined` is returned if no matching DataTable is found.
   * @ignore
   */

  var _toSettings = function (mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $.map(settings, function (el, i) {
      return el.nTable;
    });

    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oApi) {
      // DataTables settings object
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
      // Table node
      idx = $.inArray(mixed, tables);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === 'function') {
      return mixed.settings().toArray();
    } else if (typeof mixed === 'string') {
      // jQuery selector
      jq = $(mixed);
    } else if (mixed instanceof $) {
      // jQuery object (also DataTables instance)
      jq = mixed;
    }

    if (jq) {
      return jq.map(function (i) {
        idx = $.inArray(this, tables);
        return idx !== -1 ? settings[idx] : null;
      }).toArray();
    }
  };
  /**
   * DataTables API class - used to control and interface with  one or more
   * DataTables enhanced tables.
   *
   * The API class is heavily based on jQuery, presenting a chainable interface
   * that you can use to interact with tables. Each instance of the API class has
   * a "context" - i.e. the tables that it will operate on. This could be a single
   * table, all tables on a page or a sub-set thereof.
   *
   * Additionally the API is designed to allow you to easily work with the data in
   * the tables, retrieving and manipulating it as required. This is done by
   * presenting the API class as an array like interface. The contents of the
   * array depend upon the actions requested by each method (for example
   * `rows().nodes()` will return an array of nodes, while `rows().data()` will
   * return an array of objects or arrays depending upon your table's
   * configuration). The API object has a number of array like methods (`push`,
   * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
   * `unique` etc) to assist your working with the data held in a table.
   *
   * Most methods (those which return an Api instance) are chainable, which means
   * the return from a method call also has all of the methods available that the
   * top level object had. For example, these two calls are equivalent:
   *
   *     // Not chained
   *     api.row.add( {...} );
   *     api.draw();
   *
   *     // Chained
   *     api.row.add( {...} ).draw();
   *
   * @class DataTable.Api
   * @param {array|object|string|jQuery} context DataTable identifier. This is
   *   used to define which DataTables enhanced tables this API will operate on.
   *   Can be one of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   * @param {array} [data] Data to initialise the Api instance with.
   *
   * @example
   *   // Direct initialisation during DataTables construction
   *   var api = $('#example').DataTable();
   *
   * @example
   *   // Initialisation using a DataTables jQuery object
   *   var api = $('#example').dataTable().api();
   *
   * @example
   *   // Initialisation as a constructor
   *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
   */


  _Api = function (context, data) {
    if (!(this instanceof _Api)) {
      return new _Api(context, data);
    }

    var settings = [];

    var ctxSettings = function (o) {
      var a = _toSettings(o);

      if (a) {
        settings.push.apply(settings, a);
      }
    };

    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    } // Remove duplicates


    this.context = _unique(settings); // Initial data

    if (data) {
      $.merge(this, data);
    } // selector


    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };

    _Api.extend(this, this, __apiStruct);
  };

  DataTable.Api = _Api; // Don't destroy the existing prototype, just extend it. Required for jQuery 2's
  // isPlainObject.

  $.extend(_Api.prototype, {
    any: function () {
      return this.count() !== 0;
    },
    concat: __arrayProto.concat,
    context: [],
    // array of table settings objects
    count: function () {
      return this.flatten().length;
    },
    each: function (fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }

      return this;
    },
    eq: function (idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
    },
    filter: function (fn) {
      var a = [];

      if (__arrayProto.filter) {
        a = __arrayProto.filter.call(this, fn, this);
      } else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for (var i = 0, ien = this.length; i < ien; i++) {
          if (fn.call(this, this[i], i, this)) {
            a.push(this[i]);
          }
        }
      }

      return new _Api(this.context, a);
    },
    flatten: function () {
      var a = [];
      return new _Api(this.context, a.concat.apply(a, this.toArray()));
    },
    join: __arrayProto.join,
    indexOf: __arrayProto.indexOf || function (obj, start) {
      for (var i = start || 0, ien = this.length; i < ien; i++) {
        if (this[i] === obj) {
          return i;
        }
      }

      return -1;
    },
    iterator: function (flatten, type, fn, alwaysNew) {
      var a = [],
          ret,
          i,
          ien,
          j,
          jen,
          context = this.context,
          rows,
          items,
          item,
          selector = this.selector; // Argument shifting

      if (typeof flatten === 'string') {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }

      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api(context[i]);

        if (type === 'table') {
          ret = fn.call(apiInst, context[i], i);

          if (ret !== undefined) {
            a.push(ret);
          }
        } else if (type === 'columns' || type === 'rows') {
          // this has same length as context - one entry for each table
          ret = fn.call(apiInst, context[i], this[i], i);

          if (ret !== undefined) {
            a.push(ret);
          }
        } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
          // columns and rows share the same structure.
          // 'this' is an array of column indexes for each context
          items = this[i];

          if (type === 'column-rows') {
            rows = _selector_row_indexes(context[i], selector.opts);
          }

          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];

            if (type === 'cell') {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }

            if (ret !== undefined) {
              a.push(ret);
            }
          }
        }
      }

      if (a.length || alwaysNew) {
        var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }

      return this;
    },
    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
      // Bit cheeky...
      return this.indexOf.apply(this.toArray.reverse(), arguments);
    },
    length: 0,
    map: function (fn) {
      var a = [];

      if (__arrayProto.map) {
        a = __arrayProto.map.call(this, fn, this);
      } else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for (var i = 0, ien = this.length; i < ien; i++) {
          a.push(fn.call(this, this[i], i));
        }
      }

      return new _Api(this.context, a);
    },
    pluck: function (prop) {
      return this.map(function (el) {
        return el[prop];
      });
    },
    pop: __arrayProto.pop,
    push: __arrayProto.push,
    // Does not return an API instance
    reduce: __arrayProto.reduce || function (fn, init) {
      return _fnReduce(this, fn, init, 0, this.length, 1);
    },
    reduceRight: __arrayProto.reduceRight || function (fn, init) {
      return _fnReduce(this, fn, init, this.length - 1, -1, -1);
    },
    reverse: __arrayProto.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto.shift,
    slice: function () {
      return new _Api(this.context, this);
    },
    sort: __arrayProto.sort,
    // ? name - order?
    splice: __arrayProto.splice,
    toArray: function () {
      return __arrayProto.slice.call(this);
    },
    to$: function () {
      return $(this);
    },
    toJQuery: function () {
      return $(this);
    },
    unique: function () {
      return new _Api(this.context, _unique(this));
    },
    unshift: __arrayProto.unshift
  });

  _Api.extend = function (scope, obj, ext) {
    // Only extend API instances and static properties of the API
    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
      return;
    }

    var i,
        ien,
        struct,
        methodScoping = function (scope, fn, struc) {
      return function () {
        var ret = fn.apply(scope, arguments); // Method extension

        _Api.extend(ret, ret, struc.methodExt);

        return ret;
      };
    };

    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i]; // Value

      obj[struct.name] = struct.type === 'function' ? methodScoping(scope, struct.val, struct) : struct.type === 'object' ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true; // Property extension

      _Api.extend(scope, obj[struct.name], struct.propExt);
    }
  }; // @todo - Is there need for an augment function?
  // _Api.augment = function ( inst, name )
  // {
  // 	// Find src object in the structure from the name
  // 	var parts = name.split('.');
  // 	_Api.extend( inst, obj );
  // };
  //     [
  //       {
  //         name:      'data'                -- string   - Property name
  //         val:       function () {},       -- function - Api method (or undefined if just an object
  //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
  //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  //       },
  //       {
  //         name:     'row'
  //         val:       {},
  //         methodExt: [ ... ],
  //         propExt:   [
  //           {
  //             name:      'data'
  //             val:       function () {},
  //             methodExt: [ ... ],
  //             propExt:   [ ... ]
  //           },
  //           ...
  //         ]
  //       }
  //     ]


  _Api.register = _api_register = function (name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api.register(name[j], val);
      }

      return;
    }

    var i,
        ien,
        heir = name.split('.'),
        struct = __apiStruct,
        key,
        method;

    var find = function (src, name) {
      for (var i = 0, ien = src.length; i < ien; i++) {
        if (src[i].name === name) {
          return src[i];
        }
      }

      return null;
    };

    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf('()') !== -1;
      key = method ? heir[i].replace('()', '') : heir[i];
      var src = find(struct, key);

      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: 'object'
        };
        struct.push(src);
      }

      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === 'function' ? 'function' : $.isPlainObject(val) ? 'object' : 'other';
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };

  _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {
    _Api.register(pluralName, val);

    _Api.register(singularName, function () {
      var ret = val.apply(this, arguments);

      if (ret === this) {
        // Returned item is the API instance that was passed in, return it
        return this;
      } else if (ret instanceof _Api) {
        // New API instance returned, want the value from the first item
        // in the returned array for the singular result.
        return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : // Array results are 'enhanced'
        ret[0] : undefined;
      } // Non-API return - just fire it back


      return ret;
    });
  };
  /**
   * Selector for HTML tables. Apply the given selector to the give array of
   * DataTables settings objects.
   *
   * @param {string|integer} [selector] jQuery selector string or integer
   * @param  {array} Array of DataTables settings objects to be filtered
   * @return {array}
   * @ignore
   */


  var __table_selector = function (selector, a) {
    if (Array.isArray(selector)) {
      return $.map(selector, function (item) {
        return __table_selector(item, a);
      });
    } // Integer is used to pick out a table by index


    if (typeof selector === 'number') {
      return [a[selector]];
    } // Perform a jQuery selector on the table nodes


    var nodes = $.map(a, function (el, i) {
      return el.nTable;
    });
    return $(nodes).filter(selector).map(function (i) {
      // Need to translate back from the table node to the settings
      var idx = $.inArray(this, nodes);
      return a[idx];
    }).toArray();
  };
  /**
   * Context selector for the API's context (i.e. the tables the API instance
   * refers to.
   *
   * @name    DataTable.Api#tables
   * @param {string|integer} [selector] Selector to pick which tables the iterator
   *   should operate on. If not given, all tables in the current context are
   *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
   *   select multiple tables or as an integer to select a single table.
   * @returns {DataTable.Api} Returns a new API instance if a selector is given.
   */


  _api_register('tables()', function (selector) {
    // A new instance is created if there was a selector specified
    return selector !== undefined && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;
  });

  _api_register('table()', function (selector) {
    var tables = this.tables(selector);
    var ctx = tables.context; // Truncate to the first matched table

    return ctx.length ? new _Api(ctx[0]) : tables;
  });

  _api_registerPlural('tables().nodes()', 'table().node()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTable;
    }, 1);
  });

  _api_registerPlural('tables().body()', 'table().body()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTBody;
    }, 1);
  });

  _api_registerPlural('tables().header()', 'table().header()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTHead;
    }, 1);
  });

  _api_registerPlural('tables().footer()', 'table().footer()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTFoot;
    }, 1);
  });

  _api_registerPlural('tables().containers()', 'table().container()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  /**
   * Redraw the tables in the current context.
   */


  _api_register('draw()', function (paging) {
    return this.iterator('table', function (settings) {
      if (paging === 'page') {
        _fnDraw(settings);
      } else {
        if (typeof paging === 'string') {
          paging = paging === 'full-hold' ? false : true;
        }

        _fnReDraw(settings, paging === false);
      }
    });
  });
  /**
   * Get the current page index.
   *
   * @return {integer} Current page index (zero based)
   */

  /**
  * Set the current page.
  *
  * Note that if you attempt to show a page which does not exist, DataTables will
  * not throw an error, but rather reset the paging.
  *
  * @param {integer|string} action The paging action to take. This can be one of:
  *  * `integer` - The page index to jump to
  *  * `string` - An action to take:
  *    * `first` - Jump to first page.
  *    * `next` - Jump to the next page
  *    * `previous` - Jump to previous page
  *    * `last` - Jump to the last page.
  * @returns {DataTables.Api} this
  */


  _api_register('page()', function (action) {
    if (action === undefined) {
      return this.page.info().page; // not an expensive call
    } // else, have an action to take on all tables


    return this.iterator('table', function (settings) {
      _fnPageChange(settings, action);
    });
  });
  /**
   * Paging information for the first table in the current context.
   *
   * If you require paging information for another table, use the `table()` method
   * with a suitable selector.
   *
   * @return {object} Object with the following properties set:
   *  * `page` - Current page index (zero based - i.e. the first page is `0`)
   *  * `pages` - Total number of pages
   *  * `start` - Display index for the first record shown on the current page
   *  * `end` - Display index for the last record shown on the current page
   *  * `length` - Display length (number of records). Note that generally `start
   *    + length = end`, but this is not always true, for example if there are
   *    only 2 records to show on the final page, with a length of 10.
   *  * `recordsTotal` - Full data set length
   *  * `recordsDisplay` - Data set length once the current filtering criterion
   *    are applied.
   */


  _api_register('page.info()', function (action) {
    if (this.context.length === 0) {
      return undefined;
    }

    var settings = this.context[0],
        start = settings._iDisplayStart,
        len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
        visRecords = settings.fnRecordsDisplay(),
        all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource(settings) === 'ssp'
    };
  });
  /**
   * Get the current page length.
   *
   * @return {integer} Current page length. Note `-1` indicates that all records
   *   are to be shown.
   */

  /**
  * Set the current page length.
  *
  * @param {integer} Page length to set. Use `-1` to show all records.
  * @returns {DataTables.Api} this
  */


  _api_register('page.len()', function (len) {
    // Note that we can't call this function 'length()' because `length`
    // is a Javascript property of functions which defines how many arguments
    // the function expects.
    if (len === undefined) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
    } // else, set the page length


    return this.iterator('table', function (settings) {
      _fnLengthChange(settings, len);
    });
  });

  var __reload = function (settings, holdPosition, callback) {
    // Use the draw event to trigger a callback
    if (callback) {
      var api = new _Api(settings);
      api.one('draw', function () {
        callback(api.ajax.json());
      });
    }

    if (_fnDataSource(settings) == 'ssp') {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true); // Cancel an existing request


      var xhr = settings.jqXHR;

      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      } // Trigger xhr


      _fnBuildAjax(settings, [], function (json) {
        _fnClearTable(settings);

        var data = _fnAjaxDataSrc(settings, json);

        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }

        _fnReDraw(settings, holdPosition);

        _fnProcessingDisplay(settings, false);
      });
    }
  };
  /**
   * Get the JSON response from the last Ajax request that DataTables made to the
   * server. Note that this returns the JSON from the first table in the current
   * context.
   *
   * @return {object} JSON received from the server.
   */


  _api_register('ajax.json()', function () {
    var ctx = this.context;

    if (ctx.length > 0) {
      return ctx[0].json;
    } // else return undefined;

  });
  /**
   * Get the data submitted in the last Ajax request
   */


  _api_register('ajax.params()', function () {
    var ctx = this.context;

    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    } // else return undefined;

  });
  /**
   * Reload tables from the Ajax data source. Note that this function will
   * automatically re-draw the table when the remote data has been loaded.
   *
   * @param {boolean} [reset=true] Reset (default) or hold the current paging
   *   position. A full re-sort and re-filter is performed when this method is
   *   called, which is why the pagination reset is the default action.
   * @returns {DataTables.Api} this
   */


  _api_register('ajax.reload()', function (callback, resetPaging) {
    return this.iterator('table', function (settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  /**
   * Get the current Ajax URL. Note that this returns the URL from the first
   * table in the current context.
   *
   * @return {string} Current Ajax source URL
   */

  /**
  * Set the Ajax URL. Note that this will set the URL for all tables in the
  * current context.
  *
  * @param {string} url URL to set.
  * @returns {DataTables.Api} this
  */


  _api_register('ajax.url()', function (url) {
    var ctx = this.context;

    if (url === undefined) {
      // get
      if (ctx.length === 0) {
        return undefined;
      }

      ctx = ctx[0];
      return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
    } // set


    return this.iterator('table', function (settings) {
      if ($.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      } // No need to consider sAjaxSource here since DataTables gives priority
      // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
      // value of `sAjaxSource` redundant.

    });
  });
  /**
   * Load data from the newly set Ajax URL. Note that this method is only
   * available when `ajax.url()` is used to set a URL. Additionally, this method
   * has the same effect as calling `ajax.reload()` but is provided for
   * convenience when setting a new URL. Like `ajax.reload()` it will
   * automatically redraw the table once the remote data has been loaded.
   *
   * @returns {DataTables.Api} this
   */


  _api_register('ajax.url().load()', function (callback, resetPaging) {
    // Same as a reload, but makes sense to present it for easy access after a
    // url change
    return this.iterator('table', function (ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });

  var _selector_run = function (type, selector, selectFn, settings, opts) {
    var out = [],
        res,
        a,
        i,
        ien,
        j,
        jen,
        selectorType = typeof selector; // Can't just check for isArray here, as an API or jQuery instance might be
    // given with their array like look

    if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
      selector = [selector];
    }

    for (i = 0, ien = selector.length; i < ien; i++) {
      // Only split on simple strings - complex expressions will be jQuery selectors
      a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(',') : [selector[i]];

      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === 'string' ? a[j].trim() : a[j]);

        if (res && res.length) {
          out = out.concat(res);
        }
      }
    } // selector extensions


    var ext = _ext.selector[type];

    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }

    return _unique(out);
  };

  var _selector_opts = function (opts) {
    if (!opts) {
      opts = {};
    } // Backwards compatibility for 1.9- which used the terminology filter rather
    // than search


    if (opts.filter && opts.search === undefined) {
      opts.search = opts.filter;
    }

    return $.extend({
      search: 'none',
      order: 'current',
      page: 'all'
    }, opts);
  };

  var _selector_first = function (inst) {
    // Reduce the API instance to the first item found
    for (var i = 0, ien = inst.length; i < ien; i++) {
      if (inst[i].length > 0) {
        // Assign the first element to the first item in the instance
        // and truncate the instance and context
        inst[0] = inst[i];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [inst.context[i]];
        return inst;
      }
    } // Not found - return an empty instance


    inst.length = 0;
    return inst;
  };

  var _selector_row_indexes = function (settings, opts) {
    var i,
        ien,
        tmp,
        a = [],
        displayFiltered = settings.aiDisplay,
        displayMaster = settings.aiDisplayMaster;
    var search = opts.search,
        // none, applied, removed
    order = opts.order,
        // applied, current, index (original - compatibility with 1.9)
    page = opts.page; // all, current

    if (_fnDataSource(settings) == 'ssp') {
      // In server-side processing mode, most options are irrelevant since
      // rows not shown don't exist and the index order is the applied order
      // Removed is a special case - for consistency just return an empty
      // array
      return search === 'removed' ? [] : _range(0, displayMaster.length);
    } else if (page == 'current') {
      // Current page implies that order=current and fitler=applied, since it is
      // fairly senseless otherwise, regardless of what order and search actually
      // are
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == 'current' || order == 'applied') {
      if (search == 'none') {
        a = displayMaster.slice();
      } else if (search == 'applied') {
        a = displayFiltered.slice();
      } else if (search == 'removed') {
        // O(n+m) solution by creating a hash map
        var displayFilteredMap = {};

        for (var i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }

        a = $.map(displayMaster, function (el) {
          return !displayFilteredMap.hasOwnProperty(el) ? el : null;
        });
      }
    } else if (order == 'index' || order == 'original') {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (search == 'none') {
          a.push(i);
        } else {
          // applied | removed
          tmp = $.inArray(i, displayFiltered);

          if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
            a.push(i);
          }
        }
      }
    }

    return a;
  };
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Rows
   *
   * {}          - no selector - use all available rows
   * {integer}   - row aoData index
   * {node}      - TR node
   * {string}    - jQuery selector to apply to the TR elements
   * {array}     - jQuery array of nodes, or simply an array of TR nodes
   *
   */


  var __row_selector = function (settings, selector, opts) {
    var rows;

    var run = function (sel) {
      var selInt = _intVal(sel);

      var i, ien;
      var aoData = settings.aoData; // Short cut - selector is a number and no options provided (default is
      // all records, so no need to check if the index is in there, since it
      // must be - dev error if the index doesn't exist).

      if (selInt !== null && !opts) {
        return [selInt];
      }

      if (!rows) {
        rows = _selector_row_indexes(settings, opts);
      }

      if (selInt !== null && $.inArray(selInt, rows) !== -1) {
        // Selector - integer
        return [selInt];
      } else if (sel === null || sel === undefined || sel === '') {
        // Selector - none
        return rows;
      } // Selector - function


      if (typeof sel === 'function') {
        return $.map(rows, function (idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      } // Selector - node


      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex; // Property added by DT for fast lookup

        var cellIdx = sel._DT_CellIndex;

        if (rowIdx !== undefined) {
          // Make sure that the row is actually still present in the table
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $(sel).closest('*[data-dt-row]');
          return host.length ? [host.data('dt-row')] : [];
        }
      } // ID selector. Want to always be able to select rows by id, regardless
      // of if the tr element has been created or not, so can't rely upon
      // jQuery here - hence a custom implementation. This does not match
      // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
      // but to select it using a CSS selector engine (like Sizzle or
      // querySelect) it would need to need to be escaped for some characters.
      // DataTables simplifies this for row selectors since you can select
      // only a row. A # indicates an id any anything that follows is the id -
      // unescaped.


      if (typeof sel === 'string' && sel.charAt(0) === '#') {
        // get row index from id
        var rowObj = settings.aIds[sel.replace(/^#/, '')];

        if (rowObj !== undefined) {
          return [rowObj.idx];
        } // need to fall through to jQuery in case there is DOM id that
        // matches

      } // Get nodes in the order from the `rows` array with null values removed


      var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr')); // Selector - jQuery selector string, array of nodes or jQuery object/
      // As jQuery's .filter() allows jQuery objects to be passed in filter,
      // it also allows arrays, so this will cope with all three options


      return $(nodes).filter(sel).map(function () {
        return this._DT_RowIndex;
      }).toArray();
    };

    return _selector_run('row', selector, run, settings, opts);
  };

  _api_register('rows()', function (selector, opts) {
    // argument shifting
    if (selector === undefined) {
      selector = '';
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts(opts);
    var inst = this.iterator('table', function (settings) {
      return __row_selector(settings, selector, opts);
    }, 1); // Want argument shifting here and in __row_selector?

    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });

  _api_register('rows().nodes()', function () {
    return this.iterator('row', function (settings, row) {
      return settings.aoData[row].nTr || undefined;
    }, 1);
  });

  _api_register('rows().data()', function () {
    return this.iterator(true, 'rows', function (settings, rows) {
      return _pluck_order(settings.aoData, rows, '_aData');
    }, 1);
  });

  _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
    return this.iterator('row', function (settings, row) {
      var r = settings.aoData[row];
      return type === 'search' ? r._aFilterData : r._aSortData;
    }, 1);
  });

  _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
    return this.iterator('row', function (settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });

  _api_registerPlural('rows().indexes()', 'row().index()', function () {
    return this.iterator('row', function (settings, row) {
      return row;
    }, 1);
  });

  _api_registerPlural('rows().ids()', 'row().id()', function (hash) {
    var a = [];
    var context = this.context; // `iterator` will drop undefined values, but in this case we want them

    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? '#' : '') + id);
      }
    }

    return new _Api(context, a);
  });

  _api_registerPlural('rows().remove()', 'row().remove()', function () {
    var that = this;
    this.iterator('row', function (settings, row, thatIdx) {
      var data = settings.aoData;
      var rowData = data[row];
      var i, ien, j, jen;
      var loopRow, loopCells;
      data.splice(row, 1); // Update the cached indexes

      for (i = 0, ien = data.length; i < ien; i++) {
        loopRow = data[i];
        loopCells = loopRow.anCells; // Rows

        if (loopRow.nTr !== null) {
          loopRow.nTr._DT_RowIndex = i;
        } // Cells


        if (loopCells !== null) {
          for (j = 0, jen = loopCells.length; j < jen; j++) {
            loopCells[j]._DT_CellIndex.row = i;
          }
        }
      } // Delete from the display arrays


      _fnDeleteIndex(settings.aiDisplayMaster, row);

      _fnDeleteIndex(settings.aiDisplay, row);

      _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes
      // For server-side processing tables - subtract the deleted row from the count


      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      } // Check for an 'overflow' they case for displaying the table


      _fnLengthOverflow(settings); // Remove the row's ID reference if there is one


      var id = settings.rowIdFn(rowData._aData);

      if (id !== undefined) {
        delete settings.aIds[id];
      }
    });
    this.iterator('table', function (settings) {
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        settings.aoData[i].idx = i;
      }
    });
    return this;
  });

  _api_register('rows.add()', function (rows) {
    var newRows = this.iterator('table', function (settings) {
      var row, i, ien;
      var out = [];

      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];

        if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }

      return out;
    }, 1); // Return an Api.rows() extended instance, so rows().nodes() etc can be used

    var modRows = this.rows(-1);
    modRows.pop();
    $.merge(modRows, newRows);
    return modRows;
  });
  /**
   *
   */


  _api_register('row()', function (selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });

  _api_register('row().data()', function (data) {
    var ctx = this.context;

    if (data === undefined) {
      // Get
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
    } // Set


    var row = ctx[0].aoData[this[0]];
    row._aData = data; // If the DOM has an id, and the data source is an array

    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
    } // Automatically invalidate


    _fnInvalidate(ctx[0], this[0], 'data');

    return this;
  });

  _api_register('row().node()', function () {
    var ctx = this.context;
    return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
  });

  _api_register('row.add()', function (row) {
    // Allow a jQuery object to be passed in - only a single row is added from
    // it though - the first element in the set
    if (row instanceof $ && row.length) {
      row = row[0];
    }

    var rows = this.iterator('table', function (settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
        return _fnAddTr(settings, row)[0];
      }

      return _fnAddData(settings, row);
    }); // Return an Api.rows() extended instance, with the newly added row selected

    return this.row(rows[0]);
  });

  var __details_add = function (ctx, row, data, klass) {
    // Convert to array of TR elements
    var rows = [];

    var addRow = function (r, k) {
      // Recursion to allow for arrays of jQuery objects
      if (Array.isArray(r) || r instanceof $) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }

        return;
      } // If we get a TR element, then just add it directly - up to the dev
      // to add the correct number of columns etc


      if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
        rows.push(r);
      } else {
        // Otherwise create a row with a wrapper
        var created = $('<tr><td></td></tr>').addClass(k);
        $('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };

    addRow(data, klass);

    if (row._details) {
      row._details.detach();
    }

    row._details = $(rows); // If the children were already shown, that state should be retained

    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };

  var __details_remove = function (api, idx) {
    var ctx = api.context;

    if (ctx.length) {
      var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

      if (row && row._details) {
        row._details.remove();

        row._detailsShow = undefined;
        row._details = undefined;
      }
    }
  };

  var __details_display = function (api, show) {
    var ctx = api.context;

    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];

      if (row._details) {
        row._detailsShow = show;

        if (show) {
          row._details.insertAfter(row.nTr);
        } else {
          row._details.detach();
        }

        __details_events(ctx[0]);
      }
    }
  };

  var __details_events = function (settings) {
    var api = new _Api(settings);
    var namespace = '.dt.DT_details';
    var drawEvent = 'draw' + namespace;
    var colvisEvent = 'column-visibility' + namespace;
    var destroyEvent = 'destroy' + namespace;
    var data = settings.aoData;
    api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

    if (_pluck(data, '_details').length > 0) {
      // On each draw, insert the required elements into the document
      api.on(drawEvent, function (e, ctx) {
        if (settings !== ctx) {
          return;
        }

        api.rows({
          page: 'current'
        }).eq(0).each(function (idx) {
          // Internal data grab
          var row = data[idx];

          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      }); // Column visibility change - update the colspan

      api.on(colvisEvent, function (e, ctx, idx, vis) {
        if (settings !== ctx) {
          return;
        } // Update the colspan for the details rows (note, only if it already has
        // a colspan)


        var row,
            visible = _fnVisbleColumns(ctx);

        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];

          if (row._details) {
            row._details.children('td[colspan]').attr('colspan', visible);
          }
        }
      }); // Table destroyed - nuke any child rows

      api.on(destroyEvent, function (e, ctx) {
        if (settings !== ctx) {
          return;
        }

        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i]._details) {
            __details_remove(api, i);
          }
        }
      });
    }
  }; // Strings for the method names to help minification


  var _emp = '';

  var _child_obj = _emp + 'row().child';

  var _child_mth = _child_obj + '()'; // data can be:
  //  tr
  //  string
  //  jQuery or array of any of the above


  _api_register(_child_mth, function (data, klass) {
    var ctx = this.context;

    if (data === undefined) {
      // get
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
    } else if (data === true) {
      // show
      this.child.show();
    } else if (data === false) {
      // remove
      __details_remove(this);
    } else if (ctx.length && this.length) {
      // set
      __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }

    return this;
  });

  _api_register([_child_obj + '.show()', _child_mth + '.show()' // only when `child()` was called with parameters (without
  ], function (show) {
    // it returns an object and this method is not executed)
    __details_display(this, true);

    return this;
  });

  _api_register([_child_obj + '.hide()', _child_mth + '.hide()' // only when `child()` was called with parameters (without
  ], function () {
    // it returns an object and this method is not executed)
    __details_display(this, false);

    return this;
  });

  _api_register([_child_obj + '.remove()', _child_mth + '.remove()' // only when `child()` was called with parameters (without
  ], function () {
    // it returns an object and this method is not executed)
    __details_remove(this);

    return this;
  });

  _api_register(_child_obj + '.isShown()', function () {
    var ctx = this.context;

    if (ctx.length && this.length) {
      // _detailsShown as false or undefined will fall through to return false
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }

    return false;
  });
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Columns
   *
   * {integer}           - column index (>=0 count from left, <0 count from right)
   * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
   * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
   * "{string}:name"     - column name
   * "{string}"          - jQuery selector on column header nodes
   *
   */
  // can be an array of these items, comma separated list, or an array of comma
  // separated lists


  var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/; // r1 and r2 are redundant - but it means that the parameters match for the
  // iterator callback in columns().data()

  var __columnData = function (settings, column, r1, r2, rows) {
    var a = [];

    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData(settings, rows[row], column));
    }

    return a;
  };

  var __column_selector = function (settings, selector, opts) {
    var columns = settings.aoColumns,
        names = _pluck(columns, 'sName'),
        nodes = _pluck(columns, 'nTh');

    var run = function (s) {
      var selInt = _intVal(s); // Selector - all


      if (s === '') {
        return _range(columns.length);
      } // Selector - index


      if (selInt !== null) {
        return [selInt >= 0 ? selInt : // Count from left
        columns.length + selInt // Count from right (+ because its a negative value)
        ];
      } // Selector = function


      if (typeof s === 'function') {
        var rows = _selector_row_indexes(settings, opts);

        return $.map(columns, function (col, idx) {
          return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
        });
      } // jQuery or string selector


      var match = typeof s === 'string' ? s.match(__re_column_selector) : '';

      if (match) {
        switch (match[2]) {
          case 'visIdx':
          case 'visible':
            var idx = parseInt(match[1], 10); // Visible index given, convert to column index

            if (idx < 0) {
              // Counting from the right
              var visColumns = $.map(columns, function (col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            } // Counting from the left


            return [_fnVisibleToColumnIndex(settings, idx)];

          case 'name':
            // match by name. `names` is column index complete and in order
            return $.map(names, function (name, i) {
              return name === match[1] ? i : null;
            });

          default:
            return [];
        }
      } // Cell in the table body


      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      } // jQuery selector on the TH elements for the columns


      var jqResult = $(nodes).filter(s).map(function () {
        return $.inArray(this, nodes); // `nodes` is column index complete and in order
      }).toArray();

      if (jqResult.length || !s.nodeName) {
        return jqResult;
      } // Otherwise a node which might have a `dt-column` data attribute, or be
      // a child or such an element


      var host = $(s).closest('*[data-dt-column]');
      return host.length ? [host.data('dt-column')] : [];
    };

    return _selector_run('column', selector, run, settings, opts);
  };

  var __setColumnVis = function (settings, column, vis) {
    var cols = settings.aoColumns,
        col = cols[column],
        data = settings.aoData,
        row,
        cells,
        i,
        ien,
        tr; // Get

    if (vis === undefined) {
      return col.bVisible;
    } // Set
    // No change


    if (col.bVisible === vis) {
      return;
    }

    if (vis) {
      // Insert column
      // Need to decide if we should use appendChild or insertBefore
      var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

      for (i = 0, ien = data.length; i < ien; i++) {
        tr = data[i].nTr;
        cells = data[i].anCells;

        if (tr) {
          // insertBefore can act like appendChild if 2nd arg is null
          tr.insertBefore(cells[column], cells[insertBefore] || null);
        }
      }
    } else {
      // Remove column
      $(_pluck(settings.aoData, 'anCells', column)).detach();
    } // Common actions


    col.bVisible = vis;
  };

  _api_register('columns()', function (selector, opts) {
    // argument shifting
    if (selector === undefined) {
      selector = '';
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts(opts);
    var inst = this.iterator('table', function (settings) {
      return __column_selector(settings, selector, opts);
    }, 1); // Want argument shifting here and in _row_selector?

    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });

  _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].nTh;
    }, 1);
  });

  _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].nTf;
    }, 1);
  });

  _api_registerPlural('columns().data()', 'column().data()', function () {
    return this.iterator('column-rows', __columnData, 1);
  });

  _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });

  _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
    return this.iterator('column-rows', function (settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
    }, 1);
  });

  _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
    return this.iterator('column-rows', function (settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, 'anCells', column);
    }, 1);
  });

  _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
    var that = this;
    var ret = this.iterator('column', function (settings, column) {
      if (vis === undefined) {
        return settings.aoColumns[column].bVisible;
      } // else


      __setColumnVis(settings, column, vis);
    }); // Group the column visibility changes

    if (vis !== undefined) {
      this.iterator('table', function (settings) {
        // Redraw the header after changes
        _fnDrawHead(settings, settings.aoHeader);

        _fnDrawHead(settings, settings.aoFooter); // Update colspan for no records display. Child rows and extensions will use their own
        // listeners to do this - only need to update the empty table item here


        if (!settings.aiDisplay.length) {
          $(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
        }

        _fnSaveState(settings); // Second loop once the first is done for events


        that.iterator('column', function (settings, column) {
          _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
        });

        if (calc === undefined || calc) {
          that.columns.adjust();
        }
      });
    }

    return ret;
  });

  _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
    return this.iterator('column', function (settings, column) {
      return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });

  _api_register('columns.adjust()', function () {
    return this.iterator('table', function (settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });

  _api_register('column.index()', function (type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];

      if (type === 'fromVisible' || type === 'toData') {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else if (type === 'fromData' || type === 'toVisible') {
        return _fnColumnIndexToVisible(ctx, idx);
      }
    }
  });

  _api_register('column()', function (selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });

  var __cell_selector = function (settings, selector, opts) {
    var data = settings.aoData;

    var rows = _selector_row_indexes(settings, opts);

    var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));

    var allCells = $(_flatten([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;

    var run = function (s) {
      var fnSelector = typeof s === 'function';

      if (s === null || s === undefined || fnSelector) {
        // All cells and function selectors
        a = [];

        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];

          for (j = 0; j < columns; j++) {
            o = {
              row: row,
              column: j
            };

            if (fnSelector) {
              // Selector - function
              host = data[row];

              if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              // Selector - all
              a.push(o);
            }
          }
        }

        return a;
      } // Selector - index


      if ($.isPlainObject(s)) {
        // Valid cell index and its in the array of selectable rows
        return s.column !== undefined && s.row !== undefined && $.inArray(s.row, rows) !== -1 ? [s] : [];
      } // Selector - jQuery filtered cells


      var jqResult = allCells.filter(s).map(function (i, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();

      if (jqResult.length || !s.nodeName) {
        return jqResult;
      } // Otherwise the selector is a node, and there is one last option - the
      // element might be a child of an element which has dt-row and dt-column
      // data attributes


      host = $(s).closest('*[data-dt-row]');
      return host.length ? [{
        row: host.data('dt-row'),
        column: host.data('dt-column')
      }] : [];
    };

    return _selector_run('cell', selector, run, settings, opts);
  };

  _api_register('cells()', function (rowSelector, columnSelector, opts) {
    // Argument shifting
    if ($.isPlainObject(rowSelector)) {
      // Indexes
      if (rowSelector.row === undefined) {
        // Selector options in first parameter
        opts = rowSelector;
        rowSelector = null;
      } else {
        // Cell index objects in first parameter
        opts = columnSelector;
        columnSelector = null;
      }
    }

    if ($.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    } // Cell selector


    if (columnSelector === null || columnSelector === undefined) {
      return this.iterator('table', function (settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    } // The default built in options need to apply to row and columns


    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {}; // Row + column selector

    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator('table', function (settings, idx) {
      var a = [];

      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }

      return a;
    }, 1); // There is currently only one extension which uses a cell selector extension
    // It is a _major_ performance drag to run this if it isn't needed, so this is
    // an extension specific check at the moment

    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts: opts
    });
    return cells;
  });

  _api_registerPlural('cells().nodes()', 'cell().node()', function () {
    return this.iterator('cell', function (settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : undefined;
    }, 1);
  });

  _api_register('cells().data()', function () {
    return this.iterator('cell', function (settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });

  _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
    type = type === 'search' ? '_aFilterData' : '_aSortData';
    return this.iterator('cell', function (settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });

  _api_registerPlural('cells().render()', 'cell().render()', function (type) {
    return this.iterator('cell', function (settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });

  _api_registerPlural('cells().indexes()', 'cell().index()', function () {
    return this.iterator('cell', function (settings, row, column) {
      return {
        row: row,
        column: column,
        columnVisible: _fnColumnIndexToVisible(settings, column)
      };
    }, 1);
  });

  _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
    return this.iterator('cell', function (settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });

  _api_register('cell()', function (rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });

  _api_register('cell().data()', function (data) {
    var ctx = this.context;
    var cell = this[0];

    if (data === undefined) {
      // Get
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
    } // Set


    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);

    _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

    return this;
  });
  /**
   * Get current ordering (sorting) that has been applied to the table.
   *
   * @returns {array} 2D array containing the sorting information for the first
   *   table in the current context. Each element in the parent array represents
   *   a column being sorted upon (i.e. multi-sorting with two columns would have
   *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
   *   the column index that the sorting condition applies to, the second is the
   *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
   *   index of the sorting order from the `column.sorting` initialisation array.
   */

  /**
  * Set the ordering for the table.
  *
  * @param {integer} order Column index to sort upon.
  * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
  * @returns {DataTables.Api} this
  */

  /**
  * Set the ordering for the table.
  *
  * @param {array} order 1D array of sorting information to be applied.
  * @param {array} [...] Optional additional sorting conditions
  * @returns {DataTables.Api} this
  */

  /**
  * Set the ordering for the table.
  *
  * @param {array} order 2D array of sorting information to be applied.
  * @returns {DataTables.Api} this
  */


  _api_register('order()', function (order, dir) {
    var ctx = this.context;

    if (order === undefined) {
      // get
      return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
    } // set


    if (typeof order === 'number') {
      // Simple column / direction passed in
      order = [[order, dir]];
    } else if (order.length && !Array.isArray(order[0])) {
      // Arguments passed in (list of 1D arrays)
      order = Array.prototype.slice.call(arguments);
    } // otherwise a 2D array was passed in


    return this.iterator('table', function (settings) {
      settings.aaSorting = order.slice();
    });
  });
  /**
   * Attach a sort listener to an element for a given column
   *
   * @param {node|jQuery|string} node Identifier for the element(s) to attach the
   *   listener to. This can take the form of a single DOM node, a jQuery
   *   collection of nodes or a jQuery selector which will identify the node(s).
   * @param {integer} column the column that a click on this node will sort on
   * @param {function} [callback] callback function when sort is run
   * @returns {DataTables.Api} this
   */


  _api_register('order.listener()', function (node, column, callback) {
    return this.iterator('table', function (settings) {
      _fnSortAttachListener(settings, node, column, callback);
    });
  });

  _api_register('order.fixed()', function (set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;
      return Array.isArray(fixed) ? {
        pre: fixed
      } : fixed;
    }

    return this.iterator('table', function (settings) {
      settings.aaSortingFixed = $.extend(true, {}, set);
    });
  }); // Order by the selected column(s)


  _api_register(['columns().order()', 'column().order()'], function (dir) {
    var that = this;
    return this.iterator('table', function (settings, i) {
      var sort = [];
      $.each(that[i], function (j, col) {
        sort.push([col, dir]);
      });
      settings.aaSorting = sort;
    });
  });

  _api_register('search()', function (input, regex, smart, caseInsen) {
    var ctx = this.context;

    if (input === undefined) {
      // get
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
    } // set


    return this.iterator('table', function (settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }

      _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      }), 1);
    });
  });

  _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
    return this.iterator('column', function (settings, column) {
      var preSearch = settings.aoPreSearchCols;

      if (input === undefined) {
        // get
        return preSearch[column].sSearch;
      } // set


      if (!settings.oFeatures.bFilter) {
        return;
      }

      $.extend(preSearch[column], {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      });

      _fnFilterComplete(settings, settings.oPreviousSearch, 1);
    });
  });
  /*
   * State API methods
   */


  _api_register('state()', function () {
    return this.context.length ? this.context[0].oSavedState : null;
  });

  _api_register('state.clear()', function () {
    return this.iterator('table', function (settings) {
      // Save an empty object
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });

  _api_register('state.loaded()', function () {
    return this.context.length ? this.context[0].oLoadedState : null;
  });

  _api_register('state.save()', function () {
    return this.iterator('table', function (settings) {
      _fnSaveState(settings);
    });
  });
  /**
   * Provide a common method for plug-ins to check the version of DataTables being
   * used, in order to ensure compatibility.
   *
   *  @param {string} version Version string to check for, in the format "X.Y.Z".
   *    Note that the formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to
   *    the required version, or false if this version of DataTales is not
   *    suitable
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
   */


  DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
    var aThis = DataTable.version.split('.');
    var aThat = version.split('.');
    var iThis, iThat;

    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0; // Parts are the same, keep comparing

      if (iThis === iThat) {
        continue;
      } // Parts are different, return immediately


      return iThis > iThat;
    }

    return true;
  };
  /**
   * Check if a `<table>` node is a DataTable table already or not.
   *
   *  @param {node|jquery|string} table Table node, jQuery object or jQuery
   *      selector for the table to test. Note that if more than more than one
   *      table is passed on, only the first will be checked
   *  @returns {boolean} true the table given is a DataTable, or false otherwise
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
   *      $('#example').dataTable();
   *    }
   */


  DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
    var t = $(table).get(0);
    var is = false;

    if (table instanceof DataTable.Api) {
      return true;
    }

    $.each(DataTable.settings, function (i, o) {
      var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  /**
   * Get all DataTable tables that have been initialised - optionally you can
   * select to get only currently visible tables.
   *
   *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
   *    or visible tables only.
   *  @returns {array} Array of `table` nodes (not DataTable instances) which are
   *    DataTables
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    $.each( $.fn.dataTable.tables(true), function () {
   *      $(table).DataTable().columns.adjust();
   *    } );
   */


  DataTable.tables = DataTable.fnTables = function (visible) {
    var api = false;

    if ($.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }

    var a = $.map(DataTable.settings, function (o) {
      if (!visible || visible && $(o.nTable).is(':visible')) {
        return o.nTable;
      }
    });
    return api ? new _Api(a) : a;
  };
  /**
   * Convert from camel case parameters to Hungarian notation. This is made public
   * for the extensions to provide the same ability as DataTables core to accept
   * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
   * parameters.
   *
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   */


  DataTable.camelToHungarian = _fnCamelToHungarian;
  /**
   *
   */

  _api_register('$()', function (selector, opts) {
    var rows = this.rows(opts).nodes(),
        // Get all rows
    jqRows = $(rows);
    return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
  }); // jQuery functions to operate on the tables


  $.each(['on', 'one', 'off'], function (i, key) {
    _api_register(key + '()', function ()
    /* event, handler */
    {
      var args = Array.prototype.slice.call(arguments); // Add the `dt` namespace automatically if it isn't already present

      args[0] = $.map(args[0].split(/\s/), function (e) {
        return !e.match(/\.dt\b/) ? e + '.dt' : e;
      }).join(' ');
      var inst = $(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });

  _api_register('clear()', function () {
    return this.iterator('table', function (settings) {
      _fnClearTable(settings);
    });
  });

  _api_register('settings()', function () {
    return new _Api(this.context, this.context);
  });

  _api_register('init()', function () {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });

  _api_register('data()', function () {
    return this.iterator('table', function (settings) {
      return _pluck(settings.aoData, '_aData');
    }).flatten();
  });

  _api_register('destroy()', function (remove) {
    remove = remove || false;
    return this.iterator('table', function (settings) {
      var orig = settings.nTableWrapper.parentNode;
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $(table);
      var jqTbody = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows = $.map(settings.aoData, function (r) {
        return r.nTr;
      });
      var i, ien; // Flag to note that the table is currently being destroyed - no action
      // should be taken

      settings.bDestroying = true; // Fire off the destroy callbacks for plug-ins etc

      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]); // If not being removed from the document, make all columns visible


      if (!remove) {
        new _Api(settings).columns().visible(true);
      } // Blitz all `DT` namespaced events (these are internal events, the
      // lowercase, `dt` events are user subscribed and they are responsible
      // for removing them


      jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
      $(window).off('.DT-' + settings.sInstance); // When scrolling we had to break the table up - restore it

      if (table != thead.parentNode) {
        jqTable.children('thead').detach();
        jqTable.append(thead);
      }

      if (tfoot && table != tfoot.parentNode) {
        jqTable.children('tfoot').detach();
        jqTable.append(tfoot);
      }

      settings.aaSorting = [];
      settings.aaSortingFixed = [];

      _fnSortingClasses(settings);

      $(rows).removeClass(settings.asStripeClasses.join(' '));
      $('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone); // Add the TR elements back into the table in their original order

      jqTbody.children().detach();
      jqTbody.append(rows); // Remove the DataTables generated nodes, events and classes

      var removedMethod = remove ? 'remove' : 'detach';
      jqTable[removedMethod]();
      jqWrapper[removedMethod](); // If we need to reattach the table to the document

      if (!remove && orig) {
        // insertBefore acts like appendChild if !arg[1]
        orig.insertBefore(table, settings.nTableReinsertBefore); // Restore the width of the original table - was read from the style property,
        // so we can restore directly to that

        jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable); // If the were originally stripe classes - then we add them back here.
        // Note this is not fool proof (for example if not all rows had stripe
        // classes - but it's a good effort without getting carried away

        ien = settings.asDestroyStripes.length;

        if (ien) {
          jqTbody.children().each(function (i) {
            $(this).addClass(settings.asDestroyStripes[i % ien]);
          });
        }
      }
      /* Remove the settings object from the settings array */


      var idx = $.inArray(settings, DataTable.settings);

      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  }); // Add the `every()` method for rows, columns and cells in a compact form


  $.each(['column', 'row', 'cell'], function (i, type) {
    _api_register(type + 's().every()', function (fn) {
      var opts = this.selector.opts;
      var api = this;
      return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {
        // Rows and columns:
        //  arg1 - index
        //  arg2 - table counter
        //  arg3 - loop counter
        //  arg4 - undefined
        // Cells:
        //  arg1 - row index
        //  arg2 - column index
        //  arg3 - table counter
        //  arg4 - loop counter
        fn.call(api[type](arg1, type === 'cell' ? arg2 : opts, type === 'cell' ? opts : undefined), arg1, arg2, arg3, arg4);
      });
    });
  }); // i18n method for extensions to be able to use the language object from the
  // DataTable

  _api_register('i18n()', function (token, def, plural) {
    var ctx = this.context[0];

    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

    if (resolved === undefined) {
      resolved = def;
    }

    if (plural !== undefined && $.isPlainObject(resolved)) {
      resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
    }

    return resolved.replace('%d', plural); // nb: plural might be undefined,
  });
  /**
   * Version string for plug-ins to check compatibility. Allowed format is
   * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
   * only for non-release builds. See http://semver.org/ for more information.
   *  @member
   *  @type string
   *  @default Version number
   */


  DataTable.version = "1.10.22";
  /**
   * Private data store, containing all of the settings objects that are
   * created for the tables on a given page.
   *
   * Note that the `DataTable.settings` object is aliased to
   * `jQuery.fn.dataTableExt` through which it may be accessed and
   * manipulated, or `jQuery.fn.dataTable.settings`.
   *  @member
   *  @type array
   *  @default []
   *  @private
   */

  DataTable.settings = [];
  /**
   * Object models container, for the various models that DataTables has
   * available to it. These models define the objects that are used to hold
   * the active state and configuration of the table.
   *  @namespace
   */

  DataTable.models = {};
  /**
   * Template object for the way in which DataTables holds information about
   * search information for the global filter and individual column filters.
   *  @namespace
   */

  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,

    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",

    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,

    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true
  };
  /**
   * Template object for the way in which DataTables holds information about
   * each individual row. This is the object format used for the settings
   * aoData array.
   *  @namespace
   */

  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,

    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,

    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],

    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,

    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,

    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,

    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",

    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null,

    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     *  @type integer
     *  @default -1
     *  @private
     */
    "idx": -1
  };
  /**
   * Template object for the column information object in DataTables. This object
   * is held in the settings aoColumns array and contains all the information that
   * DataTables needs about each individual column.
   *
   * Note that this object is related to {@link DataTable.defaults.column}
   * but this one is the internal data store for DataTables's cache of columns.
   * It should NOT be manipulated outside of DataTables. Any configuration should
   * be done through the initialisation options.
   *  @namespace
   */

  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,

    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,

    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,

    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,

    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,

    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,

    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,

    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,

    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,

    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,

    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,

    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,

    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,

    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,

    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,

    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,

    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": 'std',

    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,

    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,

    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,

    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,

    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,

    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };
  /*
   * Developer note: The properties of the object below are given in Hungarian
   * notation, that was used as the interface for DataTables prior to v1.10, however
   * from v1.10 onwards the primary interface is camel case. In order to avoid
   * breaking backwards compatibility utterly with this change, the Hungarian
   * version is still, internally the primary interface, but is is not documented
   * - hence the @name tags in each doc comment. This allows a Javascript function
   * to create a map from Hungarian notation to camel case (going the other direction
   * would require each property to be listed, which would add around 3K to the size
   * of DataTables, while this method is about a 0.5K hit).
   *
   * Ultimately this does pave the way for Hungarian notation to be dropped
   * completely, but that is a massive amount of work and will break current
   * installs (therefore is on-hold until v2).
   */

  /**
   * Initialisation options that can be given to DataTables at initialisation
   * time.
   *  @namespace
   */

  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,

    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0, 'asc']],

    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],

    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,

    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [10, 25, 50, 100],

    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,

    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,

    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],

    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,

    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,

    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,

    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,

    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,

    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,

    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,

    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,

    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,

    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,

    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,

    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,

    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,

    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,

    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,

    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,

    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,

    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,

    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,

    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,

    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function (toFormat) {
      return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
    },

    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,

    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,

    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,

    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,

    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,

    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} callback Callback that can be executed when done. It
     *    should be passed the loaded state object.
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings, callback) {
     *          $.ajax( {
     *            "url": "/state_load",
     *            "dataType": "json",
     *            "success": function (json) {
     *              callback( json );
     *            }
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function (settings) {
      try {
        return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
      } catch (e) {
        return {};
      }
    },

    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,

    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,

    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function (settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
      } catch (e) {}
    },

    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,

    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,

    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,

    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,

    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,

    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,

    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},

    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",

        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },

      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",

        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",

        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",

        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },

      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",

      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",

      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",

      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",

      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",

      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",

      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",

      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",

      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "Loading...",

      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *  @default Processing...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "Processing...",

      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",

      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",

      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",

      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "No matching records found"
    },

    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $.extend({}, DataTable.models.oSearch),

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,

    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",

    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     *  @type integer
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.searchDelay
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchDelay": 200
     *      } );
     *    } )
     */
    "searchDelay": null,

    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     *  
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",

    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",

    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",

    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",

    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null,

    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     *  @type string
     *  @default DT_RowId
     *
     *  @name DataTable.defaults.rowId
     */
    "rowId": "DT_RowId"
  };

  _fnHungarianMap(DataTable.defaults);
  /*
   * Developer note - See note in model.defaults.js about the use of Hungarian
   * notation and camel case.
   */

  /**
   * Column options that can be given to DataTables at initialisation time.
   *  @namespace
   */


  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,

    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": ['asc', 'desc'],

    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,

    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,

    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,

    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */

    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "details.0" },
     *          { "data": "details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed dislay and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,

    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,

    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",

    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,

    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",

    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",

    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,

    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,

    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };

  _fnHungarianMap(DataTable.defaults.column);
  /**
   * DataTables settings object - this holds all the information needed for a
   * given table, including configuration, data and current application of the
   * table options. DataTables does not have a single instance for each DataTable
   * with the settings attached to that instance, but rather instances of the
   * DataTable "class" are created on-the-fly as needed (typically by a
   * $().dataTable() call) and the settings object is then applied to that
   * instance.
   *
   * Note that this object is related to {@link DataTable.defaults} but this
   * one is the internal data store for DataTables's cache of columns. It should
   * NOT be manipulated outside of DataTables. Any configuration should be done
   * through the initialisation options.
   *  @namespace
   *  @todo Really should attach the settings object to individual instances so we
   *    don't need to create new instances on each $().dataTable() call (if the
   *    table already exists). It would also save passing oSettings around and
   *    into every single function. However, this is a very significant
   *    architecture change for DataTables and will almost certainly break
   *    backwards compatibility with older installations. This is something that
   *    will be done in 2.0.
   */


  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,

      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all fro DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,

      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,

      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,

      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,

      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,

      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,

      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,

      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,

      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,

      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,

      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },

    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,

      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,

      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,

      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,

      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },

    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },

    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,

      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false,

      /**
       * Flag for if `getBoundingClientRect` is fully supported or not
       *  @type boolean
       *  @default false
       */
      "bBounding": false,

      /**
       * Browser scrollbar width
       *  @type integer
       *  @default 0
       */
      "barWidth": 0
    },
    "ajax": null,

    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],

    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],

    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],

    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],

    /**
     * Map of row ids to data indexes
     *  @type object
     *  @default {}
     */
    "aIds": {},

    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],

    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],

    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],

    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},

    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],

    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,

    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],

    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,

    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],

    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,

    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],

    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],

    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],

    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],

    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],

    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],

    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],

    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],

    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],

    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],

    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",

    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,

    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,

    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,

    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,

    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,

    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,

    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,

    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],

    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,

    /**
     * Search delay (in mS)
     *  @type integer
     *  @default null
     */
    "searchDelay": null,

    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",

    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,

    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],

    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],

    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,

    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,

    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,

    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,

    /**
     * Note if draw should be blocked while getting data
     *  @type boolean
     *  @default true
     */
    "bAjaxDataGet": true,

    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,

    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": undefined,

    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": undefined,

    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,

    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],

    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,

    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,

    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,

    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,

    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,

    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,

    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,

    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,

    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,

    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,

    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,

    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,

    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,

    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],

    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function () {
      return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },

    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function () {
      return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },

    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function () {
      var len = this._iDisplayLength,
          start = this._iDisplayStart,
          calc = start + len,
          records = this.aiDisplay.length,
          features = this.oFeatures,
          paginate = features.bPaginate;

      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },

    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,

    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,

    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,

    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],

    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {},

    /**
     * Function used to get a row's id from the row's data
     *  @type function
     *  @default null
     */
    "rowIdFn": null,

    /**
     * Data location where to store a row's id
     *  @type string
     *  @default null
     */
    "rowId": null
  };
  /**
   * Extension object for DataTables that is used to provide all extension
   * options.
   *
   * Note that the `DataTable.ext` object is available through
   * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
   * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
   *  @namespace
   *  @extends DataTable.models.ext
   */

  /**
   * DataTables extensions
   * 
   * This namespace acts as a collection area for plug-ins that can be used to
   * extend DataTables capabilities. Indeed many of the build in methods
   * use this method to provide their own capabilities (sorting methods for
   * example).
   *
   * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
   * reasons
   *
   *  @namespace
   */

  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},

    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},

    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",

    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",

    /**
     * Feature plug-ins.
     * 
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     * 
     * Each feature plug-in is described by an object which must have the
     * following properties:
     * 
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     * 
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],

    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],

    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },

    /**
     * Internal functions, exposed for used in plug-ins.
     * 
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},

    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },

    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },

    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},

    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],

      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},

      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },

    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatiblity only.
    // The should not be used in new projects and will be removed in a future
    // version
    //

    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,

    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,

    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},

    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  }; //
  // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
  //

  $.extend(_ext, {
    afnFiltering: _ext.search,
    aTypes: _ext.type.detect,
    ofnSearch: _ext.type.search,
    oSort: _ext.type.order,
    afnSortData: _ext.order,
    aoFeatures: _ext.feature,
    oApi: _ext.internal,
    oStdClasses: _ext.classes,
    oPagination: _ext.pager
  });
  $.extend(DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",

    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",

    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",

    /* Empty row */
    "sRowEmpty": "dataTables_empty",

    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_",

    /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",

    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting",

    /* Sortable in both directions */
    "sSortableAsc": "sorting_asc_disabled",
    "sSortableDesc": "sorting_desc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_",

    /* Note that an int is postfixed for the sorting order */

    /* Filtering */
    "sFilterInput": "",

    /* Page length */
    "sLengthSelect": "",

    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",

    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",
    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  });
  var extPagination = DataTable.ext.pager;

  function _numbers(page, pages) {
    var numbers = [],
        buttons = extPagination.numbers_length,
        half = Math.floor(buttons / 2),
        i = 1;

    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else if (page <= half) {
      numbers = _range(0, buttons - 2);
      numbers.push('ellipsis');
      numbers.push(pages - 1);
    } else if (page >= pages - 1 - half) {
      numbers = _range(pages - (buttons - 2), pages);
      numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6

      numbers.splice(0, 0, 0);
    } else {
      numbers = _range(page - half + 2, page + half - 1);
      numbers.push('ellipsis');
      numbers.push(pages - 1);
      numbers.splice(0, 0, 'ellipsis');
      numbers.splice(0, 0, 0);
    }

    numbers.DT_el = 'span';
    return numbers;
  }

  $.extend(extPagination, {
    simple: function (page, pages) {
      return ['previous', 'next'];
    },
    full: function (page, pages) {
      return ['first', 'previous', 'next', 'last'];
    },
    numbers: function (page, pages) {
      return [_numbers(page, pages)];
    },
    simple_numbers: function (page, pages) {
      return ['previous', _numbers(page, pages), 'next'];
    },
    full_numbers: function (page, pages) {
      return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
    },
    first_last_numbers: function (page, pages) {
      return ['first', _numbers(page, pages), 'last'];
    },
    // For testing and plug-ins to use
    _numbers: _numbers,
    // Number of number buttons (including ellipsis) to show. _Must be odd!_
    numbers_length: 7
  });
  $.extend(true, DataTable.ext.renderer, {
    pageButton: {
      _: function (settings, host, idx, buttons, page, pages) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay,
            btnClass,
            counter = 0;

        var attach = function (container, buttons) {
          var i, ien, node, button, tabIndex;
          var disabledClass = classes.sPageButtonDisabled;

          var clickHandler = function (e) {
            _fnPageChange(settings, e.data.action, true);
          };

          for (i = 0, ien = buttons.length; i < ien; i++) {
            button = buttons[i];

            if (Array.isArray(button)) {
              var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
              attach(inner, button);
            } else {
              btnDisplay = null;
              btnClass = button;
              tabIndex = settings.iTabIndex;

              switch (button) {
                case 'ellipsis':
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;

                case 'first':
                  btnDisplay = lang.sFirst;

                  if (page === 0) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                case 'previous':
                  btnDisplay = lang.sPrevious;

                  if (page === 0) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                case 'next':
                  btnDisplay = lang.sNext;

                  if (pages === 0 || page === pages - 1) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                case 'last':
                  btnDisplay = lang.sLast;

                  if (pages === 0 || page === pages - 1) {
                    tabIndex = -1;
                    btnClass += ' ' + disabledClass;
                  }

                  break;

                default:
                  btnDisplay = settings.fnFormatNumber(button + 1);
                  btnClass = page === button ? classes.sPageButtonActive : '';
                  break;
              }

              if (btnDisplay !== null) {
                node = $('<a>', {
                  'class': classes.sPageButton + ' ' + btnClass,
                  'aria-controls': settings.sTableId,
                  'aria-label': aria[button],
                  'data-dt-idx': counter,
                  'tabindex': tabIndex,
                  'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                }).html(btnDisplay).appendTo(container);

                _fnBindAction(node, {
                  action: button
                }, clickHandler);

                counter++;
              }
            }
          }
        }; // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame. Try / catch the error. Not good for
        // accessibility, but neither are frames.


        var activeEl;

        try {
          // Because this approach is destroying and recreating the paging
          // elements, focus is lost on the select button which is bad for
          // accessibility. So we want to restore focus once the draw has
          // completed
          activeEl = $(host).find(document.activeElement).data('dt-idx');
        } catch (e) {}

        attach($(host).empty(), buttons);

        if (activeEl !== undefined) {
          $(host).find('[data-dt-idx=' + activeEl + ']').trigger('focus');
        }
      }
    }
  }); // Built in type detection. See model.ext.aTypes for information about
  // what is required from this methods.

  $.extend(DataTable.ext.type.detect, [// Plain numbers - first since V8 detects some plain numbers as dates
  // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal) ? 'num' + decimal : null;
  }, // Dates (only those recognised by the browser's Date.parse)
  function (d, settings) {
    // V8 tries _very_ hard to make a string passed into `Date.parse()`
    // valid, so we need to use a regex to restrict date formats. Use a
    // plug-in for anything other than ISO8601 style strings
    if (d && !(d instanceof Date) && !_re_date.test(d)) {
      return null;
    }

    var parsed = Date.parse(d);
    return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
  }, // Formatted numbers
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
  }, // HTML numeric
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
  }, // HTML numeric, formatted
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
  }, // HTML (this is strict checking - there must be html)
  function (d, settings) {
    return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
  }]); // Filter formatting functions. See model.ext.ofnSearch for information about
  // what is required from these methods.
  // 
  // Note that additional search methods are added for the html numbers and
  // html formatted numbers by `_addNumericSort()` when we know what the decimal
  // place is

  $.extend(DataTable.ext.type.search, {
    html: function (data) {
      return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ").replace(_re_html, "") : '';
    },
    string: function (data) {
      return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ") : data;
    }
  });

  var __numericReplace = function (d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === '-')) {
      return -Infinity;
    } // If a decimal place other than `.` is used, it needs to be given to the
    // function so we can detect it and replace with a `.` which is the only
    // decimal place Javascript recognises - it is not locale aware.


    if (decimalPlace) {
      d = _numToDecimal(d, decimalPlace);
    }

    if (d.replace) {
      if (re1) {
        d = d.replace(re1, '');
      }

      if (re2) {
        d = d.replace(re2, '');
      }
    }

    return d * 1;
  }; // Add the numeric 'deformatting' functions for sorting and search. This is done
  // in a function to provide an easy ability for the language options to add
  // additional methods if a non-period decimal place is used.


  function _addNumericSort(decimalPlace) {
    $.each({
      // Plain numbers
      "num": function (d) {
        return __numericReplace(d, decimalPlace);
      },
      // Formatted numbers
      "num-fmt": function (d) {
        return __numericReplace(d, decimalPlace, _re_formatted_numeric);
      },
      // HTML numeric
      "html-num": function (d) {
        return __numericReplace(d, decimalPlace, _re_html);
      },
      // HTML numeric, formatted
      "html-num-fmt": function (d) {
        return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
      }
    }, function (key, fn) {
      // Add the ordering method
      _ext.type.order[key + decimalPlace + '-pre'] = fn; // For HTML types add a search formatter that will strip the HTML

      if (key.match(/^html\-/)) {
        _ext.type.search[key + decimalPlace] = _ext.type.search.html;
      }
    });
  } // Default sort methods


  $.extend(_ext.type.order, {
    // Dates
    "date-pre": function (d) {
      var ts = Date.parse(d);
      return isNaN(ts) ? -Infinity : ts;
    },
    // html
    "html-pre": function (a) {
      return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + '';
    },
    // string
    "string-pre": function (a) {
      // This is a little complex, but faster than always calling toString,
      // http://jsperf.com/tostring-v-check
      return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
    },
    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function (x, y) {
      return x < y ? -1 : x > y ? 1 : 0;
    },
    "string-desc": function (x, y) {
      return x < y ? 1 : x > y ? -1 : 0;
    }
  }); // Numeric sorting types - order doesn't matter here

  _addNumericSort('');

  $.extend(true, DataTable.ext.renderer, {
    header: {
      _: function (settings, cell, column, classes) {
        // No additional mark-up required
        // Attach a sort listener to update on sort - note that using the
        // `DT` namespace will allow the event to be removed automatically
        // on destroy, while the `dt` namespaced event is the one we are
        // listening for
        $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
          if (settings !== ctx) {
            // need to check this this is the host
            return; // table, not a nested one
          }

          var colIdx = column.idx;
          cell.removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
        });
      },
      jqueryui: function (settings, cell, column, classes) {
        $('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell); // Attach a sort listener to update on sort

        $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }

          var colIdx = column.idx;
          cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
          cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
        });
      }
    }
  });
  /*
   * Public helper functions. These aren't used internally by DataTables, or
   * called by any of the options passed into DataTables, but they can be used
   * externally by developers working with DataTables. They are helper functions
   * to make working with DataTables a little bit easier.
   */

  var __htmlEscapeEntities = function (d) {
    return typeof d === 'string' ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') : d;
  };
  /**
   * Helpers for `columns.render`.
   *
   * The options defined here can be used with the `columns.render` initialisation
   * option to provide a display renderer. The following functions are defined:
   *
   * * `number` - Will format numeric data (defined by `columns.data`) for
   *   display, retaining the original unformatted data for sorting and filtering.
   *   It takes 5 parameters:
   *   * `string` - Thousands grouping separator
   *   * `string` - Decimal point indicator
   *   * `integer` - Number of decimal points to show
   *   * `string` (optional) - Prefix.
   *   * `string` (optional) - Postfix (/suffix).
   * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
   *   parameters.
   *
   * @example
   *   // Column definition using the number renderer
   *   {
   *     data: "salary",
   *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
   *   }
   *
   * @namespace
   */


  DataTable.render = {
    number: function (thousands, decimal, precision, prefix, postfix) {
      return {
        display: function (d) {
          if (typeof d !== 'number' && typeof d !== 'string') {
            return d;
          }

          var negative = d < 0 ? '-' : '';
          var flo = parseFloat(d); // If NaN then there isn't much formatting that we can do - just
          // return immediately, escaping any HTML (this was supposed to
          // be a number after all)

          if (isNaN(flo)) {
            return __htmlEscapeEntities(d);
          }

          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';
          return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || '');
        }
      };
    },
    text: function () {
      return {
        display: __htmlEscapeEntities,
        filter: __htmlEscapeEntities
      };
    }
  };
  /*
   * This is really a good bit rubbish this method of exposing the internal methods
   * publicly... - To be fixed in 2.0 using methods on the prototype
   */

  /**
   * Create a wrapper function for exporting an internal functions to an external API.
   *  @param {string} fn API function name
   *  @returns {function} wrapped function
   *  @memberof DataTable#internal
   */

  function _fnExternApiFunc(fn) {
    return function () {
      var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
      return DataTable.ext.internal[fn].apply(this, args);
    };
  }
  /**
   * Reference to internal functions for use by plug-in developers. Note that
   * these methods are references to internal functions and are considered to be
   * private. If you use these methods, be aware that they are liable to change
   * between versions.
   *  @namespace
   */


  $.extend(DataTable.ext.internal, {
    _fnExternApiFunc: _fnExternApiFunc,
    _fnBuildAjax: _fnBuildAjax,
    _fnAjaxUpdate: _fnAjaxUpdate,
    _fnAjaxParameters: _fnAjaxParameters,
    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
    _fnAjaxDataSrc: _fnAjaxDataSrc,
    _fnAddColumn: _fnAddColumn,
    _fnColumnOptions: _fnColumnOptions,
    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
    _fnVisbleColumns: _fnVisbleColumns,
    _fnGetColumns: _fnGetColumns,
    _fnColumnTypes: _fnColumnTypes,
    _fnApplyColumnDefs: _fnApplyColumnDefs,
    _fnHungarianMap: _fnHungarianMap,
    _fnCamelToHungarian: _fnCamelToHungarian,
    _fnLanguageCompat: _fnLanguageCompat,
    _fnBrowserDetect: _fnBrowserDetect,
    _fnAddData: _fnAddData,
    _fnAddTr: _fnAddTr,
    _fnNodeToDataIndex: _fnNodeToDataIndex,
    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
    _fnGetCellData: _fnGetCellData,
    _fnSetCellData: _fnSetCellData,
    _fnSplitObjNotation: _fnSplitObjNotation,
    _fnGetObjectDataFn: _fnGetObjectDataFn,
    _fnSetObjectDataFn: _fnSetObjectDataFn,
    _fnGetDataMaster: _fnGetDataMaster,
    _fnClearTable: _fnClearTable,
    _fnDeleteIndex: _fnDeleteIndex,
    _fnInvalidate: _fnInvalidate,
    _fnGetRowElements: _fnGetRowElements,
    _fnCreateTr: _fnCreateTr,
    _fnBuildHead: _fnBuildHead,
    _fnDrawHead: _fnDrawHead,
    _fnDraw: _fnDraw,
    _fnReDraw: _fnReDraw,
    _fnAddOptionsHtml: _fnAddOptionsHtml,
    _fnDetectHeader: _fnDetectHeader,
    _fnGetUniqueThs: _fnGetUniqueThs,
    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
    _fnFilterComplete: _fnFilterComplete,
    _fnFilterCustom: _fnFilterCustom,
    _fnFilterColumn: _fnFilterColumn,
    _fnFilter: _fnFilter,
    _fnFilterCreateSearch: _fnFilterCreateSearch,
    _fnEscapeRegex: _fnEscapeRegex,
    _fnFilterData: _fnFilterData,
    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
    _fnUpdateInfo: _fnUpdateInfo,
    _fnInfoMacros: _fnInfoMacros,
    _fnInitialise: _fnInitialise,
    _fnInitComplete: _fnInitComplete,
    _fnLengthChange: _fnLengthChange,
    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
    _fnPageChange: _fnPageChange,
    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
    _fnProcessingDisplay: _fnProcessingDisplay,
    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
    _fnScrollDraw: _fnScrollDraw,
    _fnApplyToChildren: _fnApplyToChildren,
    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
    _fnThrottle: _fnThrottle,
    _fnConvertToWidth: _fnConvertToWidth,
    _fnGetWidestNode: _fnGetWidestNode,
    _fnGetMaxLenString: _fnGetMaxLenString,
    _fnStringToCss: _fnStringToCss,
    _fnSortFlatten: _fnSortFlatten,
    _fnSort: _fnSort,
    _fnSortAria: _fnSortAria,
    _fnSortListener: _fnSortListener,
    _fnSortAttachListener: _fnSortAttachListener,
    _fnSortingClasses: _fnSortingClasses,
    _fnSortData: _fnSortData,
    _fnSaveState: _fnSaveState,
    _fnLoadState: _fnLoadState,
    _fnSettingsFromNode: _fnSettingsFromNode,
    _fnLog: _fnLog,
    _fnMap: _fnMap,
    _fnBindAction: _fnBindAction,
    _fnCallbackReg: _fnCallbackReg,
    _fnCallbackFire: _fnCallbackFire,
    _fnLengthOverflow: _fnLengthOverflow,
    _fnRenderer: _fnRenderer,
    _fnDataSource: _fnDataSource,
    _fnRowAttributes: _fnRowAttributes,
    _fnExtend: _fnExtend,
    _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
    // in 1.10, so this dead-end function is
    // added to prevent errors

  }); // jQuery access

  $.fn.dataTable = DataTable; // Provide access to the host jQuery object (circular reference)

  DataTable.$ = $; // Legacy aliases

  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext; // With a capital `D` we return a DataTables API instance rather than a
  // jQuery object

  $.fn.DataTable = function (opts) {
    return $(this).dataTable(opts).api();
  }; // All properties that are available to $.fn.dataTable should also be
  // available on $.fn.DataTable


  $.each(DataTable, function (prop, val) {
    $.fn.DataTable[prop] = val;
  }); // Information about events fired by DataTables - for documentation.

  /**
   * Draw event, fired whenever the table is redrawn on the page, at the same
   * point as fnDrawCallback. This may be useful for binding events or
   * performing calculations when the table is altered at all.
   *  @name DataTable#draw.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Search event, fired when the searching applied to the table (using the
   * built-in global search, or column filters) is altered.
   *  @name DataTable#search.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page change event, fired when the paging of the table is altered.
   *  @name DataTable#page.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Order event, fired when the ordering applied to the table is altered.
   *  @name DataTable#order.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * DataTables initialisation complete event, fired when the table is fully
   * drawn, including Ajax data loaded, if Ajax data is required.
   *  @name DataTable#init.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used</li></ol>
   */

  /**
   * State save event, fired when the table has changed state a new state save
   * is required. This event allows modification of the state saving object
   * prior to actually doing the save, including addition or other state
   * properties (for plug-ins) or modification of a DataTables core property.
   *  @name DataTable#stateSaveParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The state information to be saved
   */

  /**
   * State load event, fired when the table is loading state from the stored
   * data, but prior to the settings object being modified by the saved state
   * - allowing modification of the saved state is required or loading of
   * state for a plug-in.
   *  @name DataTable#stateLoadParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * State loaded event, fired when state has been loaded from stored data and
   * the settings object has been modified by the loaded data.
   *  @name DataTable#stateLoaded.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * Processing event, fired when DataTables is doing some kind of processing
   * (be it, order, search or anything else). It can be used to indicate to
   * the end user that there is something happening, or that something has
   * finished.
   *  @name DataTable#processing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {boolean} bShow Flag for if DataTables is doing processing or not
   */

  /**
   * Ajax (XHR) event, fired whenever an Ajax request is completed from a
   * request to made to the server for new data. This event is called before
   * DataTables processed the returned data, so it can also be used to pre-
   * process the data returned from the server, if needed.
   *
   * Note that this trigger is called in `fnServerData`, if you override
   * `fnServerData` and which to use this event, you need to trigger it in you
   * success function.
   *  @name DataTable#xhr.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {object} json JSON returned from the server
   *
   *  @example
   *     // Use a custom property returned from the server in another DOM element
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       $('#status').html( json.status );
   *     } );
   *
   *  @example
   *     // Pre-process the data returned from the server
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
   *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
   *       }
   *       // Note no return - manipulate the data directly in the JSON object.
   *     } );
   */

  /**
   * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
   * or passing the bDestroy:true parameter in the initialisation object. This
   * can be used to remove bound events, added DOM nodes, etc.
   *  @name DataTable#destroy.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page length change event, fired when number of records to show on each
   * page (the length) is changed.
   *  @name DataTable#length.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {integer} len New length
   */

  /**
   * Column sizing has changed.
   *  @name DataTable#column-sizing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Column visibility has changed.
   *  @name DataTable#column-visibility.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {int} column Column index
   *  @param {bool} vis `false` if column now hidden, or `true` if visible
   */

  return $.fn.dataTable;
});

/***/ }),

/***/ "./src/public/js/wowpi-guild-roster.js":
/*!*********************************************!*\
  !*** ./src/public/js/wowpi-guild-roster.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(datatables_net__WEBPACK_IMPORTED_MODULE_1__);


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
  var tableColumns = ['name', 'race', 'class', 'role', 'level', 'rank'];
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('.wowpi-roster').each(function () {
    var tableRanks = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('ranks');
    console.log(tableRanks);
    var dataTableOpts = {
      "processing": true,
      "serverSide": true,
      "ajax": wowpiRosterAjax.ajaxurl,
      "paging": true,
      "pageLength": parseInt(rows),
      "columns": [{
        'data': 'name',
        'sortable': true
      }, {
        'data': 'race',
        'render': function render(data, type, row) {
          return '<div class="icon"><img src="/wp-content/plugins/wowpi-guild/assets/icon/' + data.icon + '" alt="' + data.name + '" /></div>';
        },
        'sortable': false
      }, {
        'data': 'class',
        'render': function render(data, type, row) {
          return '<div class="icon"><img src="/wp-content/plugins/wowpi-guild/assets/icon/' + data.icon + '" alt="' + data.name + '" /></div>';
        },
        'sortable': false
      }, {
        'data': 'role',
        'render': function render(data, type, row) {
          return '<div class="icon"><img src="/wp-content/plugins/wowpi-guild/assets/icon/role_' + data.type + '.png" alt="' + data.name + '" /></div>';
        },
        'sortable': false
      }, {
        'data': 'level',
        'sortable': true
      }, {
        'data': 'rank',
        'sortable': false
      }],
      'searchCols': [null, null, null, null, null, {
        "search": tableRanks
      }]
    };
    var rows = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('length');
    dataTableOpts.pageLength = parseInt(rows);
    var ordering = [];
    var orderBy = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('orderby');
    var orderByCols = orderBy.split('|');

    for (var i = 0; i < orderByCols.length; i++) {
      var orderByColOrdering = orderByCols[i].split(' ');
      var col = tableColumns.indexOf(orderByColOrdering[0]);
      var order = orderByColOrdering[1] || 'asc';
      var newOrdering = [col, order];
      ordering.push(newOrdering);
    }

    if (ordering.length > 0) {
      dataTableOpts.order = ordering;
    }
    /*
    l - length changing input control
    f - filtering input
    t - The table
    i - Table information summary
    p - pagination control
    r - processing display element
    */


    var dom = '';
    var showSelectPageLength = parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('showselectlength'));

    if (1 === showSelectPageLength) {
      dom += 'l';
    }

    var showSearch = parseInt(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('showsearch'));

    if (1 === showSearch) {
      dom += 'f';
    }

    dom += 'rtip';
    dataTableOpts.dom = dom;
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).DataTable(dataTableOpts);
  });
});

/***/ }),

/***/ 1:
/*!***************************************************!*\
  !*** multi ./src/public/js/wowpi-guild-roster.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! D:\laragon\www\wowpi\wp-content\plugins\wowpi-guild\src\public\js\wowpi-guild-roster.js */"./src/public/js/wowpi-guild-roster.js");


/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0L2pzL2pxdWVyeS5kYXRhVGFibGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9wdWJsaWMvanMvd293cGktZ3VpbGQtcm9zdGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJkZWZpbmUiLCIkIiwid2luZG93IiwiZG9jdW1lbnQiLCJ1bmRlZmluZWQiLCJEYXRhVGFibGUiLCJvcHRpb25zIiwic1NlbGVjdG9yIiwib09wdHMiLCJhcGkiLCJfIiwicm93cyIsImRhdGEiLCJ0cmFkaXRpb25hbCIsIl9BcGkiLCJfZm5TZXR0aW5nc0Zyb21Ob2RlIiwiX2V4dCIsImlBcGlJbmRleCIsImZuQWRkRGF0YSIsInJlZHJhdyIsIkFycmF5IiwiaXNBcnJheSIsImlzUGxhaW5PYmplY3QiLCJhZGQiLCJyb3ciLCJkcmF3IiwiZmxhdHRlbiIsInRvQXJyYXkiLCJmbkFkanVzdENvbHVtblNpemluZyIsImJSZWRyYXciLCJjb2x1bW5zIiwiYWRqdXN0Iiwic2V0dGluZ3MiLCJzY3JvbGwiLCJvU2Nyb2xsIiwic1giLCJzWSIsIl9mblNjcm9sbERyYXciLCJmbkNsZWFyVGFibGUiLCJjbGVhciIsImZuQ2xvc2UiLCJuVHIiLCJjaGlsZCIsImhpZGUiLCJmbkRlbGV0ZVJvdyIsInRhcmdldCIsImNhbGxiYWNrIiwiYW9EYXRhIiwicmVtb3ZlIiwiY2FsbCIsImZuRGVzdHJveSIsImRlc3Ryb3kiLCJmbkRyYXciLCJjb21wbGV0ZSIsImZuRmlsdGVyIiwic0lucHV0IiwiaUNvbHVtbiIsImJSZWdleCIsImJTbWFydCIsImJTaG93R2xvYmFsIiwiYkNhc2VJbnNlbnNpdGl2ZSIsInNlYXJjaCIsImNvbHVtbiIsImZuR2V0RGF0YSIsInNyYyIsImNvbCIsInR5cGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiY2VsbCIsImZuR2V0Tm9kZXMiLCJpUm93Iiwibm9kZSIsIm5vZGVzIiwiZm5HZXRQb3NpdGlvbiIsInRvVXBwZXJDYXNlIiwiaW5kZXgiLCJjb2x1bW5WaXNpYmxlIiwiZm5Jc09wZW4iLCJpc1Nob3duIiwiZm5PcGVuIiwibUh0bWwiLCJzQ2xhc3MiLCJzaG93IiwiZm5QYWdlQ2hhbmdlIiwibUFjdGlvbiIsInBhZ2UiLCJmblNldENvbHVtblZpcyIsImlDb2wiLCJiU2hvdyIsInZpc2libGUiLCJmblNldHRpbmdzIiwiZm5Tb3J0IiwiYWFTb3J0Iiwib3JkZXIiLCJmblNvcnRMaXN0ZW5lciIsIm5Ob2RlIiwiZm5DYWxsYmFjayIsImxpc3RlbmVyIiwiZm5VcGRhdGUiLCJtRGF0YSIsIm1Sb3ciLCJiQWN0aW9uIiwiZm5WZXJzaW9uQ2hlY2siLCJfdGhhdCIsImVtcHR5SW5pdCIsImxlbiIsImxlbmd0aCIsIm9BcGkiLCJpbnRlcm5hbCIsImZuIiwiZXh0IiwiX2ZuRXh0ZXJuQXBpRnVuYyIsImVhY2giLCJvIiwib0luaXQiLCJfZm5FeHRlbmQiLCJpIiwiaUxlbiIsImoiLCJqTGVuIiwiayIsImtMZW4iLCJzSWQiLCJnZXRBdHRyaWJ1dGUiLCJiSW5pdEhhbmRlZE9mZiIsImRlZmF1bHRzIiwiJHRoaXMiLCJfZm5Mb2ciLCJfZm5Db21wYXRPcHRzIiwiX2ZuQ29tcGF0Q29scyIsIl9mbkNhbWVsVG9IdW5nYXJpYW4iLCJleHRlbmQiLCJhbGxTZXR0aW5ncyIsInMiLCJuVGFibGUiLCJuVEhlYWQiLCJwYXJlbnROb2RlIiwiblRGb290IiwiYlJldHJpZXZlIiwiYkRlc3Ryb3kiLCJvSW5zdGFuY2UiLCJzVGFibGVJZCIsImlkIiwic3BsaWNlIiwiX3VuaXF1ZSIsIm9TZXR0aW5ncyIsIm1vZGVscyIsInN0eWxlIiwid2lkdGgiLCJwdXNoIiwiZGF0YVRhYmxlIiwiX2ZuTGFuZ3VhZ2VDb21wYXQiLCJvTGFuZ3VhZ2UiLCJhTGVuZ3RoTWVudSIsImlEaXNwbGF5TGVuZ3RoIiwiX2ZuTWFwIiwib0ZlYXR1cmVzIiwiX2ZuQ2FsbGJhY2tSZWciLCJmbkRyYXdDYWxsYmFjayIsImZuU2VydmVyUGFyYW1zIiwiZm5TdGF0ZVNhdmVQYXJhbXMiLCJmblN0YXRlTG9hZFBhcmFtcyIsImZuU3RhdGVMb2FkZWQiLCJmblJvd0NhbGxiYWNrIiwiZm5DcmVhdGVkUm93IiwiZm5IZWFkZXJDYWxsYmFjayIsImZuRm9vdGVyQ2FsbGJhY2siLCJmbkluaXRDb21wbGV0ZSIsImZuUHJlRHJhd0NhbGxiYWNrIiwicm93SWRGbiIsIl9mbkdldE9iamVjdERhdGFGbiIsInJvd0lkIiwiX2ZuQnJvd3NlckRldGVjdCIsIm9DbGFzc2VzIiwiY2xhc3NlcyIsImFkZENsYXNzIiwic1RhYmxlIiwiaUluaXREaXNwbGF5U3RhcnQiLCJpRGlzcGxheVN0YXJ0IiwiX2lEaXNwbGF5U3RhcnQiLCJpRGVmZXJMb2FkaW5nIiwiYkRlZmVyTG9hZGluZyIsInRtcCIsIl9pUmVjb3Jkc0Rpc3BsYXkiLCJfaVJlY29yZHNUb3RhbCIsInNVcmwiLCJhamF4IiwiZGF0YVR5cGUiLCJ1cmwiLCJzdWNjZXNzIiwianNvbiIsIl9mbkluaXRpYWxpc2UiLCJlcnJvciIsImFzU3RyaXBlQ2xhc3NlcyIsInNTdHJpcGVPZGQiLCJzU3RyaXBlRXZlbiIsInN0cmlwZUNsYXNzZXMiLCJyb3dPbmUiLCJjaGlsZHJlbiIsImZpbmQiLCJlcSIsImluQXJyYXkiLCJtYXAiLCJlbCIsImhhc0NsYXNzIiwicmVtb3ZlQ2xhc3MiLCJqb2luIiwiYXNEZXN0cm95U3RyaXBlcyIsInNsaWNlIiwiYW5UaHMiLCJhb0NvbHVtbnNJbml0IiwiblRoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJfZm5EZXRlY3RIZWFkZXIiLCJhb0hlYWRlciIsIl9mbkdldFVuaXF1ZVRocyIsImFvQ29sdW1ucyIsIl9mbkFkZENvbHVtbiIsIl9mbkFwcGx5Q29sdW1uRGVmcyIsImFvQ29sdW1uRGVmcyIsIm9EZWYiLCJfZm5Db2x1bW5PcHRpb25zIiwiYSIsIm5hbWUiLCJzb3J0IiwiZmlsdGVyIiwiZmVhdHVyZXMiLCJsb2FkZWRJbml0IiwiYWFTb3J0aW5nIiwic29ydGluZyIsImFzU29ydGluZyIsIl9mblNvcnRpbmdDbGFzc2VzIiwiYlNvcnQiLCJiU29ydGVkIiwiYVNvcnQiLCJfZm5Tb3J0RmxhdHRlbiIsInNvcnRlZENvbHVtbnMiLCJ2YWwiLCJkaXIiLCJfZm5DYWxsYmFja0ZpcmUiLCJfZm5Tb3J0QXJpYSIsIl9mbkRhdGFTb3VyY2UiLCJiRGVmZXJSZW5kZXIiLCJjYXB0aW9ucyIsIl9jYXB0aW9uU2lkZSIsImNzcyIsInRoZWFkIiwiYXBwZW5kVG8iLCJ0Ym9keSIsIm5UQm9keSIsInRmb290Iiwic05vRm9vdGVyIiwiYW9Gb290ZXIiLCJhYURhdGEiLCJfZm5BZGREYXRhIiwiX2ZuQWRkVHIiLCJhaURpc3BsYXkiLCJhaURpc3BsYXlNYXN0ZXIiLCJiSW5pdGlhbGlzZWQiLCJiU3RhdGVTYXZlIiwiX2ZuU2F2ZVN0YXRlIiwiX2ZuTG9hZFN0YXRlIiwiX2FwaV9yZWdpc3RlciIsIl9hcGlfcmVnaXN0ZXJQbHVyYWwiLCJfcmVfZGljIiwiX3JlX25ld19saW5lcyIsIl9yZV9odG1sIiwiX3JlX2RhdGUiLCJfcmVfZXNjYXBlX3JlZ2V4IiwiUmVnRXhwIiwiX3JlX2Zvcm1hdHRlZF9udW1lcmljIiwiX2VtcHR5IiwiZCIsIl9pbnRWYWwiLCJpbnRlZ2VyIiwicGFyc2VJbnQiLCJpc05hTiIsImlzRmluaXRlIiwiX251bVRvRGVjaW1hbCIsIm51bSIsImRlY2ltYWxQb2ludCIsIl9mbkVzY2FwZVJlZ2V4IiwicmVwbGFjZSIsIl9pc051bWJlciIsImZvcm1hdHRlZCIsInN0clR5cGUiLCJwYXJzZUZsb2F0IiwiX2lzSHRtbCIsIl9odG1sTnVtZXJpYyIsImh0bWwiLCJfc3RyaXBIdG1sIiwiX3BsdWNrIiwicHJvcCIsInByb3AyIiwib3V0IiwiaWVuIiwiX3BsdWNrX29yZGVyIiwiX3JhbmdlIiwic3RhcnQiLCJlbmQiLCJfcmVtb3ZlRW1wdHkiLCJfYXJlQWxsVW5pcXVlIiwic29ydGVkIiwibGFzdCIsImFnYWluIiwiX2ZsYXR0ZW4iLCJhcmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsIlN0cmluZyIsInRyaW0iLCJ1dGlsIiwidGhyb3R0bGUiLCJmcmVxIiwiZnJlcXVlbmN5IiwidGltZXIiLCJ0aGF0Iiwibm93IiwiRGF0ZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJlc2NhcGVSZWdleCIsIl9mbkh1bmdhcmlhbk1hcCIsImh1bmdhcmlhbiIsIm1hdGNoIiwibmV3S2V5Iiwia2V5IiwiaW5kZXhPZiIsIl9odW5nYXJpYW5NYXAiLCJ1c2VyIiwiZm9yY2UiLCJodW5nYXJpYW5LZXkiLCJjaGFyQXQiLCJsYW5nIiwiZGVmYXVsdERlY2ltYWwiLCJzRGVjaW1hbCIsIl9hZGROdW1lcmljU29ydCIsInplcm9SZWNvcmRzIiwic1plcm9SZWNvcmRzIiwic0VtcHR5VGFibGUiLCJzTG9hZGluZ1JlY29yZHMiLCJzSW5mb1Rob3VzYW5kcyIsInNUaG91c2FuZHMiLCJkZWNpbWFsIiwiX2ZuQ29tcGF0TWFwIiwia25ldyIsIm9sZCIsImluaXQiLCJzU2Nyb2xsWCIsInNjcm9sbFgiLCJzZWFyY2hDb2xzIiwiYW9TZWFyY2hDb2xzIiwib1NlYXJjaCIsImRhdGFTb3J0IiwiYURhdGFTb3J0IiwiX19icm93c2VyIiwiYnJvd3NlciIsIm4iLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwiaGVpZ2h0Iiwib3ZlcmZsb3ciLCJhcHBlbmQiLCJvdXRlciIsImlubmVyIiwiYmFyV2lkdGgiLCJvZmZzZXRXaWR0aCIsImNsaWVudFdpZHRoIiwiYlNjcm9sbE92ZXJzaXplIiwiYlNjcm9sbGJhckxlZnQiLCJNYXRoIiwicm91bmQiLCJvZmZzZXQiLCJiQm91bmRpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvQnJvd3NlciIsImlCYXJXaWR0aCIsIl9mblJlZHVjZSIsImluYyIsInZhbHVlIiwiaXNTZXQiLCJoYXNPd25Qcm9wZXJ0eSIsIm5UaCIsIm9EZWZhdWx0cyIsIm9Db2wiLCJvQ29sdW1uIiwiY3JlYXRlRWxlbWVudCIsInNUaXRsZSIsImlubmVySFRNTCIsImlkeCIsImFvUHJlU2VhcmNoQ29scyIsIm9PcHRpb25zIiwidGgiLCJzV2lkdGhPcmlnIiwiYXR0ciIsInQiLCJtRGF0YVByb3AiLCJzVHlwZSIsIl9zTWFudWFsVHlwZSIsImNsYXNzTmFtZSIsImlEYXRhU29ydCIsIm1EYXRhU3JjIiwibVJlbmRlciIsImF0dHJUZXN0IiwiX2JBdHRyU3JjIiwiX3NldHRlciIsInJvd0RhdGEiLCJtZXRhIiwiaW5uZXJEYXRhIiwiZm5TZXREYXRhIiwiX2ZuU2V0T2JqZWN0RGF0YUZuIiwiX3Jvd1JlYWRPYmplY3QiLCJiU29ydGFibGUiLCJzU29ydGFibGVOb25lIiwiYkFzYyIsImJEZXNjIiwic1NvcnRpbmdDbGFzcyIsInNTb3J0aW5nQ2xhc3NKVUkiLCJzU29ydGFibGVBc2MiLCJzU29ydEpVSUFzY0FsbG93ZWQiLCJzU29ydGFibGVEZXNjIiwic1NvcnRKVUlEZXNjQWxsb3dlZCIsInNTb3J0YWJsZSIsInNTb3J0SlVJIiwiX2ZuQWRqdXN0Q29sdW1uU2l6aW5nIiwiYkF1dG9XaWR0aCIsIl9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyIsInNXaWR0aCIsIl9mblZpc2libGVUb0NvbHVtbkluZGV4IiwiaU1hdGNoIiwiYWlWaXMiLCJfZm5HZXRDb2x1bW5zIiwiX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUiLCJpUG9zIiwiX2ZuVmlzYmxlQ29sdW1ucyIsInZpcyIsImJWaXNpYmxlIiwic1BhcmFtIiwiX2ZuQ29sdW1uVHlwZXMiLCJ0eXBlcyIsImRldGVjdCIsImplbiIsImtlbiIsImRldGVjdGVkVHlwZSIsImNhY2hlIiwiX2ZuR2V0Q2VsbERhdGEiLCJhb0NvbERlZnMiLCJhb0NvbHMiLCJkZWYiLCJhVGFyZ2V0cyIsInRhcmdldHMiLCJhRGF0YUluIiwiYW5UZHMiLCJvRGF0YSIsIm9Sb3ciLCJfYURhdGEiLCJuVGQiLCJzVGhpc1R5cGUiLCJhSWRzIiwiX2ZuQ3JlYXRlVHIiLCJ0cnMiLCJfZm5HZXRSb3dFbGVtZW50cyIsImNlbGxzIiwiX2ZuTm9kZVRvRGF0YUluZGV4IiwiX0RUX1Jvd0luZGV4IiwiX2ZuTm9kZVRvQ29sdW1uSW5kZXgiLCJhbkNlbGxzIiwicm93SWR4IiwiY29sSWR4IiwiaURyYXciLCJkZWZhdWx0Q29udGVudCIsInNEZWZhdWx0Q29udGVudCIsImNlbGxEYXRhIiwiaURyYXdFcnJvciIsIl9mblNldENlbGxEYXRhIiwiX19yZUFycmF5IiwiX19yZUZuIiwiX2ZuU3BsaXRPYmpOb3RhdGlvbiIsInN0ciIsIm1Tb3VyY2UiLCJmZXRjaERhdGEiLCJhcnJheU5vdGF0aW9uIiwiZnVuY05vdGF0aW9uIiwiaW5uZXJTcmMiLCJzdWJzdHJpbmciLCJzZXREYXRhIiwiYiIsImFMYXN0IiwiRXJyb3IiLCJfZm5HZXREYXRhTWFzdGVyIiwiX2ZuQ2xlYXJUYWJsZSIsIl9mbkRlbGV0ZUluZGV4IiwiaVRhcmdldCIsImlUYXJnZXRJbmRleCIsIl9mbkludmFsaWRhdGUiLCJjZWxsV3JpdGUiLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwiX2FTb3J0RGF0YSIsIl9hRmlsdGVyRGF0YSIsImNvbHMiLCJfZm5Sb3dBdHRyaWJ1dGVzIiwidGRzIiwidGQiLCJjb250ZW50cyIsIm9iamVjdFJlYWQiLCJzZXR0ZXIiLCJjZWxsUHJvY2VzcyIsIm5leHRTaWJsaW5nIiwicm93Tm9kZSIsIm5UckluIiwiY3JlYXRlIiwic0NlbGxUeXBlIiwiX0RUX0NlbGxJbmRleCIsImFwcGVuZENoaWxkIiwiZm5DcmVhdGVkQ2VsbCIsInNldEF0dHJpYnV0ZSIsInRyIiwiRFRfUm93Q2xhc3MiLCJzcGxpdCIsIl9fcm93YyIsImNvbmNhdCIsIkRUX1Jvd0F0dHIiLCJEVF9Sb3dEYXRhIiwiX2ZuQnVpbGRIZWFkIiwiY3JlYXRlSGVhZGVyIiwiaVRhYkluZGV4IiwiX2ZuU29ydEF0dGFjaExpc3RlbmVyIiwiX2ZuUmVuZGVyZXIiLCJzSGVhZGVyVEgiLCJzRm9vdGVyVEgiLCJuVGYiLCJfZm5EcmF3SGVhZCIsImFvU291cmNlIiwiYkluY2x1ZGVIaWRkZW4iLCJuTG9jYWxUciIsImFvTG9jYWwiLCJhQXBwbGllZCIsImlDb2x1bW5zIiwiaVJvd3NwYW4iLCJpQ29sc3BhbiIsIl9mbkRyYXciLCJhUHJlRHJhdyIsIl9mblByb2Nlc3NpbmdEaXNwbGF5IiwiYW5Sb3dzIiwiaVJvd0NvdW50IiwiaVN0cmlwZXMiLCJpT3BlblJvd3MiLCJhb09wZW5Sb3dzIiwib0xhbmciLCJiU2VydmVyU2lkZSIsImJEcmF3aW5nIiwiZm5SZWNvcmRzRGlzcGxheSIsImlEaXNwbGF5RW5kIiwiZm5EaXNwbGF5RW5kIiwiYkRlc3Ryb3lpbmciLCJfZm5BamF4VXBkYXRlIiwiaVN0YXJ0IiwiaUVuZCIsImlEYXRhSW5kZXgiLCJuUm93Iiwic1N0cmlwZSIsIl9zUm93U3RyaXBlIiwic1plcm8iLCJmblJlY29yZHNUb3RhbCIsInNSb3dFbXB0eSIsImJvZHkiLCJkZXRhY2giLCJiRmlsdGVyZWQiLCJfZm5SZURyYXciLCJob2xkUG9zaXRpb24iLCJiRmlsdGVyIiwiX2ZuU29ydCIsIl9mbkZpbHRlckNvbXBsZXRlIiwib1ByZXZpb3VzU2VhcmNoIiwiX2RyYXdIb2xkIiwiX2ZuQWRkT3B0aW9uc0h0bWwiLCJ0YWJsZSIsImhvbGRpbmciLCJpbnNlcnRCZWZvcmUiLCJpbnNlcnQiLCJzV3JhcHBlciIsIm5Ib2xkaW5nIiwiblRhYmxlV3JhcHBlciIsIm5UYWJsZVJlaW5zZXJ0QmVmb3JlIiwiYURvbSIsInNEb20iLCJmZWF0dXJlTm9kZSIsImNPcHRpb24iLCJuTmV3Tm9kZSIsImNOZXh0Iiwic0F0dHIiLCJzSlVJSGVhZGVyIiwic0pVSUZvb3RlciIsImFTcGxpdCIsInN1YnN0ciIsInBhcmVudCIsImJQYWdpbmF0ZSIsImJMZW5ndGhDaGFuZ2UiLCJfZm5GZWF0dXJlSHRtbExlbmd0aCIsIl9mbkZlYXR1cmVIdG1sRmlsdGVyIiwiYlByb2Nlc3NpbmciLCJfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmciLCJfZm5GZWF0dXJlSHRtbFRhYmxlIiwiYkluZm8iLCJfZm5GZWF0dXJlSHRtbEluZm8iLCJfZm5GZWF0dXJlSHRtbFBhZ2luYXRlIiwiZmVhdHVyZSIsImFvRmVhdHVyZXMiLCJjRmVhdHVyZSIsImZuSW5pdCIsImFhbkZlYXR1cmVzIiwicmVwbGFjZVdpdGgiLCJhTGF5b3V0IiwiblRycyIsIm5DZWxsIiwibCIsImlDb2xTaGlmdGVkIiwiYlVuaXF1ZSIsImZuU2hpZnRDb2wiLCJuSGVhZGVyIiwiYVJldHVybiIsInVuaXF1ZSIsImJTb3J0Q2VsbHNUb3AiLCJfZm5CdWlsZEFqYXgiLCJyYnJhY2tldCIsImFqYXhEYXRhIiwiaW5zdGFuY2UiLCJqcVhIUiIsIm5ld0RhdGEiLCJiYXNlQWpheCIsInNFcnJvciIsInNTZXJ2ZXJNZXRob2QiLCJ4aHIiLCJ0aHJvd24iLCJyZXQiLCJyZWFkeVN0YXRlIiwib0FqYXhEYXRhIiwiZm5TZXJ2ZXJEYXRhIiwic0FqYXhTb3VyY2UiLCJiQWpheERhdGFHZXQiLCJfZm5BamF4UGFyYW1ldGVycyIsIl9mbkFqYXhVcGRhdGVEcmF3IiwiY29sdW1uQ291bnQiLCJwcmVTZWFyY2giLCJwcmVDb2xTZWFyY2giLCJkYXRhUHJvcCIsImNvbHVtblNlYXJjaCIsImRpc3BsYXlTdGFydCIsImRpc3BsYXlMZW5ndGgiLCJfaURpc3BsYXlMZW5ndGgiLCJwYXJhbSIsInNTZWFyY2giLCJyZWdleCIsInNOYW1lIiwic2VhcmNoYWJsZSIsImJTZWFyY2hhYmxlIiwib3JkZXJhYmxlIiwibGVnYWN5IiwiY29tcGF0IiwibW9kZXJuIiwiX2ZuQWpheERhdGFTcmMiLCJyZWNvcmRzVG90YWwiLCJyZWNvcmRzRmlsdGVyZWQiLCJfYkluaXRDb21wbGV0ZSIsIl9mbkluaXRDb21wbGV0ZSIsImRhdGFTcmMiLCJzQWpheERhdGFQcm9wIiwidGFibGVJZCIsImxhbmd1YWdlIiwicHJldmlvdXNTZWFyY2giLCJpbnB1dCIsInNGaWx0ZXJJbnB1dCIsImYiLCJzRmlsdGVyIiwic2VhcmNoRm4iLCJzZWFyY2hEZWxheSIsImpxRmlsdGVyIiwic1NlYXJjaFBsYWNlaG9sZGVyIiwib24iLCJfZm5UaHJvdHRsZSIsImUiLCJrZXlDb2RlIiwiZXYiLCJhY3RpdmVFbGVtZW50Iiwib0lucHV0IiwiaUZvcmNlIiwib1ByZXZTZWFyY2giLCJhb1ByZXZTZWFyY2giLCJmblNhdmVGaWx0ZXIiLCJvRmlsdGVyIiwiZm5SZWdleCIsImJFc2NhcGVSZWdleCIsIl9mbkZpbHRlciIsIl9mbkZpbHRlckNvbHVtbiIsIl9mbkZpbHRlckN1c3RvbSIsImZpbHRlcnMiLCJkaXNwbGF5Um93cyIsIm1lcmdlIiwic2VhcmNoU3RyIiwic21hcnQiLCJjYXNlSW5zZW5zaXRpdmUiLCJkaXNwbGF5IiwicnBTZWFyY2giLCJfZm5GaWx0ZXJDcmVhdGVTZWFyY2giLCJ0ZXN0IiwicHJldlNlYXJjaCIsImRpc3BsYXlNYXN0ZXIiLCJpbnZhbGlkYXRlZCIsImZpbHRlcmVkIiwiX2ZuRmlsdGVyRGF0YSIsIl9zRmlsdGVyUm93Iiwid29yZCIsIm0iLCJfX2ZpbHRlcl9kaXYiLCJfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsImZpbHRlckRhdGEiLCJmb21hdHRlcnMiLCJ3YXNJbnZhbGlkYXRlZCIsImlubmVyVGV4dCIsIl9mblNlYXJjaFRvQ2FtZWwiLCJvYmoiLCJfZm5TZWFyY2hUb0h1bmciLCJ0aWQiLCJzSW5mbyIsImFvRHJhd0NhbGxiYWNrIiwiX2ZuVXBkYXRlSW5mbyIsIm1heCIsInRvdGFsIiwic0luZm9FbXB0eSIsInNJbmZvRmlsdGVyZWQiLCJzSW5mb1Bvc3RGaXgiLCJfZm5JbmZvTWFjcm9zIiwiZm5JbmZvQ2FsbGJhY2siLCJmb3JtYXR0ZXIiLCJmbkZvcm1hdE51bWJlciIsImFsbCIsImNlaWwiLCJpQWpheFN0YXJ0IiwiZGVmZXJMb2FkaW5nIiwiX2ZuU3RyaW5nVG9Dc3MiLCJhRGF0YSIsIl9mbkxlbmd0aENoYW5nZSIsIl9mbkxlbmd0aE92ZXJmbG93IiwibWVudSIsImQyIiwibGVuZ3RocyIsInNlbGVjdCIsInNMZW5ndGhTZWxlY3QiLCJPcHRpb24iLCJkaXYiLCJzTGVuZ3RoIiwic0xlbmd0aE1lbnUiLCJvdXRlckhUTUwiLCJzUGFnaW5hdGlvblR5cGUiLCJwbHVnaW4iLCJwYWdlciIsInNQYWdpbmciLCJwIiwidmlzUmVjb3JkcyIsInBhZ2VzIiwiYnV0dG9ucyIsIl9mblBhZ2VDaGFuZ2UiLCJhY3Rpb24iLCJyZWNvcmRzIiwiZmxvb3IiLCJjaGFuZ2VkIiwiciIsInNQcm9jZXNzaW5nIiwic2Nyb2xsWSIsImNhcHRpb24iLCJjYXB0aW9uU2lkZSIsImhlYWRlckNsb25lIiwiY2xvbmVOb2RlIiwiZm9vdGVyQ2xvbmUiLCJmb290ZXIiLCJfZGl2Iiwic2l6ZSIsInNjcm9sbGVyIiwic1Njcm9sbFdyYXBwZXIiLCJzU2Nyb2xsSGVhZCIsImJvcmRlciIsInNTY3JvbGxIZWFkSW5uZXIiLCJzWElubmVyIiwicmVtb3ZlQXR0ciIsInNTY3JvbGxCb2R5Iiwic1Njcm9sbEZvb3QiLCJzU2Nyb2xsRm9vdElubmVyIiwic2Nyb2xsSGVhZCIsInNjcm9sbEJvZHkiLCJzY3JvbGxGb290IiwiYkNvbGxhcHNlIiwiblNjcm9sbEhlYWQiLCJuU2Nyb2xsQm9keSIsIm5TY3JvbGxGb290Iiwic2Nyb2xsWElubmVyIiwiZGl2SGVhZGVyIiwiZGl2SGVhZGVyU3R5bGUiLCJkaXZIZWFkZXJJbm5lciIsImRpdkhlYWRlcklubmVyU3R5bGUiLCJkaXZIZWFkZXJUYWJsZSIsImRpdkJvZHlFbCIsImRpdkJvZHkiLCJkaXZCb2R5U3R5bGUiLCJkaXZGb290ZXIiLCJkaXZGb290ZXJJbm5lciIsImRpdkZvb3RlclRhYmxlIiwiaGVhZGVyIiwidGFibGVFbCIsInRhYmxlU3R5bGUiLCJpZTY3IiwiZHRIZWFkZXJDZWxscyIsImhlYWRlclRyZ0VscyIsImZvb3RlclRyZ0VscyIsImhlYWRlclNyY0VscyIsImZvb3RlclNyY0VscyIsImhlYWRlckNvcHkiLCJmb290ZXJDb3B5IiwiaGVhZGVyV2lkdGhzIiwiZm9vdGVyV2lkdGhzIiwiaGVhZGVyQ29udGVudCIsImZvb3RlckNvbnRlbnQiLCJjb3JyZWN0aW9uIiwic2FuaXR5V2lkdGgiLCJ6ZXJvT3V0IiwiblNpemVyIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwic2Nyb2xsQmFyVmlzIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY2xvbmUiLCJwcmVwZW5kVG8iLCJfZm5BcHBseVRvQ2hpbGRyZW4iLCJvdXRlcldpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiblRvU2l6ZSIsImlPdXRlcldpZHRoIiwiYlNjcm9sbGluZyIsInBhZGRpbmciLCJ0cmlnZ2VyIiwic2Nyb2xsVG9wIiwiYW4xIiwiYW4yIiwibk5vZGUxIiwibk5vZGUyIiwibm9kZVR5cGUiLCJfX3JlX2h0bWxfcmVtb3ZlIiwidmlzaWJsZUNvbHVtbnMiLCJoZWFkZXJDZWxscyIsInRhYmxlV2lkdGhBdHRyIiwidGFibGVDb250YWluZXIiLCJ1c2VySW5wdXRzIiwiY29sdW1uSWR4Iiwic3R5bGVXaWR0aCIsIl9mbkNvbnZlcnRUb1dpZHRoIiwidG1wVGFibGUiLCJtYXJnaW4iLCJfZm5HZXRXaWRlc3ROb2RlIiwic0NvbnRlbnRQYWRkaW5nIiwiaG9sZGVyIiwicmlnaHQiLCJib3VuZGluZyIsIl9yZXN6RXZ0IiwiYmluZFJlc2l6ZSIsInNJbnN0YW5jZSIsIl9mbkdldE1heExlblN0cmluZyIsIm1heElkeCIsImFpT3JpZyIsInNyY0NvbCIsImZpeGVkIiwiYWFTb3J0aW5nRml4ZWQiLCJmaXhlZE9iaiIsIm5lc3RlZFNvcnQiLCJwcmUiLCJwb3N0IiwiX2lkeCIsInNEYXRhVHlwZSIsIm9FeHRTb3J0Iiwib1NvcnQiLCJmb3JtYXR0ZXJzIiwic29ydENvbCIsIl9mblNvcnREYXRhIiwieCIsInkiLCJkYXRhQSIsImRhdGFCIiwibGFiZWwiLCJuZXh0U29ydCIsIm9BcmlhIiwicmVtb3ZlQXR0cmlidXRlIiwic1NvcnRBc2NlbmRpbmciLCJzU29ydERlc2NlbmRpbmciLCJfZm5Tb3J0TGlzdGVuZXIiLCJuZXh0U29ydElkeCIsIm5leHQiLCJiU29ydE11bHRpIiwic29ydElkeCIsImF0dGFjaFRvIiwiX2ZuQmluZEFjdGlvbiIsInNoaWZ0S2V5Iiwib2xkU29ydCIsImFMYXN0U29ydCIsInNvcnRDbGFzcyIsInNTb3J0Q29sdW1uIiwiYlNvcnRDbGFzc2VzIiwiY3VzdG9tU29ydCIsInNTb3J0RGF0YVR5cGUiLCJjdXN0b21EYXRhIiwic3RhdGUiLCJ0aW1lIiwib1NhdmVkU3RhdGUiLCJmblN0YXRlU2F2ZUNhbGxiYWNrIiwibG9hZGVkIiwiYWJTdGF0ZUxvYWQiLCJkdXJhdGlvbiIsImlTdGF0ZUR1cmF0aW9uIiwib0xvYWRlZFN0YXRlIiwiZm5TdGF0ZUxvYWRDYWxsYmFjayIsImxldmVsIiwibXNnIiwidG4iLCJzRXJyTW9kZSIsImVyck1vZGUiLCJhbGVydCIsImNvbnNvbGUiLCJsb2ciLCJtYXBwZWROYW1lIiwiZXh0ZW5kZXIiLCJicmVha1JlZnMiLCJ3aGljaCIsInByZXZlbnREZWZhdWx0Iiwic1N0b3JlIiwiY2FsbGJhY2tBcnIiLCJldmVudE5hbWUiLCJyZXZlcnNlIiwiRXZlbnQiLCJyZXN1bHQiLCJyZW5kZXJlciIsImhvc3QiLCJfX2FwaVN0cnVjdCIsIl9fYXJyYXlQcm90byIsIl90b1NldHRpbmdzIiwibWl4ZWQiLCJqcSIsInRhYmxlcyIsImNvbnRleHQiLCJjdHhTZXR0aW5ncyIsInNlbGVjdG9yIiwib3B0cyIsIkFwaSIsImFueSIsImNvdW50IiwiY3R4IiwiaXRlcmF0b3IiLCJhbHdheXNOZXciLCJpdGVtcyIsIml0ZW0iLCJhcGlJbnN0IiwiX3NlbGVjdG9yX3Jvd19pbmRleGVzIiwiYXBpU2VsZWN0b3IiLCJsYXN0SW5kZXhPZiIsInBsdWNrIiwicG9wIiwicmVkdWNlIiwicmVkdWNlUmlnaHQiLCJzaGlmdCIsInRvJCIsInRvSlF1ZXJ5IiwidW5zaGlmdCIsInNjb3BlIiwiX19kdF93cmFwcGVyIiwic3RydWN0IiwibWV0aG9kU2NvcGluZyIsInN0cnVjIiwibWV0aG9kRXh0IiwicHJvcEV4dCIsInJlZ2lzdGVyIiwiaGVpciIsIm1ldGhvZCIsInJlZ2lzdGVyUGx1cmFsIiwicGx1cmFsTmFtZSIsInNpbmd1bGFyTmFtZSIsIl9fdGFibGVfc2VsZWN0b3IiLCJwYWdpbmciLCJpbmZvIiwiX19yZWxvYWQiLCJvbmUiLCJhYm9ydCIsInJlc2V0UGFnaW5nIiwiX3NlbGVjdG9yX3J1biIsInNlbGVjdEZuIiwicmVzIiwic2VsZWN0b3JUeXBlIiwiX3NlbGVjdG9yX29wdHMiLCJfc2VsZWN0b3JfZmlyc3QiLCJpbnN0IiwiZGlzcGxheUZpbHRlcmVkIiwiZGlzcGxheUZpbHRlcmVkTWFwIiwiX19yb3dfc2VsZWN0b3IiLCJydW4iLCJzZWwiLCJzZWxJbnQiLCJjZWxsSWR4IiwiY2xvc2VzdCIsInJvd09iaiIsImhhc2giLCJ0aGF0SWR4IiwibG9vcFJvdyIsImxvb3BDZWxscyIsIm5ld1Jvd3MiLCJtb2RSb3dzIiwiX19kZXRhaWxzX2FkZCIsImtsYXNzIiwiYWRkUm93IiwiY3JlYXRlZCIsImNvbFNwYW4iLCJfZGV0YWlscyIsIl9kZXRhaWxzU2hvdyIsImluc2VydEFmdGVyIiwiX19kZXRhaWxzX3JlbW92ZSIsIl9fZGV0YWlsc19kaXNwbGF5IiwiX19kZXRhaWxzX2V2ZW50cyIsIm5hbWVzcGFjZSIsImRyYXdFdmVudCIsImNvbHZpc0V2ZW50IiwiZGVzdHJveUV2ZW50Iiwib2ZmIiwiX2VtcCIsIl9jaGlsZF9vYmoiLCJfY2hpbGRfbXRoIiwiX19yZV9jb2x1bW5fc2VsZWN0b3IiLCJfX2NvbHVtbkRhdGEiLCJyMSIsInIyIiwiX19jb2x1bW5fc2VsZWN0b3IiLCJuYW1lcyIsInZpc0NvbHVtbnMiLCJqcVJlc3VsdCIsIl9fc2V0Q29sdW1uVmlzIiwiY2FsYyIsIl9fY2VsbF9zZWxlY3RvciIsImFsbENlbGxzIiwiZm5TZWxlY3RvciIsInJvd1NlbGVjdG9yIiwiY29sdW1uU2VsZWN0b3IiLCJpbnRlcm5hbE9wdHMiLCJjZWxsc05vT3B0cyIsInNlbGVjdGVkIiwic2V0IiwiY2FzZUluc2VuIiwidmVyc2lvbkNoZWNrIiwidmVyc2lvbiIsImFUaGlzIiwiYVRoYXQiLCJpVGhpcyIsImlUaGF0IiwiaXNEYXRhVGFibGUiLCJmbklzRGF0YVRhYmxlIiwiZ2V0IiwiaXMiLCJoZWFkIiwiZm9vdCIsImZuVGFibGVzIiwiY2FtZWxUb0h1bmdhcmlhbiIsImpxUm93cyIsIm9yaWciLCJqcVRhYmxlIiwianFUYm9keSIsImpxV3JhcHBlciIsInJlbW92ZWRNZXRob2QiLCJzRGVzdHJveVdpZHRoIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsInRva2VuIiwicGx1cmFsIiwicmVzb2x2ZWQiLCJ0b0Zvcm1hdCIsIkpTT04iLCJwYXJzZSIsInNlc3Npb25TdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicGFnaW5hdGUiLCJtaW4iLCJidWlsZGVyIiwicGFnZUJ1dHRvbiIsIm9KVUlDbGFzc2VzIiwic1ZlcnNpb24iLCJhZm5GaWx0ZXJpbmciLCJhVHlwZXMiLCJvZm5TZWFyY2giLCJhZm5Tb3J0RGF0YSIsIm9TdGRDbGFzc2VzIiwib1BhZ2luYXRpb24iLCJleHRQYWdpbmF0aW9uIiwiX251bWJlcnMiLCJudW1iZXJzIiwibnVtYmVyc19sZW5ndGgiLCJoYWxmIiwiRFRfZWwiLCJzaW1wbGUiLCJmdWxsIiwic2ltcGxlX251bWJlcnMiLCJmdWxsX251bWJlcnMiLCJmaXJzdF9sYXN0X251bWJlcnMiLCJvUGFnaW5hdGUiLCJhcmlhIiwiYnRuRGlzcGxheSIsImJ0bkNsYXNzIiwiY291bnRlciIsImF0dGFjaCIsImNvbnRhaW5lciIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGlzYWJsZWRDbGFzcyIsInNQYWdlQnV0dG9uRGlzYWJsZWQiLCJjbGlja0hhbmRsZXIiLCJzRmlyc3QiLCJzUHJldmlvdXMiLCJzTmV4dCIsInNMYXN0Iiwic1BhZ2VCdXR0b25BY3RpdmUiLCJzUGFnZUJ1dHRvbiIsImFjdGl2ZUVsIiwiZW1wdHkiLCJwYXJzZWQiLCJzdHJpbmciLCJfX251bWVyaWNSZXBsYWNlIiwiZGVjaW1hbFBsYWNlIiwicmUxIiwicmUyIiwiSW5maW5pdHkiLCJ0cyIsInNTb3J0QXNjIiwic1NvcnREZXNjIiwianF1ZXJ5dWkiLCJzU29ydEpVSVdyYXBwZXIiLCJzU29ydEljb24iLCJzU29ydEpVSUFzYyIsInNTb3J0SlVJRGVzYyIsIl9faHRtbEVzY2FwZUVudGl0aWVzIiwicmVuZGVyIiwibnVtYmVyIiwidGhvdXNhbmRzIiwicHJlY2lzaW9uIiwicHJlZml4IiwicG9zdGZpeCIsIm5lZ2F0aXZlIiwiZmxvIiwidG9GaXhlZCIsImFicyIsImludFBhcnQiLCJmbG9hdFBhcnQiLCJ0ZXh0IiwiX2ZuQ2FsY3VsYXRlRW5kIiwiZGF0YVRhYmxlU2V0dGluZ3MiLCJkYXRhVGFibGVFeHQiLCJyZWFkeSIsInRhYmxlQ29sdW1ucyIsInRhYmxlUmFua3MiLCJkYXRhVGFibGVPcHRzIiwid293cGlSb3N0ZXJBamF4IiwiYWpheHVybCIsImljb24iLCJwYWdlTGVuZ3RoIiwib3JkZXJpbmciLCJvcmRlckJ5Iiwib3JkZXJCeUNvbHMiLCJvcmRlckJ5Q29sT3JkZXJpbmciLCJuZXdPcmRlcmluZyIsImRvbSIsInNob3dTZWxlY3RQYWdlTGVuZ3RoIiwic2hvd1NlYXJjaCJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxzQkFBa0IsRUFqSEU7O0FBb0hwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLFlBQVEsSUE5UVk7O0FBaVJwQjtBQUNGO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsZ0JBQVksSUFsTGU7O0FBcUwzQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UscUJBQWlCLElBbE5VOztBQXFOM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxhQUFTLElBdllrQjs7QUEwWTNCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxlQUFXLElBamdCZ0I7O0FBb2dCM0I7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRWx0QixTQUFLLEVBQUUsRUExU2U7O0FBNlN0QjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFNUIsUUFBSSxFQUFFO0FBQ0w7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRzZYLFlBQU0sRUFBRSxFQXpDSDs7QUE0Q0w7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0dsWSxZQUFNLEVBQUUsRUFoRkg7O0FBbUZMO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0QsUUFBSUosUUFBUSxDQUFDcGpDLE1BQVQsR0FBa0IsQ0FBdEIsRUFBMEI7QUFDdEIraUMsbUJBQWEsQ0FBQzVqQyxLQUFkLEdBQXNCaWtDLFFBQXRCO0FBQ0g7QUFFRDtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFUSxRQUFJSyxHQUFHLEdBQUcsRUFBVjtBQUVBLFFBQUlDLG9CQUFvQixHQUFHajVCLFFBQVEsQ0FBQ25SLDZDQUFDLENBQUMsSUFBRCxDQUFELENBQVFXLElBQVIsQ0FBYSxrQkFBYixDQUFELENBQW5DOztBQUNBLFFBQUcsTUFBTXlwQyxvQkFBVCxFQUErQjtBQUMzQkQsU0FBRyxJQUFJLEdBQVA7QUFDSDs7QUFFRCxRQUFJRSxVQUFVLEdBQUdsNUIsUUFBUSxDQUFDblIsNkNBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUVcsSUFBUixDQUFhLFlBQWIsQ0FBRCxDQUF6Qjs7QUFDQSxRQUFHLE1BQU0wcEMsVUFBVCxFQUFxQjtBQUNqQkYsU0FBRyxJQUFJLEdBQVA7QUFDSDs7QUFFREEsT0FBRyxJQUFJLE1BQVA7QUFFQVYsaUJBQWEsQ0FBQ1UsR0FBZCxHQUFvQkEsR0FBcEI7QUFJQW5xQyxpREFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRSSxTQUFSLENBQW1CcXBDLGFBQW5CO0FBQ0gsR0FwR0Q7QUFxR0gsQ0F4R0QsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQSx3QiIsImZpbGUiOiJ3b3dwaS1ndWlsZC1yb3N0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4iLCIvKiEgRGF0YVRhYmxlcyAxLjEwLjIyXG4gKiDCqTIwMDgtMjAyMCBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIERhdGFUYWJsZXNcbiAqIEBkZXNjcmlwdGlvbiBQYWdpbmF0ZSwgc2VhcmNoIGFuZCBvcmRlciBIVE1MIHRhYmxlc1xuICogQHZlcnNpb24gICAgIDEuMTAuMjJcbiAqIEBmaWxlICAgICAgICBqcXVlcnkuZGF0YVRhYmxlcy5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGRcbiAqIEBjb250YWN0ICAgICB3d3cuZGF0YXRhYmxlcy5uZXRcbiAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAwOC0yMDIwIFNwcnlNZWRpYSBMdGQuXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBmcmVlIHNvZnR3YXJlLCBhdmFpbGFibGUgdW5kZXIgdGhlIGZvbGxvd2luZyBsaWNlbnNlOlxuICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHVuZGVmOiB0cnVlLCBicm93c2VyOiB0cnVlICovXG4vKmdsb2JhbHMgJCxyZXF1aXJlLGpRdWVyeSxkZWZpbmUsX3NlbGVjdG9yX3J1bixfc2VsZWN0b3Jfb3B0cyxfc2VsZWN0b3JfZmlyc3QsX3NlbGVjdG9yX3Jvd19pbmRleGVzLF9leHQsX0FwaSxfYXBpX3JlZ2lzdGVyLF9hcGlfcmVnaXN0ZXJQbHVyYWwsX3JlX25ld19saW5lcyxfcmVfaHRtbCxfcmVfZm9ybWF0dGVkX251bWVyaWMsX3JlX2VzY2FwZV9yZWdleCxfZW1wdHksX2ludFZhbCxfbnVtVG9EZWNpbWFsLF9pc051bWJlcixfaXNIdG1sLF9odG1sTnVtZXJpYyxfcGx1Y2ssX3BsdWNrX29yZGVyLF9yYW5nZSxfc3RyaXBIdG1sLF91bmlxdWUsX2ZuQnVpbGRBamF4LF9mbkFqYXhVcGRhdGUsX2ZuQWpheFBhcmFtZXRlcnMsX2ZuQWpheFVwZGF0ZURyYXcsX2ZuQWpheERhdGFTcmMsX2ZuQWRkQ29sdW1uLF9mbkNvbHVtbk9wdGlvbnMsX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLF9mblZpc2libGVUb0NvbHVtbkluZGV4LF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLF9mblZpc2JsZUNvbHVtbnMsX2ZuR2V0Q29sdW1ucyxfZm5Db2x1bW5UeXBlcyxfZm5BcHBseUNvbHVtbkRlZnMsX2ZuSHVuZ2FyaWFuTWFwLF9mbkNhbWVsVG9IdW5nYXJpYW4sX2ZuTGFuZ3VhZ2VDb21wYXQsX2ZuQnJvd3NlckRldGVjdCxfZm5BZGREYXRhLF9mbkFkZFRyLF9mbk5vZGVUb0RhdGFJbmRleCxfZm5Ob2RlVG9Db2x1bW5JbmRleCxfZm5HZXRDZWxsRGF0YSxfZm5TZXRDZWxsRGF0YSxfZm5TcGxpdE9iak5vdGF0aW9uLF9mbkdldE9iamVjdERhdGFGbixfZm5TZXRPYmplY3REYXRhRm4sX2ZuR2V0RGF0YU1hc3RlcixfZm5DbGVhclRhYmxlLF9mbkRlbGV0ZUluZGV4LF9mbkludmFsaWRhdGUsX2ZuR2V0Um93RWxlbWVudHMsX2ZuQ3JlYXRlVHIsX2ZuQnVpbGRIZWFkLF9mbkRyYXdIZWFkLF9mbkRyYXcsX2ZuUmVEcmF3LF9mbkFkZE9wdGlvbnNIdG1sLF9mbkRldGVjdEhlYWRlcixfZm5HZXRVbmlxdWVUaHMsX2ZuRmVhdHVyZUh0bWxGaWx0ZXIsX2ZuRmlsdGVyQ29tcGxldGUsX2ZuRmlsdGVyQ3VzdG9tLF9mbkZpbHRlckNvbHVtbixfZm5GaWx0ZXIsX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLF9mbkVzY2FwZVJlZ2V4LF9mbkZpbHRlckRhdGEsX2ZuRmVhdHVyZUh0bWxJbmZvLF9mblVwZGF0ZUluZm8sX2ZuSW5mb01hY3JvcyxfZm5Jbml0aWFsaXNlLF9mbkluaXRDb21wbGV0ZSxfZm5MZW5ndGhDaGFuZ2UsX2ZuRmVhdHVyZUh0bWxMZW5ndGgsX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxfZm5QYWdlQ2hhbmdlLF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxfZm5Qcm9jZXNzaW5nRGlzcGxheSxfZm5GZWF0dXJlSHRtbFRhYmxlLF9mblNjcm9sbERyYXcsX2ZuQXBwbHlUb0NoaWxkcmVuLF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxfZm5UaHJvdHRsZSxfZm5Db252ZXJ0VG9XaWR0aCxfZm5HZXRXaWRlc3ROb2RlLF9mbkdldE1heExlblN0cmluZyxfZm5TdHJpbmdUb0NzcyxfZm5Tb3J0RmxhdHRlbixfZm5Tb3J0LF9mblNvcnRBcmlhLF9mblNvcnRMaXN0ZW5lcixfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsX2ZuU29ydGluZ0NsYXNzZXMsX2ZuU29ydERhdGEsX2ZuU2F2ZVN0YXRlLF9mbkxvYWRTdGF0ZSxfZm5TZXR0aW5nc0Zyb21Ob2RlLF9mbkxvZyxfZm5NYXAsX2ZuQmluZEFjdGlvbixfZm5DYWxsYmFja1JlZyxfZm5DYWxsYmFja0ZpcmUsX2ZuTGVuZ3RoT3ZlcmZsb3csX2ZuUmVuZGVyZXIsX2ZuRGF0YVNvdXJjZSxfZm5Sb3dBdHRyaWJ1dGVzKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0Ly8gQ29tbW9uSlMgZW52aXJvbm1lbnRzIHdpdGhvdXQgYSB3aW5kb3cgZ2xvYmFsIG11c3QgcGFzcyBhXG5cdFx0XHRcdC8vIHJvb3QuIFRoaXMgd2lsbCBnaXZlIGFuIGVycm9yIG90aGVyd2lzZVxuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCApIHtcblx0XHRcdFx0JCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gLy8galF1ZXJ5J3MgZmFjdG9yeSBjaGVja3MgZm9yIGEgZ2xvYmFsIHdpbmRvd1xuXHRcdFx0XHRcdHJlcXVpcmUoJ2pxdWVyeScpIDpcblx0XHRcdFx0XHRyZXF1aXJlKCdqcXVlcnknKSggcm9vdCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59XG4oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgaXMgYSBwbHVnLWluIGZvciB0aGUgalF1ZXJ5IEphdmFzY3JpcHQgbGlicmFyeS4gSXQgaXMgYSBoaWdobHlcblx0ICogZmxleGlibGUgdG9vbCwgYmFzZWQgdXBvbiB0aGUgZm91bmRhdGlvbnMgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsXG5cdCAqIHdoaWNoIHdpbGwgYWRkIGFkdmFuY2VkIGludGVyYWN0aW9uIGNvbnRyb2xzIHRvIGFueSBIVE1MIHRhYmxlLiBGb3IgYVxuXHQgKiBmdWxsIGxpc3Qgb2YgZmVhdHVyZXMgcGxlYXNlIHJlZmVyIHRvXG5cdCAqIFtEYXRhVGFibGVzLm5ldF0oaHJlZj1cImh0dHA6Ly9kYXRhdGFibGVzLm5ldCkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZWAgb2JqZWN0IGlzIG5vdCBhIGdsb2JhbCB2YXJpYWJsZSBidXQgaXMgYWxpYXNlZFxuXHQgKiB0byBgalF1ZXJ5LmZuLkRhdGFUYWJsZWAgYW5kIGBqUXVlcnkuZm4uZGF0YVRhYmxlYCB0aHJvdWdoIHdoaWNoIGl0IG1heVxuXHQgKiBiZSAgYWNjZXNzZWQuXG5cdCAqXG5cdCAqICBAY2xhc3Ncblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbaW5pdD17fV0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMuIE9wdGlvbnNcblx0ICogICAgYXJlIGRlZmluZWQgYnkge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c31cblx0ICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gQmFzaWMgaW5pdGlhbGlzYXRpb25cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBJbml0aWFsaXNhdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAtIGluIHRoaXMgY2FzZSwgZGlzYWJsZVxuXHQgKiAgICAvLyBwYWdpbmF0aW9uIGFuZCBzb3J0aW5nLlxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxuXHQgKiAgICAgICAgXCJzb3J0XCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR2YXIgRGF0YVRhYmxlID0gZnVuY3Rpb24gKCBvcHRpb25zIClcblx0e1xuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXG5cdFx0ICogcmV0dXJuIHRoZSByZXN1bHRpbmcgalF1ZXJ5IG9iamVjdC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5maWx0ZXI9bm9uZV0gU2VsZWN0IFRSIGVsZW1lbnRzIHRoYXQgbWVldCB0aGUgY3VycmVudCBmaWx0ZXJcblx0XHQgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgVFIgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cblx0XHQgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuXHRcdCAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG5cdFx0ICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuXHRcdCAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXG5cdFx0ICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSGlnaGxpZ2h0IGV2ZXJ5IHNlY29uZCByb3dcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvIHJvd3Mgd2l0aCAnV2Via2l0JyBpbiB0aGVtLCBhZGQgYSBiYWNrZ3JvdW5kIGNvbG91ciBhbmQgdGhlblxuXHRcdCAqICAgICAgLy8gcmVtb3ZlIHRoZSBmaWx0ZXIsIHRodXMgaGlnaGxpZ2h0aW5nIHRoZSAnV2Via2l0JyByb3dzIG9ubHkuXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSkuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCAnYmx1ZScpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCcnKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy4kID0gZnVuY3Rpb24gKCBzU2VsZWN0b3IsIG9PcHRzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkodHJ1ZSkuJCggc1NlbGVjdG9yLCBvT3B0cyApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQWxtb3N0IGlkZW50aWNhbCB0byAkIGluIG9wZXJhdGlvbiwgYnV0IGluIHRoaXMgY2FzZSByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbWF0Y2hlZFxuXHRcdCAqIHJvd3MgLSBhcyBzdWNoLCB0aGUgalF1ZXJ5IHNlbGVjdG9yIHVzZWQgc2hvdWxkIG1hdGNoIFRSIHJvdyBub2RlcyBvciBURC9USCBjZWxsIG5vZGVzXG5cdFx0ICogcmF0aGVyIHRoYW4gYW55IGRlc2NlbmRhbnRzLCBzbyB0aGUgZGF0YSBjYW4gYmUgb2J0YWluZWQgZm9yIHRoZSByb3cvY2VsbC4gSWYgbWF0Y2hpbmdcblx0XHQgKiByb3dzIGFyZSBmb3VuZCwgdGhlIGRhdGEgcmV0dXJuZWQgaXMgdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkvb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG9cblx0XHQgKiBjcmVhdGUgdGhlIHJvdyAob3IgYSBnZW5lcmF0ZWQgYXJyYXkgaWYgZnJvbSBhIERPTSBzb3VyY2UpLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgb2Z0ZW4gdXNlZnVsIGluLWNvbWJpbmF0aW9uIHdpdGggJCB3aGVyZSBib3RoIGZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlXG5cdFx0ICogc2FtZSBwYXJhbWV0ZXJzIGFuZCB0aGUgYXJyYXkgaW5kZXhlcyB3aWxsIG1hdGNoIGlkZW50aWNhbGx5LlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gc1NlbGVjdG9yIGpRdWVyeSBzZWxlY3RvciBvciBub2RlIGNvbGxlY3Rpb24gdG8gYWN0IG9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuXHRcdCAqICAgIGNyaXRlcmlvbiAoXCJhcHBsaWVkXCIpIG9yIGFsbCBlbGVtZW50cyAoaS5lLiBubyBmaWx0ZXIpLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBkYXRhIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXG5cdFx0ICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3Jcblx0XHQgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxuXHRcdCAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcblx0XHQgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IERhdGEgZm9yIHRoZSBtYXRjaGVkIGVsZW1lbnRzLiBJZiBhbnkgZWxlbWVudHMsIGFzIGEgcmVzdWx0IG9mIHRoZVxuXHRcdCAqICAgIHNlbGVjdG9yLCB3ZXJlIG5vdCBUUiwgVEQgb3IgVEggZWxlbWVudHMgaW4gdGhlIERhdGFUYWJsZSwgdGhleSB3aWxsIGhhdmUgYSBudWxsXG5cdFx0ICogICAgZW50cnkgaW4gdGhlIGFycmF5LlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZVxuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHI6Zmlyc3QnKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBkYXRhXG5cdFx0ICogICAgICBhbGVydCggXCJGaXJzdCBjZWxsIGlzOiBcIitkYXRhWzBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRmlsdGVyIHRvICdXZWJraXQnIGFuZCBnZXQgYWxsIGRhdGEgZm9yXG5cdFx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHRcdCAqICAgICAgdmFyIGRhdGEgPSBvVGFibGUuXygndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGFcblx0XHQgKiAgICAgIGFsZXJ0KCBkYXRhLmxlbmd0aCtcIiByb3dzIG1hdGNoZWQgdGhlIHNlYXJjaFwiICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuXyA9IGZ1bmN0aW9uICggc1NlbGVjdG9yLCBvT3B0cyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBpKHRydWUpLnJvd3MoIHNTZWxlY3Rvciwgb09wdHMgKS5kYXRhKCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBEYXRhVGFibGVzIEFwaSBpbnN0YW5jZSwgd2l0aCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYmxlcyBmb3Jcblx0XHQgKiB0aGUgQXBpJ3MgY29udGV4dC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFkaXRpb25hbD1mYWxzZV0gU2V0IHRoZSBBUEkgaW5zdGFuY2UncyBjb250ZXh0IHRvIGJlXG5cdFx0ICogICBvbmx5IHRoZSB0YWJsZSByZWZlcnJlZCB0byBieSB0aGUgYERhdGFUYWJsZS5leHQuaUFwaUluZGV4YCBvcHRpb24sIGFzIHdhc1xuXHRcdCAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxuXHRcdCAqICAgb3IgaWYgYWxsIHRhYmxlcyBjYXB0dXJlZCBpbiB0aGUgalF1ZXJ5IG9iamVjdCBzaG91bGQgYmUgdXNlZC5cblx0XHQgKiBAcmV0dXJuIHtEYXRhVGFibGVzLkFwaX1cblx0XHQgKi9cblx0XHR0aGlzLmFwaSA9IGZ1bmN0aW9uICggdHJhZGl0aW9uYWwgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cmFkaXRpb25hbCA/XG5cdFx0XHRcdG5ldyBfQXBpKFxuXHRcdFx0XHRcdF9mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbIF9leHQuaUFwaUluZGV4IF0gKVxuXHRcdFx0XHQpIDpcblx0XHRcdFx0bmV3IF9BcGkoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXG5cdFx0ICogdGhhdCB0aGlzIGlzIHN1aXRhYmxlIGZvciBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIG9ubHkgLSBpZiB5b3UgYXJlIHVzaW5nXG5cdFx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAoaS5lLiBcImJTZXJ2ZXJTaWRlXCI6IHRydWUpLCB0aGVuIHRvIGFkZCBkYXRhLCB5b3Vcblx0XHQgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRhYmxlLiBUaGlzIGNhbiBiZTpcblx0XHQgKiAgICA8dWw+XG5cdFx0ICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XG5cdFx0ICogICAgICA8bGk+MkQgYXJyYXkgb2YgYXJyYXlzIC0gYWRkIG11bHRpcGxlIHJvd3MgaW4gYSBzaW5nbGUgY2FsbDwvbGk+XG5cdFx0ICogICAgICA8bGk+b2JqZWN0IC0gZGF0YSBvYmplY3Qgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHRcdCAqICAgIDwvdWw+XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxuXHRcdCAqICAgIDxpPmFvRGF0YTwvaT4gKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc30pIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvXG5cdFx0ICogICAgdGhlIHRhYmxlLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBHbG9iYWwgdmFyIGZvciBjb3VudGVyXG5cdFx0ICogICAgdmFyIGdpQ291bnQgPSAyO1xuXHRcdCAqXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgIGZ1bmN0aW9uIGZuQ2xpY2tBZGRSb3coKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjFcIixcblx0XHQgKiAgICAgICAgZ2lDb3VudCtcIi4yXCIsXG5cdFx0ICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxuXHRcdCAqICAgICAgICBnaUNvdW50K1wiLjRcIiBdXG5cdFx0ICogICAgICApO1xuXHRcdCAqXG5cdFx0ICogICAgICBnaUNvdW50Kys7XG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGREYXRhID0gZnVuY3Rpb24oIGRhdGEsIHJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHQvKiBDaGVjayBpZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSByb3dzIG9yIG5vdCAqL1xuXHRcdFx0dmFyIHJvd3MgPSBBcnJheS5pc0FycmF5KGRhdGEpICYmICggQXJyYXkuaXNBcnJheShkYXRhWzBdKSB8fCAkLmlzUGxhaW5PYmplY3QoZGF0YVswXSkgKSA/XG5cdFx0XHRcdGFwaS5yb3dzLmFkZCggZGF0YSApIDpcblx0XHRcdFx0YXBpLnJvdy5hZGQoIGRhdGEgKTtcblx0XHRcblx0XHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0cmV0dXJuIHJvd3MuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIERhdGFUYWJsZXMgcmVjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXplcywgYmFzZWQgb24gdGhlIGRhdGFcblx0XHQgKiBjb250YWluZWQgaW4gdGhlIHRhYmxlIGFuZCB0aGUgc2l6ZXMgYXBwbGllZCB0byB0aGUgY29sdW1ucyAoaW4gdGhlIERPTSwgQ1NTIG9yXG5cdFx0ICogdGhyb3VnaCB0aGUgc1dpZHRoIHBhcmFtZXRlcikuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUnc1xuXHRcdCAqIHBhcmVudCBlbGVtZW50IGNoYW5nZXMgKGZvciBleGFtcGxlIGEgd2luZG93IHJlc2l6ZSkuXG5cdFx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3QsIHlvdSB3aWxsIHR5cGljYWxseSB3YW50IHRvXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic1Njcm9sbFlcIjogXCIyMDBweFwiLFxuXHRcdCAqICAgICAgICBcImJQYWdpbmF0ZVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgb1RhYmxlLmZuQWRqdXN0Q29sdW1uU2l6aW5nKCk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5BZGp1c3RDb2x1bW5TaXppbmcgPSBmdW5jdGlvbiAoIGJSZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSBhcGkuc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsLnNYICE9PSBcIlwiIHx8IHNjcm9sbC5zWSAhPT0gXCJcIiApIHtcblx0XHRcdFx0LyogSWYgbm90IHJlZHJhd2luZywgYnV0IHNjcm9sbGluZywgd2Ugd2FudCB0byBhcHBseSB0aGUgbmV3IGNvbHVtbiBzaXplcyBhbnl3YXkgKi9cblx0XHRcdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFF1aWNrbHkgYW5kIHNpbXBseSBjbGVhciBhIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gSW1tZWRpYXRlbHkgJ251a2UnIHRoZSBjdXJyZW50IHJvd3MgKHBlcmhhcHMgd2FpdGluZyBmb3IgYW4gQWpheCBjYWxsYmFjay4uLilcblx0XHQgKiAgICAgIG9UYWJsZS5mbkNsZWFyVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkNsZWFyVGFibGUgPSBmdW5jdGlvbiggYlJlZHJhdyApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY2xlYXIoKTtcblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXhhY3Qgb3Bwb3NpdGUgb2YgJ29wZW5pbmcnIGEgcm93LCB0aGlzIGZ1bmN0aW9uIHdpbGwgY2xvc2UgYW55IHJvd3Mgd2hpY2hcblx0XHQgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byAnY2xvc2UnXG5cdFx0ICogIEByZXR1cm5zIHtpbnR9IDAgb24gc3VjY2Vzcywgb3IgMSBpZiBmYWlsZWQgKGNhbid0IGZpbmQgdGhlIHJvdylcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHRcdCAqICAgICAgICB9IGVsc2Uge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkNsb3NlID0gZnVuY3Rpb24oIG5UciApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmhpZGUoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhIHJvdyBmb3IgdGhlIHRhYmxlXG5cdFx0ICogIEBwYXJhbSB7bWl4ZWR9IHRhcmdldCBUaGUgaW5kZXggb2YgdGhlIHJvdyBmcm9tIGFvRGF0YSB0byBiZSBkZWxldGVkLCBvclxuXHRcdCAqICAgIHRoZSBUUiBlbGVtZW50IHlvdSB3YW50IHRvIGRlbGV0ZVxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IFtjYWxsQmFja10gQ2FsbGJhY2sgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdFx0ICogIEByZXR1cm5zIHthcnJheX0gVGhlIHJvdyB0aGF0IHdhcyBkZWxldGVkXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgZmlyc3Qgcm93XG5cdFx0ICogICAgICBvVGFibGUuZm5EZWxldGVSb3coIDAgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkRlbGV0ZVJvdyA9IGZ1bmN0aW9uKCB0YXJnZXQsIGNhbGxiYWNrLCByZWRyYXcgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFx0dmFyIHJvd3MgPSBhcGkucm93cyggdGFyZ2V0ICk7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSByb3dzLnNldHRpbmdzKClbMF07XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93c1swXVswXSBdO1xuXHRcdFxuXHRcdFx0cm93cy5yZW1vdmUoKTtcblx0XHRcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXMsIHNldHRpbmdzLCBkYXRhICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmRyYXcoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVzdG9yZSB0aGUgdGFibGUgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSBpbiB0aGUgRE9NIGJ5IHJlbW92aW5nIGFsbCBvZiBEYXRhVGFibGVzXG5cdFx0ICogZW5oYW5jZW1lbnRzLCBhbHRlcmF0aW9ucyB0byB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdGFibGUgYW5kIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKiAgQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlPWZhbHNlXSBDb21wbGV0ZWx5IHJlbW92ZSB0aGUgdGFibGUgZnJvbSB0aGUgRE9NXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgLy8gVGhpcyBleGFtcGxlIGlzIGZhaXJseSBwb2ludGxlc3MgaW4gcmVhbGl0eSwgYnV0IHNob3dzIGhvdyBmbkRlc3Ryb3kgY2FuIGJlIHVzZWRcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuRGVzdHJveSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRGVzdHJveSA9IGZ1bmN0aW9uICggcmVtb3ZlIClcblx0XHR7XG5cdFx0XHR0aGlzLmFwaSggdHJ1ZSApLmRlc3Ryb3koIHJlbW92ZSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVkcmF3IHRoZSB0YWJsZVxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtjb21wbGV0ZT10cnVlXSBSZS1maWx0ZXIgYW5kIHJlc29ydCAoaWYgZW5hYmxlZCkgdGhlIHRhYmxlIGJlZm9yZSB0aGUgZHJhdy5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gUmUtZHJhdyB0aGUgdGFibGUgLSB5b3Ugd291bGRuJ3Qgd2FudCB0byBkbyBpdCBoZXJlLCBidXQgaXQncyBhbiBleGFtcGxlIDotKVxuXHRcdCAqICAgICAgb1RhYmxlLmZuRHJhdygpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuRHJhdyA9IGZ1bmN0aW9uKCBjb21wbGV0ZSApXG5cdFx0e1xuXHRcdFx0Ly8gTm90ZSB0aGF0IHRoaXMgaXNuJ3QgYW4gZXhhY3QgbWF0Y2ggdG8gdGhlIG9sZCBjYWxsIHRvIF9mbkRyYXcgLSBpdCB0YWtlc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50IHRoZSBuZXcgZGF0YSwgYnV0IGNhbiBob2xkIHBvc2l0aW9uLlxuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5kcmF3KCBjb21wbGV0ZSApO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyIHRoZSBpbnB1dCBiYXNlZCBvbiBkYXRhXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgU3RyaW5nIHRvIGZpbHRlciB0aGUgdGFibGUgb25cblx0XHQgKiAgQHBhcmFtIHtpbnR8bnVsbH0gW2lDb2x1bW5dIENvbHVtbiB0byBsaW1pdCBmaWx0ZXJpbmcgdG9cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZ2V4PWZhbHNlXSBUcmVhdCBhcyByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gW2JTbWFydD10cnVlXSBQZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlNob3dHbG9iYWw9dHJ1ZV0gU2hvdyB0aGUgaW5wdXQgZ2xvYmFsIGZpbHRlciBpbiBpdCdzIGlucHV0IGJveChlcylcblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYkNhc2VJbnNlbnNpdGl2ZT10cnVlXSBEbyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nICh0cnVlKSBvciBub3QgKGZhbHNlKVxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTb21ldGltZSBsYXRlciAtIGZpbHRlci4uLlxuXHRcdCAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCAndGVzdCBzdHJpbmcnICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5GaWx0ZXIgPSBmdW5jdGlvbiggc0lucHV0LCBpQ29sdW1uLCBiUmVnZXgsIGJTbWFydCwgYlNob3dHbG9iYWwsIGJDYXNlSW5zZW5zaXRpdmUgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0aWYgKCBpQ29sdW1uID09PSBudWxsIHx8IGlDb2x1bW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0YXBpLnNlYXJjaCggc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5jb2x1bW4oIGlDb2x1bW4gKS5zZWFyY2goIHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUgKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB3aG9sZSB0YWJsZSwgYW4gaW5kaXZpZHVhbCByb3cgb3IgYW4gaW5kaXZpZHVhbCBjZWxsIGJhc2VkIG9uIHRoZVxuXHRcdCAqIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG5cdFx0ICogIEBwYXJhbSB7aW50fG5vZGV9IFtzcmNdIEEgVFIgcm93IG5vZGUsIFREL1RIIGNlbGwgbm9kZSBvciBhbiBpbnRlZ2VyLiBJZiBnaXZlbiBhc1xuXHRcdCAqICAgIGEgVFIgbm9kZSB0aGVuIHRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhXG5cdFx0ICogICAgVEQvVEggY2VsbCBub2RlIHRoZW4gaUNvbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdGhlIGRhdGEgZm9yIHRoZVxuXHRcdCAqICAgIGNlbGwgcmV0dXJuZWQuIElmIGdpdmVuIGFzIGFuIGludGVnZXIsIHRoZW4gdGhpcyBpcyB0cmVhdGVkIGFzIHRoZSBhb0RhdGEgaW50ZXJuYWxcblx0XHQgKiAgICBkYXRhIGluZGV4IGZvciB0aGUgcm93IChzZWUgZm5HZXRQb3NpdGlvbikgYW5kIHRoZSBkYXRhIGZvciB0aGF0IHJvdyB1c2VkLlxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2NvbF0gT3B0aW9uYWwgY29sdW1uIGluZGV4IHRoYXQgeW91IHdhbnQgdGhlIGRhdGEgb2YuXG5cdFx0ICogIEByZXR1cm5zIHthcnJheXxvYmplY3R8c3RyaW5nfSBJZiBtUm93IGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgZGF0YSBmb3IgYWxsIHJvd3MgaXNcblx0XHQgKiAgICByZXR1cm5lZC4gSWYgbVJvdyBpcyBkZWZpbmVkLCBqdXN0IGRhdGEgZm9yIHRoYXQgcm93LCBhbmQgaXMgaUNvbCBpc1xuXHRcdCAqICAgIGRlZmluZWQsIG9ubHkgZGF0YSBmb3IgdGhlIGRlc2lnbmF0ZWQgY2VsbCBpcyByZXR1cm5lZC5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUm93IGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZS4kKCd0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIHZhciBkYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuXHRcdCAqICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFycmF5IC8gb2JqZWN0IG9mIGRhdGEgZm9yIHRoZSByb3dcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBJbmRpdmlkdWFsIGNlbGwgZGF0YVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgb1RhYmxlLiQoJ3RkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgdmFyIHNEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuXHRcdCAqICAgICAgICBhbGVydCggJ1RoZSBjZWxsIGNsaWNrZWQgb24gaGFkIHRoZSB2YWx1ZSBvZiAnK3NEYXRhICk7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5HZXREYXRhID0gZnVuY3Rpb24oIHNyYywgY29sIClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XHRcblx0XHRcdGlmICggc3JjICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gc3JjLm5vZGVOYW1lID8gc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0XHRcblx0XHRcdFx0cmV0dXJuIGNvbCAhPT0gdW5kZWZpbmVkIHx8IHR5cGUgPT0gJ3RkJyB8fCB0eXBlID09ICd0aCcgP1xuXHRcdFx0XHRcdGFwaS5jZWxsKCBzcmMsIGNvbCApLmRhdGEoKSA6XG5cdFx0XHRcdFx0YXBpLnJvdyggc3JjICkuZGF0YSgpIHx8IG51bGw7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRyZXR1cm4gYXBpLmRhdGEoKS50b0FycmF5KCk7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBHZXQgYW4gYXJyYXkgb2YgdGhlIFRSIG5vZGVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlJ3MgYm9keS4gTm90ZSB0aGF0IHlvdSB3aWxsXG5cdFx0ICogdHlwaWNhbGx5IHdhbnQgdG8gdXNlIHRoZSAnJCcgQVBJIG1ldGhvZCBpbiBwcmVmZXJlbmNlIHRvIHRoaXMgYXMgaXQgaXMgbW9yZVxuXHRcdCAqIGZsZXhpYmxlLlxuXHRcdCAqICBAcGFyYW0ge2ludH0gW2lSb3ddIE9wdGlvbmFsIHJvdyBpbmRleCBmb3IgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnRcblx0XHQgKiAgQHJldHVybnMge2FycmF5fG5vZGV9IElmIGlSb3cgaXMgdW5kZWZpbmVkLCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBUUiBlbGVtZW50c1xuXHRcdCAqICAgIGluIHRoZSB0YWJsZSdzIGJvZHksIG9yIGlSb3cgaXMgZGVmaW5lZCwganVzdCB0aGUgVFIgZWxlbWVudCByZXF1ZXN0ZWQuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEdldCB0aGUgbm9kZXMgZnJvbSB0aGUgdGFibGVcblx0XHQgKiAgICAgIHZhciBuTm9kZXMgPSBvVGFibGUuZm5HZXROb2RlcyggKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldE5vZGVzID0gZnVuY3Rpb24oIGlSb3cgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFxuXHRcdFx0cmV0dXJuIGlSb3cgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGFwaS5yb3coIGlSb3cgKS5ub2RlKCkgOlxuXHRcdFx0XHRhcGkucm93cygpLm5vZGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgYXJyYXkgaW5kZXhlcyBvZiBhIHBhcnRpY3VsYXIgY2VsbCBmcm9tIGl0J3MgRE9NIGVsZW1lbnRcblx0XHQgKiBhbmQgY29sdW1uIGluZGV4IGluY2x1ZGluZyBoaWRkZW4gY29sdW1uc1xuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5vZGUgdGhpcyBjYW4gZWl0aGVyIGJlIGEgVFIsIFREIG9yIFRIIGluIHRoZSB0YWJsZSdzIGJvZHlcblx0XHQgKiAgQHJldHVybnMge2ludH0gSWYgbk5vZGUgaXMgZ2l2ZW4gYXMgYSBUUiwgdGhlbiBhIHNpbmdsZSBpbmRleCBpcyByZXR1cm5lZCwgb3Jcblx0XHQgKiAgICBpZiBnaXZlbiBhcyBhIGNlbGwsIGFuIGFycmF5IG9mIFtyb3cgaW5kZXgsIGNvbHVtbiBpbmRleCAodmlzaWJsZSksXG5cdFx0ICogICAgY29sdW1uIGluZGV4IChhbGwpXSBpcyBnaXZlbi5cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0YSBmcm9tIHRoZSBub2RlXG5cdFx0ICogICAgICAgIHZhciBhUG9zID0gb1RhYmxlLmZuR2V0UG9zaXRpb24oIHRoaXMgKTtcblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBHZXQgdGhlIGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogICAgICAgIHZhciBhRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIGFQb3NbMF0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBVcGRhdGUgdGhlIGRhdGEgYXJyYXkgYW5kIHJldHVybiB0aGUgdmFsdWVcblx0XHQgKiAgICAgICAgYURhdGFbIGFQb3NbMV0gXSA9ICdjbGlja2VkJztcblx0XHQgKiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnY2xpY2tlZCc7XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIEluaXQgRGF0YVRhYmxlc1xuXHRcdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mbkdldFBvc2l0aW9uID0gZnVuY3Rpb24oIG5vZGUgKVxuXHRcdHtcblx0XHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdFxuXHRcdFx0aWYgKCBub2RlTmFtZSA9PSAnVFInICkge1xuXHRcdFx0XHRyZXR1cm4gYXBpLnJvdyggbm9kZSApLmluZGV4KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggbm9kZU5hbWUgPT0gJ1REJyB8fCBub2RlTmFtZSA9PSAnVEgnICkge1xuXHRcdFx0XHR2YXIgY2VsbCA9IGFwaS5jZWxsKCBub2RlICkuaW5kZXgoKTtcblx0XHRcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRjZWxsLnJvdyxcblx0XHRcdFx0XHRjZWxsLmNvbHVtblZpc2libGUsXG5cdFx0XHRcdFx0Y2VsbC5jb2x1bW5cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgdG8gc2VlIGlmIGEgcm93IGlzICdvcGVuJyBvciBub3QuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIHRoZSB0YWJsZSByb3cgdG8gY2hlY2tcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdyBpcyBjdXJyZW50bHkgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0XHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0XHQgKiAgICAgICAgfSBlbHNlIHtcblx0XHQgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Jc09wZW4gPSBmdW5jdGlvbiggblRyIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmlzU2hvd24oKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XG5cdFx0ICogb24gZGlzcGxheSBvbiB0aGUgcGFnZSwgd2l0aCB0aGUgSFRNTCBjb250ZW50cyB0aGF0IGlzIHBhc3NlZCBpbnRvIHRoZVxuXHRcdCAqIGZ1bmN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gYXNrIGZvciBjb25maXJtYXRpb24gdGhhdCBhXG5cdFx0ICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gblRyIFRoZSB0YWJsZSByb3cgdG8gJ29wZW4nXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBtSHRtbCBUaGUgSFRNTCB0byBwdXQgaW50byB0aGUgcm93XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcblx0XHQgKiAgQHJldHVybnMge25vZGV9IFRoZSByb3cgb3BlbmVkLiBOb3RlIHRoYXQgaWYgdGhlIHRhYmxlIHJvdyBwYXNzZWQgaW4gYXMgdGhlXG5cdFx0ICogICAgZmlyc3QgcGFyYW1ldGVyLCBpcyBub3QgZm91bmQgaW4gdGhlIHRhYmxlLCB0aGlzIG1ldGhvZCB3aWxsIHNpbGVudGx5XG5cdFx0ICogICAgcmV0dXJuLlxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGU7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG5cdFx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHRcdCAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG5cdFx0ICogICAgICAgIH0gZWxzZSB7XG5cdFx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqXG5cdFx0ICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuT3BlbiA9IGZ1bmN0aW9uKCBuVHIsIG1IdG1sLCBzQ2xhc3MgKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmFwaSggdHJ1ZSApXG5cdFx0XHRcdC5yb3coIG5UciApXG5cdFx0XHRcdC5jaGlsZCggbUh0bWwsIHNDbGFzcyApXG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LmNoaWxkKClbMF07XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIHBhZ2luYXRpb24gLSBwcm92aWRlcyB0aGUgaW50ZXJuYWwgbG9naWMgZm9yIHBhZ2luYXRpb24gaW4gYSBzaW1wbGUgQVBJXG5cdFx0ICogZnVuY3Rpb24uIFdpdGggdGhpcyBmdW5jdGlvbiB5b3UgY2FuIGhhdmUgYSBEYXRhVGFibGVzIHRhYmxlIGdvIHRvIHRoZSBuZXh0LFxuXHRcdCAqIHByZXZpb3VzLCBmaXJzdCBvciBsYXN0IHBhZ2VzLlxuXHRcdCAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IG1BY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIiwgXCJuZXh0XCIgb3IgXCJsYXN0XCJcblx0XHQgKiAgICBvciBwYWdlIG51bWJlciB0byBqdW1wIHRvIChpbnRlZ2VyKSwgbm90ZSB0aGF0IHBhZ2UgMCBpcyB0aGUgZmlyc3QgcGFnZS5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqICAgICAgb1RhYmxlLmZuUGFnZUNoYW5nZSggJ25leHQnICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5QYWdlQ2hhbmdlID0gZnVuY3Rpb24gKCBtQWN0aW9uLCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5wYWdlKCBtQWN0aW9uICk7XG5cdFx0XG5cdFx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0XHRhcGkuZHJhdyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBTaG93IGEgcGFydGljdWxhciBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgVGhlIGNvbHVtbiB3aG9zZSBkaXNwbGF5IHNob3VsZCBiZSBjaGFuZ2VkXG5cdFx0ICogIEBwYXJhbSB7Ym9vbH0gYlNob3cgU2hvdyAodHJ1ZSkgb3IgaGlkZSAoZmFsc2UpIHRoZSBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAZHRvcHQgQVBJXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBIaWRlIHRoZSBzZWNvbmQgY29sdW1uIGFmdGVyIGluaXRpYWxpc2F0aW9uXG5cdFx0ICogICAgICBvVGFibGUuZm5TZXRDb2x1bW5WaXMoIDEsIGZhbHNlICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5TZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIGlDb2wsIGJTaG93LCBiUmVkcmF3IClcblx0XHR7XG5cdFx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jb2x1bW4oIGlDb2wgKS52aXNpYmxlKCBiU2hvdyApO1xuXHRcdFxuXHRcdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdFx0YXBpLmNvbHVtbnMuYWRqdXN0KCkuZHJhdygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzZXR0aW5ncyBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cblx0XHQgKiAgQHJldHVybnMge29iamVjdH0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIHZhciBvU2V0dGluZ3MgPSBvVGFibGUuZm5TZXR0aW5ncygpO1xuXHRcdCAqXG5cdFx0ICogICAgICAvLyBTaG93IGFuIGV4YW1wbGUgcGFyYW1ldGVyIGZyb20gdGhlIHNldHRpbmdzXG5cdFx0ICogICAgICBhbGVydCggb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5TZXR0aW5ncyA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tfZXh0LmlBcGlJbmRleF0gKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNvcnQgdGhlIHRhYmxlIGJ5IGEgcGFydGljdWxhciBjb2x1bW5cblx0XHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgdGhlIGRhdGEgaW5kZXggdG8gc29ydCBvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgbWF0Y2ggdGhlXG5cdFx0ICogICAgJ2Rpc3BsYXkgaW5kZXgnIGlmIHlvdSBoYXZlIGhpZGRlbiBkYXRhIGVudHJpZXNcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29ydCBpbW1lZGlhdGVseSB3aXRoIGNvbHVtbnMgMCBhbmQgMVxuXHRcdCAqICAgICAgb1RhYmxlLmZuU29ydCggWyBbMCwnYXNjJ10sIFsxLCdhc2MnXSBdICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdHRoaXMuZm5Tb3J0ID0gZnVuY3Rpb24oIGFhU29ydCApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5vcmRlciggYWFTb3J0ICkuZHJhdygpO1xuXHRcdH07XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IG5Ob2RlIHRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc29ydCBsaXN0ZW5lciB0b1xuXHRcdCAqICBAcGFyYW0ge2ludH0gaUNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtmbkNhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICpcblx0XHQgKiAgICAgIC8vIFNvcnQgb24gY29sdW1uIDEsIHdoZW4gJ3NvcnRlcicgaXMgY2xpY2tlZCBvblxuXHRcdCAqICAgICAgb1RhYmxlLmZuU29ydExpc3RlbmVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29ydGVyJyksIDEgKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblNvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApXG5cdFx0e1xuXHRcdFx0dGhpcy5hcGkoIHRydWUgKS5vcmRlci5saXN0ZW5lciggbk5vZGUsIGlDb2x1bW4sIGZuQ2FsbGJhY2sgKTtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSBhIHRhYmxlIGNlbGwgb3Igcm93IC0gdGhpcyBtZXRob2Qgd2lsbCBhY2NlcHQgZWl0aGVyIGEgc2luZ2xlIHZhbHVlIHRvXG5cdFx0ICogdXBkYXRlIHRoZSBjZWxsIHdpdGgsIGFuIGFycmF5IG9mIHZhbHVlcyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGNvbHVtbiBvclxuXHRcdCAqIGFuIG9iamVjdCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlLiBUaGUgZnVuY3Rpb24gaXNcblx0XHQgKiBzZWxmLXJlZmVyZW5jaW5nIGluIG9yZGVyIHRvIG1ha2UgdGhlIG11bHRpIGNvbHVtbiB1cGRhdGVzIGVhc2llci5cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfSBtRGF0YSBEYXRhIHRvIHVwZGF0ZSB0aGUgY2VsbC9yb3cgd2l0aFxuXHRcdCAqICBAcGFyYW0ge25vZGV8aW50fSBtUm93IFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gdXBkYXRlIG9yIHRoZSBhb0RhdGEgaW5kZXhcblx0XHQgKiAgQHBhcmFtIHtpbnR9IFtpQ29sdW1uXSBUaGUgY29sdW1uIHRvIHVwZGF0ZSwgZ2l2ZSBhcyBudWxsIG9yIHVuZGVmaW5lZCB0b1xuXHRcdCAqICAgIHVwZGF0ZSBhIHdob2xlIHJvdy5cblx0XHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAcGFyYW0ge2Jvb2x9IFtiQWN0aW9uPXRydWVdIFBlcmZvcm0gcHJlLWRyYXcgYWN0aW9ucyBvciBub3Rcblx0XHQgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCAxIG9uIGVycm9yXG5cdFx0ICogIEBkdG9wdCBBUElcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdFx0ICogICAgICBvVGFibGUuZm5VcGRhdGUoICdFeGFtcGxlIHVwZGF0ZScsIDAsIDAgKTsgLy8gU2luZ2xlIGNlbGxcblx0XHQgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgJCgndGJvZHkgdHInKVswXSApOyAvLyBSb3dcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0dGhpcy5mblVwZGF0ZSA9IGZ1bmN0aW9uKCBtRGF0YSwgbVJvdywgaUNvbHVtbiwgYlJlZHJhdywgYkFjdGlvbiApXG5cdFx0e1xuXHRcdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0XG5cdFx0XHRpZiAoIGlDb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBpQ29sdW1uID09PSBudWxsICkge1xuXHRcdFx0XHRhcGkucm93KCBtUm93ICkuZGF0YSggbURhdGEgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhcGkuY2VsbCggbVJvdywgaUNvbHVtbiApLmRhdGEoIG1EYXRhICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoIGJBY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBiQWN0aW9uICkge1xuXHRcdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nIHVzZWQsIGluIG9yZGVyXG5cdFx0ICogdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzVmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLiBOb3RlIHRoYXQgdGhlXG5cdFx0ICogICAgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZSByZXF1aXJlZFxuXHRcdCAqICAgIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90IHN1aXRhYmxlXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKiAgQGR0b3B0IEFQSVxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0XHQgKiAgICAgIGFsZXJ0KCBvVGFibGUuZm5WZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHR0aGlzLmZuVmVyc2lvbkNoZWNrID0gX2V4dC5mblZlcnNpb25DaGVjaztcblx0XHRcblxuXHRcdHZhciBfdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGVtcHR5SW5pdCA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZDtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGVtcHR5SW5pdCApIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9XG5cblx0XHR0aGlzLm9BcGkgPSB0aGlzLmludGVybmFsID0gX2V4dC5pbnRlcm5hbDtcblxuXHRcdC8vIEV4dGVuZCB3aXRoIG9sZCBzdHlsZSBwbHVnLWluIEFQSSBtZXRob2RzXG5cdFx0Zm9yICggdmFyIGZuIGluIERhdGFUYWJsZS5leHQuaW50ZXJuYWwgKSB7XG5cdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHR0aGlzW2ZuXSA9IF9mbkV4dGVybkFwaUZ1bmMoZm4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdC8vIEZvciBlYWNoIGluaXRpYWxpc2F0aW9uIHdlIHdhbnQgdG8gZ2l2ZSBpdCBhIGNsZWFuIGluaXRpYWxpc2F0aW9uXG5cdFx0XHQvLyBvYmplY3QgdGhhdCBjYW4gYmUgYmFzaGVkIGFyb3VuZFxuXHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdHZhciBvSW5pdCA9IGxlbiA+IDEgPyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSB0YWJsZSBjYXNlXG5cdFx0XHRcdF9mbkV4dGVuZCggbywgb3B0aW9ucywgdHJ1ZSApIDpcblx0XHRcdFx0b3B0aW9ucztcblxuXHRcdFx0LypnbG9iYWwgb0luaXQsX3RoYXQsZW1wdHlJbml0Ki9cblx0XHRcdHZhciBpPTAsIGlMZW4sIGosIGpMZW4sIGssIGtMZW47XG5cdFx0XHR2YXIgc0lkID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdHZhciBiSW5pdEhhbmRlZE9mZiA9IGZhbHNlO1xuXHRcdFx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvKiBTYW5pdHkgY2hlY2sgKi9cblx0XHRcdGlmICggdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICd0YWJsZScgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5Mb2coIG51bGwsIDAsICdOb24tdGFibGUgbm9kZSBpbml0aWFsaXNhdGlvbiAoJyt0aGlzLm5vZGVOYW1lKycpJywgMiApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgZGVmYXVsdHMgKi9cblx0XHRcdF9mbkNvbXBhdE9wdHMoIGRlZmF1bHRzICk7XG5cdFx0XHRfZm5Db21wYXRDb2xzKCBkZWZhdWx0cy5jb2x1bW4gKTtcblx0XHRcdFxuXHRcdFx0LyogQ29udmVydCB0aGUgY2FtZWwtY2FzZSBkZWZhdWx0cyB0byBIdW5nYXJpYW4gKi9cblx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCBkZWZhdWx0cywgdHJ1ZSApO1xuXHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUgKTtcblx0XHRcdFxuXHRcdFx0LyogU2V0dGluZyB1cCB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0ICovXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgJC5leHRlbmQoIG9Jbml0LCAkdGhpcy5kYXRhKCkgKSwgdHJ1ZSApO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xuXHRcdFx0dmFyIGFsbFNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFsbFNldHRpbmdzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBzID0gYWxsU2V0dGluZ3NbaV07XG5cdFx0XHRcblx0XHRcdFx0LyogQmFzZSBjaGVjayBvbiB0YWJsZSBub2RlICovXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRzLm5UYWJsZSA9PSB0aGlzIHx8XG5cdFx0XHRcdFx0KHMublRIZWFkICYmIHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcykgfHxcblx0XHRcdFx0XHQocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdFx0dmFyIGJEZXN0cm95ID0gb0luaXQuYkRlc3Ryb3kgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJEZXN0cm95IDogZGVmYXVsdHMuYkRlc3Ryb3k7XG5cdFx0XHRcblx0XHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBzLm9JbnN0YW5jZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGJEZXN0cm95IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0X2ZuTG9nKCBzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxuXHRcdFx0XHQgKiBpbml0aWFsaXNlZCwgYnV0IHRoZSB0YWJsZSBub2RlcyBkb24ndCBtYXRjaCAoZnJvbSBiZWZvcmUpIHRoZW4gd2UgZGVzdHJveSB0aGUgb2xkXG5cdFx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0XHQgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFNldHRpbmdzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cblx0XHRcdGlmICggc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIiApXG5cdFx0XHR7XG5cdFx0XHRcdHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIisoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuXHRcdFx0XHR0aGlzLmlkID0gc0lkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xuXHRcdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFx0XCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XHRcInNJbnN0YW5jZVwiOiAgICAgc0lkLFxuXHRcdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkXG5cdFx0XHR9ICk7XG5cdFx0XHRvU2V0dGluZ3MublRhYmxlID0gdGhpcztcblx0XHRcdG9TZXR0aW5ncy5vQXBpICAgPSBfdGhhdC5pbnRlcm5hbDtcblx0XHRcdG9TZXR0aW5ncy5vSW5pdCAgPSBvSW5pdDtcblx0XHRcdFxuXHRcdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdC8vIE5lZWQgdG8gYWRkIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBhZGRlZFxuXHRcdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRcdG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoPT09MSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRcdF9mbkNvbXBhdE9wdHMoIG9Jbml0ICk7XG5cdFx0XHRfZm5MYW5ndWFnZUNvbXBhdCggb0luaXQub0xhbmd1YWdlICk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBsZW5ndGggbWVudSBpcyBnaXZlbiwgYnV0IHRoZSBpbml0IGRpc3BsYXkgbGVuZ3RoIGlzIG5vdCwgdXNlIHRoZSBsZW5ndGggbWVudVxuXHRcdFx0aWYgKCBvSW5pdC5hTGVuZ3RoTWVudSAmJiAhIG9Jbml0LmlEaXNwbGF5TGVuZ3RoIClcblx0XHRcdHtcblx0XHRcdFx0b0luaXQuaURpc3BsYXlMZW5ndGggPSBBcnJheS5pc0FycmF5KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApID9cblx0XHRcdFx0XHRvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRcdG9Jbml0ID0gX2ZuRXh0ZW5kKCAkLmV4dGVuZCggdHJ1ZSwge30sIGRlZmF1bHRzICksIG9Jbml0ICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFwIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zIG9udG8gdGhlIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XHRcImJMZW5ndGhDaGFuZ2VcIixcblx0XHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFx0XCJiU29ydE11bHRpXCIsXG5cdFx0XHRcdFwiYkluZm9cIixcblx0XHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XHRcImJBdXRvV2lkdGhcIixcblx0XHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XHRcImJEZWZlclJlbmRlclwiXG5cdFx0XHRdICk7XG5cdFx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFx0XCJhc1N0cmlwZUNsYXNzZXNcIixcblx0XHRcdFx0XCJhamF4XCIsXG5cdFx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XHRcInNBamF4U291cmNlXCIsXG5cdFx0XHRcdFwic0FqYXhEYXRhUHJvcFwiLFxuXHRcdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFxuXHRcdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFx0XCJyb3dJZFwiLFxuXHRcdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFx0WyBcImFvU2VhcmNoQ29sc1wiLCBcImFvUHJlU2VhcmNoQ29sc1wiIF0sXG5cdFx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF1cblx0XHRcdF0gKTtcblx0XHRcdF9mbk1hcCggb1NldHRpbmdzLm9TY3JvbGwsIG9Jbml0LCBbXG5cdFx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFx0WyBcInNTY3JvbGxZXCIsIFwic1lcIiBdLFxuXHRcdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdFx0XSApO1xuXHRcdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0xhbmd1YWdlLCBvSW5pdCwgXCJmbkluZm9DYWxsYmFja1wiICk7XG5cdFx0XHRcblx0XHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAgICAgICBvSW5pdC5mbkRyYXdDYWxsYmFjaywgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICAgICAgIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgICAgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQsICAgICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCAgICAgICAgb0luaXQuZm5Sb3dDYWxsYmFjaywgICAgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3csICAgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgICAgJ3VzZXInICk7XG5cdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAgICAgICBvSW5pdC5mbkluaXRDb21wbGV0ZSwgICAgICAndXNlcicgKTtcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAgICd1c2VyJyApO1xuXHRcdFx0XG5cdFx0XHRvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbiggb0luaXQucm93SWQgKTtcblx0XHRcdFxuXHRcdFx0LyogQnJvd3NlciBzdXBwb3J0IGRldGVjdGlvbiAqL1xuXHRcdFx0X2ZuQnJvd3NlckRldGVjdCggb1NldHRpbmdzICk7XG5cdFx0XHRcblx0XHRcdHZhciBvQ2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFxuXHRcdFx0JC5leHRlbmQoIG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0XHQkdGhpcy5hZGRDbGFzcyggb0NsYXNzZXMuc1RhYmxlICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXG5cdFx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICggb0luaXQuaURlZmVyTG9hZGluZyAhPT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHRtcCA9IEFycmF5LmlzQXJyYXkoIG9Jbml0LmlEZWZlckxvYWRpbmcgKTtcblx0XHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzBdIDogb0luaXQuaURlZmVyTG9hZGluZztcblx0XHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gdG1wID8gb0luaXQuaURlZmVyTG9hZGluZ1sxXSA6IG9Jbml0LmlEZWZlckxvYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIExhbmd1YWdlIGRlZmluaXRpb25zICovXG5cdFx0XHR2YXIgb0xhbmd1YWdlID0gb1NldHRpbmdzLm9MYW5ndWFnZTtcblx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFx0XG5cdFx0XHRpZiAoIG9MYW5ndWFnZS5zVXJsIClcblx0XHRcdHtcblx0XHRcdFx0LyogR2V0IHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyBmcm9tIGEgZmlsZSAtIGJlY2F1c2UgdGhpcyBBamF4IGNhbGwgbWFrZXMgdGhlIGxhbmd1YWdlXG5cdFx0XHRcdCAqIGdldCBhc3luYyB0byB0aGUgcmVtYWluZGVyIG9mIHRoaXMgZnVuY3Rpb24gd2UgdXNlIGJJbml0SGFuZGVkT2ZmIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdFx0ICogX2ZuSW5pdGlhbGlzZSB3aWxsIGJlIGZpcmVkIGJ5IHRoZSByZXR1cm5lZCBBamF4IGhhbmRsZXIsIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvclxuXHRcdFx0XHQgKi9cblx0XHRcdFx0JC5hamF4KCB7XG5cdFx0XHRcdFx0ZGF0YVR5cGU6ICdqc29uJyxcblx0XHRcdFx0XHR1cmw6IG9MYW5ndWFnZS5zVXJsLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHRcdFx0XHRcdF9mbkxhbmd1YWdlQ29tcGF0KCBqc29uICk7XG5cdFx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cy5vTGFuZ3VhZ2UsIGpzb24gKTtcblx0XHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIGpzb24gKTtcblx0XHRcdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vIEVycm9yIG9jY3VycmVkIGxvYWRpbmcgbGFuZ3VhZ2UgZmlsZSwgY29udGludWUgb24gYXMgYmVzdCB3ZSBjYW5cblx0XHRcdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRiSW5pdEhhbmRlZE9mZiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQgKiBTdHJpcGVzXG5cdFx0XHQgKi9cblx0XHRcdGlmICggb0luaXQuYXNTdHJpcGVDbGFzc2VzID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0b1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcyA9W1xuXHRcdFx0XHRcdG9DbGFzc2VzLnNTdHJpcGVPZGQsXG5cdFx0XHRcdFx0b0NsYXNzZXMuc1N0cmlwZUV2ZW5cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogUmVtb3ZlIHJvdyBzdHJpcGUgY2xhc3NlcyBpZiB0aGV5IGFyZSBhbHJlYWR5IG9uIHRoZSB0YWJsZSByb3cgKi9cblx0XHRcdHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcztcblx0XHRcdHZhciByb3dPbmUgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKS5maW5kKCd0cicpLmVxKDApO1xuXHRcdFx0aWYgKCAkLmluQXJyYXkoIHRydWUsICQubWFwKCBzdHJpcGVDbGFzc2VzLCBmdW5jdGlvbihlbCwgaSkge1xuXHRcdFx0XHRyZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcblx0XHRcdH0gKSApICE9PSAtMSApIHtcblx0XHRcdFx0JCgndGJvZHkgdHInLCB0aGlzKS5yZW1vdmVDbGFzcyggc3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykgKTtcblx0XHRcdFx0b1NldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMgPSBzdHJpcGVDbGFzc2VzLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qXG5cdFx0XHQgKiBDb2x1bW5zXG5cdFx0XHQgKiBTZWUgaWYgd2Ugc2hvdWxkIGxvYWQgY29sdW1ucyBhdXRvbWF0aWNhbGx5IG9yIHVzZSBkZWZpbmVkIG9uZXNcblx0XHRcdCAqL1xuXHRcdFx0dmFyIGFuVGhzID0gW107XG5cdFx0XHR2YXIgYW9Db2x1bW5zSW5pdDtcblx0XHRcdHZhciBuVGhlYWQgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aGVhZCcpO1xuXHRcdFx0aWYgKCBuVGhlYWQubGVuZ3RoICE9PSAwIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MuYW9IZWFkZXIsIG5UaGVhZFswXSApO1xuXHRcdFx0XHRhblRocyA9IF9mbkdldFVuaXF1ZVRocyggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIElmIG5vdCBnaXZlbiBhIGNvbHVtbiBhcnJheSwgZ2VuZXJhdGUgb25lIHdpdGggbnVsbHMgKi9cblx0XHRcdGlmICggb0luaXQuYW9Db2x1bW5zID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0YW9Db2x1bW5zSW5pdCA9IFtdO1xuXHRcdFx0XHRmb3IgKCBpPTAsIGlMZW49YW5UaHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFvQ29sdW1uc0luaXQucHVzaCggbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGFvQ29sdW1uc0luaXQgPSBvSW5pdC5hb0NvbHVtbnM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEFkZCB0aGUgY29sdW1ucyAqL1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29sdW1uc0luaXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MsIGFuVGhzID8gYW5UaHNbaV0gOiBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8qIEFwcGx5IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgKi9cblx0XHRcdF9mbkFwcGx5Q29sdW1uRGVmcyggb1NldHRpbmdzLCBvSW5pdC5hb0NvbHVtbkRlZnMsIGFvQ29sdW1uc0luaXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XG5cdFx0XHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb0RlZiApO1xuXHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHQvKiBIVE1MNSBhdHRyaWJ1dGUgZGV0ZWN0aW9uIC0gYnVpbGQgYW4gbURhdGEgb2JqZWN0IGF1dG9tYXRpY2FsbHkgaWYgdGhlXG5cdFx0XHQgKiBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIHJvd09uZS5sZW5ndGggKSB7XG5cdFx0XHRcdHZhciBhID0gZnVuY3Rpb24gKCBjZWxsLCBuYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiBjZWxsLmdldEF0dHJpYnV0ZSggJ2RhdGEtJytuYW1lICkgIT09IG51bGwgPyBuYW1lIDogbnVsbDtcblx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XHQkKCByb3dPbmVbMF0gKS5jaGlsZHJlbigndGgsIHRkJykuZWFjaCggZnVuY3Rpb24gKGksIGNlbGwpIHtcblx0XHRcdFx0XHR2YXIgY29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcblx0XHRcdFxuXHRcdFx0XHRcdGlmICggY29sLm1EYXRhID09PSBpICkge1xuXHRcdFx0XHRcdFx0dmFyIHNvcnQgPSBhKCBjZWxsLCAnc29ydCcgKSB8fCBhKCBjZWxsLCAnb3JkZXInICk7XG5cdFx0XHRcdFx0XHR2YXIgZmlsdGVyID0gYSggY2VsbCwgJ2ZpbHRlcicgKSB8fCBhKCBjZWxsLCAnc2VhcmNoJyApO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoIHNvcnQgIT09IG51bGwgfHwgZmlsdGVyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRjb2wubURhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XzogICAgICBpKycuZGlzcGxheScsXG5cdFx0XHRcdFx0XHRcdFx0c29ydDogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyOiBmaWx0ZXIgIT09IG51bGwgPyBpKycuQGRhdGEtJytmaWx0ZXIgOiB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XHRcdHZhciBsb2FkZWRJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBTb3J0aW5nXG5cdFx0XHRcdCAqIEB0b2RvIEZvciBtb2R1bGFyaXNhdGlvbiAoMS4xMSkgdGhpcyBuZWVkcyB0byBkbyBpbnRvIGEgc29ydCBzdGFydCB1cCBoYW5kbGVyXG5cdFx0XHRcdCAqL1xuXHRcdFx0XG5cdFx0XHRcdC8vIElmIGFhU29ydGluZyBpcyBub3QgZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGluZGljYXRvciBpbiBhc1NvcnRpbmdcblx0XHRcdFx0Ly8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cblx0XHRcdFx0aWYgKCBvSW5pdC5hYVNvcnRpbmcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR2YXIgc29ydGluZyA9IG9TZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0XHRcdFx0Zm9yICggaT0wLCBpTGVuPXNvcnRpbmcubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0c29ydGluZ1tpXVsxXSA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGkgXS5hc1NvcnRpbmdbMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cblx0XHRcdFx0ICogYWNjb3VudCwgYW5kIGFsc28gd2lsbCBhcHBseSBzb3J0aW5nIGRpc2FibGVkIGNsYXNzZXMgaWYgZGlzYWJsZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdFxuXHRcdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmICggb1NldHRpbmdzLmJTb3J0ZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdFx0dmFyIHNvcnRlZENvbHVtbnMgPSB7fTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHQkLmVhY2goIGFTb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0c29ydGVkQ29sdW1uc1sgdmFsLnNyYyBdID0gdmFsLmRpcjtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydCwgc29ydGVkQ29sdW1uc10gKTtcblx0XHRcdFx0XHRcdFx0X2ZuU29ydEFyaWEoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIgKSB7XG5cdFx0XHRcdFx0XHRfZm5Tb3J0aW5nQ2xhc3Nlcyggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAnc2MnICk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBGaW5hbCBpbml0XG5cdFx0XHRcdCAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcblx0XHRcdFx0ICovXG5cdFx0XHRcblx0XHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xuXHRcdFx0XHR2YXIgY2FwdGlvbnMgPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLl9jYXB0aW9uU2lkZSA9ICQodGhpcykuY3NzKCdjYXB0aW9uLXNpZGUnKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XG5cdFx0XHRcdHZhciB0aGVhZCA9ICR0aGlzLmNoaWxkcmVuKCd0aGVhZCcpO1xuXHRcdFx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHR0aGVhZCA9ICQoJzx0aGVhZC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcblx0XHRcdFx0aWYgKCB0Ym9keS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0dGJvZHkgPSAkKCc8dGJvZHkvPicpLmFwcGVuZFRvKCR0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XG5cdFx0XHRcblx0XHRcdFx0dmFyIHRmb290ID0gJHRoaXMuY2hpbGRyZW4oJ3Rmb290Jyk7XG5cdFx0XHRcdGlmICggdGZvb3QubGVuZ3RoID09PSAwICYmIGNhcHRpb25zLmxlbmd0aCA+IDAgJiYgKG9TZXR0aW5ncy5vU2Nyb2xsLnNYICE9PSBcIlwiIHx8IG9TZXR0aW5ncy5vU2Nyb2xsLnNZICE9PSBcIlwiKSApIHtcblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgYSBzY3JvbGxpbmcgdGFibGUsIGFuZCBubyBmb290ZXIgaGFzIGJlZW4gZ2l2ZW4sIHRoZW4gd2UgbmVlZCB0byBjcmVhdGVcblx0XHRcdFx0XHQvLyBhIHRmb290IGVsZW1lbnQgZm9yIHRoZSBjYXB0aW9uIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgdG9cblx0XHRcdFx0XHR0Zm9vdCA9ICQoJzx0Zm9vdC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0aWYgKCB0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0JHRoaXMuYWRkQ2xhc3MoIG9DbGFzc2VzLnNOb0Zvb3RlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0Zm9vdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdG9TZXR0aW5ncy5uVEZvb3QgPSB0Zm9vdFswXTtcblx0XHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIG9TZXR0aW5ncy5hb0Zvb3Rlciwgb1NldHRpbmdzLm5URm9vdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0LyogQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yICovXG5cdFx0XHRcdGlmICggb0luaXQuYWFEYXRhICkge1xuXHRcdFx0XHRcdGZvciAoIGk9MCA7IGk8b0luaXQuYWFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRcdF9mbkFkZERhdGEoIG9TZXR0aW5ncywgb0luaXQuYWFEYXRhWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdkb20nICkge1xuXHRcdFx0XHRcdC8qIEdyYWIgdGhlIGRhdGEgZnJvbSB0aGUgcGFnZSAtIG9ubHkgZG8gdGhpcyB3aGVuIGRlZmVycmVkIGxvYWRpbmcgb3Igbm8gQWpheFxuXHRcdFx0XHRcdCAqIHNvdXJjZSBzaW5jZSB0aGVyZSBpcyBubyBwb2ludCBpbiByZWFkaW5nIHRoZSBET00gZGF0YSBpZiB3ZSBhcmUgdGhlbiBnb2luZ1xuXHRcdFx0XHRcdCAqIHRvIHJlcGxhY2UgaXQgd2l0aCBBamF4IGRhdGFcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRfZm5BZGRUciggb1NldHRpbmdzLCAkKG9TZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpICk7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHQvKiBDb3B5IHRoZSBkYXRhIGluZGV4IGFycmF5ICovXG5cdFx0XHRcdG9TZXR0aW5ncy5haURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XHRcblx0XHRcdFx0LyogSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd24gKi9cblx0XHRcdFx0b1NldHRpbmdzLmJJbml0aWFsaXNlZCA9IHRydWU7XG5cdFx0XHRcblx0XHRcdFx0LyogQ2hlY2sgaWYgd2UgbmVlZCB0byBpbml0aWFsaXNlIHRoZSB0YWJsZSAoaXQgbWlnaHQgbm90IGhhdmUgYmVlbiBoYW5kZWQgb2ZmIHRvIHRoZVxuXHRcdFx0XHQgKiBsYW5ndWFnZSBwcm9jZXNzb3IpXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGJJbml0SGFuZGVkT2ZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0LyogTXVzdCBiZSBkb25lIGFmdGVyIGV2ZXJ5dGhpbmcgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0YXRlIHNhdmluZyEgKi9cblx0XHRcdGlmICggb0luaXQuYlN0YXRlU2F2ZSApXG5cdFx0XHR7XG5cdFx0XHRcdGZlYXR1cmVzLmJTdGF0ZVNhdmUgPSB0cnVlO1xuXHRcdFx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBfZm5TYXZlU3RhdGUsICdzdGF0ZV9zYXZlJyApO1xuXHRcdFx0XHRfZm5Mb2FkU3RhdGUoIG9TZXR0aW5ncywgb0luaXQsIGxvYWRlZEluaXQgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsb2FkZWRJbml0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9ICk7XG5cdFx0X3RoYXQgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdFxuXHQvKlxuXHQgKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXG5cdCAqIERhdGFUYWJsZXMgZnVuY3Rpb25zIGNhbiBhY2Nlc3MgdGhlbSBhbmQgdGhleSBkb24ndCBsZWFrIGludG8gZ2xvYmFsIHNwYWNlLlxuXHQgKiBBdCB0aGUgc2FtZSB0aW1lIHRoZXNlIGZ1bmN0aW9ucyBhcmUgb2Z0ZW4gdXNlZnVsIG92ZXIgbXVsdGlwbGUgZmlsZXMgaW4gdGhlXG5cdCAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcblx0ICogYnkgRGF0YVRhYmxlcyBhcyBwcml2YXRlIHZhcmlhYmxlcyBoZXJlLiBUaGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vXG5cdCAqIGNsYXNoaW5nIG9mIHZhcmlhYmxlIG5hbWVzIGFuZCB0aGF0IHRoZXkgY2FuIGVhc2lseSByZWZlcmVuY2VkIGZvciByZXVzZS5cblx0ICovXG5cdFxuXHRcblx0Ly8gRGVmaW5lZCBlbHNlIHdoZXJlXG5cdC8vICBfc2VsZWN0b3JfcnVuXG5cdC8vICBfc2VsZWN0b3Jfb3B0c1xuXHQvLyAgX3NlbGVjdG9yX2ZpcnN0XG5cdC8vICBfc2VsZWN0b3Jfcm93X2luZGV4ZXNcblx0XG5cdHZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XG5cdHZhciBfQXBpOyAvLyBEYXRhVGFibGUuQXBpXG5cdHZhciBfYXBpX3JlZ2lzdGVyOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyXG5cdHZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXG5cdFxuXHR2YXIgX3JlX2RpYyA9IHt9O1xuXHR2YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXFx1MjAyOF0vZztcblx0dmFyIF9yZV9odG1sID0gLzwuKj8+L2c7XG5cdFxuXHQvLyBUaGlzIGlzIG5vdCBzdHJpY3QgSVNPODYwMSAtIERhdGUucGFyc2UoKSBpcyBxdWl0ZSBsYXgsIGFsdGhvdWdoXG5cdC8vIGltcGxlbWVudGF0aW9ucyBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy5cblx0dmFyIF9yZV9kYXRlID0gL15cXGR7Miw0fVtcXC5cXC9cXC1dXFxkezEsMn1bXFwuXFwvXFwtXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6XFwuXVxcZHsyfShbXFwuOl1cXGR7Mn0pPyk/JC87XG5cdFxuXHQvLyBFc2NhcGUgcmVndWxhciBleHByZXNzaW9uIHNwZWNpYWwgY2hhcmFjdGVyc1xuXHR2YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoICcoXFxcXCcgKyBbICcvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJywgJyQnLCAnXicsICctJyBdLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyApO1xuXHRcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JlaWduX2V4Y2hhbmdlX21hcmtldFxuXHQvLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxuXHQvLyAtIFxcdTIwYTkgLSBTb3V0aCBLb3JlYW4gV29uXG5cdC8vIC0gXFx1MjBCQSAtIFR1cmtpc2ggTGlyYVxuXHQvLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcblx0Ly8gLSBSIC0gQnJhemlsIChSJCkgYW5kIFNvdXRoIEFmcmljYVxuXHQvLyAtIGZyIC0gU3dpc3MgRnJhbmNcblx0Ly8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXG5cdC8vIC0gXFx1MjAwOSBpcyB0aGluIHNwYWNlIGFuZCBcXHUyMDJGIGlzIG5hcnJvdyBuby1icmVhayBzcGFjZSwgYm90aCB1c2VkIGluIG1hbnlcblx0Ly8gLSDJgyAtIEJpdGNvaW5cblx0Ly8gLSDOniAtIEV0aGVyZXVtXG5cdC8vICAgc3RhbmRhcmRzIGFzIHRob3VzYW5kcyBzZXBhcmF0b3JzLlxuXHR2YXIgX3JlX2Zvcm1hdHRlZF9udW1lcmljID0gL1snXFx1MDBBMCwkwqPigqzCpSVcXHUyMDA5XFx1MjAyRlxcdTIwQkRcXHUyMGE5XFx1MjBCQXJma8mDzp5dL2dpO1xuXHRcblx0XG5cdHZhciBfZW1wdHkgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXHRcblx0XG5cdHZhciBfaW50VmFsID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoIHMsIDEwICk7XG5cdFx0cmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xuXHR9O1xuXHRcblx0Ly8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXG5cdC8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcblx0dmFyIF9udW1Ub0RlY2ltYWwgPSBmdW5jdGlvbiAoIG51bSwgZGVjaW1hbFBvaW50ICkge1xuXHRcdC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cblx0XHRpZiAoICEgX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gKSB7XG5cdFx0XHRfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSA9IG5ldyBSZWdFeHAoIF9mbkVzY2FwZVJlZ2V4KCBkZWNpbWFsUG9pbnQgKSwgJ2cnICk7XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBkZWNpbWFsUG9pbnQgIT09ICcuJyA/XG5cdFx0XHRudW0ucmVwbGFjZSggL1xcLi9nLCAnJyApLnJlcGxhY2UoIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdLCAnLicgKSA6XG5cdFx0XHRudW07XG5cdH07XG5cdFxuXHRcblx0dmFyIF9pc051bWJlciA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSB7XG5cdFx0dmFyIHN0clR5cGUgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZyc7XG5cdFxuXHRcdC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcblx0XHQvLyBmb3JtYXR0ZWQgc3RyaW5nICh0aGlzIHN0b3BzIHRoZSBzdHJpbmcgXCJrXCIsIG9yIFwia3JcIiwgZXRjIGJlaW5nIGRldGVjdGVkXG5cdFx0Ly8gYXMgYSBmb3JtYXR0ZWQgbnVtYmVyIGZvciBjdXJyZW5jeVxuXHRcdGlmICggX2VtcHR5KCBkICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0XHRkID0gX251bVRvRGVjaW1hbCggZCwgZGVjaW1hbFBvaW50ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZvcm1hdHRlZCAmJiBzdHJUeXBlICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChkKSApICYmIGlzRmluaXRlKCBkICk7XG5cdH07XG5cdFxuXHRcblx0Ly8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcblx0dmFyIF9pc0h0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcblx0fTtcblx0XG5cdFxuXHR2YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApIHtcblx0XHRpZiAoIF9lbXB0eSggZCApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHRtbCA9IF9pc0h0bWwoIGQgKTtcblx0XHRyZXR1cm4gISBodG1sID9cblx0XHRcdG51bGwgOlxuXHRcdFx0X2lzTnVtYmVyKCBfc3RyaXBIdG1sKCBkICksIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkICkgP1xuXHRcdFx0XHR0cnVlIDpcblx0XHRcdFx0bnVsbDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3BsdWNrID0gZnVuY3Rpb24gKCBhLCBwcm9wLCBwcm9wMiApIHtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGk9MCwgaWVuPWEubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhW2ldICYmIGFbaV1bIHByb3AgXSApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGFbaV0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0XG5cdC8vIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBfcGx1Y2ssIGJ1dCByYXRoZXIgdGhhbiBsb29waW5nIG92ZXIgYGFgIHdlIHVzZSBgb3JkZXJgXG5cdC8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcblx0dmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uICggYSwgb3JkZXIsIHByb3AsIHByb3AyIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgaT0wLCBpZW49b3JkZXIubGVuZ3RoO1xuXHRcblx0XHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHRcdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdFx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JhbmdlID0gZnVuY3Rpb24gKCBsZW4sIHN0YXJ0IClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XHR2YXIgZW5kO1xuXHRcblx0XHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRlbmQgPSBsZW47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IGxlbjtcblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPXN0YXJ0IDsgaTxlbmQgOyBpKysgKSB7XG5cdFx0XHRvdXQucHVzaCggaSApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKCBhIClcblx0e1xuXHRcdHZhciBvdXQgPSBbXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gKSB7IC8vIGNhcmVmdWwgLSB3aWxsIHJlbW92ZSBhbGwgZmFsc3kgdmFsdWVzIVxuXHRcdFx0XHRvdXQucHVzaCggYVtpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG91dDtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uICggZCApIHtcblx0XHRyZXR1cm4gZC5yZXBsYWNlKCBfcmVfaHRtbCwgJycgKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGFsbCB2YWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB1bmlxdWUuIFRoaXMgbWVhbnMgd2UgY2FuIHNob3J0XG5cdCAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuXHQgKiB0byBlYXNpbHkgY2hlY2sgdGhlIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbGwgdW5pcXVlLCBmYWxzZSBvdGhlcndpc2Vcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9hcmVBbGxVbmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApIHtcblx0XHRpZiAoIHNyYy5sZW5ndGggPCAyICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHRcdHZhciBsYXN0ID0gc29ydGVkWzBdO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBzb3J0ZWRbaV0gPT09IGxhc3QgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRsYXN0ID0gc29ydGVkW2ldO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbmQgdGhlIHVuaXF1ZSBlbGVtZW50cyBpbiBhIHNvdXJjZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcblx0ICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX3VuaXF1ZSA9IGZ1bmN0aW9uICggc3JjIClcblx0e1xuXHRcdGlmICggX2FyZUFsbFVuaXF1ZSggc3JjICkgKSB7XG5cdFx0XHRyZXR1cm4gc3JjLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcblx0XHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdFx0Ly8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcblx0XHQvLyBpbmZvcm1hdGlvbi5cblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0XHRqLCBrPTA7XG5cdFxuXHRcdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhbCA9IHNyY1tpXTtcblx0XG5cdFx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRcdGlmICggb3V0W2pdID09PSB2YWwgKSB7XG5cdFx0XHRcdFx0Y29udGludWUgYWdhaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0XHRrKys7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHRcblx0Ly8gU3VycHJpc2luZ2x5IHRoaXMgaXMgZmFzdGVyIHRoYW4gW10uY29uY2F0LmFwcGx5XG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9mbGF0dGVuLWFuLWFycmF5LWxvb3AtdnMtcmVkdWNlLzJcblx0dmFyIF9mbGF0dGVuID0gZnVuY3Rpb24gKG91dCwgdmFsKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTx2YWwubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRcdF9mbGF0dGVuKG91dCwgdmFsW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRvdXQucHVzaCh2YWwpO1xuXHRcdH1cblx0ICBcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cdFxuXHQvLyBBcnJheS5pc0FycmF5IHBvbHlmaWxsLlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5cdGlmICghIEFycmF5LmlzQXJyYXkpIHtcblx0ICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcblx0ICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdCAgICB9O1xuXHR9XG5cdFxuXHQvLyAudHJpbSgpIHBvbHlmaWxsXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy90cmltXG5cdGlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG5cdCAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblx0ICB9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcblx0ICogXG5cdCAqIFRoaXMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBtZXRob2RzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGludGVybmFsbHkgdG9cblx0ICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXG5cdCAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2Zcblx0ICogY29kZS5cblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS51dGlsID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWRcblx0XHQgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xuXHRcdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dGhyb3R0bGU6IGZ1bmN0aW9uICggZm4sIGZyZXEgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0ZnJlcXVlbmN5ID0gZnJlcSAhPT0gdW5kZWZpbmVkID8gZnJlcSA6IDIwMCxcblx0XHRcdFx0bGFzdCxcblx0XHRcdFx0dGltZXI7XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0bm93ICA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFxuXHRcdFx0XHRpZiAoIGxhc3QgJiYgbm93IDwgbGFzdCArIGZyZXF1ZW5jeSApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0fSwgZnJlcXVlbmN5ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bGFzdCA9IG5vdztcblx0XHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBzdHJpbmcgdG8gZXNjYXBlXG5cdFx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG5cdFx0ICovXG5cdFx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uICggdmFsICkge1xuXHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKCBfcmVfZXNjYXBlX3JlZ2V4LCAnXFxcXCQxJyApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIG1hcHBpbmcgb2JqZWN0IHRoYXQgYWxsb3dzIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBiZSBsb29rZWQgdXBcblx0ICogZm9yIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHMuIFRoZSBtYXBwaW5nIGlzIHN0b3JlZCBpbiBhIHByaXZhdGVcblx0ICogcGFyYW1ldGVyIGNhbGxlZCBgX2h1bmdhcmlhbk1hcGAgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSHVuZ2FyaWFuTWFwICggbyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGh1bmdhcmlhbiA9ICdhIGFhIGFpIGFvIGFzIGIgZm4gaSBtIG8gcyAnLFxuXHRcdFx0bWF0Y2gsXG5cdFx0XHRuZXdLZXksXG5cdFx0XHRtYXAgPSB7fTtcblx0XG5cdFx0JC5lYWNoKCBvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eKFteQS1aXSs/KShbQS1aXSkvKTtcblx0XG5cdFx0XHRpZiAoIG1hdGNoICYmIGh1bmdhcmlhbi5pbmRleE9mKG1hdGNoWzFdKycgJykgIT09IC0xIClcblx0XHRcdHtcblx0XHRcdFx0bmV3S2V5ID0ga2V5LnJlcGxhY2UoIG1hdGNoWzBdLCBtYXRjaFsyXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRcdG1hcFsgbmV3S2V5IF0gPSBrZXk7XG5cdFxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdID09PSAnbycgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBvW2tleV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0by5faHVuZ2FyaWFuTWFwID0gbWFwO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcblx0ICogY3JlYXRlZCBieSBfZm5IdW5nYXJpYW5NYXAuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNhbWVsVG9IdW5nYXJpYW4gKCBzcmMsIHVzZXIsIGZvcmNlIClcblx0e1xuXHRcdGlmICggISBzcmMuX2h1bmdhcmlhbk1hcCApIHtcblx0XHRcdF9mbkh1bmdhcmlhbk1hcCggc3JjICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgaHVuZ2FyaWFuS2V5O1xuXHRcblx0XHQkLmVhY2goIHVzZXIsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0aHVuZ2FyaWFuS2V5ID0gc3JjLl9odW5nYXJpYW5NYXBbIGtleSBdO1xuXHRcblx0XHRcdGlmICggaHVuZ2FyaWFuS2V5ICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IHVzZXJbaHVuZ2FyaWFuS2V5XSA9PT0gdW5kZWZpbmVkKSApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXG5cdFx0XHRcdGlmICggaHVuZ2FyaWFuS2V5LmNoYXJBdCgwKSA9PT0gJ28nIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxuXHRcdFx0XHRcdGlmICggISB1c2VyWyBodW5nYXJpYW5LZXkgXSApIHtcblx0XHRcdFx0XHRcdHVzZXJbIGh1bmdhcmlhbktleSBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCB1c2VyW2h1bmdhcmlhbktleV0sIHVzZXJba2V5XSApO1xuXHRcblx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBzcmNbaHVuZ2FyaWFuS2V5XSwgdXNlcltodW5nYXJpYW5LZXldLCBmb3JjZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIExhbmd1YWdlIGNvbXBhdGliaWxpdHkgLSB3aGVuIGNlcnRhaW4gb3B0aW9ucyBhcmUgZ2l2ZW4sIGFuZCBvdGhlcnMgYXJlbid0LCB3ZVxuXHQgKiBuZWVkIHRvIGR1cGxpY2F0ZSB0aGUgdmFsdWVzIG92ZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0ICogd2l0aCBvbGRlciBsYW5ndWFnZSBmaWxlcy5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuTGFuZ3VhZ2VDb21wYXQoIGxhbmcgKVxuXHR7XG5cdFx0Ly8gTm90ZSB0aGUgdXNlIG9mIHRoZSBIdW5nYXJpYW4gbm90YXRpb24gZm9yIHRoZSBwYXJhbWV0ZXJzIGluIHRoaXMgbWV0aG9kIGFzXG5cdFx0Ly8gdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1hcHBpbmcgb2YgY2FtZWxDYXNlIHRvIEh1bmdhcmlhblxuXHRcdHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2U7XG5cdFxuXHRcdC8vIERlZmF1bHQgbWFwcGluZ1xuXHRcdHZhciBkZWZhdWx0RGVjaW1hbCA9IGRlZmF1bHRzLnNEZWNpbWFsO1xuXHRcdGlmICggZGVmYXVsdERlY2ltYWwgKSB7XG5cdFx0XHRfYWRkTnVtZXJpY1NvcnQoIGRlZmF1bHREZWNpbWFsICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGxhbmcgKSB7XG5cdFx0XHR2YXIgemVyb1JlY29yZHMgPSBsYW5nLnNaZXJvUmVjb3Jkcztcblx0XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIGlmIHRoZXJlIGlzIG5vIHNFbXB0eVRhYmxlIGdpdmVuLCB0aGVuIHVzZSB0aGUgc2FtZSBhc1xuXHRcdFx0Ly8gc1plcm9SZWNvcmRzIC0gYXNzdW1pbmcgdGhhdCBpcyBnaXZlbi5cblx0XHRcdGlmICggISBsYW5nLnNFbXB0eVRhYmxlICYmIHplcm9SZWNvcmRzICYmXG5cdFx0XHRcdGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5NYXAoIGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0VtcHR5VGFibGUnICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTGlrZXdpc2Ugd2l0aCBsb2FkaW5nIHJlY29yZHNcblx0XHRcdGlmICggISBsYW5nLnNMb2FkaW5nUmVjb3JkcyAmJiB6ZXJvUmVjb3JkcyAmJlxuXHRcdFx0XHRkZWZhdWx0cy5zTG9hZGluZ1JlY29yZHMgPT09IFwiTG9hZGluZy4uLlwiIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuTWFwKCBsYW5nLCBsYW5nLCAnc1plcm9SZWNvcmRzJywgJ3NMb2FkaW5nUmVjb3JkcycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBPbGQgcGFyYW1ldGVyIG5hbWUgb2YgdGhlIHRob3VzYW5kcyBzZXBhcmF0b3IgbWFwcGVkIG9udG8gdGhlIG5ld1xuXHRcdFx0aWYgKCBsYW5nLnNJbmZvVGhvdXNhbmRzICkge1xuXHRcdFx0XHRsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBkZWNpbWFsID0gbGFuZy5zRGVjaW1hbDtcblx0XHRcdGlmICggZGVjaW1hbCAmJiBkZWZhdWx0RGVjaW1hbCAhPT0gZGVjaW1hbCApIHtcblx0XHRcdFx0X2FkZE51bWVyaWNTb3J0KCBkZWNpbWFsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE1hcCBvbmUgcGFyYW1ldGVyIG9udG8gYW5vdGhlclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gT2JqZWN0IHRvIG1hcFxuXHQgKiAgQHBhcmFtIHsqfSBrbmV3IFRoZSBuZXcgcGFyYW1ldGVyIG5hbWVcblx0ICogIEBwYXJhbSB7Kn0gb2xkIFRoZSBvbGQgcGFyYW1ldGVyIG5hbWVcblx0ICovXG5cdHZhciBfZm5Db21wYXRNYXAgPSBmdW5jdGlvbiAoIG8sIGtuZXcsIG9sZCApIHtcblx0XHRpZiAoIG9bIGtuZXcgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b1sgb2xkIF0gPSBvWyBrbmV3IF07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgbWFpbiBEVCBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ld1xuXHQgKiBvcHRpb25zIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlXG5cdCAqIGNoYW5nZSBvbmx5LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29tcGF0T3B0cyAoIGluaXQgKVxuXHR7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJpbmcnLCAgICAgICdiU29ydCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlck11bHRpJywgICAgJ2JTb3J0TXVsdGknICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDbGFzc2VzJywgICdiU29ydENsYXNzZXMnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDZWxsc1RvcCcsICdiU29ydENlbGxzVG9wJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyJywgICAgICAgICAnYWFTb3J0aW5nJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRml4ZWQnLCAgICAnYWFTb3J0aW5nRml4ZWQnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nJywgICAgICAgICdiUGFnaW5hdGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nVHlwZScsICAgICdzUGFnaW5hdGlvblR5cGUnICk7XG5cdFx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnZUxlbmd0aCcsICAgICdpRGlzcGxheUxlbmd0aCcgKTtcblx0XHRfZm5Db21wYXRNYXAoIGluaXQsICdzZWFyY2hpbmcnLCAgICAgJ2JGaWx0ZXInICk7XG5cdFxuXHRcdC8vIEJvb2xlYW4gaW5pdGlhbGlzYXRpb24gb2YgeC1zY3JvbGxpbmdcblx0XHRpZiAoIHR5cGVvZiBpbml0LnNTY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRpbml0LnNTY3JvbGxYID0gaW5pdC5zU2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBpbml0LnNjcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRcdGluaXQuc2Nyb2xsWCA9IGluaXQuc2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29sdW1uIHNlYXJjaCBvYmplY3RzIGFyZSBpbiBhbiBhcnJheSwgc28gaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG5cdFx0Ly8gZWxlbWVudCBieSBlbGVtZW50XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcblx0XG5cdFx0aWYgKCBzZWFyY2hDb2xzICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNlYXJjaENvbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2VhcmNoQ29sc1tpXSApIHtcblx0XHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBjb2x1bW4gb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXcgb3B0aW9uc1xuXHQgKiBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZSBjaGFuZ2Vcblx0ICogb25seS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbXBhdENvbHMgKCBpbml0IClcblx0e1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyYWJsZScsICAgICAnYlNvcnRhYmxlJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YScsICAgICAnYURhdGFTb3J0JyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyU2VxdWVuY2UnLCAnYXNTb3J0aW5nJyApO1xuXHRcdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YVR5cGUnLCAnc29ydERhdGFUeXBlJyApO1xuXHRcblx0XHQvLyBvcmRlckRhdGEgY2FuIGJlIGdpdmVuIGFzIGFuIGludGVnZXJcblx0XHR2YXIgZGF0YVNvcnQgPSBpbml0LmFEYXRhU29ydDtcblx0XHRpZiAoIHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgISBBcnJheS5pc0FycmF5KCBkYXRhU29ydCApICkge1xuXHRcdFx0aW5pdC5hRGF0YVNvcnQgPSBbIGRhdGFTb3J0IF07XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJyb3dzZXIgZmVhdHVyZSBkZXRlY3Rpb24gZm9yIGNhcGFiaWxpdGllcywgcXVpcmtzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQnJvd3NlckRldGVjdCggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzIGV2ZXJ5IHRpbWUgRGF0YVRhYmxlcyBpcyBjb25zdHJ1Y3RlZCwgdGhlIHZhbHVlc1xuXHRcdC8vIGNhbGN1bGF0ZWQgYXJlIHNwZWNpZmljIHRvIHRoZSBicm93c2VyIGFuZCBPUyBjb25maWd1cmF0aW9uIHdoaWNoIHdlXG5cdFx0Ly8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xuXHRcdGlmICggISBEYXRhVGFibGUuX19icm93c2VyICkge1xuXHRcdFx0dmFyIGJyb3dzZXIgPSB7fTtcblx0XHRcdERhdGFUYWJsZS5fX2Jyb3dzZXIgPSBicm93c2VyO1xuXHRcblx0XHRcdC8vIFNjcm9sbGluZyBmZWF0dXJlIC8gcXVpcmtzIGRldGVjdGlvblxuXHRcdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCcsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6ICQod2luZG93KS5zY3JvbGxMZWZ0KCkqLTEsIC8vIGFsbG93IGZvciBzY3JvbGxpbmdcblx0XHRcdFx0XHRoZWlnaHQ6IDEsXG5cdFx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDEsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IDEsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAxMDAsXG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJ1xuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IDEwXG5cdFx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHRcdFx0LmFwcGVuZFRvKCAnYm9keScgKTtcblx0XG5cdFx0XHR2YXIgb3V0ZXIgPSBuLmNoaWxkcmVuKCk7XG5cdFx0XHR2YXIgaW5uZXIgPSBvdXRlci5jaGlsZHJlbigpO1xuXHRcblx0XHRcdC8vIE51bWJlcnMgYmVsb3csIGluIG9yZGVyLCBhcmU6XG5cdFx0XHQvLyBpbm5lci5vZmZzZXRXaWR0aCwgaW5uZXIuY2xpZW50V2lkdGgsIG91dGVyLm9mZnNldFdpZHRoLCBvdXRlci5jbGllbnRXaWR0aFxuXHRcdFx0Ly9cblx0XHRcdC8vIElFNiBYUDogICAgICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcblx0XHRcdC8vIElFNyBWaXN0YTogICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcblx0XHRcdC8vIElFIDgrIFdpbmRvd3M6ICAgICAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHRcdC8vIEV2ZXJncmVlbiBXaW5kb3dzOiAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aCBzY3JvbGxiYXJzOiAgICAgODUgIDg1IDEwMCAgODVcblx0XHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aG91dCBzY3JvbGxiYXJzOiAxMDAgMTAwIDEwMCAxMDBcblx0XG5cdFx0XHQvLyBHZXQgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0XHRicm93c2VyLmJhcldpZHRoID0gb3V0ZXJbMF0ub2Zmc2V0V2lkdGggLSBvdXRlclswXS5jbGllbnRXaWR0aDtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIG92ZXJzaXplIGEgd2lkdGggMTAwJSBlbGVtZW50IGluc2lkZSBhIHNjcm9sbGluZyBlbGVtZW50LCB0b1xuXHRcdFx0Ly8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhciwgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZW5zdXJlIHRoZSBpbm5lclxuXHRcdFx0Ly8gZWxlbWVudCBpcyBjb250YWluZWQgd2l0aG91dCBmb3JjaW5nIHNjcm9sbGluZ1xuXHRcdFx0YnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUgPSBpbm5lclswXS5vZmZzZXRXaWR0aCA9PT0gMTAwICYmIG91dGVyWzBdLmNsaWVudFdpZHRoICE9PSAxMDA7XG5cdFxuXHRcdFx0Ly8gSW4gcnRsIHRleHQgbGF5b3V0LCBzb21lIGJyb3dzZXJzIChtb3N0LCBidXQgbm90IGFsbCkgd2lsbCBwbGFjZSB0aGVcblx0XHRcdC8vIHNjcm9sbGJhciBvbiB0aGUgbGVmdCwgcmF0aGVyIHRoYW4gdGhlIHJpZ2h0LlxuXHRcdFx0YnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA9IE1hdGgucm91bmQoIGlubmVyLm9mZnNldCgpLmxlZnQgKSAhPT0gMTtcblx0XG5cdFx0XHQvLyBJRTgtIGRvbid0IHByb3ZpZGUgaGVpZ2h0IGFuZCB3aWR0aCBmb3IgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRicm93c2VyLmJCb3VuZGluZyA9IG5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0cnVlIDogZmFsc2U7XG5cdFxuXHRcdFx0bi5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vQnJvd3NlciwgRGF0YVRhYmxlLl9fYnJvd3NlciApO1xuXHRcdHNldHRpbmdzLm9TY3JvbGwuaUJhcldpZHRoID0gRGF0YVRhYmxlLl9fYnJvd3Nlci5iYXJXaWR0aDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcnJheS5wcm90b3R5cGUgcmVkdWNlW1JpZ2h0XSBtZXRob2QsIHVzZWQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnRcblx0ICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJlZHVjZSAoIHRoYXQsIGZuLCBpbml0LCBzdGFydCwgZW5kLCBpbmMgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpID0gc3RhcnQsXG5cdFx0XHR2YWx1ZSxcblx0XHRcdGlzU2V0ID0gZmFsc2U7XG5cdFxuXHRcdGlmICggaW5pdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSBpbml0O1xuXHRcdFx0aXNTZXQgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0d2hpbGUgKCBpICE9PSBlbmQgKSB7XG5cdFx0XHRpZiAoICEgdGhhdC5oYXNPd25Qcm9wZXJ0eShpKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dmFsdWUgPSBpc1NldCA/XG5cdFx0XHRcdGZuKCB2YWx1ZSwgdGhhdFtpXSwgaSwgdGhhdCApIDpcblx0XHRcdFx0dGhhdFtpXTtcblx0XG5cdFx0XHRpc1NldCA9IHRydWU7XG5cdFx0XHRpICs9IGluYztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIGNvbHVtbiB0byB0aGUgbGlzdCB1c2VkIGZvciB0aGUgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVGggVGhlIHRoIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkFkZENvbHVtbiggb1NldHRpbmdzLCBuVGggKVxuXHR7XG5cdFx0Ly8gQWRkIGNvbHVtbiB0byBhb0NvbHVtbnMgYXJyYXlcblx0XHR2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcblx0XHR2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBvQ29sID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xuXHRcdFx0XCJuVGhcIjogblRoID8gblRoIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSxcblx0XHRcdFwic1RpdGxlXCI6ICAgIG9EZWZhdWx0cy5zVGl0bGUgICAgPyBvRGVmYXVsdHMuc1RpdGxlICAgIDogblRoID8gblRoLmlubmVySFRNTCA6ICcnLFxuXHRcdFx0XCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXG5cdFx0XHRcIm1EYXRhXCI6IG9EZWZhdWx0cy5tRGF0YSA/IG9EZWZhdWx0cy5tRGF0YSA6IGlDb2wsXG5cdFx0XHRpZHg6IGlDb2xcblx0XHR9ICk7XG5cdFx0b1NldHRpbmdzLmFvQ29sdW1ucy5wdXNoKCBvQ29sICk7XG5cdFxuXHRcdC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXG5cdFx0Ly8gcGFzc2VkIGludG8gZXh0ZW5kIGNhbiBiZSB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGdpdmUgYSBkZWZhdWx0XG5cdFx0Ly8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XG5cdFx0dmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHRcdHNlYXJjaENvbHNbIGlDb2wgXSA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzWyBpQ29sIF0gKTtcblx0XG5cdFx0Ly8gVXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBvcHRpb25zIGZ1bmN0aW9uIHRvIGluaXRpYWxpc2UgY2xhc3NlcyBldGNcblx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsICQoblRoKS5kYXRhKCkgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBcHBseSBvcHRpb25zIGZvciBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb09wdGlvbnMgb2JqZWN0IHdpdGggc1R5cGUsIGJWaXNpYmxlIGFuZCBiU2VhcmNoYWJsZSBldGNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucyApXG5cdHtcblx0XHR2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGlDb2wgXTtcblx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRoID0gJChvQ29sLm5UaCk7XG5cdFxuXHRcdC8vIFRyeSB0byBnZXQgd2lkdGggaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBXZSBjYW4ndCBnZXQgaXQgZnJvbSBDU1Ncblx0XHQvLyBhcyB3ZSdkIG5lZWQgdG8gcGFyc2UgdGhlIENTUyBzdHlsZXNoZWV0LiBgd2lkdGhgIG9wdGlvbiBjYW4gb3ZlcnJpZGVcblx0XHRpZiAoICEgb0NvbC5zV2lkdGhPcmlnICkge1xuXHRcdFx0Ly8gV2lkdGggYXR0cmlidXRlXG5cdFx0XHRvQ29sLnNXaWR0aE9yaWcgPSB0aC5hdHRyKCd3aWR0aCcpIHx8IG51bGw7XG5cdFxuXHRcdFx0Ly8gU3R5bGUgYXR0cmlidXRlXG5cdFx0XHR2YXIgdCA9ICh0aC5hdHRyKCdzdHlsZScpIHx8ICcnKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7XG5cdFx0XHRpZiAoIHQgKSB7XG5cdFx0XHRcdG9Db2wuc1dpZHRoT3JpZyA9IHRbMV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKiBVc2VyIHNwZWNpZmllZCBjb2x1bW4gb3B0aW9ucyAqL1xuXHRcdGlmICggb09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdF9mbkNvbXBhdENvbHMoIG9PcHRpb25zICk7XG5cdFxuXHRcdFx0Ly8gTWFwIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzXG5cdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucywgdHJ1ZSApO1xuXHRcblx0XHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cblx0XHRcdGlmICggb09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhIClcblx0XHRcdHtcblx0XHRcdFx0b09wdGlvbnMubURhdGEgPSBvT3B0aW9ucy5tRGF0YVByb3A7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5zVHlwZSApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXG5cdFx0XHQvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxuXHRcdFx0aWYgKCBvT3B0aW9ucy5jbGFzc05hbWUgJiYgISBvT3B0aW9ucy5zQ2xhc3MgKVxuXHRcdFx0e1xuXHRcdFx0XHRvT3B0aW9ucy5zQ2xhc3MgPSBvT3B0aW9ucy5jbGFzc05hbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9PcHRpb25zLnNDbGFzcyApIHtcblx0XHRcdFx0dGguYWRkQ2xhc3MoIG9PcHRpb25zLnNDbGFzcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdCQuZXh0ZW5kKCBvQ29sLCBvT3B0aW9ucyApO1xuXHRcdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJzV2lkdGhcIiwgXCJzV2lkdGhPcmlnXCIgKTtcblx0XG5cdFx0XHQvKiBpRGF0YVNvcnQgdG8gYmUgYXBwbGllZCAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLCBidXQgYURhdGFTb3J0IHdpbGwgdGFrZVxuXHRcdFx0ICogcHJpb3JpdHkgaWYgZGVmaW5lZFxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIG9PcHRpb25zLmlEYXRhU29ydCAhPT0gdW5kZWZpbmVkIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbC5hRGF0YVNvcnQgPSBbIG9PcHRpb25zLmlEYXRhU29ydCBdO1xuXHRcdFx0fVxuXHRcdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJhRGF0YVNvcnRcIiApO1xuXHRcdH1cblx0XG5cdFx0LyogQ2FjaGUgdGhlIGRhdGEgZ2V0IGFuZCBzZXQgZnVuY3Rpb25zIGZvciBzcGVlZCAqL1xuXHRcdHZhciBtRGF0YVNyYyA9IG9Db2wubURhdGE7XG5cdFx0dmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApO1xuXHRcdHZhciBtUmVuZGVyID0gb0NvbC5tUmVuZGVyID8gX2ZuR2V0T2JqZWN0RGF0YUZuKCBvQ29sLm1SZW5kZXIgKSA6IG51bGw7XG5cdFxuXHRcdHZhciBhdHRyVGVzdCA9IGZ1bmN0aW9uKCBzcmMgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLmluZGV4T2YoJ0AnKSAhPT0gLTE7XG5cdFx0fTtcblx0XHRvQ29sLl9iQXR0clNyYyA9ICQuaXNQbGFpbk9iamVjdCggbURhdGFTcmMgKSAmJiAoXG5cdFx0XHRhdHRyVGVzdChtRGF0YVNyYy5zb3J0KSB8fCBhdHRyVGVzdChtRGF0YVNyYy50eXBlKSB8fCBhdHRyVGVzdChtRGF0YVNyYy5maWx0ZXIpXG5cdFx0KTtcblx0XHRvQ29sLl9zZXR0ZXIgPSBudWxsO1xuXHRcblx0XHRvQ29sLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhLCB0eXBlLCBtZXRhKSB7XG5cdFx0XHR2YXIgaW5uZXJEYXRhID0gbURhdGEoIHJvd0RhdGEsIHR5cGUsIHVuZGVmaW5lZCwgbWV0YSApO1xuXHRcblx0XHRcdHJldHVybiBtUmVuZGVyICYmIHR5cGUgP1xuXHRcdFx0XHRtUmVuZGVyKCBpbm5lckRhdGEsIHR5cGUsIHJvd0RhdGEsIG1ldGEgKSA6XG5cdFx0XHRcdGlubmVyRGF0YTtcblx0XHR9O1xuXHRcdG9Db2wuZm5TZXREYXRhID0gZnVuY3Rpb24gKCByb3dEYXRhLCB2YWwsIG1ldGEgKSB7XG5cdFx0XHRyZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApKCByb3dEYXRhLCB2YWwsIG1ldGEgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBJbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCByZWFkIERPTSBkYXRhIGFzIGFuIG9iamVjdCBvciBhcnJheVxuXHRcdC8vIFVzZWQgaW4gX2ZuR2V0Um93RWxlbWVudHNcblx0XHRpZiAoIHR5cGVvZiBtRGF0YVNyYyAhPT0gJ251bWJlcicgKSB7XG5cdFx0XHRvU2V0dGluZ3MuX3Jvd1JlYWRPYmplY3QgPSB0cnVlO1xuXHRcdH1cblx0XG5cdFx0LyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cblx0XHRpZiAoICFvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0IClcblx0XHR7XG5cdFx0XHRvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xuXHRcdFx0dGguYWRkQ2xhc3MoIG9DbGFzc2VzLnNTb3J0YWJsZU5vbmUgKTsgLy8gSGF2ZSB0byBhZGQgY2xhc3MgaGVyZSBhcyBvcmRlciBldmVudCBpc24ndCBjYWxsZWRcblx0XHR9XG5cdFxuXHRcdC8qIENoZWNrIHRoYXQgdGhlIGNsYXNzIGFzc2lnbm1lbnQgaXMgY29ycmVjdCBmb3Igc29ydGluZyAqL1xuXHRcdHZhciBiQXNjID0gJC5pbkFycmF5KCdhc2MnLCBvQ29sLmFzU29ydGluZykgIT09IC0xO1xuXHRcdHZhciBiRGVzYyA9ICQuaW5BcnJheSgnZGVzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdFx0aWYgKCAhb0NvbC5iU29ydGFibGUgfHwgKCFiQXNjICYmICFiRGVzYykgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZU5vbmU7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBcIlwiO1xuXHRcdH1cblx0XHRlbHNlIGlmICggYkFzYyAmJiAhYkRlc2MgKVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZUFzYztcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICFiQXNjICYmIGJEZXNjIClcblx0XHR7XG5cdFx0XHRvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVEZXNjO1xuXHRcdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZTtcblx0XHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGp1c3QgdGhlIHRhYmxlIGNvbHVtbiB3aWR0aHMgZm9yIG5ldyBkYXRhLiBOb3RlOiB5b3Ugd291bGQgcHJvYmFibHkgd2FudCB0b1xuXHQgKiBkbyBhIHJlZHJhdyBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24hXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRqdXN0Q29sdW1uU2l6aW5nICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0LyogTm90IGludGVyZXN0ZWQgaW4gZG9pbmcgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uIGlmIGF1dG8td2lkdGggaXMgZGlzYWJsZWQgKi9cblx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iQXV0b1dpZHRoICE9PSBmYWxzZSApXG5cdFx0e1xuXHRcdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFxuXHRcdFx0X2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKCBzZXR0aW5ncyApO1xuXHRcdFx0Zm9yICggdmFyIGk9MCAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRjb2x1bW5zW2ldLm5UaC5zdHlsZS53aWR0aCA9IGNvbHVtbnNbaV0uc1dpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdFx0aWYgKCBzY3JvbGwuc1kgIT09ICcnIHx8IHNjcm9sbC5zWCAhPT0gJycpXG5cdFx0e1xuXHRcdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tc2l6aW5nJywgW3NldHRpbmdzXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvdmVydCB0aGUgaW5kZXggb2YgYSB2aXNpYmxlIGNvbHVtbiB0byB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkgKHRha2UgYWNjb3VudFxuXHQgKiBvZiBoaWRkZW4gY29sdW1ucylcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpTWF0Y2ggVmlzaWJsZSBjb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XG5cdFx0cmV0dXJuIHR5cGVvZiBhaVZpc1tpTWF0Y2hdID09PSAnbnVtYmVyJyA/XG5cdFx0XHRhaVZpc1tpTWF0Y2hdIDpcblx0XHRcdG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuXHQgKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxuXHQgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBvU2V0dGluZ3MsIGlNYXRjaCApXG5cdHtcblx0XHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0XHR2YXIgaVBvcyA9ICQuaW5BcnJheSggaU1hdGNoLCBhaVZpcyApO1xuXHRcblx0XHRyZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyggb1NldHRpbmdzIClcblx0e1xuXHRcdHZhciB2aXMgPSAwO1xuXHRcblx0XHQvLyBObyByZWR1Y2UgaW4gSUU4LCB1c2UgYSBsb29wIGZvciBub3dcblx0XHQkLmVhY2goIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdFx0aWYgKCBjb2wuYlZpc2libGUgJiYgJChjb2wublRoKS5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnICkge1xuXHRcdFx0XHR2aXMrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiB2aXM7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRoYXQgbWF0Y2ggYSBnaXZlbiBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNQYXJhbSBQYXJhbWV0ZXIgaW4gYW9Db2x1bW5zIHRvIGxvb2sgZm9yIC0gdHlwaWNhbGx5XG5cdCAqICAgIGJWaXNpYmxlIG9yIGJTZWFyY2hhYmxlXG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCBzUGFyYW0gKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0JC5tYXAoIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uKHZhbCwgaSkge1xuXHRcdFx0aWYgKCB2YWxbc1BhcmFtXSApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gYTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcblx0XHR2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcblx0XHR2YXIgY29sLCBjZWxsLCBkZXRlY3RlZFR5cGUsIGNhY2hlO1xuXHRcblx0XHQvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgXG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRjYWNoZSA9IFtdO1xuXHRcblx0XHRcdGlmICggISBjb2wuc1R5cGUgJiYgY29sLl9zTWFudWFsVHlwZSApIHtcblx0XHRcdFx0Y29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49dHlwZXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggaz0wLCBrZW49ZGF0YS5sZW5ndGggOyBrPGtlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdC8vIFVzZSBhIGNhY2hlIGFycmF5IHNvIHdlIG9ubHkgbmVlZCB0byBnZXQgdGhlIHR5cGUgZGF0YVxuXHRcdFx0XHRcdFx0Ly8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuXHRcdFx0XHRcdFx0aWYgKCBjYWNoZVtrXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRjYWNoZVtrXSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaywgaSwgJ3R5cGUnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gdHlwZXNbal0oIGNhY2hlW2tdLCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0XHRcdC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xuXHRcdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdGVzdGluZyBhbGwgY2VsbHMsIGJyZWFrIG91dC4gVGhlcmUgaXMgYW5cblx0XHRcdFx0XHRcdC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxuXHRcdFx0XHRcdFx0Ly8gdHlwZXNcblx0XHRcdFx0XHRcdGlmICggISBkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIE9ubHkgYSBzaW5nbGUgbWF0Y2ggaXMgbmVlZGVkIGZvciBodG1sIHR5cGUgc2luY2UgaXQgaXNcblx0XHRcdFx0XHRcdC8vIGJvdHRvbSBvZiB0aGUgcGlsZSBhbmQgdmVyeSBzaW1pbGFyIHRvIHN0cmluZ1xuXHRcdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgPT09ICdodG1sJyApIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBUeXBlIGlzIHZhbGlkIGZvciBhbGwgZGF0YSBwb2ludHMgaW4gdGhlIGNvbHVtbiAtIHVzZSB0aGlzXG5cdFx0XHRcdFx0Ly8gdHlwZVxuXHRcdFx0XHRcdGlmICggZGV0ZWN0ZWRUeXBlICkge1xuXHRcdFx0XHRcdFx0Y29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBGYWxsIGJhY2sgLSBpZiBubyB0eXBlIHdhcyBkZXRlY3RlZCwgYWx3YXlzIHVzZSBzdHJpbmdcblx0XHRcdFx0aWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdFx0XHRjb2wuc1R5cGUgPSAnc3RyaW5nJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIHN0YXRpYyBjb2x1bW5zIGFycmF5cyBhbmQgY2FsY3VsYXRlIGhvd1xuXHQgKiB0aGV5IHJlbGF0ZSB0byBjb2x1bW4gaW5kZXhlcy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgdGhlbiBhcHBseSB0aGVcblx0ICogZGVmaW5pdGlvbiBmb3VuZCBmb3IgYSBjb2x1bW4gdG8gYSBzdWl0YWJsZSBjb25maWd1cmF0aW9uIG9iamVjdC5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFvQ29sRGVmcyBUaGUgYW9Db2x1bW5EZWZzIGFycmF5IHRoYXQgaXMgdG8gYmUgYXBwbGllZFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xzIFRoZSBhb0NvbHVtbnMgYXJyYXkgdGhhdCBkZWZpbmVzIGNvbHVtbnMgaW5kaXZpZHVhbGx5XG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiAtIHRha2VzIHR3byBwYXJhbWV0ZXJzLCB0aGUgY2FsY3VsYXRlZFxuXHQgKiAgICBjb2x1bW4gaW5kZXggYW5kIHRoZSBkZWZpbml0aW9uIGZvciB0aGF0IGNvbHVtbi5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBmbiApXG5cdHtcblx0XHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgZGVmO1xuXHRcdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0Ly8gQ29sdW1uIGRlZmluaXRpb25zIHdpdGggYVRhcmdldHNcblx0XHRpZiAoIGFvQ29sRGVmcyApXG5cdFx0e1xuXHRcdFx0LyogTG9vcCBvdmVyIHRoZSBkZWZpbml0aW9ucyBhcnJheSAtIGxvb3AgaW4gcmV2ZXJzZSBzbyBmaXJzdCBpbnN0YW5jZSBoYXMgcHJpb3JpdHkgKi9cblx0XHRcdGZvciAoIGk9YW9Db2xEZWZzLmxlbmd0aC0xIDsgaT49MCA7IGktLSApXG5cdFx0XHR7XG5cdFx0XHRcdGRlZiA9IGFvQ29sRGVmc1tpXTtcblx0XG5cdFx0XHRcdC8qIEVhY2ggZGVmaW5pdGlvbiBjYW4gdGFyZ2V0IG11bHRpcGxlIGNvbHVtbnMsIGFzIGl0IGlzIGFuIGFycmF5ICovXG5cdFx0XHRcdHZhciBhVGFyZ2V0cyA9IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGRlZi50YXJnZXRzIDpcblx0XHRcdFx0XHRkZWYuYVRhcmdldHM7XG5cdFxuXHRcdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggYVRhcmdldHMgKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhVGFyZ2V0cyA9IFsgYVRhcmdldHMgXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICggaj0wLCBqTGVuPWFUYXJnZXRzLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPj0gMCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0LyogQWRkIGNvbHVtbnMgdGhhdCB3ZSBkb24ndCB5ZXQga25vdyBhYm91dCAqL1xuXHRcdFx0XHRcdFx0d2hpbGUoIGNvbHVtbnMubGVuZ3RoIDw9IGFUYXJnZXRzW2pdIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvKiBJbnRlZ2VyLCBiYXNpYyBpbmRleCAqL1xuXHRcdFx0XHRcdFx0Zm4oIGFUYXJnZXRzW2pdLCBkZWYgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPCAwIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvKiBOZWdhdGl2ZSBpbnRlZ2VyLCByaWdodCB0byBsZWZ0IGNvbHVtbiBjb3VudGluZyAqL1xuXHRcdFx0XHRcdFx0Zm4oIGNvbHVtbnMubGVuZ3RoK2FUYXJnZXRzW2pdLCBkZWYgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ3N0cmluZycgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIENsYXNzIG5hbWUgbWF0Y2hpbmcgb24gVEggZWxlbWVudCAqL1xuXHRcdFx0XHRcdFx0Zm9yICggaz0wLCBrTGVuPWNvbHVtbnMubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCBhVGFyZ2V0c1tqXSA9PSBcIl9hbGxcIiB8fFxuXHRcdFx0XHRcdFx0XHQgICAgICQoY29sdW1uc1trXS5uVGgpLmhhc0NsYXNzKCBhVGFyZ2V0c1tqXSApIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGZuKCBrLCBkZWYgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gU3RhdGljYWxseSBkZWZpbmVkIGNvbHVtbnMgYXJyYXlcblx0XHRpZiAoIGFvQ29scyApXG5cdFx0e1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29scy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRmbiggaSwgYW9Db2xzW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGEgZGF0YSBhcnJheSB0byB0aGUgdGFibGUsIGNyZWF0aW5nIERPTSBub2RlIGV0Yy4gVGhpcyBpcyB0aGUgcGFyYWxsZWwgdG9cblx0ICogX2ZuR2F0aGVyRGF0YSwgYnV0IGZvciBhZGRpbmcgcm93cyBmcm9tIGEgSmF2YXNjcmlwdCBzb3VyY2UsIHJhdGhlciB0aGFuIGFcblx0ICogRE9NIHNvdXJjZS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7YXJyYXl9IGFEYXRhIGRhdGEgYXJyYXkgdG8gYmUgYWRkZWRcblx0ICogIEBwYXJhbSB7bm9kZX0gW25Ucl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcblx0ICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XG5cdCAqICBAcGFyYW0ge2FycmF5fSBbYW5UZHNdIEFycmF5IG9mIFREfFRIIGVsZW1lbnRzIGZvciB0aGUgcm93IC0gbXVzdCBiZSBnaXZlblxuXHQgKiAgICBpZiBuVHIgaXMuXG5cdCAqICBAcmV0dXJucyB7aW50fSA+PTAgaWYgc3VjY2Vzc2Z1bCAoaW5kZXggb2YgbmV3IGFvRGF0YSBlbnRyeSksIC0xIGlmIGZhaWxlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BZGREYXRhICggb1NldHRpbmdzLCBhRGF0YUluLCBuVHIsIGFuVGRzIClcblx0e1xuXHRcdC8qIENyZWF0ZSB0aGUgb2JqZWN0IGZvciBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHJvdyAqL1xuXHRcdHZhciBpUm93ID0gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGg7XG5cdFx0dmFyIG9EYXRhID0gJC5leHRlbmQoIHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Sb3csIHtcblx0XHRcdHNyYzogblRyID8gJ2RvbScgOiAnZGF0YScsXG5cdFx0XHRpZHg6IGlSb3dcblx0XHR9ICk7XG5cdFxuXHRcdG9EYXRhLl9hRGF0YSA9IGFEYXRhSW47XG5cdFx0b1NldHRpbmdzLmFvRGF0YS5wdXNoKCBvRGF0YSApO1xuXHRcblx0XHQvKiBDcmVhdGUgdGhlIGNlbGxzICovXG5cdFx0dmFyIG5UZCwgc1RoaXNUeXBlO1xuXHRcdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdFx0Ly8gSW52YWxpZGF0ZSB0aGUgY29sdW1uIHR5cGVzIGFzIHRoZSBuZXcgZGF0YSBuZWVkcyB0byBiZSByZXZhbGlkYXRlZFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGNvbHVtbnNbaV0uc1R5cGUgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0LyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXG5cdFx0b1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5wdXNoKCBpUm93ICk7XG5cdFxuXHRcdHZhciBpZCA9IG9TZXR0aW5ncy5yb3dJZEZuKCBhRGF0YUluICk7XG5cdFx0aWYgKCBpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b1NldHRpbmdzLmFJZHNbIGlkIF0gPSBvRGF0YTtcblx0XHR9XG5cdFxuXHRcdC8qIENyZWF0ZSB0aGUgRE9NIGluZm9ybWF0aW9uLCBvciByZWdpc3RlciBpdCBpZiBhbHJlYWR5IHByZXNlbnQgKi9cblx0XHRpZiAoIG5UciB8fCAhIG9TZXR0aW5ncy5vRmVhdHVyZXMuYkRlZmVyUmVuZGVyIClcblx0XHR7XG5cdFx0XHRfZm5DcmVhdGVUciggb1NldHRpbmdzLCBpUm93LCBuVHIsIGFuVGRzICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gaVJvdztcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBZGQgb25lIG9yIG1vcmUgVFIgZWxlbWVudHMgdG8gdGhlIHRhYmxlLiBHZW5lcmFsbHkgd2UnZCBleHBlY3QgdG9cblx0ICogdXNlIHRoaXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIGEgRE9NIHNvdXJjZWQgdGFibGUsIGJ1dCBpdCBjb3VsZCBiZVxuXHQgKiB1c2VkIGZvciBhbiBUUiBlbGVtZW50LiBOb3RlIHRoYXQgaWYgYSBUUiBpcyBnaXZlbiwgaXQgaXMgdXNlZCAoaS5lLlxuXHQgKiBpdCBpcyBub3QgY2xvbmVkKS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHthcnJheXxub2RlfGpRdWVyeX0gdHJzIFRoZSBUUiBlbGVtZW50KHMpIHRvIGFkZCB0byB0aGUgdGFibGVcblx0ICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyBmb3IgdGhlIGFkZGVkIHJvd3Ncblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkVHIoIHNldHRpbmdzLCB0cnMgKVxuXHR7XG5cdFx0dmFyIHJvdztcblx0XG5cdFx0Ly8gQWxsb3cgYW4gaW5kaXZpZHVhbCBub2RlIHRvIGJlIHBhc3NlZCBpblxuXHRcdGlmICggISAodHJzIGluc3RhbmNlb2YgJCkgKSB7XG5cdFx0XHR0cnMgPSAkKHRycyk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdHJzLm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRyb3cgPSBfZm5HZXRSb3dFbGVtZW50cyggc2V0dGluZ3MsIGVsICk7XG5cdFx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdy5kYXRhLCBlbCwgcm93LmNlbGxzICk7XG5cdFx0fSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRha2UgYSBUUiBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IHRvIGFuIGluZGV4IGluIGFvRGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuIHRoZSBUUiBlbGVtZW50IHRvIGZpbmRcblx0ICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCBudWxsIGlmIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Ob2RlVG9EYXRhSW5kZXgoIG9TZXR0aW5ncywgbiApXG5cdHtcblx0XHRyZXR1cm4gKG4uX0RUX1Jvd0luZGV4IT09dW5kZWZpbmVkKSA/IG4uX0RUX1Jvd0luZGV4IDogbnVsbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBUYWtlIGEgVEQgZWxlbWVudCBhbmQgY29udmVydCBpdCBpbnRvIGEgY29sdW1uIGRhdGEgaW5kZXggKG5vdCB0aGUgdmlzaWJsZSBpbmRleClcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgbnVtYmVyIHRoZSBURC9USCBjYW4gYmUgZm91bmQgaW5cblx0ICogIEBwYXJhbSB7bm9kZX0gbiBUaGUgVEQvVEggZWxlbWVudCB0byBmaW5kXG5cdCAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgLTEgaWYgbm90XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbk5vZGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlSb3csIG4gKVxuXHR7XG5cdFx0cmV0dXJuICQuaW5BcnJheSggbiwgb1NldHRpbmdzLmFvRGF0YVsgaVJvdyBdLmFuQ2VsbHMgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gY2VsbCBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSwgdGFraW5nIGludG8gYWNjb3VudCBkYXRhIG1hcHBpbmdcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG5cdCAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnKVxuXHQgKiAgQHJldHVybnMgeyp9IENlbGwgZGF0YVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB0eXBlIClcblx0e1xuXHRcdHZhciBkcmF3ICAgICAgICAgICA9IHNldHRpbmdzLmlEcmF3O1xuXHRcdHZhciBjb2wgICAgICAgICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHRcdHZhciByb3dEYXRhICAgICAgICA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcblx0XHR2YXIgZGVmYXVsdENvbnRlbnQgPSBjb2wuc0RlZmF1bHRDb250ZW50O1xuXHRcdHZhciBjZWxsRGF0YSAgICAgICA9IGNvbC5mbkdldERhdGEoIHJvd0RhdGEsIHR5cGUsIHtcblx0XHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0XHRjb2w6ICAgICAgY29sSWR4XG5cdFx0fSApO1xuXHRcblx0XHRpZiAoIGNlbGxEYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzLmlEcmF3RXJyb3IgIT0gZHJhdyAmJiBkZWZhdWx0Q29udGVudCA9PT0gbnVsbCApIHtcblx0XHRcdFx0X2ZuTG9nKCBzZXR0aW5ncywgMCwgXCJSZXF1ZXN0ZWQgdW5rbm93biBwYXJhbWV0ZXIgXCIrXG5cdFx0XHRcdFx0KHR5cGVvZiBjb2wubURhdGE9PSdmdW5jdGlvbicgPyAne2Z1bmN0aW9ufScgOiBcIidcIitjb2wubURhdGErXCInXCIpK1xuXHRcdFx0XHRcdFwiIGZvciByb3cgXCIrcm93SWR4K1wiLCBjb2x1bW4gXCIrY29sSWR4LCA0ICk7XG5cdFx0XHRcdHNldHRpbmdzLmlEcmF3RXJyb3IgPSBkcmF3O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlZmF1bHRDb250ZW50O1xuXHRcdH1cblx0XG5cdFx0Ly8gV2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCBhbmQgYSBzcGVjaWZpYyBkYXRhIHR5cGUgaXMgcmVxdWVzdGVkIChpLmUuXG5cdFx0Ly8gbm90IHRoZSBvcmlnaW5hbCBkYXRhKSwgd2UgY2FuIHVzZSBkZWZhdWx0IGNvbHVtbiBkYXRhXG5cdFx0aWYgKCAoY2VsbERhdGEgPT09IHJvd0RhdGEgfHwgY2VsbERhdGEgPT09IG51bGwpICYmIGRlZmF1bHRDb250ZW50ICE9PSBudWxsICYmIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNlbGxEYXRhID0gZGVmYXVsdENvbnRlbnQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgY2VsbERhdGEgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBJZiB0aGUgZGF0YSBzb3VyY2UgaXMgYSBmdW5jdGlvbiwgdGhlbiB3ZSBydW4gaXQgYW5kIHVzZSB0aGUgcmV0dXJuLFxuXHRcdFx0Ly8gZXhlY3V0aW5nIGluIHRoZSBzY29wZSBvZiB0aGUgZGF0YSBvYmplY3QgKGZvciBpbnN0YW5jZXMpXG5cdFx0XHRyZXR1cm4gY2VsbERhdGEuY2FsbCggcm93RGF0YSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBjZWxsRGF0YSA9PT0gbnVsbCAmJiB0eXBlID09ICdkaXNwbGF5JyApIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0cmV0dXJuIGNlbGxEYXRhO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc3BlY2lmaWMgY2VsbCwgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBjYWNoZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG5cdCAqICBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byBzZXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdmFsIClcblx0e1xuXHRcdHZhciBjb2wgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdFx0dmFyIHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XG5cdFxuXHRcdGNvbC5mblNldERhdGEoIHJvd0RhdGEsIHZhbCwge1xuXHRcdFx0c2V0dGluZ3M6IHNldHRpbmdzLFxuXHRcdFx0cm93OiAgICAgIHJvd0lkeCxcblx0XHRcdGNvbDogICAgICBjb2xJZHhcblx0XHR9ICApO1xuXHR9XG5cdFxuXHRcblx0Ly8gUHJpdmF0ZSB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gbWF0Y2ggYWN0aW9uIHN5bnRheCBpbiB0aGUgZGF0YSBwcm9wZXJ0eSBvYmplY3Rcblx0dmFyIF9fcmVBcnJheSA9IC9cXFsuKj9cXF0kLztcblx0dmFyIF9fcmVGbiA9IC9cXChcXCkkLztcblx0XG5cdC8qKlxuXHQgKiBTcGxpdCBzdHJpbmcgb24gcGVyaW9kcywgdGFraW5nIGludG8gYWNjb3VudCBlc2NhcGVkIHBlcmlvZHNcblx0ICogQHBhcmFtICB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0XG5cdCAqIEByZXR1cm4ge2FycmF5fSBTcGxpdCBzdHJpbmdcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNwbGl0T2JqTm90YXRpb24oIHN0ciApXG5cdHtcblx0XHRyZXR1cm4gJC5tYXAoIHN0ci5tYXRjaCgvKFxcXFwufFteXFwuXSkrL2cpIHx8IFsnJ10sIGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHJldHVybiBzLnJlcGxhY2UoL1xcXFxcXC4vZywgJy4nKTtcblx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG5cdCAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2Vcblx0ICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBnZXQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0T2JqZWN0RGF0YUZuKCBtU291cmNlIClcblx0e1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBtU291cmNlICkgKVxuXHRcdHtcblx0XHRcdC8qIEJ1aWxkIGFuIG9iamVjdCBvZiBnZXQgZnVuY3Rpb25zLCBhbmQgd3JhcCB0aGVtIGluIGEgc2luZ2xlIGNhbGwgKi9cblx0XHRcdHZhciBvID0ge307XG5cdFx0XHQkLmVhY2goIG1Tb3VyY2UsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRvW2tleV0gPSBfZm5HZXRPYmplY3REYXRhRm4oIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0dmFyIHQgPSBvW3R5cGVdIHx8IG8uXztcblx0XHRcdFx0cmV0dXJuIHQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0dChkYXRhLCB0eXBlLCByb3csIG1ldGEpIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1Tb3VyY2UgPT09IG51bGwgKVxuXHRcdHtcblx0XHRcdC8qIEdpdmUgYW4gZW1wdHkgc3RyaW5nIGZvciByZW5kZXJpbmcgLyBzb3J0aW5nIGV0YyAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHR5cGUsIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnZnVuY3Rpb24nIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xuXHRcdFx0XHRyZXR1cm4gbVNvdXJjZSggZGF0YSwgdHlwZSwgcm93LCBtZXRhICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIG1Tb3VyY2UgPT09ICdzdHJpbmcnICYmIChtU291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcblx0XHRcdCAgICAgIG1Tb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBtU291cmNlLmluZGV4T2YoJygnKSAhPT0gLTEpIClcblx0XHR7XG5cdFx0XHQvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxuXHRcdFx0ICogbmVzdGVkIG9iamVjdCBzbyB3ZSBsb29wIG92ZXIgdGhlIGRhdGEgZm9yIGVhY2ggbGV2ZWwgdG8gZ2V0IHRoZSBuZXh0XG5cdFx0XHQgKiBsZXZlbCBkb3duLiBPbiBlYWNoIGxvb3Agd2UgdGVzdCBmb3IgdW5kZWZpbmVkLCBhbmQgaWYgZm91bmQgaW1tZWRpYXRlbHlcblx0XHRcdCAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXG5cdFx0XHQgKiBiZSB1c2VkIGlmIGRlZmluZWQsIHJhdGhlciB0aGFuIHRocm93aW5nIGFuIGVycm9yXG5cdFx0XHQgKi9cblx0XHRcdHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XG5cdFx0XHRcdHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRpZiAoIHNyYyAhPT0gXCJcIiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApO1xuXHRcblx0XHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cblx0XHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0XHRmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBhcnJheU5vdGF0aW9uIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gQXJyYXkgbm90YXRpb25cblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxuXHRcdFx0XHRcdFx0XHRpZiAoIGFbaV0gIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRvdXQgPSBbXTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIGdldFxuXHRcdFx0XHRcdFx0XHRhLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRcdGlubmVyU3JjID0gYS5qb2luKCcuJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBnZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0LnB1c2goIGZldGNoRGF0YSggZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMgKSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxuXHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gKGpvaW49PT1cIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBmZXRjaERhdGEoIGRhdGEsIHR5cGUsIG1Tb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGRhdGFbbVNvdXJjZV07XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcblx0ICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIHNldCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UgKVxuXHR7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIG1Tb3VyY2UgKSApXG5cdFx0e1xuXHRcdFx0LyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXG5cdFx0XHQgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3Rcblx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0ICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4oIG1Tb3VyY2UuXyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbVNvdXJjZSA9PT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0LyogTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsICovXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge307XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcblx0XHRcdFx0bVNvdXJjZSggZGF0YSwgJ3NldCcsIHZhbCwgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHQgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0LyogTGlrZSB0aGUgZ2V0LCB3ZSBuZWVkIHRvIGdldCBkYXRhIGZyb20gYSBuZXN0ZWQgb2JqZWN0ICovXG5cdFx0XHR2YXIgc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB2YWwsIHNyYykge1xuXHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApLCBiO1xuXHRcdFx0XHR2YXIgYUxhc3QgPSBhW2EubGVuZ3RoLTFdO1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvLCBpbm5lclNyYztcblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGgtMSA7IGk8aUxlbiA7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBQcm90ZWN0IGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHRcdGlmIChhW2ldID09PSAnX19wcm90b19fJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHByb3RvdHlwZSB2YWx1ZXMnKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXkgbm90YXRpb24gcmVxdWVzdFxuXHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSBbXTtcblx0XG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBzZXQgc28gd2UgY2FuIHJlY3Vyc2Vcblx0XHRcdFx0XHRcdGIgPSBhLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRiLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRpbm5lclNyYyA9IGIuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IHNldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj12YWwubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzZXREYXRhKCBvLCB2YWxbal0sIGlubmVyU3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBXZSd2ZSBiZWVuIGFza2VkIHRvIHNhdmUgZGF0YSB0byBhbiBhcnJheSwgYnV0IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlzbid0IGFycmF5IGRhdGEgdG8gYmUgc2F2ZWQuIEJlc3QgdGhhdCBjYW4gYmUgZG9uZVxuXHRcdFx0XHRcdFx0XHQvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHQvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGZ1bmNOb3RhdGlvbiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5lc3RlZCBvYmplY3QgZG9lc24ndCBjdXJyZW50bHkgZXhpc3QgLSBzaW5jZSB3ZSBhcmVcblx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxuXHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gTGFzdCBpdGVtIGluIHRoZSBpbnB1dCAtIGkuZSwgdGhlIGFjdHVhbCBzZXRcblx0XHRcdFx0aWYgKCBhTGFzdC5tYXRjaChfX3JlRm4gKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUZuLCAnJykgXSggdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHQvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxuXHRcdFx0XHRcdGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUFycmF5LCAnJykgXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIHNldERhdGEoIGRhdGEsIHZhbCwgbVNvdXJjZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8qIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmcgKi9cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRkYXRhW21Tb3VyY2VdID0gdmFsO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIGZ1bGwgdGFibGUgZGF0YVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIE51a2UgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNsZWFyVGFibGUoIHNldHRpbmdzIClcblx0e1xuXHRcdHNldHRpbmdzLmFvRGF0YS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuXHRcdHNldHRpbmdzLmFJZHMgPSB7fTtcblx0fVxuXHRcblx0XG5cdCAvKipcblx0ICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3Rcblx0ICogdGhlIGtleSEpXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxuXHQgKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZWxldGVJbmRleCggYSwgaVRhcmdldCwgc3BsaWNlIClcblx0e1xuXHRcdHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0aWYgKCBhW2ldID09IGlUYXJnZXQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpVGFyZ2V0SW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGFbaV0gPiBpVGFyZ2V0IClcblx0XHRcdHtcblx0XHRcdFx0YVtpXS0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0aWYgKCBpVGFyZ2V0SW5kZXggIT0gLTEgJiYgc3BsaWNlID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdGEuc3BsaWNlKCBpVGFyZ2V0SW5kZXgsIDEgKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG5cdCAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcblx0ICogICAgIG9yICdkYXRhJ1xuXHQgKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcblx0ICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXG5cdCAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKlxuXHQgKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xuXHQgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcblx0ICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cblx0ICovXG5cdGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcblx0e1xuXHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNlbGxXcml0ZSA9IGZ1bmN0aW9uICggY2VsbCwgY29sICkge1xuXHRcdFx0Ly8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcblx0XHRcdC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcblx0XHRcdC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcblx0XHRcdHdoaWxlICggY2VsbC5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0Y2VsbC5yZW1vdmVDaGlsZCggY2VsbC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScgKTtcblx0XHR9O1xuXHRcblx0XHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRcdGlmICggc3JjID09PSAnZG9tJyB8fCAoKCEgc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykgKSB7XG5cdFx0XHQvLyBSZWFkIHRoZSBkYXRhIGZyb20gdGhlIERPTVxuXHRcdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRcdHNldHRpbmdzLCByb3csIGNvbElkeCwgY29sSWR4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3cuX2FEYXRhXG5cdFx0XHRcdClcblx0XHRcdFx0LmRhdGE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdFx0dmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cdFxuXHRcdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjZWxsV3JpdGUoIGNlbGxzW2NvbElkeF0sIGNvbElkeCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tpXSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuXHRcdC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XG5cdFx0cm93Ll9hU29ydERhdGEgPSBudWxsO1xuXHRcdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXHRcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXG5cdFx0Ly8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdFx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2xzW2ldLnNUeXBlID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XG5cdFx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBzZXR0aW5ncywgcm93ICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJ1aWxkIGEgZGF0YSBzb3VyY2Ugb2JqZWN0IGZyb20gYW4gSFRNTCByb3csIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcblx0ICogICBvYmplY3QgZnJvbSB3aGljaCB0byByZS1yZWFkIHRoZSBkYXRhIGZyb20gdGhlIGNlbGxzXG5cdCAqIEBwYXJhbSB7aW50fSBbY29sSWR4XSBPcHRpb25hbCBjb2x1bW4gaW5kZXhcblx0ICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xuXHQgKiAgIHBhcmFtZXRlciBzaG91bGQgYWxzbyBiZSBnaXZlbiBhbmQgd2lsbCBiZSB1c2VkIHRvIHdyaXRlIHRoZSBkYXRhIGludG8uXG5cdCAqICAgT25seSB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIHdpbGwgYmUgd3JpdHRlblxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXG5cdCAqICAgZG9jdW1lbnQgb3JkZXIsIGFuZCBgY2VsbHNgIGFuZCBhcnJheSBvZiBub2RlcyAodGhleSBjYW4gYmUgdXNlZnVsIHRvIHRoZVxuXHQgKiAgIGNhbGxlciwgc28gcmF0aGVyIHRoYW4gbmVlZGluZyBhIHNlY29uZCB0cmF2ZXJzYWwgdG8gZ2V0IHRoZW0sIGp1c3QgcmV0dXJuXG5cdCAqICAgdGhlbSBmcm9tIGhlcmUpLlxuXHQgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0ZHMgPSBbXSxcblx0XHRcdHRkID0gcm93LmZpcnN0Q2hpbGQsXG5cdFx0XHRuYW1lLCBjb2wsIG8sIGk9MCwgY29udGVudHMsXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0b2JqZWN0UmVhZCA9IHNldHRpbmdzLl9yb3dSZWFkT2JqZWN0O1xuXHRcblx0XHQvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3Rcblx0XHRkID0gZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGQgOlxuXHRcdFx0b2JqZWN0UmVhZCA/XG5cdFx0XHRcdHt9IDpcblx0XHRcdFx0W107XG5cdFxuXHRcdHZhciBhdHRyID0gZnVuY3Rpb24gKCBzdHIsIHRkICApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHZhciBpZHggPSBzdHIuaW5kZXhPZignQCcpO1xuXHRcblx0XHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHRcdHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyggaWR4KzEgKTtcblx0XHRcdFx0XHR2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKCBzdHIgKTtcblx0XHRcdFx0XHRzZXR0ZXIoIGQsIHRkLmdldEF0dHJpYnV0ZSggYXR0ciApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBSZWFkIGRhdGEgZnJvbSBhIGNlbGwgYW5kIHN0b3JlIGludG8gdGhlIGRhdGEgb2JqZWN0XG5cdFx0dmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKCBjZWxsICkge1xuXHRcdFx0aWYgKCBjb2xJZHggPT09IHVuZGVmaW5lZCB8fCBjb2xJZHggPT09IGkgKSB7XG5cdFx0XHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0XHRcdGNvbnRlbnRzID0gKGNlbGwuaW5uZXJIVE1MKS50cmltKCk7XG5cdFxuXHRcdFx0XHRpZiAoIGNvbCAmJiBjb2wuX2JBdHRyU3JjICkge1xuXHRcdFx0XHRcdHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIGNvbC5tRGF0YS5fICk7XG5cdFx0XHRcdFx0c2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcblx0XHRcdFx0XHRhdHRyKCBjb2wubURhdGEuc29ydCwgY2VsbCApO1xuXHRcdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS50eXBlLCBjZWxsICk7XG5cdFx0XHRcdFx0YXR0ciggY29sLm1EYXRhLmZpbHRlciwgY2VsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYGRhdGFgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbnMgdGhlIGRhdGEgY2FuXG5cdFx0XHRcdFx0Ly8gYmUgcmVhZCB0byBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuXHRcdFx0XHRcdGlmICggb2JqZWN0UmVhZCApIHtcblx0XHRcdFx0XHRcdGlmICggISBjb2wuX3NldHRlciApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIHNldHRlciBmdW5jdGlvblxuXHRcdFx0XHRcdFx0XHRjb2wuX3NldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2wuX3NldHRlciggZCwgY29udGVudHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRkW2ldID0gY29udGVudHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH07XG5cdFxuXHRcdGlmICggdGQgKSB7XG5cdFx0XHQvLyBgdHJgIGVsZW1lbnQgd2FzIHBhc3NlZCBpblxuXHRcdFx0d2hpbGUgKCB0ZCApIHtcblx0XHRcdFx0bmFtZSA9IHRkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cdFxuXHRcdFx0XHRpZiAoIG5hbWUgPT0gXCJURFwiIHx8IG5hbWUgPT0gXCJUSFwiICkge1xuXHRcdFx0XHRcdGNlbGxQcm9jZXNzKCB0ZCApO1xuXHRcdFx0XHRcdHRkcy5wdXNoKCB0ZCApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR0ZCA9IHRkLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXG5cdFx0XHR0ZHMgPSByb3cuYW5DZWxscztcblx0XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGRzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRjZWxsUHJvY2VzcyggdGRzW2pdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvLyBSZWFkIHRoZSBJRCBmcm9tIHRoZSBET00gaWYgcHJlc2VudFxuXHRcdHZhciByb3dOb2RlID0gcm93LmZpcnN0Q2hpbGQgPyByb3cgOiByb3cublRyO1xuXHRcblx0XHRpZiAoIHJvd05vZGUgKSB7XG5cdFx0XHR2YXIgaWQgPSByb3dOb2RlLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcblx0XHRcdGlmICggaWQgKSB7XG5cdFx0XHRcdF9mblNldE9iamVjdERhdGFGbiggc2V0dGluZ3Mucm93SWQgKSggZCwgaWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBkLFxuXHRcdFx0Y2VsbHM6IHRkc1xuXHRcdH07XG5cdH1cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBUUiBlbGVtZW50IChhbmQgaXQncyBURCBjaGlsZHJlbikgZm9yIGEgcm93XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gaVJvdyBSb3cgdG8gY29uc2lkZXJcblx0ICogIEBwYXJhbSB7bm9kZX0gW25UckluXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuXHQgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcblx0ICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG5cdCAqICAgIGlmIG5UciBpcy5cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQ3JlYXRlVHIgKCBvU2V0dGluZ3MsIGlSb3csIG5UckluLCBhblRkcyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHJvdyA9IG9TZXR0aW5ncy5hb0RhdGFbaVJvd10sXG5cdFx0XHRyb3dEYXRhID0gcm93Ll9hRGF0YSxcblx0XHRcdGNlbGxzID0gW10sXG5cdFx0XHRuVHIsIG5UZCwgb0NvbCxcblx0XHRcdGksIGlMZW4sIGNyZWF0ZTtcblx0XG5cdFx0aWYgKCByb3cublRyID09PSBudWxsIClcblx0XHR7XG5cdFx0XHRuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXHRcblx0XHRcdHJvdy5uVHIgPSBuVHI7XG5cdFx0XHRyb3cuYW5DZWxscyA9IGNlbGxzO1xuXHRcblx0XHRcdC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcblx0XHRcdCAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxuXHRcdFx0ICovXG5cdFx0XHRuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcblx0XG5cdFx0XHQvKiBTcGVjaWFsIHBhcmFtZXRlcnMgY2FuIGJlIGdpdmVuIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBiZSB1c2VkIG9uIHRoZSByb3cgKi9cblx0XHRcdF9mblJvd0F0dHJpYnV0ZXMoIG9TZXR0aW5ncywgcm93ICk7XG5cdFxuXHRcdFx0LyogUHJvY2VzcyBlYWNoIGNvbHVtbiAqL1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPW9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XHRcdGNyZWF0ZSA9IG5UckluID8gZmFsc2UgOiB0cnVlO1xuXHRcblx0XHRcdFx0blRkID0gY3JlYXRlID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggb0NvbC5zQ2VsbFR5cGUgKSA6IGFuVGRzW2ldO1xuXHRcdFx0XHRuVGQuX0RUX0NlbGxJbmRleCA9IHtcblx0XHRcdFx0XHRyb3c6IGlSb3csXG5cdFx0XHRcdFx0Y29sdW1uOiBpXG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRjZWxscy5wdXNoKCBuVGQgKTtcblx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIHRoZSBIVE1MIGlmIG5ldywgb3IgaWYgYSByZW5kZXJpbmcgZnVuY3Rpb24gaXMgZGVmaW5lZFxuXHRcdFx0XHRpZiAoIGNyZWF0ZSB8fCAoKCFuVHJJbiB8fCBvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcblx0XHRcdFx0XHQgKCEkLmlzUGxhaW5PYmplY3Qob0NvbC5tRGF0YSkgfHwgb0NvbC5tRGF0YS5fICE9PSBpKycuZGlzcGxheScpXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRuVGQuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSwgJ2Rpc3BsYXknICk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8qIEFkZCB1c2VyIGRlZmluZWQgY2xhc3MgKi9cblx0XHRcdFx0aWYgKCBvQ29sLnNDbGFzcyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuVGQuY2xhc3NOYW1lICs9ICcgJytvQ29sLnNDbGFzcztcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gVmlzaWJpbGl0eSAtIGFkZCBvciByZW1vdmUgYXMgcmVxdWlyZWRcblx0XHRcdFx0aWYgKCBvQ29sLmJWaXNpYmxlICYmICEgblRySW4gKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0blRyLmFwcGVuZENoaWxkKCBuVGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggISBvQ29sLmJWaXNpYmxlICYmIG5UckluIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5UZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBuVGQgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCBvQ29sLmZuQ3JlYXRlZENlbGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0b0NvbC5mbkNyZWF0ZWRDZWxsLmNhbGwoIG9TZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRcdFx0XHRuVGQsIF9mbkdldENlbGxEYXRhKCBvU2V0dGluZ3MsIGlSb3csIGkgKSwgcm93RGF0YSwgaVJvdywgaVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgbnVsbCwgW25Uciwgcm93RGF0YSwgaVJvdywgY2VsbHNdICk7XG5cdFx0fVxuXHRcblx0XHQvLyBSZW1vdmUgb25jZSB3ZWJraXQgYnVnIDEzMTgxOSBhbmQgQ2hyb21pdW0gYnVnIDM2NTYxOSBoYXZlIGJlZW4gcmVzb2x2ZWRcblx0XHQvLyBhbmQgZGVwbG95ZWRcblx0XHRyb3cublRyLnNldEF0dHJpYnV0ZSggJ3JvbGUnLCAncm93JyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxuXHQgKiBzb3VyY2Ugb2JqZWN0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKVxuXHR7XG5cdFx0dmFyIHRyID0gcm93Lm5Ucjtcblx0XHR2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cdFxuXHRcdGlmICggdHIgKSB7XG5cdFx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhICk7XG5cdFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0dHIuaWQgPSBpZDtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93Q2xhc3MgKSB7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgY2xhc3NlcyBhZGRlZCBieSBEVF9Sb3dDbGFzcyBiZWZvcmVcblx0XHRcdFx0dmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XG5cdFx0XHRcdHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cblx0XHRcdFx0XHRfdW5pcXVlKCByb3cuX19yb3djLmNvbmNhdCggYSApICkgOlxuXHRcdFx0XHRcdGE7XG5cdFxuXHRcdFx0XHQkKHRyKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggcm93Ll9fcm93Yy5qb2luKCcgJykgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggZGF0YS5EVF9Sb3dDbGFzcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggZGF0YS5EVF9Sb3dBdHRyICkge1xuXHRcdFx0XHQkKHRyKS5hdHRyKCBkYXRhLkRUX1Jvd0F0dHIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGRhdGEuRFRfUm93RGF0YSApIHtcblx0XHRcdFx0JCh0cikuZGF0YSggZGF0YS5EVF9Sb3dEYXRhICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEhlYWQoIG9TZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgaSwgaWVuLCBjZWxsLCByb3csIGNvbHVtbjtcblx0XHR2YXIgdGhlYWQgPSBvU2V0dGluZ3MublRIZWFkO1xuXHRcdHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XG5cdFx0dmFyIGNyZWF0ZUhlYWRlciA9ICQoJ3RoLCB0ZCcsIHRoZWFkKS5sZW5ndGggPT09IDA7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdHJvdyA9ICQoJzx0ci8+JykuYXBwZW5kVG8oIHRoZWFkICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRcdGNlbGwgPSAkKCBjb2x1bW4ublRoICkuYWRkQ2xhc3MoIGNvbHVtbi5zQ2xhc3MgKTtcblx0XG5cdFx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdFx0Y2VsbC5hcHBlbmRUbyggcm93ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gMS4xMSBtb3ZlIGludG8gc29ydGluZ1xuXHRcdFx0aWYgKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRjZWxsLmFkZENsYXNzKCBjb2x1bW4uc1NvcnRpbmdDbGFzcyApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQuYXR0ciggJ3RhYmluZGV4Jywgb1NldHRpbmdzLmlUYWJJbmRleCApXG5cdFx0XHRcdFx0XHQuYXR0ciggJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQgKTtcblx0XG5cdFx0XHRcdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKCBvU2V0dGluZ3MsIGNvbHVtbi5uVGgsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggY29sdW1uLnNUaXRsZSAhPSBjZWxsWzBdLmlubmVySFRNTCApIHtcblx0XHRcdFx0Y2VsbC5odG1sKCBjb2x1bW4uc1RpdGxlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuUmVuZGVyZXIoIG9TZXR0aW5ncywgJ2hlYWRlcicgKShcblx0XHRcdFx0b1NldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCApO1xuXHRcdH1cblx0XHRcblx0XHQvKiBBUklBIHJvbGUgZm9yIHRoZSByb3dzICovXG5cdFx0JCh0aGVhZCkuY2hpbGRyZW4oJ3RyJykuYXR0cigncm9sZScsICdyb3cnKTtcblx0XG5cdFx0LyogRGVhbCB3aXRoIHRoZSBmb290ZXIgLSBhZGQgY2xhc3NlcyBpZiByZXF1aXJlZCAqL1xuXHRcdCQodGhlYWQpLmNoaWxkcmVuKCd0cicpLmNoaWxkcmVuKCd0aCwgdGQnKS5hZGRDbGFzcyggY2xhc3Nlcy5zSGVhZGVyVEggKTtcblx0XHQkKHRmb290KS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJykuYWRkQ2xhc3MoIGNsYXNzZXMuc0Zvb3RlclRIICk7XG5cdFxuXHRcdC8vIENhY2hlIHRoZSBmb290ZXIgY2VsbHMuIE5vdGUgdGhhdCB3ZSBvbmx5IHRha2UgdGhlIGNlbGxzIGZyb20gdGhlIGZpcnN0XG5cdFx0Ly8gcm93IGluIHRoZSBmb290ZXIuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcm93IHRoZSB1c2VyIHdhbnRzIHRvXG5cdFx0Ly8gaW50ZXJhY3Qgd2l0aCwgdGhleSBuZWVkIHRvIHVzZSB0aGUgdGFibGUoKS5mb290KCkgbWV0aG9kLiBOb3RlIGFsc28gdGhpc1xuXHRcdC8vIGFsbG93cyBjZWxscyB0byBiZSB1c2VkIGZvciBtdWx0aXBsZSBjb2x1bW5zIHVzaW5nIGNvbHNwYW5cblx0XHRpZiAoIHRmb290ICE9PSBudWxsICkge1xuXHRcdFx0dmFyIGNlbGxzID0gb1NldHRpbmdzLmFvRm9vdGVyWzBdO1xuXHRcblx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHRjb2x1bW4ublRmID0gY2VsbHNbaV0uY2VsbDtcblx0XG5cdFx0XHRcdGlmICggY29sdW1uLnNDbGFzcyApIHtcblx0XHRcdFx0XHQkKGNvbHVtbi5uVGYpLmFkZENsYXNzKCBjb2x1bW4uc0NsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy4gVGhlXG5cdCAqIG1ldGhvZG9sb2d5IGhlcmUgaXMgdG8gdXNlIHRoZSBsYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXIsIG1vZGlmaWVkIGZvclxuXHQgKiB0aGUgaW5zdGFudGFuZW91cyBjb2x1bW4gdmlzaWJpbGl0eSwgdG8gY29uc3RydWN0IHRoZSBuZXcgbGF5b3V0LiBUaGUgZ3JpZCBpc1xuXHQgKiB0cmF2ZXJzZWQgb3ZlciBjZWxsIGF0IGEgdGltZSBpbiBhIHJvd3MgeCBjb2x1bW5zIGdyaWQgZmFzaGlvbiwgYWx0aG91Z2ggZWFjaFxuXHQgKiBjZWxsIGluc2VydCBjYW4gY292ZXIgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIGdyaWQgLSB3aGljaCBpcyB0cmFja3MgdXNpbmcgdGhlXG5cdCAqIGFBcHBsaWVkIGFycmF5LiBDZWxsIGluc2VydHMgaW4gdGhlIGdyaWQgd2lsbCBvbmx5IG9jY3VyIHdoZXJlIHRoZXJlIGlzbid0XG5cdCAqIGFscmVhZHkgYSBjZWxsIGluIHRoYXQgcG9zaXRpb24uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdHN9IGFvU291cmNlIExheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlclxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYkluY2x1ZGVIaWRkZW49ZmFsc2VdIElmIHRydWUgdGhlbiBpbmNsdWRlIHRoZSBoaWRkZW4gY29sdW1ucyBpbiB0aGUgY2FsYyxcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhd0hlYWQoIG9TZXR0aW5ncywgYW9Tb3VyY2UsIGJJbmNsdWRlSGlkZGVuIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBuLCBuTG9jYWxUcjtcblx0XHR2YXIgYW9Mb2NhbCA9IFtdO1xuXHRcdHZhciBhQXBwbGllZCA9IFtdO1xuXHRcdHZhciBpQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHRcdHZhciBpUm93c3BhbiwgaUNvbHNwYW47XG5cdFxuXHRcdGlmICggISBhb1NvdXJjZSApXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAgYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0YkluY2x1ZGVIaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFxuXHRcdC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aG91dCB0aGUgdmlzaWJsZSBjb2x1bW5zIGluIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvU291cmNlLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0YW9Mb2NhbFtpXSA9IGFvU291cmNlW2ldLnNsaWNlKCk7XG5cdFx0XHRhb0xvY2FsW2ldLm5UciA9IGFvU291cmNlW2ldLm5Ucjtcblx0XG5cdFx0XHQvKiBSZW1vdmUgYW55IGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBoaWRkZW4gKi9cblx0XHRcdGZvciAoIGo9aUNvbHVtbnMtMSA7IGo+PTAgOyBqLS0gKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFvU2V0dGluZ3MuYW9Db2x1bW5zW2pdLmJWaXNpYmxlICYmICFiSW5jbHVkZUhpZGRlbiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhb0xvY2FsW2ldLnNwbGljZSggaiwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUHJlcCB0aGUgYXBwbGllZCBhcnJheSAtIGl0IG5lZWRzIGFuIGVsZW1lbnQgZm9yIGVhY2ggcm93ICovXG5cdFx0XHRhQXBwbGllZC5wdXNoKCBbXSApO1xuXHRcdH1cblx0XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvTG9jYWwubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRuTG9jYWxUciA9IGFvTG9jYWxbaV0ublRyO1xuXHRcblx0XHRcdC8qIEFsbCBjZWxscyBhcmUgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHNvIGVtcHR5IG91dCB0aGUgcm93ICovXG5cdFx0XHRpZiAoIG5Mb2NhbFRyIClcblx0XHRcdHtcblx0XHRcdFx0d2hpbGUoIChuID0gbkxvY2FsVHIuZmlyc3RDaGlsZCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGZvciAoIGo9MCwgakxlbj1hb0xvY2FsW2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlSb3dzcGFuID0gMTtcblx0XHRcdFx0aUNvbHNwYW4gPSAxO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuXHRcdFx0XHQgKiBpbnNlcnQgcG9pbnQuIElmIHRoZXJlIGlzLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bkxvY2FsVHIuYXBwZW5kQ2hpbGQoIGFvTG9jYWxbaV1bal0uY2VsbCApO1xuXHRcdFx0XHRcdGFBcHBsaWVkW2ldW2pdID0gMTtcblx0XG5cdFx0XHRcdFx0LyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cblx0XHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaStpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaStpUm93c3Bhbl1bal0uY2VsbCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YUFwcGxpZWRbaStpUm93c3Bhbl1bal0gPSAxO1xuXHRcdFx0XHRcdFx0aVJvd3NwYW4rKztcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IGNvbHVtbnMgYXMgbmVlZGVkICovXG5cdFx0XHRcdFx0d2hpbGUgKCBhb0xvY2FsW2ldW2oraUNvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2ldW2oraUNvbHNwYW5dLmNlbGwgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8qIE11c3QgdXBkYXRlIHRoZSBhcHBsaWVkIGFycmF5IG92ZXIgdGhlIHJvd3MgZm9yIHRoZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGlSb3dzcGFuIDsgaysrIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YUFwcGxpZWRbaStrXVtqK2lDb2xzcGFuXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpQ29sc3BhbisrO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0LyogRG8gdGhlIGFjdHVhbCBleHBhbnNpb24gaW4gdGhlIERPTSAqL1xuXHRcdFx0XHRcdCQoYW9Mb2NhbFtpXVtqXS5jZWxsKVxuXHRcdFx0XHRcdFx0LmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3Bhbilcblx0XHRcdFx0XHRcdC5hdHRyKCdjb2xzcGFuJywgaUNvbHNwYW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRHJhdyggb1NldHRpbmdzIClcblx0e1xuXHRcdC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXG5cdFx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0XHRpZiAoICQuaW5BcnJheSggZmFsc2UsIGFQcmVEcmF3ICkgIT09IC0xIClcblx0XHR7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0dmFyIGksIGlMZW4sIG47XG5cdFx0dmFyIGFuUm93cyA9IFtdO1xuXHRcdHZhciBpUm93Q291bnQgPSAwO1xuXHRcdHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHRcdHZhciBpU3RyaXBlcyA9IGFzU3RyaXBlQ2xhc3Nlcy5sZW5ndGg7XG5cdFx0dmFyIGlPcGVuUm93cyA9IG9TZXR0aW5ncy5hb09wZW5Sb3dzLmxlbmd0aDtcblx0XHR2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdHZhciBpSW5pdERpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcblx0XHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0XHR2YXIgYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheTtcblx0XG5cdFx0b1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcblx0XG5cdFx0LyogQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZyAqL1xuXHRcdGlmICggaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IGJTZXJ2ZXJTaWRlID9cblx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQgOlxuXHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRpSW5pdERpc3BsYXlTdGFydDtcblx0XG5cdFx0XHRvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcblx0XHR9XG5cdFxuXHRcdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHRcdHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcblx0XG5cdFx0LyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xuXHRcdGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhYlNlcnZlclNpZGUgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdH1cblx0XHRlbHNlIGlmICggIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhX2ZuQWpheFVwZGF0ZSggb1NldHRpbmdzICkgKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggYWlEaXNwbGF5Lmxlbmd0aCAhPT0gMCApXG5cdFx0e1xuXHRcdFx0dmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XG5cdFx0XHR2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcblx0XG5cdFx0XHRmb3IgKCB2YXIgaj1pU3RhcnQgOyBqPGlFbmQgOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgaURhdGFJbmRleCA9IGFpRGlzcGxheVtqXTtcblx0XHRcdFx0dmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbIGlEYXRhSW5kZXggXTtcblx0XHRcdFx0aWYgKCBhb0RhdGEublRyID09PSBudWxsIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9mbkNyZWF0ZVRyKCBvU2V0dGluZ3MsIGlEYXRhSW5kZXggKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0dmFyIG5Sb3cgPSBhb0RhdGEublRyO1xuXHRcblx0XHRcdFx0LyogUmVtb3ZlIHRoZSBvbGQgc3RyaXBpbmcgY2xhc3NlcyBhbmQgdGhlbiBhZGQgdGhlIG5ldyBvbmUgKi9cblx0XHRcdFx0aWYgKCBpU3RyaXBlcyAhPT0gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgc1N0cmlwZSA9IGFzU3RyaXBlQ2xhc3Nlc1sgaVJvd0NvdW50ICUgaVN0cmlwZXMgXTtcblx0XHRcdFx0XHRpZiAoIGFvRGF0YS5fc1Jvd1N0cmlwZSAhPSBzU3RyaXBlIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQkKG5Sb3cpLnJlbW92ZUNsYXNzKCBhb0RhdGEuX3NSb3dTdHJpcGUgKS5hZGRDbGFzcyggc1N0cmlwZSApO1xuXHRcdFx0XHRcdFx0YW9EYXRhLl9zUm93U3RyaXBlID0gc1N0cmlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xuXHRcdFx0XHQvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXG5cdFx0XHRcdC8vIHVzZWZ1bD9cblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgbnVsbCxcblx0XHRcdFx0XHRbblJvdywgYW9EYXRhLl9hRGF0YSwgaVJvd0NvdW50LCBqLCBpRGF0YUluZGV4XSApO1xuXHRcblx0XHRcdFx0YW5Sb3dzLnB1c2goIG5Sb3cgKTtcblx0XHRcdFx0aVJvd0NvdW50Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXQgKi9cblx0XHRcdHZhciBzWmVybyA9IG9MYW5nLnNaZXJvUmVjb3Jkcztcblx0XHRcdGlmICggb1NldHRpbmdzLmlEcmF3ID09IDEgJiYgIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdhamF4JyApXG5cdFx0XHR7XG5cdFx0XHRcdHNaZXJvID0gb0xhbmcuc0xvYWRpbmdSZWNvcmRzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9MYW5nLnNFbXB0eVRhYmxlICYmIG9TZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwIClcblx0XHRcdHtcblx0XHRcdFx0c1plcm8gPSBvTGFuZy5zRW1wdHlUYWJsZTtcblx0XHRcdH1cblx0XG5cdFx0XHRhblJvd3NbIDAgXSA9ICQoICc8dHIvPicsIHsgJ2NsYXNzJzogaVN0cmlwZXMgPyBhc1N0cmlwZUNsYXNzZXNbMF0gOiAnJyB9IClcblx0XHRcdFx0LmFwcGVuZCggJCgnPHRkIC8+Jywge1xuXHRcdFx0XHRcdCd2YWxpZ24nOiAgJ3RvcCcsXG5cdFx0XHRcdFx0J2NvbFNwYW4nOiBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSxcblx0XHRcdFx0XHQnY2xhc3MnOiAgIG9TZXR0aW5ncy5vQ2xhc3Nlcy5zUm93RW1wdHlcblx0XHRcdFx0fSApLmh0bWwoIHNaZXJvICkgKVswXTtcblx0XHR9XG5cdFxuXHRcdC8qIEhlYWRlciBhbmQgZm9vdGVyIGNhbGxiYWNrcyAqL1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICdoZWFkZXInLCBbICQob1NldHRpbmdzLm5USGVhZCkuY2hpbGRyZW4oJ3RyJylbMF0sXG5cdFx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsICdmb290ZXInLCBbICQob1NldHRpbmdzLm5URm9vdCkuY2hpbGRyZW4oJ3RyJylbMF0sXG5cdFx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cdFxuXHRcdHZhciBib2R5ID0gJChvU2V0dGluZ3MublRCb2R5KTtcblx0XG5cdFx0Ym9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xuXHRcdGJvZHkuYXBwZW5kKCAkKGFuUm93cykgKTtcblx0XG5cdFx0LyogQ2FsbCBhbGwgcmVxdWlyZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgZW5kIG9mIGEgZHJhdyAqL1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAnZHJhdycsIFtvU2V0dGluZ3NdICk7XG5cdFxuXHRcdC8qIERyYXcgaXMgY29tcGxldGUsIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBtdXN0IGJlIGFzIHdlbGwgKi9cblx0XHRvU2V0dGluZ3MuYlNvcnRlZCA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5iRmlsdGVyZWQgPSBmYWxzZTtcblx0XHRvU2V0dGluZ3MuYkRyYXdpbmcgPSBmYWxzZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW2hvbGRQb3NpdGlvbl0gS2VlcCB0aGUgY3VycmVudCBwYWdpbmcgcG9zaXRpb24uIEJ5IGRlZmF1bHRcblx0ICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRcdHNvcnQgICAgID0gZmVhdHVyZXMuYlNvcnQsXG5cdFx0XHRmaWx0ZXIgICA9IGZlYXR1cmVzLmJGaWx0ZXI7XG5cdFxuXHRcdGlmICggc29ydCApIHtcblx0XHRcdF9mblNvcnQoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGZpbHRlciApIHtcblx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gZmlsdGVyaW5nLCBzbyB3ZSB3YW50IHRvIGp1c3QgdXNlIHRoZSBkaXNwbGF5IG1hc3RlclxuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGhvbGRQb3NpdGlvbiAhPT0gdHJ1ZSApIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHR9XG5cdFxuXHRcdC8vIExldCBhbnkgbW9kdWxlcyBrbm93IGFib3V0IHRoZSBkcmF3IGhvbGQgcG9zaXRpb24gc3RhdGUgKHVzZWQgYnlcblx0XHQvLyBzY3JvbGxpbmcgaW50ZXJuYWxseSlcblx0XHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBob2xkUG9zaXRpb247XG5cdFxuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdHNldHRpbmdzLl9kcmF3SG9sZCA9IGZhbHNlO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCB0aGUgb3B0aW9ucyB0byB0aGUgcGFnZSBIVE1MIGZvciB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWRkT3B0aW9uc0h0bWwgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRhYmxlID0gJChvU2V0dGluZ3MublRhYmxlKTtcblx0XHR2YXIgaG9sZGluZyA9ICQoJzxkaXYvPicpLmluc2VydEJlZm9yZSggdGFibGUgKTsgLy8gSG9sZGluZyBlbGVtZW50IGZvciBzcGVlZFxuXHRcdHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XG5cdFxuXHRcdC8vIEFsbCBEYXRhVGFibGVzIGFyZSB3cmFwcGVkIGluIGEgZGl2XG5cdFx0dmFyIGluc2VydCA9ICQoJzxkaXYvPicsIHtcblx0XHRcdGlkOiAgICAgIG9TZXR0aW5ncy5zVGFibGVJZCsnX3dyYXBwZXInLFxuXHRcdFx0J2NsYXNzJzogY2xhc3Nlcy5zV3JhcHBlciArIChvU2V0dGluZ3MublRGb290ID8gJycgOiAnICcrY2xhc3Nlcy5zTm9Gb290ZXIpXG5cdFx0fSApO1xuXHRcblx0XHRvU2V0dGluZ3MubkhvbGRpbmcgPSBob2xkaW5nWzBdO1xuXHRcdG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyID0gaW5zZXJ0WzBdO1xuXHRcdG9TZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSA9IG9TZXR0aW5ncy5uVGFibGUubmV4dFNpYmxpbmc7XG5cdFxuXHRcdC8qIExvb3Agb3ZlciB0aGUgdXNlciBzZXQgcG9zaXRpb25pbmcgYW5kIHBsYWNlIHRoZSBlbGVtZW50cyBhcyBuZWVkZWQgKi9cblx0XHR2YXIgYURvbSA9IG9TZXR0aW5ncy5zRG9tLnNwbGl0KCcnKTtcblx0XHR2YXIgZmVhdHVyZU5vZGUsIGNPcHRpb24sIG5OZXdOb2RlLCBjTmV4dCwgc0F0dHIsIGo7XG5cdFx0Zm9yICggdmFyIGk9MCA7IGk8YURvbS5sZW5ndGggOyBpKysgKVxuXHRcdHtcblx0XHRcdGZlYXR1cmVOb2RlID0gbnVsbDtcblx0XHRcdGNPcHRpb24gPSBhRG9tW2ldO1xuXHRcblx0XHRcdGlmICggY09wdGlvbiA9PSAnPCcgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBOZXcgY29udGFpbmVyIGRpdiAqL1xuXHRcdFx0XHRuTmV3Tm9kZSA9ICQoJzxkaXYvPicpWzBdO1xuXHRcblx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBhcHBlbmQgYW4gaWQgYW5kL29yIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyICovXG5cdFx0XHRcdGNOZXh0ID0gYURvbVtpKzFdO1xuXHRcdFx0XHRpZiAoIGNOZXh0ID09IFwiJ1wiIHx8IGNOZXh0ID09ICdcIicgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c0F0dHIgPSBcIlwiO1xuXHRcdFx0XHRcdGogPSAyO1xuXHRcdFx0XHRcdHdoaWxlICggYURvbVtpK2pdICE9IGNOZXh0IClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciArPSBhRG9tW2kral07XG5cdFx0XHRcdFx0XHRqKys7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvKiBSZXBsYWNlIGpRdWVyeSBVSSBjb25zdGFudHMgQHRvZG8gZGVwcmVjaWF0ZWQgKi9cblx0XHRcdFx0XHRpZiAoIHNBdHRyID09IFwiSFwiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUhlYWRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyID09IFwiRlwiIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUZvb3Rlcjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8qIFRoZSBhdHRyaWJ1dGUgY2FuIGJlIGluIHRoZSBmb3JtYXQgb2YgXCIjaWQuY2xhc3NcIiwgXCIjaWRcIiBvciBcImNsYXNzXCIgVGhpcyBsb2dpY1xuXHRcdFx0XHRcdCAqIGJyZWFrcyB0aGUgc3RyaW5nIGludG8gcGFydHMgYW5kIGFwcGxpZXMgdGhlbSBhcyBuZWVkZWRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpZiAoIHNBdHRyLmluZGV4T2YoJy4nKSAhPSAtMSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGFTcGxpdCA9IHNBdHRyLnNwbGl0KCcuJyk7XG5cdFx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IGFTcGxpdFswXS5zdWJzdHIoMSwgYVNwbGl0WzBdLmxlbmd0aC0xKTtcblx0XHRcdFx0XHRcdG5OZXdOb2RlLmNsYXNzTmFtZSA9IGFTcGxpdFsxXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyLmNoYXJBdCgwKSA9PSBcIiNcIiApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuaWQgPSBzQXR0ci5zdWJzdHIoMSwgc0F0dHIubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bk5ld05vZGUuY2xhc3NOYW1lID0gc0F0dHI7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpICs9IGo7IC8qIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5ICovXG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGluc2VydC5hcHBlbmQoIG5OZXdOb2RlICk7XG5cdFx0XHRcdGluc2VydCA9ICQobk5ld05vZGUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJz4nIClcblx0XHRcdHtcblx0XHRcdFx0LyogRW5kIGNvbnRhaW5lciBkaXYgKi9cblx0XHRcdFx0aW5zZXJ0ID0gaW5zZXJ0LnBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQHRvZG8gTW92ZSBvcHRpb25zIGludG8gdGhlaXIgb3duIHBsdWdpbnM/XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnbCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlICYmIGZlYXR1cmVzLmJMZW5ndGhDaGFuZ2UgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBMZW5ndGggKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbExlbmd0aCggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnZicgJiYgZmVhdHVyZXMuYkZpbHRlciApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEZpbHRlciAqL1xuXHRcdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sRmlsdGVyKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdyJyAmJiBmZWF0dXJlcy5iUHJvY2Vzc2luZyApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIHBSb2Nlc3NpbmcgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3QnIClcblx0XHRcdHtcblx0XHRcdFx0LyogVGFibGUgKi9cblx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFRhYmxlKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICAnaScgJiYgZmVhdHVyZXMuYkluZm8gKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBJbmZvICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxJbmZvKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdwJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUgKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBQYWdpbmF0aW9uICovXG5cdFx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSggb1NldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIFBsdWctaW4gZmVhdHVyZXMgKi9cblx0XHRcdFx0dmFyIGFvRmVhdHVyZXMgPSBEYXRhVGFibGUuZXh0LmZlYXR1cmU7XG5cdFx0XHRcdGZvciAoIHZhciBrPTAsIGtMZW49YW9GZWF0dXJlcy5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCBjT3B0aW9uID09IGFvRmVhdHVyZXNba10uY0ZlYXR1cmUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZlYXR1cmVOb2RlID0gYW9GZWF0dXJlc1trXS5mbkluaXQoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQWRkIHRvIHRoZSAyRCBmZWF0dXJlcyBhcnJheSAqL1xuXHRcdFx0aWYgKCBmZWF0dXJlTm9kZSApXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBhYW5GZWF0dXJlcyA9IG9TZXR0aW5ncy5hYW5GZWF0dXJlcztcblx0XG5cdFx0XHRcdGlmICggISBhYW5GZWF0dXJlc1tjT3B0aW9uXSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXSA9IFtdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXS5wdXNoKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0XHRpbnNlcnQuYXBwZW5kKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogQnVpbHQgb3VyIERPTSBzdHJ1Y3R1cmUgLSByZXBsYWNlIHRoZSBob2xkaW5nIGRpdiB3aXRoIHdoYXQgd2Ugd2FudCAqL1xuXHRcdGhvbGRpbmcucmVwbGFjZVdpdGgoIGluc2VydCApO1xuXHRcdG9TZXR0aW5ncy5uSG9sZGluZyA9IG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXNlIHRoZSBET00gc291cmNlIHRvIGNyZWF0ZSB1cCBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbHMuIFRoZSBpZGVhIGhlcmUgaXMgdG9cblx0ICogY3JlYXRlIGEgbGF5b3V0IGdyaWQgKGFycmF5KSBvZiByb3dzIHggY29sdW1ucywgd2hpY2ggY29udGFpbnMgYSByZWZlcmVuY2Vcblx0ICogdG8gdGhlIGNlbGwgdGhhdCB0aGF0IHBvaW50IGluIHRoZSBncmlkIChyZWdhcmRsZXNzIG9mIGNvbC9yb3dzcGFuKSwgc3VjaCB0aGF0XG5cdCAqIGFueSBjb2x1bW4gLyByb3cgY291bGQgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBncmlkIGNvbnN0cnVjdGVkXG5cdCAqICBAcGFyYW0gYXJyYXkge29iamVjdH0gYUxheW91dCBBcnJheSB0byBzdG9yZSB0aGUgY2FsY3VsYXRlZCBsYXlvdXQgaW5cblx0ICogIEBwYXJhbSB7bm9kZX0gblRoZWFkIFRoZSBoZWFkZXIvZm9vdGVyIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EZXRlY3RIZWFkZXIgKCBhTGF5b3V0LCBuVGhlYWQgKVxuXHR7XG5cdFx0dmFyIG5UcnMgPSAkKG5UaGVhZCkuY2hpbGRyZW4oJ3RyJyk7XG5cdFx0dmFyIG5UciwgbkNlbGw7XG5cdFx0dmFyIGksIGssIGwsIGlMZW4sIGpMZW4sIGlDb2xTaGlmdGVkLCBpQ29sdW1uLCBpQ29sc3BhbiwgaVJvd3NwYW47XG5cdFx0dmFyIGJVbmlxdWU7XG5cdFx0dmFyIGZuU2hpZnRDb2wgPSBmdW5jdGlvbiAoIGEsIGksIGogKSB7XG5cdFx0XHR2YXIgayA9IGFbaV07XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoIGtbal0gKSB7XG5cdFx0XHRcdGorKztcblx0XHRcdH1cblx0XHRcdHJldHVybiBqO1xuXHRcdH07XG5cdFxuXHRcdGFMYXlvdXQuc3BsaWNlKCAwLCBhTGF5b3V0Lmxlbmd0aCApO1xuXHRcblx0XHQvKiBXZSBrbm93IGhvdyBtYW55IHJvd3MgdGhlcmUgYXJlIGluIHRoZSBsYXlvdXQgLSBzbyBwcmVwIGl0ICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPW5UcnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRhTGF5b3V0LnB1c2goIFtdICk7XG5cdFx0fVxuXHRcblx0XHQvKiBDYWxjdWxhdGUgYSBsYXlvdXQgYXJyYXkgKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49blRycy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdG5UciA9IG5UcnNbaV07XG5cdFx0XHRpQ29sdW1uID0gMDtcblx0XG5cdFx0XHQvKiBGb3IgZXZlcnkgY2VsbCBpbiB0aGUgcm93Li4uICovXG5cdFx0XHRuQ2VsbCA9IG5Uci5maXJzdENoaWxkO1xuXHRcdFx0d2hpbGUgKCBuQ2VsbCApIHtcblx0XHRcdFx0aWYgKCBuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVERcIiB8fFxuXHRcdFx0XHQgICAgIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJUSFwiIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIEdldCB0aGUgY29sIGFuZCByb3dzcGFuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgRE9NIGFuZCBzYW5pdGlzZSB0aGVtICovXG5cdFx0XHRcdFx0aUNvbHNwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XG5cdFx0XHRcdFx0aVJvd3NwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSAqIDE7XG5cdFx0XHRcdFx0aUNvbHNwYW4gPSAoIWlDb2xzcGFuIHx8IGlDb2xzcGFuPT09MCB8fCBpQ29sc3Bhbj09PTEpID8gMSA6IGlDb2xzcGFuO1xuXHRcdFx0XHRcdGlSb3dzcGFuID0gKCFpUm93c3BhbiB8fCBpUm93c3Bhbj09PTAgfHwgaVJvd3NwYW49PT0xKSA/IDEgOiBpUm93c3Bhbjtcblx0XG5cdFx0XHRcdFx0LyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XG5cdFx0XHRcdFx0ICogYWNjb3JkaW5nbHlcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woIGFMYXlvdXQsIGksIGlDb2x1bW4gKTtcblx0XG5cdFx0XHRcdFx0LyogQ2FjaGUgY2FsY3VsYXRpb24gZm9yIHVuaXF1ZSBjb2x1bW5zICovXG5cdFx0XHRcdFx0YlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xuXHRcblx0XHRcdFx0XHQvKiBJZiB0aGVyZSBpcyBjb2wgLyByb3dzcGFuLCBjb3B5IHRoZSBpbmZvcm1hdGlvbiBpbnRvIHRoZSBsYXlvdXQgZ3JpZCAqL1xuXHRcdFx0XHRcdGZvciAoIGw9MCA7IGw8aUNvbHNwYW4gOyBsKysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8aVJvd3NwYW4gOyBrKysgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRhTGF5b3V0W2kra11baUNvbFNoaWZ0ZWQrbF0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0XCJjZWxsXCI6IG5DZWxsLFxuXHRcdFx0XHRcdFx0XHRcdFwidW5pcXVlXCI6IGJVbmlxdWVcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YUxheW91dFtpK2tdLm5UciA9IG5Ucjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bkNlbGwgPSBuQ2VsbC5uZXh0U2libGluZztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogR2V0IGFuIGFycmF5IG9mIHVuaXF1ZSB0aCBlbGVtZW50cywgb25lIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBuSGVhZGVyIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBsYXlvdXQgZnJvbSB0aGlzIG5vZGUgLSBvcHRpb25hbFxuXHQgKiAgQHBhcmFtIHthcnJheX0gYUxheW91dCB0aGVhZC90Zm9vdCBsYXlvdXQgZnJvbSBfZm5EZXRlY3RIZWFkZXIgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMgYXJyYXkge25vZGV9IGFSZXR1cm4gbGlzdCBvZiB1bmlxdWUgdGgnc1xuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRVbmlxdWVUaHMgKCBvU2V0dGluZ3MsIG5IZWFkZXIsIGFMYXlvdXQgKVxuXHR7XG5cdFx0dmFyIGFSZXR1cm4gPSBbXTtcblx0XHRpZiAoICFhTGF5b3V0IClcblx0XHR7XG5cdFx0XHRhTGF5b3V0ID0gb1NldHRpbmdzLmFvSGVhZGVyO1xuXHRcdFx0aWYgKCBuSGVhZGVyIClcblx0XHRcdHtcblx0XHRcdFx0YUxheW91dCA9IFtdO1xuXHRcdFx0XHRfZm5EZXRlY3RIZWFkZXIoIGFMYXlvdXQsIG5IZWFkZXIgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YUxheW91dC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49YUxheW91dFtpXS5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIGFMYXlvdXRbaV1bal0udW5pcXVlICYmXG5cdFx0XHRcdFx0ICghYVJldHVybltqXSB8fCAhb1NldHRpbmdzLmJTb3J0Q2VsbHNUb3ApIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFSZXR1cm5bal0gPSBhTGF5b3V0W2ldW2pdLmNlbGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhUmV0dXJuO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGFuIEFqYXggY2FsbCBiYXNlZCBvbiB0aGUgdGFibGUncyBzZXR0aW5ncywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0XG5cdCAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxuXHQgKiAgICAgRGF0YVRhYmxlcyAtIG1heSBiZSBhdWdtZW50ZWQgYnkgZGV2ZWxvcGVyIGNhbGxiYWNrc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiBkYXRhIGlzIG9idGFpbmVkXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5CdWlsZEFqYXgoIG9TZXR0aW5ncywgZGF0YSwgZm4gKVxuXHR7XG5cdFx0Ly8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0sIGFsbG93IGZuU2VydmVyRGF0YSBhbmQgZXZlbnQgdG8gbWFuaXB1bGF0ZVxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9TZXJ2ZXJQYXJhbXMnLCAnc2VydmVyUGFyYW1zJywgW2RhdGFdICk7XG5cdFxuXHRcdC8vIENvbnZlcnQgdG8gb2JqZWN0IGJhc2VkIGZvciAxLjEwKyBpZiB1c2luZyB0aGUgb2xkIGFycmF5IHNjaGVtZSB3aGljaCBjYW5cblx0XHQvLyBjb21lIGZyb20gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBvciBzZXJ2ZXJQYXJhbXNcblx0XHRpZiAoIGRhdGEgJiYgQXJyYXkuaXNBcnJheShkYXRhKSApIHtcblx0XHRcdHZhciB0bXAgPSB7fTtcblx0XHRcdHZhciByYnJhY2tldCA9IC8oLio/KVxcW1xcXSQvO1xuXHRcblx0XHRcdCQuZWFjaCggZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRcdHZhciBtYXRjaCA9IHZhbC5uYW1lLm1hdGNoKHJicmFja2V0KTtcblx0XG5cdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXlzXG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBtYXRjaFswXTtcblx0XG5cdFx0XHRcdFx0aWYgKCAhIHRtcFsgbmFtZSBdICkge1xuXHRcdFx0XHRcdFx0dG1wWyBuYW1lIF0gPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG1wWyBuYW1lIF0ucHVzaCggdmFsLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dG1wW3ZhbC5uYW1lXSA9IHZhbC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0ZGF0YSA9IHRtcDtcblx0XHR9XG5cdFxuXHRcdHZhciBhamF4RGF0YTtcblx0XHR2YXIgYWpheCA9IG9TZXR0aW5ncy5hamF4O1xuXHRcdHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XG5cdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBqc29uLCBvU2V0dGluZ3MuanFYSFJdICk7XG5cdFx0XHRmbigganNvbiApO1xuXHRcdH07XG5cdFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBhamF4ICkgJiYgYWpheC5kYXRhIClcblx0XHR7XG5cdFx0XHRhamF4RGF0YSA9IGFqYXguZGF0YTtcblx0XG5cdFx0XHR2YXIgbmV3RGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdGFqYXhEYXRhKCBkYXRhLCBvU2V0dGluZ3MgKSA6ICAvLyBmbiBjYW4gbWFuaXB1bGF0ZSBkYXRhIG9yIHJldHVyblxuXHRcdFx0XHRhamF4RGF0YTsgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9iamVjdCBvciBhcnJheSB0byBtZXJnZVxuXHRcblx0XHRcdC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXG5cdFx0XHRkYXRhID0gdHlwZW9mIGFqYXhEYXRhID09PSAnZnVuY3Rpb24nICYmIG5ld0RhdGEgP1xuXHRcdFx0XHRuZXdEYXRhIDpcblx0XHRcdFx0JC5leHRlbmQoIHRydWUsIGRhdGEsIG5ld0RhdGEgKTtcblx0XG5cdFx0XHQvLyBSZW1vdmUgdGhlIGRhdGEgcHJvcGVydHkgYXMgd2UndmUgcmVzb2x2ZWQgaXQgYWxyZWFkeSBhbmQgZG9uJ3Qgd2FudFxuXHRcdFx0Ly8galF1ZXJ5IHRvIGRvIGl0IGFnYWluIChpdCBpcyByZXN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbilcblx0XHRcdGRlbGV0ZSBhamF4LmRhdGE7XG5cdFx0fVxuXHRcblx0XHR2YXIgYmFzZUFqYXggPSB7XG5cdFx0XHRcImRhdGFcIjogZGF0YSxcblx0XHRcdFwic3VjY2Vzc1wiOiBmdW5jdGlvbiAoanNvbikge1xuXHRcdFx0XHR2YXIgZXJyb3IgPSBqc29uLmVycm9yIHx8IGpzb24uc0Vycm9yO1xuXHRcdFx0XHRpZiAoIGVycm9yICkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCBlcnJvciApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRvU2V0dGluZ3MuanNvbiA9IGpzb247XG5cdFx0XHRcdGNhbGxiYWNrKCBqc29uICk7XG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRhVHlwZVwiOiBcImpzb25cIixcblx0XHRcdFwiY2FjaGVcIjogZmFsc2UsXG5cdFx0XHRcInR5cGVcIjogb1NldHRpbmdzLnNTZXJ2ZXJNZXRob2QsXG5cdFx0XHRcImVycm9yXCI6IGZ1bmN0aW9uICh4aHIsIGVycm9yLCB0aHJvd24pIHtcblx0XHRcdFx0dmFyIHJldCA9IF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywgbnVsbCwgb1NldHRpbmdzLmpxWEhSXSApO1xuXHRcblx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIHRydWUsIHJldCApID09PSAtMSApIHtcblx0XHRcdFx0XHRpZiAoIGVycm9yID09IFwicGFyc2VyZXJyb3JcIiApIHtcblx0XHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW52YWxpZCBKU09OIHJlc3BvbnNlJywgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cdFx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0FqYXggZXJyb3InLCA3ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdC8vIFN0b3JlIHRoZSBkYXRhIHN1Ym1pdHRlZCBmb3IgdGhlIEFQSVxuXHRcdG9TZXR0aW5ncy5vQWpheERhdGEgPSBkYXRhO1xuXHRcblx0XHQvLyBBbGxvdyBwbHVnLWlucyBhbmQgZXh0ZXJuYWwgcHJvY2Vzc2VzIHRvIG1vZGlmeSB0aGUgZGF0YVxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAncHJlWGhyJywgW29TZXR0aW5ncywgZGF0YV0gKTtcblx0XG5cdFx0aWYgKCBvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhIClcblx0XHR7XG5cdFx0XHQvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxuXHRcdFx0b1NldHRpbmdzLmZuU2VydmVyRGF0YS5jYWxsKCBpbnN0YW5jZSxcblx0XHRcdFx0b1NldHRpbmdzLnNBamF4U291cmNlLFxuXHRcdFx0XHQkLm1hcCggZGF0YSwgZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIE5lZWQgdG8gY29udmVydCBiYWNrIHRvIDEuOSB0cmFkIGZvcm1hdFxuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGtleSwgdmFsdWU6IHZhbCB9O1xuXHRcdFx0XHR9ICksXG5cdFx0XHRcdGNhbGxiYWNrLFxuXHRcdFx0XHRvU2V0dGluZ3Ncblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvU2V0dGluZ3Muc0FqYXhTb3VyY2UgfHwgdHlwZW9mIGFqYXggPT09ICdzdHJpbmcnIClcblx0XHR7XG5cdFx0XHQvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxuXHRcdFx0b1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCAkLmV4dGVuZCggYmFzZUFqYXgsIHtcblx0XHRcdFx0dXJsOiBhamF4IHx8IG9TZXR0aW5ncy5zQWpheFNvdXJjZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgYWpheCA9PT0gJ2Z1bmN0aW9uJyApXG5cdFx0e1xuXHRcdFx0Ly8gSXMgYSBmdW5jdGlvbiAtIGxldCB0aGUgY2FsbGVyIGRlZmluZSB3aGF0IG5lZWRzIHRvIGJlIGRvbmVcblx0XHRcdG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbCggaW5zdGFuY2UsIGRhdGEsIGNhbGxiYWNrLCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8vIE9iamVjdCB0byBleHRlbmQgdGhlIGJhc2Ugc2V0dGluZ3Ncblx0XHRcdG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCggJC5leHRlbmQoIGJhc2VBamF4LCBhamF4ICkgKTtcblx0XG5cdFx0XHQvLyBSZXN0b3JlIGZvciBuZXh0IHRpbWUgYXJvdW5kXG5cdFx0XHRhamF4LmRhdGEgPSBhamF4RGF0YTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIHRoZSB0YWJsZSB1c2luZyBhbiBBamF4IGNhbGxcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IEJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4VXBkYXRlKCBzZXR0aW5ncyApXG5cdHtcblx0XHRpZiAoIHNldHRpbmdzLmJBamF4RGF0YUdldCApIHtcblx0XHRcdHNldHRpbmdzLmlEcmF3Kys7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblx0XG5cdFx0XHRfZm5CdWlsZEFqYXgoXG5cdFx0XHRcdHNldHRpbmdzLFxuXHRcdFx0XHRfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKSxcblx0XHRcdFx0ZnVuY3Rpb24oanNvbikge1xuXHRcdFx0XHRcdF9mbkFqYXhVcGRhdGVEcmF3KCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQnVpbGQgdXAgdGhlIHBhcmFtZXRlcnMgaW4gYW4gb2JqZWN0IG5lZWRlZCBmb3IgYSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdCAqIHJlcXVlc3QuIE5vdGUgdGhhdCB0aGlzIGlzIGJhc2ljYWxseSBkb25lIHR3aWNlLCBpcyBkaWZmZXJlbnQgd2F5cyAtIGEgbW9kZXJuXG5cdCAqIG1ldGhvZCB3aGljaCBpcyB1c2VkIGJ5IGRlZmF1bHQgaW4gRGF0YVRhYmxlcyAxLjEwIHdoaWNoIHVzZXMgb2JqZWN0cyBhbmRcblx0ICogYXJyYXlzLCBvciB0aGUgMS45LSBtZXRob2Qgd2l0aCBpcyBuYW1lIC8gdmFsdWUgcGFpcnMuIDEuOSBtZXRob2QgaXMgdXNlZCBpZlxuXHQgKiB0aGUgc0FqYXhTb3VyY2Ugb3B0aW9uIGlzIHVzZWQgaW4gdGhlIGluaXRpYWxpc2F0aW9uLCBvciB0aGUgbGVnYWN5QWpheFxuXHQgKiBvcHRpb24gaXMgc2V0LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Jvb2x9IGJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0Y29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcblx0XHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdFx0cHJlU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLFxuXHRcdFx0cHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxuXHRcdFx0aSwgZGF0YSA9IFtdLCBkYXRhUHJvcCwgY29sdW1uLCBjb2x1bW5TZWFyY2gsXG5cdFx0XHRzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICksXG5cdFx0XHRkaXNwbGF5U3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGRpc3BsYXlMZW5ndGggPSBmZWF0dXJlcy5iUGFnaW5hdGUgIT09IGZhbHNlID9cblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdFx0LTE7XG5cdFxuXHRcdHZhciBwYXJhbSA9IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRkYXRhLnB1c2goIHsgJ25hbWUnOiBuYW1lLCAndmFsdWUnOiB2YWx1ZSB9ICk7XG5cdFx0fTtcblx0XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGlibGUgbWV0aG9kXG5cdFx0cGFyYW0oICdzRWNobycsICAgICAgICAgIHNldHRpbmdzLmlEcmF3ICk7XG5cdFx0cGFyYW0oICdpQ29sdW1ucycsICAgICAgIGNvbHVtbkNvdW50ICk7XG5cdFx0cGFyYW0oICdzQ29sdW1ucycsICAgICAgIF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApLmpvaW4oJywnKSApO1xuXHRcdHBhcmFtKCAnaURpc3BsYXlTdGFydCcsICBkaXNwbGF5U3RhcnQgKTtcblx0XHRwYXJhbSggJ2lEaXNwbGF5TGVuZ3RoJywgZGlzcGxheUxlbmd0aCApO1xuXHRcblx0XHQvLyBEYXRhVGFibGVzIDEuMTArIG1ldGhvZFxuXHRcdHZhciBkID0ge1xuXHRcdFx0ZHJhdzogICAgc2V0dGluZ3MuaURyYXcsXG5cdFx0XHRjb2x1bW5zOiBbXSxcblx0XHRcdG9yZGVyOiAgIFtdLFxuXHRcdFx0c3RhcnQ6ICAgZGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuZ3RoOiAgZGlzcGxheUxlbmd0aCxcblx0XHRcdHNlYXJjaDogIHtcblx0XHRcdFx0dmFsdWU6IHByZVNlYXJjaC5zU2VhcmNoLFxuXHRcdFx0XHRyZWdleDogcHJlU2VhcmNoLmJSZWdleFxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGZvciAoIGk9MCA7IGk8Y29sdW1uQ291bnQgOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0Y29sdW1uU2VhcmNoID0gcHJlQ29sU2VhcmNoW2ldO1xuXHRcdFx0ZGF0YVByb3AgPSB0eXBlb2YgY29sdW1uLm1EYXRhPT1cImZ1bmN0aW9uXCIgPyAnZnVuY3Rpb24nIDogY29sdW1uLm1EYXRhIDtcblx0XG5cdFx0XHRkLmNvbHVtbnMucHVzaCgge1xuXHRcdFx0XHRkYXRhOiAgICAgICBkYXRhUHJvcCxcblx0XHRcdFx0bmFtZTogICAgICAgY29sdW1uLnNOYW1lLFxuXHRcdFx0XHRzZWFyY2hhYmxlOiBjb2x1bW4uYlNlYXJjaGFibGUsXG5cdFx0XHRcdG9yZGVyYWJsZTogIGNvbHVtbi5iU29ydGFibGUsXG5cdFx0XHRcdHNlYXJjaDogICAgIHtcblx0XHRcdFx0XHR2YWx1ZTogY29sdW1uU2VhcmNoLnNTZWFyY2gsXG5cdFx0XHRcdFx0cmVnZXg6IGNvbHVtblNlYXJjaC5iUmVnZXhcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHBhcmFtKCBcIm1EYXRhUHJvcF9cIitpLCBkYXRhUHJvcCApO1xuXHRcblx0XHRcdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0cGFyYW0oICdzU2VhcmNoXycraSwgICAgIGNvbHVtblNlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdHBhcmFtKCAnYlJlZ2V4XycraSwgICAgICBjb2x1bW5TZWFyY2guYlJlZ2V4ICk7XG5cdFx0XHRcdHBhcmFtKCAnYlNlYXJjaGFibGVfJytpLCBjb2x1bW4uYlNlYXJjaGFibGUgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdFx0XHRwYXJhbSggJ2JTb3J0YWJsZV8nK2ksIGNvbHVtbi5iU29ydGFibGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdHBhcmFtKCAnc1NlYXJjaCcsIHByZVNlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRwYXJhbSggJ2JSZWdleCcsIHByZVNlYXJjaC5iUmVnZXggKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHQkLmVhY2goIHNvcnQsIGZ1bmN0aW9uICggaSwgdmFsICkge1xuXHRcdFx0XHRkLm9yZGVyLnB1c2goIHsgY29sdW1uOiB2YWwuY29sLCBkaXI6IHZhbC5kaXIgfSApO1xuXHRcblx0XHRcdFx0cGFyYW0oICdpU29ydENvbF8nK2ksIHZhbC5jb2wgKTtcblx0XHRcdFx0cGFyYW0oICdzU29ydERpcl8nK2ksIHZhbC5kaXIgKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRwYXJhbSggJ2lTb3J0aW5nQ29scycsIHNvcnQubGVuZ3RoICk7XG5cdFx0fVxuXHRcblx0XHQvLyBJZiB0aGUgbGVnYWN5LmFqYXggcGFyYW1ldGVyIGlzIG51bGwsIHRoZW4gd2UgYXV0b21hdGljYWxseSBkZWNpZGUgd2hpY2hcblx0XHQvLyBmb3JtIHRvIHVzZSwgYmFzZWQgb24gc0FqYXhTb3VyY2Vcblx0XHR2YXIgbGVnYWN5ID0gRGF0YVRhYmxlLmV4dC5sZWdhY3kuYWpheDtcblx0XHRpZiAoIGxlZ2FjeSA9PT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5zQWpheFNvdXJjZSA/IGRhdGEgOiBkO1xuXHRcdH1cblx0XG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBsZWdhY3kgaGFzIGJlZW4gc3BlY2lmaWVkIHRoZW4gd2UgdXNlIHRoYXQgdG8gZGVjaWRlIG9uIHRoZVxuXHRcdC8vIGZvcm1cblx0XHRyZXR1cm4gbGVnYWN5ID8gZGF0YSA6IGQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24ganNvbiBkYXRhIHJldHVybiBmcm9tIHRoZSBzZXJ2ZXIuXG5cdCAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXG5cdCAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsRGlzcGxheVJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcgKCBzZXR0aW5ncywganNvbiApXG5cdHtcblx0XHQvLyB2MS4xMCB1c2VzIGNhbWVsQ2FzZSB2YXJpYWJsZXMsIHdoaWxlIDEuOSB1c2VzIEh1bmdhcmlhbiBub3RhdGlvbi5cblx0XHQvLyBTdXBwb3J0IGJvdGhcblx0XHR2YXIgY29tcGF0ID0gZnVuY3Rpb24gKCBvbGQsIG1vZGVybiApIHtcblx0XHRcdHJldHVybiBqc29uW29sZF0gIT09IHVuZGVmaW5lZCA/IGpzb25bb2xkXSA6IGpzb25bbW9kZXJuXTtcblx0XHR9O1xuXHRcblx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdHZhciBkcmF3ICAgICAgICAgICAgPSBjb21wYXQoICdzRWNobycsICAgICAgICAgICAgICAgICdkcmF3JyApO1xuXHRcdHZhciByZWNvcmRzVG90YWwgICAgPSBjb21wYXQoICdpVG90YWxSZWNvcmRzJywgICAgICAgICdyZWNvcmRzVG90YWwnICk7XG5cdFx0dmFyIHJlY29yZHNGaWx0ZXJlZCA9IGNvbXBhdCggJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcgKTtcblx0XG5cdFx0aWYgKCBkcmF3ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBQcm90ZWN0IGFnYWluc3Qgb3V0IG9mIHNlcXVlbmNlIHJldHVybnNcblx0XHRcdGlmICggZHJhdyoxIDwgc2V0dGluZ3MuaURyYXcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNldHRpbmdzLmlEcmF3ID0gZHJhdyAqIDE7XG5cdFx0fVxuXHRcblx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdHNldHRpbmdzLl9pUmVjb3Jkc1RvdGFsICAgPSBwYXJzZUludChyZWNvcmRzVG90YWwsIDEwKTtcblx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gcGFyc2VJbnQocmVjb3Jkc0ZpbHRlcmVkLCAxMCk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHR9XG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFxuXHRcdHNldHRpbmdzLmJBamF4RGF0YUdldCA9IGZhbHNlO1xuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFxuXHRcdGlmICggISBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSApIHtcblx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MsIGpzb24gKTtcblx0XHR9XG5cdFxuXHRcdHNldHRpbmdzLmJBamF4RGF0YUdldCA9IHRydWU7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBKU09OIGRhdGEgc291cmNlIHRvIHVzZSBmb3IgZHJhd2luZyBhIHRhYmxlLiBVc2luZ1xuXHQgKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXG5cdCAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxuXHQgKiAgQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGRhdGEgdG8gdXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BamF4RGF0YVNyYyAoIG9TZXR0aW5ncywganNvbiApXG5cdHtcblx0XHR2YXIgZGF0YVNyYyA9ICQuaXNQbGFpbk9iamVjdCggb1NldHRpbmdzLmFqYXggKSAmJiBvU2V0dGluZ3MuYWpheC5kYXRhU3JjICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0b1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XG5cdFx0XHRvU2V0dGluZ3Muc0FqYXhEYXRhUHJvcDsgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0uXG5cdFxuXHRcdC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLiBJbiBvcmRlciB0byByZWFkIGZyb20gYWFEYXRhLCBjaGVjayBpZiB0aGVcblx0XHQvLyBkZWZhdWx0IGhhcyBiZWVuIGNoYW5nZWQsIGlmIG5vdCwgY2hlY2sgZm9yIGFhRGF0YVxuXHRcdGlmICggZGF0YVNyYyA9PT0gJ2RhdGEnICkge1xuXHRcdFx0cmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVNyY107XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gZGF0YVNyYyAhPT0gXCJcIiA/XG5cdFx0XHRfZm5HZXRPYmplY3REYXRhRm4oIGRhdGFTcmMgKSgganNvbiApIDpcblx0XHRcdGpzb247XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZmlsdGVyaW5nIHRleHRcblx0ICogIEByZXR1cm5zIHtub2RlfSBGaWx0ZXIgY29udHJvbCBlbGVtZW50XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sRmlsdGVyICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkO1xuXHRcdHZhciBsYW5ndWFnZSA9IHNldHRpbmdzLm9MYW5ndWFnZTtcblx0XHR2YXIgcHJldmlvdXNTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cdFx0dmFyIGlucHV0ID0gJzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInK2NsYXNzZXMuc0ZpbHRlcklucHV0KydcIi8+Jztcblx0XG5cdFx0dmFyIHN0ciA9IGxhbmd1YWdlLnNTZWFyY2g7XG5cdFx0c3RyID0gc3RyLm1hdGNoKC9fSU5QVVRfLykgP1xuXHRcdFx0c3RyLnJlcGxhY2UoJ19JTlBVVF8nLCBpbnB1dCkgOlxuXHRcdFx0c3RyK2lucHV0O1xuXHRcblx0XHR2YXIgZmlsdGVyID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnaWQnOiAhIGZlYXR1cmVzLmYgPyB0YWJsZUlkKydfZmlsdGVyJyA6IG51bGwsXG5cdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc0ZpbHRlclxuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKCAkKCc8bGFiZWwvPicgKS5hcHBlbmQoIHN0ciApICk7XG5cdFxuXHRcdHZhciBzZWFyY2hGbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogVXBkYXRlIGFsbCBvdGhlciBmaWx0ZXIgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSBuZXcgZGlzcGxheSAqL1xuXHRcdFx0dmFyIG4gPSBmZWF0dXJlcy5mO1xuXHRcdFx0dmFyIHZhbCA9ICF0aGlzLnZhbHVlID8gXCJcIiA6IHRoaXMudmFsdWU7IC8vIG1lbnRhbCBJRTggZml4IDotKFxuXHRcblx0XHRcdC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXG5cdFx0XHRpZiAoIHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICkge1xuXHRcdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHtcblx0XHRcdFx0XHRcInNTZWFyY2hcIjogdmFsLFxuXHRcdFx0XHRcdFwiYlJlZ2V4XCI6IHByZXZpb3VzU2VhcmNoLmJSZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiBwcmV2aW91c1NlYXJjaC5iU21hcnQgLFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBwcmV2aW91c1NlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gcmVkcmF3LCB3aXRob3V0IHJlc29ydGluZ1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0dmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuXHRcdFx0c2V0dGluZ3Muc2VhcmNoRGVsYXkgOlxuXHRcdFx0X2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCcgP1xuXHRcdFx0XHQ0MDAgOlxuXHRcdFx0XHQwO1xuXHRcblx0XHR2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcblx0XHRcdC52YWwoIHByZXZpb3VzU2VhcmNoLnNTZWFyY2ggKVxuXHRcdFx0LmF0dHIoICdwbGFjZWhvbGRlcicsIGxhbmd1YWdlLnNTZWFyY2hQbGFjZWhvbGRlciApXG5cdFx0XHQub24oXG5cdFx0XHRcdCdrZXl1cC5EVCBzZWFyY2guRFQgaW5wdXQuRFQgcGFzdGUuRFQgY3V0LkRUJyxcblx0XHRcdFx0c2VhcmNoRGVsYXkgP1xuXHRcdFx0XHRcdF9mblRocm90dGxlKCBzZWFyY2hGbiwgc2VhcmNoRGVsYXkgKSA6XG5cdFx0XHRcdFx0c2VhcmNoRm5cblx0XHRcdClcblx0XHRcdC5vbiggJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdC8vIEVkZ2UgZml4ISBFZGdlIDE3IGRvZXMgbm90IHRyaWdnZXIgYW55dGhpbmcgb3RoZXIgdGhhbiBtb3VzZSBldmVudHMgd2hlbiBjbGlja2luZ1xuXHRcdFx0XHQvLyBvbiB0aGUgY2xlYXIgaWNvbiAoRWRnZSBidWcgMTc1ODQ1MTUpLiBUaGlzIGlzIHNhZmUgaW4gb3RoZXIgYnJvd3NlcnMgYXMgYHNlYXJjaEZuYFxuXHRcdFx0XHQvLyBjaGVja3MgdGhlIHZhbHVlIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZC4gSW4gb3RoZXIgYnJvd3NlcnMgaXQgd29uJ3QgaGF2ZS5cblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlYXJjaEZuLmNhbGwoanFGaWx0ZXJbMF0pO1xuXHRcdFx0XHR9LCAxMCk7XG5cdFx0XHR9IClcblx0XHRcdC5vbiggJ2tleXByZXNzLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHQvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xuXHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PSAxMyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0LmF0dHIoJ2FyaWEtY29udHJvbHMnLCB0YWJsZUlkKTtcblx0XG5cdFx0Ly8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdzZWFyY2guZHQuRFQnLCBmdW5jdGlvbiAoIGV2LCBzICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0Ly8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXG5cdFx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuLi5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIGpxRmlsdGVyWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0anFGaWx0ZXIudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcblx0XHRyZXR1cm4gZmlsdGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgdXNpbmcgYm90aCB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgY29sdW1uIGJhc2VkIGZpbHRlcmluZ1xuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZWFyY2ggc2VhcmNoIGluZm9ybWF0aW9uXG5cdCAqICBAcGFyYW0ge2ludH0gW2lGb3JjZV0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZSAoIG9TZXR0aW5ncywgb0lucHV0LCBpRm9yY2UgKVxuXHR7XG5cdFx0dmFyIG9QcmV2U2VhcmNoID0gb1NldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcblx0XHR2YXIgYW9QcmV2U2VhcmNoID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0XHR2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKCBvRmlsdGVyICkge1xuXHRcdFx0LyogU2F2ZSB0aGUgZmlsdGVyaW5nIHZhbHVlcyAqL1xuXHRcdFx0b1ByZXZTZWFyY2guc1NlYXJjaCA9IG9GaWx0ZXIuc1NlYXJjaDtcblx0XHRcdG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xuXHRcdFx0b1ByZXZTZWFyY2guYlNtYXJ0ID0gb0ZpbHRlci5iU21hcnQ7XG5cdFx0XHRvUHJldlNlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlID0gb0ZpbHRlci5iQ2FzZUluc2Vuc2l0aXZlO1xuXHRcdH07XG5cdFx0dmFyIGZuUmVnZXggPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBiRXNjYXBlUmVnZXggb3B0aW9uXG5cdFx0XHRyZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuXHRcdH07XG5cdFxuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHQvLyBAdG9kbyBBcyBwZXIgc29ydCAtIGNhbiB0aGlzIGJlIG1vdmVkIGludG8gYW4gZXZlbnQgaGFuZGxlcj9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdC8qIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmUgKi9cblx0XHRpZiAoIF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApICE9ICdzc3AnIClcblx0XHR7XG5cdFx0XHQvKiBHbG9iYWwgZmlsdGVyICovXG5cdFx0XHRfZm5GaWx0ZXIoIG9TZXR0aW5ncywgb0lucHV0LnNTZWFyY2gsIGlGb3JjZSwgZm5SZWdleChvSW5wdXQpLCBvSW5wdXQuYlNtYXJ0LCBvSW5wdXQuYkNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblx0XG5cdFx0XHQvKiBOb3cgZG8gdGhlIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlciAqL1xuXHRcdFx0Zm9yICggdmFyIGk9MCA7IGk8YW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkZpbHRlckNvbHVtbiggb1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxuXHRcdFx0XHRcdGFvUHJldlNlYXJjaFtpXS5iU21hcnQsIGFvUHJldlNlYXJjaFtpXS5iQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogQ3VzdG9tIGZpbHRlcmluZyAqL1xuXHRcdFx0X2ZuRmlsdGVyQ3VzdG9tKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGZuU2F2ZUZpbHRlciggb0lucHV0ICk7XG5cdFx0fVxuXHRcblx0XHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cblx0XHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xuXHRcdHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0XHR2YXIgcm93LCByb3dJZHg7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1maWx0ZXJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIHJvd3MgPSBbXTtcblx0XG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0cm93SWR4ID0gZGlzcGxheVJvd3NbIGogXTtcblx0XHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblx0XG5cdFx0XHRcdGlmICggZmlsdGVyc1tpXSggc2V0dGluZ3MsIHJvdy5fYUZpbHRlckRhdGEsIHJvd0lkeCwgcm93Ll9hRGF0YSwgaiApICkge1xuXHRcdFx0XHRcdHJvd3MucHVzaCggcm93SWR4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0XHQvLyBleGlzdGluZyBhcnJheVxuXHRcdFx0ZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcblx0XHRcdCQubWVyZ2UoIGRpc3BsYXlSb3dzLCByb3dzICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEZpbHRlciB0aGUgdGFibGUgb24gYSBwZXItY29sdW1uIGJhc2lzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc0lucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIGNvbHVtbiB0byBmaWx0ZXJcblx0ICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IHNlYXJjaCBzdHJpbmcgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCB1c2Ugc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyQ29sdW1uICggc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHRpZiAoIHNlYXJjaFN0ciA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YTtcblx0XHR2YXIgb3V0ID0gW107XG5cdFx0dmFyIGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdFx0dmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBzZWFyY2hTdHIsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlICk7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAgOyBpPGRpc3BsYXkubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9hRmlsdGVyRGF0YVsgY29sSWR4IF07XG5cdFxuXHRcdFx0aWYgKCBycFNlYXJjaC50ZXN0KCBkYXRhICkgKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBkaXNwbGF5W2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBvdXQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRmlsdGVyIHRoZSBkYXRhIHRhYmxlIGJhc2VkIG9uIHVzZXIgaW5wdXQgYW5kIGRyYXcgdGhlIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXG5cdCAqICBAcGFyYW0ge2ludH0gZm9yY2Ugb3B0aW9uYWwgLSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXG5cdCAqICBAcGFyYW0ge2Jvb2x9IHJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBzbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gY2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zdGl2ZSBtYXRjaGluZyBvciBub3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmlsdGVyKCBzZXR0aW5ncywgaW5wdXQsIGZvcmNlLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHR2YXIgcnBTZWFyY2ggPSBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApO1xuXHRcdHZhciBwcmV2U2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2g7XG5cdFx0dmFyIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdFx0dmFyIGRpc3BsYXksIGludmFsaWRhdGVkLCBpO1xuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXHRcblx0XHQvLyBOZWVkIHRvIHRha2UgYWNjb3VudCBvZiBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9ucyAtIGFsd2F5cyBmaWx0ZXJcblx0XHRpZiAoIERhdGFUYWJsZS5leHQuc2VhcmNoLmxlbmd0aCAhPT0gMCApIHtcblx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcm93cyB3ZXJlIGludmFsaWRhdGVkXG5cdFx0aW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJZiB0aGUgaW5wdXQgaXMgYmxhbmsgLSB3ZSBqdXN0IHdhbnQgdGhlIGZ1bGwgZGF0YSBzZXRcblx0XHRpZiAoIGlucHV0Lmxlbmd0aCA8PSAwICkge1xuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5ldyBzZWFyY2ggLSBzdGFydCBmcm9tIHRoZSBtYXN0ZXIgYXJyYXlcblx0XHRcdGlmICggaW52YWxpZGF0ZWQgfHxcblx0XHRcdFx0IGZvcmNlIHx8XG5cdFx0XHRcdCByZWdleCB8fFxuXHRcdFx0XHQgcHJldlNlYXJjaC5sZW5ndGggPiBpbnB1dC5sZW5ndGggfHxcblx0XHRcdFx0IGlucHV0LmluZGV4T2YocHJldlNlYXJjaCkgIT09IDAgfHxcblx0XHRcdFx0IHNldHRpbmdzLmJTb3J0ZWQgLy8gT24gcmVzb3J0LCB0aGUgZGlzcGxheSBtYXN0ZXIgbmVlZHMgdG8gYmVcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgLy8gcmUtZmlsdGVyZWQgc2luY2UgaW5kZXhlcyB3aWxsIGhhdmUgY2hhbmdlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWFyY2ggdGhlIGRpc3BsYXkgYXJyYXlcblx0XHRcdGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdFxuXHRcdFx0Zm9yICggaT0wIDsgaTxkaXNwbGF5Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBycFNlYXJjaC50ZXN0KCBzZXR0aW5ncy5hb0RhdGFbIGRpc3BsYXlbaV0gXS5fc0ZpbHRlclJvdyApICkge1xuXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goIGRpc3BsYXlbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IGZpbHRlcmVkO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBCdWlsZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3Qgc3VpdGFibGUgZm9yIHNlYXJjaGluZyBhIHRhYmxlXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1NlYXJjaCBzdHJpbmcgdG8gc2VhcmNoIGZvclxuXHQgKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG5cdCAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIG9yIG5vdFxuXHQgKiAgQHJldHVybnMge1JlZ0V4cH0gY29uc3RydWN0ZWQgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHRzZWFyY2ggPSByZWdleCA/XG5cdFx0XHRzZWFyY2ggOlxuXHRcdFx0X2ZuRXNjYXBlUmVnZXgoIHNlYXJjaCApO1xuXHRcdFxuXHRcdGlmICggc21hcnQgKSB7XG5cdFx0XHQvKiBGb3Igc21hcnQgZmlsdGVyaW5nIHdlIHdhbnQgdG8gYWxsb3cgdGhlIHNlYXJjaCB0byB3b3JrIHJlZ2FyZGxlc3Mgb2Zcblx0XHRcdCAqIHdvcmQgb3JkZXIuIFdlIGFsc28gd2FudCBkb3VibGUgcXVvdGVkIHRleHQgdG8gYmUgcHJlc2VydmVkLCBzbyB3b3JkXG5cdFx0XHQgKiBvcmRlciBpcyBpbXBvcnRhbnQgLSBhIGxhIGdvb2dsZS4gU28gdGhpcyBpcyB3aGF0IHdlIHdhbnQgdG9cblx0XHRcdCAqIGdlbmVyYXRlOlxuXHRcdFx0ICogXG5cdFx0XHQgKiBeKD89Lio/XFxib25lXFxiKSg/PS4qP1xcYnR3byB0aHJlZVxcYikoPz0uKj9cXGJmb3VyXFxiKS4qJFxuXHRcdFx0ICovXG5cdFx0XHR2YXIgYSA9ICQubWFwKCBzZWFyY2gubWF0Y2goIC9cIlteXCJdK1wifFteIF0rL2cgKSB8fCBbJyddLCBmdW5jdGlvbiAoIHdvcmQgKSB7XG5cdFx0XHRcdGlmICggd29yZC5jaGFyQXQoMCkgPT09ICdcIicgKSB7XG5cdFx0XHRcdFx0dmFyIG0gPSB3b3JkLm1hdGNoKCAvXlwiKC4qKVwiJC8gKTtcblx0XHRcdFx0XHR3b3JkID0gbSA/IG1bMV0gOiB3b3JkO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gd29yZC5yZXBsYWNlKCdcIicsICcnKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRzZWFyY2ggPSAnXig/PS4qPycrYS5qb2luKCAnKSg/PS4qPycgKSsnKS4qJCc7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbmV3IFJlZ0V4cCggc2VhcmNoLCBjYXNlSW5zZW5zaXRpdmUgPyAnaScgOiAnJyApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzVmFsIHN0cmluZyB0byBlc2NhcGVcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdHZhciBfZm5Fc2NhcGVSZWdleCA9IERhdGFUYWJsZS51dGlsLmVzY2FwZVJlZ2V4O1xuXHRcblx0dmFyIF9fZmlsdGVyX2RpdiA9ICQoJzxkaXY+JylbMF07XG5cdHZhciBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgPSBfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZDtcblx0XG5cdC8vIFVwZGF0ZSB0aGUgZmlsdGVyaW5nIGRhdGEgZm9yIGVhY2ggcm93IGlmIG5lZWRlZCAoYnkgaW52YWxpZGF0aW9uIG9yIGZpcnN0IHJ1bilcblx0ZnVuY3Rpb24gX2ZuRmlsdGVyRGF0YSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBjb2x1bW47XG5cdFx0dmFyIGksIGosIGllbiwgamVuLCBmaWx0ZXJEYXRhLCBjZWxsRGF0YSwgcm93O1xuXHRcdHZhciBmb21hdHRlcnMgPSBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoO1xuXHRcdHZhciB3YXNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRyb3cgPSBzZXR0aW5ncy5hb0RhdGFbaV07XG5cdFxuXHRcdFx0aWYgKCAhIHJvdy5fYUZpbHRlckRhdGEgKSB7XG5cdFx0XHRcdGZpbHRlckRhdGEgPSBbXTtcblx0XG5cdFx0XHRcdGZvciAoIGo9MCwgamVuPWNvbHVtbnMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0Y29sdW1uID0gY29sdW1uc1tqXTtcblx0XG5cdFx0XHRcdFx0aWYgKCBjb2x1bW4uYlNlYXJjaGFibGUgKSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaSwgaiwgJ2ZpbHRlcicgKTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIGZvbWF0dGVyc1sgY29sdW1uLnNUeXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdGNlbGxEYXRhID0gZm9tYXR0ZXJzWyBjb2x1bW4uc1R5cGUgXSggY2VsbERhdGEgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvLyBTZWFyY2ggaW4gRGF0YVRhYmxlcyAxLjEwIGlzIHN0cmluZyBiYXNlZC4gSW4gMS4xMSB0aGlzXG5cdFx0XHRcdFx0XHQvLyBzaG91bGQgYmUgYWx0ZXJlZCB0byBhbHNvIGFsbG93IHN0cmljdCB0eXBlIGNoZWNraW5nLlxuXHRcdFx0XHRcdFx0aWYgKCBjZWxsRGF0YSA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbERhdGEgPSAnJztcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjZWxsRGF0YSAhPT0gJ3N0cmluZycgJiYgY2VsbERhdGEudG9TdHJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgaXQgbG9va3MgbGlrZSB0aGVyZSBpcyBhbiBIVE1MIGVudGl0eSBpbiB0aGUgc3RyaW5nLFxuXHRcdFx0XHRcdC8vIGF0dGVtcHQgdG8gZGVjb2RlIGl0IHNvIHNvcnRpbmcgd29ya3MgYXMgZXhwZWN0ZWQuIE5vdGUgdGhhdFxuXHRcdFx0XHRcdC8vIHdlIGNvdWxkIHVzZSBhIHNpbmdsZSBsaW5lIG9mIGpRdWVyeSB0byBkbyB0aGlzLCBidXQgdGhlIERPTVxuXHRcdFx0XHRcdC8vIG1ldGhvZCB1c2VkIGhlcmUgaXMgbXVjaCBmYXN0ZXIgaHR0cDovL2pzcGVyZi5jb20vaHRtbC1kZWNvZGVcblx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhLmluZGV4T2YgJiYgY2VsbERhdGEuaW5kZXhPZignJicpICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi5pbm5lckhUTUwgPSBjZWxsRGF0YTtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID9cblx0XHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LnRleHRDb250ZW50IDpcblx0XHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVyVGV4dDtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEucmVwbGFjZSApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEucmVwbGFjZSgvW1xcclxcblxcdTIwMjhdL2csICcnKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdGZpbHRlckRhdGEucHVzaCggY2VsbERhdGEgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cm93Ll9hRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG5cdFx0XHRcdHJvdy5fc0ZpbHRlclJvdyA9IGZpbHRlckRhdGEuam9pbignICAnKTtcblx0XHRcdFx0d2FzSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHdhc0ludmFsaWRhdGVkO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSB0aGUgaW50ZXJuYWwgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsQ2FzZSBmb3IgZXh0ZXJuYWxcblx0ICogaW50ZXJhY3Rpb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGNvbnZlcnRcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IEludmVydGVkIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TZWFyY2hUb0NhbWVsICggb2JqIClcblx0e1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZWFyY2g6ICAgICAgICAgIG9iai5zU2VhcmNoLFxuXHRcdFx0c21hcnQ6ICAgICAgICAgICBvYmouYlNtYXJ0LFxuXHRcdFx0cmVnZXg6ICAgICAgICAgICBvYmouYlJlZ2V4LFxuXHRcdFx0Y2FzZUluc2Vuc2l0aXZlOiBvYmouYkNhc2VJbnNlbnNpdGl2ZVxuXHRcdH07XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnZlcnQgZnJvbSBjYW1lbENhc2Ugbm90YXRpb24gdG8gdGhlIGludGVybmFsIEh1bmdhcmlhbi4gV2UgY291bGQgdXNlIHRoZVxuXHQgKiBIdW5nYXJpYW4gY29udmVydCBmdW5jdGlvbiBoZXJlLCBidXQgdGhpcyBpcyBjbGVhbmVyXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG5cdCAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU2VhcmNoVG9IdW5nICggb2JqIClcblx0e1xuXHRcdHJldHVybiB7XG5cdFx0XHRzU2VhcmNoOiAgICAgICAgICBvYmouc2VhcmNoLFxuXHRcdFx0YlNtYXJ0OiAgICAgICAgICAgb2JqLnNtYXJ0LFxuXHRcdFx0YlJlZ2V4OiAgICAgICAgICAgb2JqLnJlZ2V4LFxuXHRcdFx0YkNhc2VJbnNlbnNpdGl2ZTogb2JqLmNhc2VJbnNlbnNpdGl2ZVxuXHRcdH07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIGluZm8gZGlzcGxheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge25vZGV9IEluZm9ybWF0aW9uIGVsZW1lbnRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxJbmZvICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0aWQgPSBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaSxcblx0XHRcdG4gPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNJbmZvLFxuXHRcdFx0XHQnaWQnOiAhIG5vZGVzID8gdGlkKydfaW5mbycgOiBudWxsXG5cdFx0XHR9ICk7XG5cdFxuXHRcdGlmICggISBub2RlcyApIHtcblx0XHRcdC8vIFVwZGF0ZSBkaXNwbGF5IG9uIGVhY2ggZHJhd1xuXHRcdFx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCgge1xuXHRcdFx0XHRcImZuXCI6IF9mblVwZGF0ZUluZm8sXG5cdFx0XHRcdFwic05hbWVcIjogXCJpbmZvcm1hdGlvblwiXG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0blxuXHRcdFx0XHQuYXR0ciggJ3JvbGUnLCAnc3RhdHVzJyApXG5cdFx0XHRcdC5hdHRyKCAnYXJpYS1saXZlJywgJ3BvbGl0ZScgKTtcblx0XG5cdFx0XHQvLyBUYWJsZSBpcyBkZXNjcmliZWQgYnkgb3VyIGluZm8gZGl2XG5cdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkuYXR0ciggJ2FyaWEtZGVzY3JpYmVkYnknLCB0aWQrJ19pbmZvJyApO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIG5bMF07XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50cyBpbiB0aGUgZGlzcGxheVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblVwZGF0ZUluZm8gKCBzZXR0aW5ncyApXG5cdHtcblx0XHQvKiBTaG93IGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSAqL1xuXHRcdHZhciBub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmk7XG5cdFx0aWYgKCBub2Rlcy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGxhbmcgID0gc2V0dGluZ3Mub0xhbmd1YWdlLFxuXHRcdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCsxLFxuXHRcdFx0ZW5kICAgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcdG1heCAgID0gc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcdHRvdGFsID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0b3V0ICAgPSB0b3RhbCA/XG5cdFx0XHRcdGxhbmcuc0luZm8gOlxuXHRcdFx0XHRsYW5nLnNJbmZvRW1wdHk7XG5cdFxuXHRcdGlmICggdG90YWwgIT09IG1heCApIHtcblx0XHRcdC8qIFJlY29yZCBzZXQgYWZ0ZXIgZmlsdGVyaW5nICovXG5cdFx0XHRvdXQgKz0gJyAnICsgbGFuZy5zSW5mb0ZpbHRlcmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29udmVydCB0aGUgbWFjcm9zXG5cdFx0b3V0ICs9IGxhbmcuc0luZm9Qb3N0Rml4O1xuXHRcdG91dCA9IF9mbkluZm9NYWNyb3MoIHNldHRpbmdzLCBvdXQgKTtcblx0XG5cdFx0dmFyIGNhbGxiYWNrID0gbGFuZy5mbkluZm9DYWxsYmFjaztcblx0XHRpZiAoIGNhbGxiYWNrICE9PSBudWxsICkge1xuXHRcdFx0b3V0ID0gY2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLFxuXHRcdFx0XHRzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgb3V0XG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0JChub2RlcykuaHRtbCggb3V0ICk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5JbmZvTWFjcm9zICggc2V0dGluZ3MsIHN0ciApXG5cdHtcblx0XHQvLyBXaGVuIGluZmluaXRlIHNjcm9sbGluZywgd2UgYXJlIGFsd2F5cyBzdGFydGluZyBhdCAxLiBfaURpc3BsYXlTdGFydCBpcyB1c2VkIG9ubHlcblx0XHQvLyBpbnRlcm5hbGx5XG5cdFx0dmFyXG5cdFx0XHRmb3JtYXR0ZXIgID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIsXG5cdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHR2aXMgICAgICAgID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cdFxuXHRcdHJldHVybiBzdHIuXG5cdFx0XHRyZXBsYWNlKC9fU1RBUlRfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc3RhcnQgKSApLlxuXHRcdFx0cmVwbGFjZSgvX0VORF8vZywgICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpICkgKS5cblx0XHRcdHJlcGxhY2UoL19NQVhfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpICkgKS5cblx0XHRcdHJlcGxhY2UoL19UT1RBTF8vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCB2aXMgKSApLlxuXHRcdFx0cmVwbGFjZSgvX1BBR0VfL2csICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICkgKSApLlxuXHRcdFx0cmVwbGFjZSgvX1BBR0VTXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpcyAvIGxlbiApICkgKTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSW5pdGlhbGlzZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBpLCBpTGVuLCBpQWpheFN0YXJ0PXNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLCBjb2x1bW47XG5cdFx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdHZhciBkZWZlckxvYWRpbmcgPSBzZXR0aW5ncy5iRGVmZXJMb2FkaW5nOyAvLyB2YWx1ZSBtb2RpZmllZCBieSB0aGUgZHJhd1xuXHRcblx0XHQvKiBFbnN1cmUgdGhhdCB0aGUgdGFibGUgZGF0YSBpcyBmdWxseSBpbml0aWFsaXNlZCAqL1xuXHRcdGlmICggISBzZXR0aW5ncy5iSW5pdGlhbGlzZWQgKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpeyBfZm5Jbml0aWFsaXNlKCBzZXR0aW5ncyApOyB9LCAyMDAgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdC8qIFNob3cgdGhlIGRpc3BsYXkgSFRNTCBvcHRpb25zICovXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWwoIHNldHRpbmdzICk7XG5cdFxuXHRcdC8qIEJ1aWxkIGFuZCBkcmF3IHRoZSBoZWFkZXIgLyBmb290ZXIgZm9yIHRoZSB0YWJsZSAqL1xuXHRcdF9mbkJ1aWxkSGVhZCggc2V0dGluZ3MgKTtcblx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3RlciApO1xuXHRcblx0XHQvKiBPa2F5IHRvIHNob3cgdGhhdCBzb21ldGhpbmcgaXMgZ29pbmcgb24gbm93ICovXG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdC8qIENhbGN1bGF0ZSBzaXplcyBmb3IgY29sdW1ucyAqL1xuXHRcdGlmICggZmVhdHVyZXMuYkF1dG9XaWR0aCApIHtcblx0XHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cdFxuXHRcdFx0aWYgKCBjb2x1bW4uc1dpZHRoICkge1xuXHRcdFx0XHRjb2x1bW4ublRoLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvbHVtbi5zV2lkdGggKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcmVJbml0JywgW3NldHRpbmdzXSApO1xuXHRcblx0XHQvLyBJZiB0aGVyZSBpcyBkZWZhdWx0IHNvcnRpbmcgcmVxdWlyZWQgLSBsZXQncyBkbyBpdC4gVGhlIHNvcnQgZnVuY3Rpb25cblx0XHQvLyB3aWxsIGRvIHRoZSBkcmF3aW5nIGZvciB1cy4gT3RoZXJ3aXNlIHdlIGRyYXcgdGhlIHRhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlXG5cdFx0Ly8gQWpheCBzb3VyY2UgLSB0aGlzIGFsbG93cyB0aGUgdGFibGUgdG8gbG9vayBpbml0aWFsaXNlZCBmb3IgQWpheCBzb3VyY2luZ1xuXHRcdC8vIGRhdGEgKHNob3cgJ2xvYWRpbmcnIG1lc3NhZ2UgcG9zc2libHkpXG5cdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGluaXQgY29tcGxldGUgaXMgZG9uZSBieSBfZm5BamF4VXBkYXRlRHJhd1xuXHRcdHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKTtcblx0XHRpZiAoIGRhdGFTcmMgIT0gJ3NzcCcgfHwgZGVmZXJMb2FkaW5nICkge1xuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gYWpheCBzb3VyY2UgbG9hZCB0aGUgZGF0YVxuXHRcdFx0aWYgKCBkYXRhU3JjID09ICdhamF4JyApIHtcblx0XHRcdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywgW10sIGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdFx0XHR2YXIgYURhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XG5cdFx0XHRcdFx0Ly8gR290IHRoZSBkYXRhIC0gYWRkIGl0IHRvIHRoZSB0YWJsZVxuXHRcdFx0XHRcdGZvciAoIGk9MCA7IGk8YURhdGEubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGFEYXRhW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBSZXNldCB0aGUgaW5pdCBkaXNwbGF5IGZvciBjb29raWUgc2F2aW5nLiBXZSd2ZSBhbHJlYWR5IGRvbmVcblx0XHRcdFx0XHQvLyBhIGZpbHRlciwgYW5kIHRoZXJlZm9yZSBjbGVhcmVkIGl0IGJlZm9yZS4gU28gd2UgbmVlZCB0byBtYWtlXG5cdFx0XHRcdFx0Ly8gaXQgYXBwZWFyICdmcmVzaCdcblx0XHRcdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IGlBamF4U3RhcnQ7XG5cdFxuXHRcdFx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0fSwgc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gW2pzb25dIEpTT04gZnJvbSB0aGUgc2VydmVyIHRoYXQgY29tcGxldGVkIHRoZSB0YWJsZSwgaWYgdXNpbmcgQWpheCBzb3VyY2Vcblx0ICogICAgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIChvcHRpb25hbClcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuSW5pdENvbXBsZXRlICggc2V0dGluZ3MsIGpzb24gKVxuXHR7XG5cdFx0c2V0dGluZ3MuX2JJbml0Q29tcGxldGUgPSB0cnVlO1xuXHRcblx0XHQvLyBXaGVuIGRhdGEgd2FzIGFkZGVkIGFmdGVyIHRoZSBpbml0aWFsaXNhdGlvbiAoZGF0YSBvciBBamF4KSB3ZSBuZWVkIHRvXG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6aW5nXG5cdFx0aWYgKCBqc29uIHx8IHNldHRpbmdzLm9Jbml0LmFhRGF0YSApIHtcblx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwbHVnaW4taW5pdCcsIFtzZXR0aW5ncywganNvbl0gKTtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIFtzZXR0aW5ncywganNvbl0gKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIF9mbkxlbmd0aENoYW5nZSAoIHNldHRpbmdzLCB2YWwgKVxuXHR7XG5cdFx0dmFyIGxlbiA9IHBhcnNlSW50KCB2YWwsIDEwICk7XG5cdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoID0gbGVuO1xuXHRcblx0XHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblx0XG5cdFx0Ly8gRmlyZSBsZW5ndGggY2hhbmdlIGV2ZW50XG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2xlbmd0aCcsIFtzZXR0aW5ncywgbGVuXSApO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB1c2VyIGRpc3BsYXkgbGVuZ3RoIGNoYW5naW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBEaXNwbGF5IGxlbmd0aCBmZWF0dXJlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxMZW5ndGggKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGNsYXNzZXMgID0gc2V0dGluZ3Mub0NsYXNzZXMsXG5cdFx0XHR0YWJsZUlkICA9IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0bWVudSAgICAgPSBzZXR0aW5ncy5hTGVuZ3RoTWVudSxcblx0XHRcdGQyICAgICAgID0gQXJyYXkuaXNBcnJheSggbWVudVswXSApLFxuXHRcdFx0bGVuZ3RocyAgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxuXHRcdFx0bGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXHRcblx0XHR2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuXHRcdFx0J25hbWUnOiAgICAgICAgICB0YWJsZUlkKydfbGVuZ3RoJyxcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzogdGFibGVJZCxcblx0XHRcdCdjbGFzcyc6ICAgICAgICAgY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XG5cdFx0fSApO1xuXHRcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGVuZ3Rocy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbihcblx0XHRcdFx0dHlwZW9mIGxhbmd1YWdlW2ldID09PSAnbnVtYmVyJyA/XG5cdFx0XHRcdFx0c2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGxhbmd1YWdlW2ldICkgOlxuXHRcdFx0XHRcdGxhbmd1YWdlW2ldLFxuXHRcdFx0XHRsZW5ndGhzW2ldXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0dmFyIGRpdiA9ICQoJzxkaXY+PGxhYmVsLz48L2Rpdj4nKS5hZGRDbGFzcyggY2xhc3Nlcy5zTGVuZ3RoICk7XG5cdFx0aWYgKCAhIHNldHRpbmdzLmFhbkZlYXR1cmVzLmwgKSB7XG5cdFx0XHRkaXZbMF0uaWQgPSB0YWJsZUlkKydfbGVuZ3RoJztcblx0XHR9XG5cdFxuXHRcdGRpdi5jaGlsZHJlbigpLmFwcGVuZChcblx0XHRcdHNldHRpbmdzLm9MYW5ndWFnZS5zTGVuZ3RoTWVudS5yZXBsYWNlKCAnX01FTlVfJywgc2VsZWN0WzBdLm91dGVySFRNTCApXG5cdFx0KTtcblx0XG5cdFx0Ly8gQ2FuJ3QgdXNlIGBzZWxlY3RgIHZhcmlhYmxlIGFzIHVzZXIgbWlnaHQgcHJvdmlkZSB0aGVpciBvd24gYW5kIHRoZVxuXHRcdC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcblx0XHQkKCdzZWxlY3QnLCBkaXYpXG5cdFx0XHQudmFsKCBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggKVxuXHRcdFx0Lm9uKCAnY2hhbmdlLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpICk7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9ICk7XG5cdFxuXHRcdC8vIFVwZGF0ZSBub2RlIHZhbHVlIHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXMgdGhlIHRhYmxlJ3MgbGVuZ3RoXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnbGVuZ3RoLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIGxlbikge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdFx0JCgnc2VsZWN0JywgZGl2KS52YWwoIGxlbiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGRpdlswXTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBOb3RlIHRoYXQgbW9zdCBvZiB0aGUgcGFnaW5nIGxvZ2ljIGlzIGRvbmUgaW5cblx0ICogRGF0YVRhYmxlLmV4dC5wYWdlclxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZGVmYXVsdCBwYWdpbmF0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gUGFnaW5hdGlvbiBmZWF0dXJlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0dHlwZSAgID0gc2V0dGluZ3Muc1BhZ2luYXRpb25UeXBlLFxuXHRcdFx0cGx1Z2luID0gRGF0YVRhYmxlLmV4dC5wYWdlclsgdHlwZSBdLFxuXHRcdFx0bW9kZXJuID0gdHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdHJlZHJhdyA9IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH0sXG5cdFx0XHRub2RlID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoIHNldHRpbmdzLm9DbGFzc2VzLnNQYWdpbmcgKyB0eXBlIClbMF0sXG5cdFx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xuXHRcblx0XHRpZiAoICEgbW9kZXJuICkge1xuXHRcdFx0cGx1Z2luLmZuSW5pdCggc2V0dGluZ3MsIG5vZGUsIHJlZHJhdyApO1xuXHRcdH1cblx0XG5cdFx0LyogQWRkIGEgZHJhdyBjYWxsYmFjayBmb3IgdGhlIHBhZ2luYXRpb24gb24gZmlyc3QgaW5zdGFuY2UsIHRvIHVwZGF0ZSB0aGUgcGFnaW5nIGRpc3BsYXkgKi9cblx0XHRpZiAoICEgZmVhdHVyZXMucCApXG5cdFx0e1xuXHRcdFx0bm9kZS5pZCA9IHNldHRpbmdzLnNUYWJsZUlkKydfcGFnaW5hdGUnO1xuXHRcblx0XHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFx0XCJmblwiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdFx0aWYgKCBtb2Rlcm4gKSB7XG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdFx0XHRcdFx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMSxcblx0XHRcdFx0XHRcdFx0cGFnZSA9IGFsbCA/IDAgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICksXG5cdFx0XHRcdFx0XHRcdHBhZ2VzID0gYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFx0XHRcdFx0XHRidXR0b25zID0gcGx1Z2luKHBhZ2UsIHBhZ2VzKSxcblx0XHRcdFx0XHRcdFx0aSwgaWVuO1xuXHRcblx0XHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWZlYXR1cmVzLnAubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRcdF9mblJlbmRlcmVyKCBzZXR0aW5ncywgJ3BhZ2VCdXR0b24nICkoXG5cdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3MsIGZlYXR1cmVzLnBbaV0sIGksIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cGx1Z2luLmZuVXBkYXRlKCBzZXR0aW5ncywgcmVkcmF3ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInNOYW1lXCI6IFwicGFnaW5hdGlvblwiXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBhY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIixcblx0ICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcblx0ICogIEBwYXJhbSBbYm9vbF0gcmVkcmF3IEF1dG9tYXRpY2FsbHkgZHJhdyB0aGUgdXBkYXRlIG9yIG5vdFxuXHQgKiAgQHJldHVybnMge2Jvb2x9IHRydWUgcGFnZSBoYXMgY2hhbmdlZCwgZmFsc2UgLSBubyBjaGFuZ2Vcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuUGFnZUNoYW5nZSAoIHNldHRpbmdzLCBhY3Rpb24sIHJlZHJhdyApXG5cdHtcblx0XHR2YXJcblx0XHRcdHN0YXJ0ICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdFx0bGVuICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0cmVjb3JkcyAgID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpO1xuXHRcblx0XHRpZiAoIHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGFjdGlvbiA9PT0gXCJudW1iZXJcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBhY3Rpb24gKiBsZW47XG5cdFxuXHRcdFx0aWYgKCBzdGFydCA+IHJlY29yZHMgKVxuXHRcdFx0e1xuXHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJmaXJzdFwiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJwcmV2aW91c1wiIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IGxlbiA+PSAwID9cblx0XHRcdFx0c3RhcnQgLSBsZW4gOlxuXHRcdFx0XHQwO1xuXHRcblx0XHRcdGlmICggc3RhcnQgPCAwIClcblx0XHRcdHtcblx0XHRcdCAgc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggYWN0aW9uID09IFwibmV4dFwiIClcblx0XHR7XG5cdFx0XHRpZiAoIHN0YXJ0ICsgbGVuIDwgcmVjb3JkcyApXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0ICs9IGxlbjtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImxhc3RcIiApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSBNYXRoLmZsb29yKCAocmVjb3Jkcy0xKSAvIGxlbikgKiBsZW47XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBcIlVua25vd24gcGFnaW5nIGFjdGlvbjogXCIrYWN0aW9uLCA1ICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgY2hhbmdlZCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICE9PSBzdGFydDtcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXHRcblx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGFnZScsIFtzZXR0aW5nc10gKTtcblx0XG5cdFx0XHRpZiAoIHJlZHJhdyApIHtcblx0XHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gUHJvY2Vzc2luZyBlbGVtZW50XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdpZCc6ICEgc2V0dGluZ3MuYWFuRmVhdHVyZXMuciA/IHNldHRpbmdzLnNUYWJsZUlkKydfcHJvY2Vzc2luZycgOiBudWxsLFxuXHRcdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zUHJvY2Vzc2luZ1xuXHRcdFx0fSApXG5cdFx0XHQuaHRtbCggc2V0dGluZ3Mub0xhbmd1YWdlLnNQcm9jZXNzaW5nIClcblx0XHRcdC5pbnNlcnRCZWZvcmUoIHNldHRpbmdzLm5UYWJsZSApWzBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3Jcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheSAoIHNldHRpbmdzLCBzaG93IClcblx0e1xuXHRcdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nICkge1xuXHRcdFx0JChzZXR0aW5ncy5hYW5GZWF0dXJlcy5yKS5jc3MoICdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScgKTtcblx0XHR9XG5cdFxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcm9jZXNzaW5nJywgW3NldHRpbmdzLCBzaG93XSApO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSk7XG5cdFxuXHRcdC8vIEFkZCB0aGUgQVJJQSBncmlkIHJvbGUgdG8gdGhlIHRhYmxlXG5cdFx0dGFibGUuYXR0ciggJ3JvbGUnLCAnZ3JpZCcgKTtcblx0XG5cdFx0Ly8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxuXHRcdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXHRcblx0XHRpZiAoIHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2Nyb2xsWCA9IHNjcm9sbC5zWDtcblx0XHR2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcblx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciBjYXB0aW9uID0gdGFibGUuY2hpbGRyZW4oJ2NhcHRpb24nKTtcblx0XHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcblx0XHR2YXIgaGVhZGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdFx0dmFyIGZvb3RlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHRcdHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcblx0XHR2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xuXHRcdHZhciBzaXplID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdFx0cmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKCBzICk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAhIGZvb3Rlci5sZW5ndGggKSB7XG5cdFx0XHRmb290ZXIgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiBUaGUgSFRNTCBzdHJ1Y3R1cmUgdGhhdCB3ZSB3YW50IHRvIGdlbmVyYXRlIGluIHRoaXMgZnVuY3Rpb24gaXM6XG5cdFx0ICogIGRpdiAtIHNjcm9sbGVyXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcblx0XHQgKiAgICAgIGRpdiAtIHNjcm9sbCBoZWFkIGlubmVyXG5cdFx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcblx0XHQgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG5cdFx0ICogICAgZGl2IC0gc2Nyb2xsIGJvZHlcblx0XHQgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcblx0XHQgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG5cdFx0ICogICAgICAgIHRib2R5IC0gdGJvZHlcblx0XHQgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxuXHRcdCAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcblx0XHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgZm9vdCB0YWJsZVxuXHRcdCAqICAgICAgICAgIHRmb290IC0gdGZvb3Rcblx0XHQgKi9cblx0XHR2YXIgc2Nyb2xsZXIgPSAkKCBfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbFdyYXBwZXIgfSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZCB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdFx0J2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGwuc1hJbm5lciB8fCAnMTAwJSdcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0aGVhZGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQuY3NzKCAnbWFyZ2luLWxlZnQnLCAwIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsQm9keSB9IClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSggc2Nyb2xsWCApXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZCggdGFibGUgKVxuXHRcdFx0KTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRzY3JvbGxlci5hcHBlbmQoXG5cdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290IH0gKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdElubmVyIH0gKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdGZvb3RlckNsb25lXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKCBjYXB0aW9uU2lkZSA9PT0gJ2JvdHRvbScgPyBjYXB0aW9uIDogbnVsbCApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cdFxuXHRcdHZhciBjaGlsZHJlbiA9IHNjcm9sbGVyLmNoaWxkcmVuKCk7XG5cdFx0dmFyIHNjcm9sbEhlYWQgPSBjaGlsZHJlblswXTtcblx0XHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHRcdHZhciBzY3JvbGxGb290ID0gZm9vdGVyID8gY2hpbGRyZW5bMl0gOiBudWxsO1xuXHRcblx0XHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0XHRpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLm9uKCAnc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cdFxuXHRcdFx0XHRzY3JvbGxIZWFkLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcblx0XHRcdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsRm9vdC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0JChzY3JvbGxCb2R5KS5jc3MoJ21heC1oZWlnaHQnLCBzY3JvbGxZKTtcblx0XHRpZiAoISBzY3JvbGwuYkNvbGxhcHNlKSB7XG5cdFx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdFx0c2V0dGluZ3MublNjcm9sbEJvZHkgPSBzY3JvbGxCb2R5O1xuXHRcdHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblx0XG5cdFx0Ly8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xuXHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFwiZm5cIjogX2ZuU2Nyb2xsRHJhdyxcblx0XHRcdFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIHNjcm9sbGVyWzBdO1xuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxuXHQgKiBhbGlnbm1lbnQuXG5cdCAqXG5cdCAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXG5cdCAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuXHQgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG5cdCAqICAgMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET01cblx0ICogICAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzIHRvIGFsaWduIHRoZSBjb2x1bW5zXG5cdCAqICAgNC4gQ2xlYW4gdXBcblx0ICpcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuXHRcdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0XHR2YXJcblx0XHRcdHNjcm9sbCAgICAgICAgID0gc2V0dGluZ3Mub1Njcm9sbCxcblx0XHRcdHNjcm9sbFggICAgICAgID0gc2Nyb2xsLnNYLFxuXHRcdFx0c2Nyb2xsWElubmVyICAgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdHNjcm9sbFkgICAgICAgID0gc2Nyb2xsLnNZLFxuXHRcdFx0YmFyV2lkdGggICAgICAgPSBzY3JvbGwuaUJhcldpZHRoLFxuXHRcdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRcdGRpdkhlYWRlclN0eWxlID0gZGl2SGVhZGVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXIgPSBkaXZIZWFkZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdFx0ZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxuXHRcdFx0ZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0XHRkaXZCb2R5ICAgICAgICA9ICQoZGl2Qm9keUVsKSxcblx0XHRcdGRpdkJvZHlTdHlsZSAgID0gZGl2Qm9keUVsLnN0eWxlLFxuXHRcdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRcdGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRcdGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHRcdHRhYmxlICAgICAgICAgID0gJChzZXR0aW5ncy5uVGFibGUpLFxuXHRcdFx0dGFibGVFbCAgICAgICAgPSB0YWJsZVswXSxcblx0XHRcdHRhYmxlU3R5bGUgICAgID0gdGFibGVFbC5zdHlsZSxcblx0XHRcdGZvb3RlciAgICAgICAgID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcblx0XHRcdGJyb3dzZXIgICAgICAgID0gc2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ICAgICAgICAgICA9IGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplLFxuXHRcdFx0ZHRIZWFkZXJDZWxscyAgPSBfcGx1Y2soIHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcgKSxcblx0XHRcdGhlYWRlclRyZ0VscywgZm9vdGVyVHJnRWxzLFxuXHRcdFx0aGVhZGVyU3JjRWxzLCBmb290ZXJTcmNFbHMsXG5cdFx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5LFxuXHRcdFx0aGVhZGVyV2lkdGhzPVtdLCBmb290ZXJXaWR0aHM9W10sXG5cdFx0XHRoZWFkZXJDb250ZW50PVtdLCBmb290ZXJDb250ZW50PVtdLFxuXHRcdFx0aWR4LCBjb3JyZWN0aW9uLCBzYW5pdHlXaWR0aCxcblx0XHRcdHplcm9PdXQgPSBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gblNpemVyLnN0eWxlO1xuXHRcdFx0XHRzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyVG9wV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gMDtcblx0XHRcdH07XG5cdFxuXHRcdC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cblx0XHQvLyBhZGp1c3QgdGhlIGNvbHVtbiBzaXplcyBhcyB0aGUgdGFibGUgd2lkdGggd2lsbCBoYXZlIGNoYW5nZWQgdG8gYWNjb3VudFxuXHRcdC8vIGZvciB0aGUgc2Nyb2xsYmFyXG5cdFx0dmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xuXHRcdFxuXHRcdGlmICggc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSBzY3JvbGxCYXJWaXMgJiYgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0XHRyZXR1cm47IC8vIGFkanVzdCBjb2x1bW4gc2l6aW5nIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHRcdH1cblx0XG5cdFx0Lypcblx0XHQgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHRcdCAqL1xuXHRcblx0XHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHRcdHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRmb290ZXJDb3B5ID0gZm9vdGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRcdFx0Zm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXG5cdFx0XHRmb290ZXJTcmNFbHMgPSBmb290ZXJDb3B5LmZpbmQoJ3RyJyk7XG5cdFx0fVxuXHRcblx0XHQvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxuXHRcdGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0aGVhZGVyVHJnRWxzID0gaGVhZGVyLmZpbmQoJ3RyJyk7IC8vIG9yaWdpbmFsIGhlYWRlciBpcyBpbiBpdHMgb3duIHRhYmxlXG5cdFx0aGVhZGVyU3JjRWxzID0gaGVhZGVyQ29weS5maW5kKCd0cicpO1xuXHRcdGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXG5cdFx0ICovXG5cdFxuXHRcdC8vIFJlbW92ZSBvbGQgc2l6aW5nIGFuZCBhcHBseSB0aGUgY2FsY3VsYXRlZCBjb2x1bW4gd2lkdGhzXG5cdFx0Ly8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxuXHRcdC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcblx0XHRpZiAoICEgc2Nyb2xsWCApXG5cdFx0e1xuXHRcdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdFx0ZGl2SGVhZGVyWzBdLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XG5cdFx0JC5lYWNoKCBfZm5HZXRVbmlxdWVUaHMoIHNldHRpbmdzLCBoZWFkZXJDb3B5ICksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0XHRpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGkgKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF0uc1dpZHRoO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0bi5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0XHR9XG5cdFxuXHRcdC8vIFNpemUgdGhlIHRhYmxlIGFzIGEgd2hvbGVcblx0XHRzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgKSB7XG5cdFx0XHQvLyBObyB4IHNjcm9sbGluZ1xuXHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXHRcblx0XHRcdC8vIElFNyB3aWxsIG1ha2UgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSB3aGVuIDEwMCUgaW5jbHVkZSB0aGUgc2Nyb2xsYmFyXG5cdFx0XHQvLyAtIHdoaWNoIGlzIHNob3VsZG4ndC4gV2hlbiB0aGVyZSBpcyBhIHNjcm9sbGJhciB3ZSBuZWVkIHRvIHRha2UgdGhpc1xuXHRcdFx0Ly8gaW50byBhY2NvdW50LlxuXHRcdFx0aWYgKCBpZTY3ICYmICh0YWJsZS5maW5kKCd0Ym9keScpLmhlaWdodCgpID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpXG5cdFx0XHQpIHtcblx0XHRcdFx0dGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZS5vdXRlcldpZHRoKCkgLSBiYXJXaWR0aCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuXHRcdFx0c2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzY3JvbGxYSW5uZXIgIT09IFwiXCIgKSB7XG5cdFx0XHQvLyBsZWdhY3kgeCBzY3JvbGwgaW5uZXIgaGFzIGJlZW4gZ2l2ZW4gLSB1c2UgaXRcblx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzY3JvbGxYSW5uZXIpO1xuXHRcblx0XHRcdC8vIFJlY2FsY3VsYXRlIHRoZSBzYW5pdHkgd2lkdGhcblx0XHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRcdH1cblx0XG5cdFx0Ly8gSGlkZGVuIGhlYWRlciBzaG91bGQgaGF2ZSB6ZXJvIGhlaWdodCwgc28gcmVtb3ZlIHBhZGRpbmcgYW5kIGJvcmRlcnMuIFRoZW5cblx0XHQvLyBzZXQgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSByZWFsIGhlYWRlcnNcblx0XG5cdFx0Ly8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggemVyb091dCwgaGVhZGVyU3JjRWxzICk7XG5cdFxuXHRcdC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5TaXplcikge1xuXHRcdFx0aGVhZGVyQ29udGVudC5wdXNoKCBuU2l6ZXIuaW5uZXJIVE1MICk7XG5cdFx0XHRoZWFkZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHQvLyBBcHBseSBhbGwgd2lkdGhzIGluIGZpbmFsIHBhc3Ncblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5Ub1NpemUsIGkpIHtcblx0XHRcdC8vIE9ubHkgYXBwbHkgd2lkdGhzIHRvIHRoZSBEYXRhVGFibGVzIGRldGVjdGVkIGhlYWRlciBjZWxscyAtIHRoaXNcblx0XHRcdC8vIHByZXZlbnRzIGNvbXBsZXggaGVhZGVycyBmcm9tIGhhdmluZyBjb250cmFkaWN0b3J5IHNpemVzIGFwcGxpZWRcblx0XHRcdGlmICggJC5pbkFycmF5KCBuVG9TaXplLCBkdEhlYWRlckNlbGxzICkgIT09IC0xICkge1xuXHRcdFx0XHRuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdFx0fVxuXHRcdH0sIGhlYWRlclRyZ0VscyApO1xuXHRcblx0XHQkKGhlYWRlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcblx0XHQvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xuXHRcdGlmICggZm9vdGVyIClcblx0XHR7XG5cdFx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGZvb3RlclNyY0VscyApO1xuXHRcblx0XHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHRcdGZvb3RlckNvbnRlbnQucHVzaCggblNpemVyLmlubmVySFRNTCApO1xuXHRcdFx0XHRmb290ZXJXaWR0aHMucHVzaCggX2ZuU3RyaW5nVG9Dc3MoICQoblNpemVyKS5jc3MoJ3dpZHRoJykgKSApO1xuXHRcdFx0fSwgZm9vdGVyU3JjRWxzICk7XG5cdFxuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuVG9TaXplLCBpKSB7XG5cdFx0XHRcdG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XG5cdFx0XHR9LCBmb290ZXJUcmdFbHMgKTtcblx0XG5cdFx0XHQkKGZvb3RlclNyY0VscykuaGVpZ2h0KDApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogMy4gQXBwbHkgdGhlIG1lYXN1cmVtZW50c1xuXHRcdCAqL1xuXHRcblx0XHQvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcblx0XHQvLyB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBzbyB0aGF0IHRoZSB3aWR0aCBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgYW5kIGJvZHlcblx0XHQvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcblx0XHQvLyB3aWR0aCB0byB3aGF0IHRoZXkgY3VycmVudGx5IGFyZVxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblNpemVyLCBpKSB7XG5cdFx0XHRuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicraGVhZGVyQ29udGVudFtpXSsnPC9kaXY+Jztcblx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0blNpemVyLmNoaWxkTm9kZXNbMF0uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHRcdH0sIGhlYWRlclNyY0VscyApO1xuXHRcblx0XHRpZiAoIGZvb3RlciApXG5cdFx0e1xuXHRcdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRcdFx0blNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIj4nK2Zvb3RlckNvbnRlbnRbaV0rJzwvZGl2Pic7XG5cdFx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuXHRcdFx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHRcdH0sIGZvb3RlclNyY0VscyApO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcblx0XHQvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcblx0XHRpZiAoIHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoIClcblx0XHR7XG5cdFx0XHQvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG5cdFx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0XHRkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XG5cdFx0XHRcdFx0c2FuaXR5V2lkdGgrYmFyV2lkdGggOlxuXHRcdFx0XHRcdHNhbml0eVdpZHRoO1xuXHRcblx0XHRcdC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cblx0XHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRcdGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0XHRpZiAoIHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvcnJlY3Rpb24gPSAnMTAwJSc7XG5cdFx0fVxuXHRcblx0XHQvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXG5cdFx0ZGl2Qm9keVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGNvcnJlY3Rpb24gKTtcblx0XHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRcdH1cblx0XG5cdFxuXHRcdC8qXG5cdFx0ICogNC4gQ2xlYW4gdXBcblx0XHQgKi9cblx0XHRpZiAoICEgc2Nyb2xsWSApIHtcblx0XHRcdC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuXHRcdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHRcdCAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXG5cdFx0XHQgKi9cblx0XHRcdGlmICggaWU2NyApIHtcblx0XHRcdFx0ZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZUVsLm9mZnNldEhlaWdodCtiYXJXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogRmluYWxseSBzZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlcyAqL1xuXHRcdHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0XHRkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XG5cdFx0Ly8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cblx0XHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdFx0dmFyIGJTY3JvbGxpbmcgPSB0YWJsZS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHRcdHZhciBwYWRkaW5nID0gJ3BhZGRpbmcnICsgKGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPyAnTGVmdCcgOiAnUmlnaHQnICk7XG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZVsgcGFkZGluZyBdID0gYlNjcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCI7XG5cdFxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0ZGl2Rm9vdGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0XHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0XHRkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuXHRcdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLmluc2VydEJlZm9yZSggdGFibGUuY2hpbGRyZW4oJ3RoZWFkJykgKTtcblx0XG5cdFx0LyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXG5cdFx0ZGl2Qm9keS50cmlnZ2VyKCdzY3JvbGwnKTtcblx0XG5cdFx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdFx0Ly8gb25seSBpZiB3ZSBhcmVuJ3QgaG9sZGluZyB0aGUgcG9zaXRpb25cblx0XHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XG5cdCAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3Ncblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xuXHQgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXG5cdCAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oIGZuLCBhbjEsIGFuMiApXG5cdHtcblx0XHR2YXIgaW5kZXg9MCwgaT0wLCBpTGVuPWFuMS5sZW5ndGg7XG5cdFx0dmFyIG5Ob2RlMSwgbk5vZGUyO1xuXHRcblx0XHR3aGlsZSAoIGkgPCBpTGVuICkge1xuXHRcdFx0bk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XG5cdFx0XHRuTm9kZTIgPSBhbjIgPyBhbjJbaV0uZmlyc3RDaGlsZCA6IG51bGw7XG5cdFxuXHRcdFx0d2hpbGUgKCBuTm9kZTEgKSB7XG5cdFx0XHRcdGlmICggbk5vZGUxLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGlmICggYW4yICkge1xuXHRcdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgbk5vZGUyLCBpbmRleCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGZuKCBuTm9kZTEsIGluZGV4ICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XG5cdFx0XHRcdG5Ob2RlMiA9IGFuMiA/IG5Ob2RlMi5uZXh0U2libGluZyA6IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHR2YXIgX19yZV9odG1sX3JlbW92ZSA9IC88Lio/Pi9nO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHR0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG5cdFx0XHRjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdHNjcm9sbCA9IG9TZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRcdHNjcm9sbFggPSBzY3JvbGwuc1gsXG5cdFx0XHRzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0XHR2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApLFxuXHRcdFx0aGVhZGVyQ2VsbHMgPSAkKCd0aCcsIG9TZXR0aW5ncy5uVEhlYWQpLFxuXHRcdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRcdHVzZXJJbnB1dHMgPSBmYWxzZSxcblx0XHRcdGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aCxcblx0XHRcdGJyb3dzZXIgPSBvU2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0XHRpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemU7XG5cdFxuXHRcdHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG5cdFx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHRcdHRhYmxlV2lkdGhBdHRyID0gc3R5bGVXaWR0aDtcblx0XHR9XG5cdFxuXHRcdC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuXHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0Y29sdW1uID0gY29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXTtcblx0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGNvbHVtbi5zV2lkdGggPSBfZm5Db252ZXJ0VG9XaWR0aCggY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyICk7XG5cdFxuXHRcdFx0XHR1c2VySW5wdXRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdC8qIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgRE9NIGVxdWFscyB0aGUgbnVtYmVyIHRoYXQgd2UgaGF2ZSB0b1xuXHRcdCAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcblx0XHQgKiB0aGUgd2ViLSBicm93c2VyLiBObyBjdXN0b20gc2l6ZXMgY2FuIGJlIHNldCBpbiBvcmRlciBmb3IgdGhpcyB0byBoYXBwZW4sXG5cdFx0ICogbm9yIHNjcm9sbGluZyB1c2VkXG5cdFx0ICovXG5cdFx0aWYgKCBpZTY3IHx8ICEgdXNlcklucHV0cyAmJiAhIHNjcm9sbFggJiYgISBzY3JvbGxZICYmXG5cdFx0ICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKCBvU2V0dGluZ3MgKSAmJlxuXHRcdCAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG5cdFx0KSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdFx0XHR2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaSApO1xuXHRcblx0XHRcdFx0aWYgKCBjb2xJZHggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1sgY29sSWR4IF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdFx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdFx0XHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHRcdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0XHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG5cdFx0XHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXHRcblx0XHRcdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdFx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdFx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXHRcblx0XHRcdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0XHQvLyBmcm9tIHRoZSBjbG9uZWQgdGFibGUsIHNpbmNlIGlmIHNjcm9sbGluZyBpcyBhY3RpdmUsIHRoZSB0YWJsZSdzXG5cdFx0XHQvLyByZWFsIGhlYWRlciBhbmQgZm9vdGVyIGFyZSBjb250YWluZWQgaW4gZGlmZmVyZW50IHRhYmxlIHRhZ3Ncblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcdFx0dG1wVGFibGVcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpIClcblx0XHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0XHRcdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cdFxuXHRcdFx0Ly8gQXBwbHkgY3VzdG9tIHNpemluZyB0byB0aGUgY2xvbmVkIGhlYWRlclxuXHRcdFx0aGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncywgdG1wVGFibGUuZmluZCgndGhlYWQnKVswXSApO1xuXHRcblx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXHRcblx0XHRcdFx0aGVhZGVyQ2VsbHNbaV0uc3R5bGUud2lkdGggPSBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gbnVsbCAmJiBjb2x1bW4uc1dpZHRoT3JpZyAhPT0gJycgP1xuXHRcdFx0XHRcdF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoT3JpZyApIDpcblx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdC8vIEZvciBzY3JvbGxYIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNvbHVtbiB3aWR0aCBvdGhlcndpc2UgdGhlXG5cdFx0XHRcdC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFggKSB7XG5cdFx0XHRcdFx0JCggaGVhZGVyQ2VsbHNbaV0gKS5hcHBlbmQoICQoJzxkaXYvPicpLmNzcygge1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNvbHVtbi5zV2lkdGhPcmlnLFxuXHRcdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdFx0cGFkZGluZzogMCxcblx0XHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHRcdH0gKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcblx0XHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXHRcblx0XHRcdFx0XHQkKCBfZm5HZXRXaWRlc3ROb2RlKCBvU2V0dGluZ3MsIGNvbHVtbklkeCApIClcblx0XHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggY29sdW1uLnNDb250ZW50UGFkZGluZyApXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHRcdFx0Ly8gZHVwbGljYXRlZCBpbiB0aGUgZG9tIChyYWRpbyBlbGVtZW50cyBmb3IgZXhhbXBsZSlcblx0XHRcdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cdFxuXHRcdFx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0XHRcdC8vIEEgaG9sZGluZyBlbGVtZW50IGlzIHVzZWQsIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG5cdFx0XHQvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuXHRcdFx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHRcdFx0Ly8gbmVlZGVkXG5cdFx0XHR2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKCBzY3JvbGxYIHx8IHNjcm9sbFkgP1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0e31cblx0XHRcdFx0KVxuXHRcdFx0XHQuYXBwZW5kKCB0bXBUYWJsZSApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyAoWCBvciBZKSB3ZSB3YW50IHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIHRhYmxlIGFzIFxuXHRcdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHRcdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRcdFx0aWYgKCBzY3JvbGxYICYmIHNjcm9sbFhJbm5lciApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNjcm9sbFggKSB7XG5cdFx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0XHRcdHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cdFxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0XHRcdC8vIGNvbGxhcHNlXG5cdFx0XHRcdGlmICggdG1wVGFibGUud2lkdGgoKSA8IHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICYmIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHRcdFx0dG1wVGFibGUud2lkdGgoIHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlIC0gd2UgbmVlZCB0b1xuXHRcdFx0Ly8ga25vdyB0aGUgaW5uZXIgd2lkdGggKHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgb3RoZXIgdGFibGUnc1xuXHRcdFx0Ly8gY2VsbHMpIGFuZCB0aGUgb3V0ZXIgd2lkdGggc28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgZnVsbCB3aWR0aCBvZiB0aGVcblx0XHRcdC8vIHRhYmxlLiBUaGlzIGlzIHNhZmUgc2luY2UgRGF0YVRhYmxlcyByZXF1aXJlcyBhIHVuaXF1ZSBjZWxsIGZvciBlYWNoXG5cdFx0XHQvLyBjb2x1bW4sIGJ1dCBpZiBldmVyIGEgaGVhZGVyIGNhbiBzcGFuIG11bHRpcGxlIGNvbHVtbnMsIHRoaXMgd2lsbFxuXHRcdFx0Ly8gbmVlZCB0byBiZSBtb2RpZmllZC5cblx0XHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0dmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcblx0XHRcdFx0dmFyIGJvcmRlciA9IGNlbGwub3V0ZXJXaWR0aCgpIC0gY2VsbC53aWR0aCgpO1xuXHRcblx0XHRcdFx0Ly8gVXNlIGdldEJvdW5kaW5nLi4uIHdoZXJlIHBvc3NpYmxlIChub3QgSUU4LSkgYmVjYXVzZSBpdCBjYW4gZ2l2ZVxuXHRcdFx0XHQvLyBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcblx0XHRcdFx0dmFyIGJvdW5kaW5nID0gYnJvd3Nlci5iQm91bmRpbmcgP1xuXHRcdFx0XHRcdE1hdGguY2VpbCggaGVhZGVyQ2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA6XG5cdFx0XHRcdFx0Y2VsbC5vdXRlcldpZHRoKCk7XG5cdFxuXHRcdFx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdFx0XHQvLyBvZiB0aGUgdGFibGUgbWlnaHQgbm90IGVxdWFsIHRoZSB0b3RhbCBnaXZlbiBoZXJlIChJRSEpLlxuXHRcdFx0XHR0b3RhbCArPSBib3VuZGluZztcblx0XG5cdFx0XHRcdC8vIFdpZHRoIGZvciBlYWNoIGNvbHVtbiB0byB1c2Vcblx0XHRcdFx0Y29sdW1uc1sgdmlzaWJsZUNvbHVtbnNbaV0gXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyggYm91bmRpbmcgLSBib3JkZXIgKTtcblx0XHRcdH1cblx0XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXHRcblx0XHRcdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0XHRcdGhvbGRlci5yZW1vdmUoKTtcblx0XHR9XG5cdFxuXHRcdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0XHQvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcblx0XHQvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxuXHRcdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRcdGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZVdpZHRoQXR0ciApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgISBvU2V0dGluZ3MuX3Jlc3pFdnQgKSB7XG5cdFx0XHR2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytvU2V0dGluZ3Muc0luc3RhbmNlLCBfZm5UaHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fTtcblx0XG5cdFx0XHQvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXG5cdFx0XHQvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuXHRcdFx0aWYgKCBpZTY3ICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBiaW5kUmVzaXplLCAxMDAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YmluZFJlc2l6ZSgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWQgZm9yXG5cdCAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiAgQHBhcmFtIHtpbnR9IFtmcmVxPTIwMF0gY2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHR2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblx0XG5cdFxuXHQvKipcblx0ICogQ29udmVydCBhIENTUyB1bml0IHdpZHRoIHRvIHBpeGVscyAoZS5nLiAyZW0pXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gd2lkdGggd2lkdGggdG8gYmUgY29udmVydGVkXG5cdCAqICBAcGFyYW0ge25vZGV9IHBhcmVudCBwYXJlbnQgdG8gZ2V0IHRoZSB3aXRoIGZvciAocmVxdWlyZWQgZm9yIHJlbGF0aXZlIHdpZHRocykgLSBvcHRpb25hbFxuXHQgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkNvbnZlcnRUb1dpZHRoICggd2lkdGgsIHBhcmVudCApXG5cdHtcblx0XHRpZiAoICEgd2lkdGggKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFxuXHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoICd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCB3aWR0aCApIClcblx0XHRcdC5hcHBlbmRUbyggcGFyZW50IHx8IGRvY3VtZW50LmJvZHkgKTtcblx0XG5cdFx0dmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XG5cdFx0bi5yZW1vdmUoKTtcblx0XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZGVzdCBub2RlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG5cdCAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdHtcblx0XHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdFx0aWYgKCBpZHggPCAwICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgaWR4IF07XG5cdFx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHRcdCQoJzx0ZC8+JykuaHRtbCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknICkgKVswXSA6XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbElkeCBdO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3Rcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoIHNldHRpbmdzLCBjb2xJZHggKVxuXHR7XG5cdFx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdFx0cyA9IHMucmVwbGFjZSggX19yZV9odG1sX3JlbW92ZSwgJycgKTtcblx0XHRcdHMgPSBzLnJlcGxhY2UoIC8mbmJzcDsvZywgJyAnICk7XG5cdFxuXHRcdFx0aWYgKCBzLmxlbmd0aCA+IG1heCApIHtcblx0XHRcdFx0bWF4ID0gcy5sZW5ndGg7XG5cdFx0XHRcdG1heElkeCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbWF4SWR4O1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlIHdpdGggY3NzIHVuaXRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU3RyaW5nVG9Dc3MoIHMgKVxuXHR7XG5cdFx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuICcwcHgnO1xuXHRcdH1cblx0XG5cdFx0aWYgKCB0eXBlb2YgcyA9PSAnbnVtYmVyJyApIHtcblx0XHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHRcdCcwcHgnIDpcblx0XHRcdFx0cysncHgnO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2hlY2sgaXQgaGFzIGEgdW5pdCBjaGFyYWN0ZXIgYWxyZWFkeVxuXHRcdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdFx0cysncHgnIDpcblx0XHRcdHM7XG5cdH1cblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEZsYXR0ZW4gKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGksIGlMZW4sIGssIGtMZW4sXG5cdFx0XHRhU29ydCA9IFtdLFxuXHRcdFx0YWlPcmlnID0gW10sXG5cdFx0XHRhb0NvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG5cdFx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdFx0Zml4ZWRPYmogPSAkLmlzUGxhaW5PYmplY3QoIGZpeGVkICksXG5cdFx0XHRuZXN0ZWRTb3J0ID0gW10sXG5cdFx0XHRhZGQgPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRcdGlmICggYS5sZW5ndGggJiYgISBBcnJheS5pc0FycmF5KCBhWzBdICkgKSB7XG5cdFx0XHRcdFx0Ly8gMUQgYXJyYXlcblx0XHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2goIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyAyRCBhcnJheVxuXHRcdFx0XHRcdCQubWVyZ2UoIG5lc3RlZFNvcnQsIGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0Ly8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxuXHRcdC8vIHNwZWNpZmllZFxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggZml4ZWQgKSApIHtcblx0XHRcdGFkZCggZml4ZWQgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZml4ZWRPYmogJiYgZml4ZWQucHJlICkge1xuXHRcdFx0YWRkKCBmaXhlZC5wcmUgKTtcblx0XHR9XG5cdFxuXHRcdGFkZCggc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cdFxuXHRcdGlmIChmaXhlZE9iaiAmJiBmaXhlZC5wb3N0ICkge1xuXHRcdFx0YWRkKCBmaXhlZC5wb3N0ICk7XG5cdFx0fVxuXHRcblx0XHRmb3IgKCBpPTAgOyBpPG5lc3RlZFNvcnQubGVuZ3RoIDsgaSsrIClcblx0XHR7XG5cdFx0XHRzcmNDb2wgPSBuZXN0ZWRTb3J0W2ldWzBdO1xuXHRcdFx0YURhdGFTb3J0ID0gYW9Db2x1bW5zWyBzcmNDb2wgXS5hRGF0YVNvcnQ7XG5cdFxuXHRcdFx0Zm9yICggaz0wLCBrTGVuPWFEYXRhU29ydC5sZW5ndGggOyBrPGtMZW4gOyBrKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpQ29sID0gYURhdGFTb3J0W2tdO1xuXHRcdFx0XHRzVHlwZSA9IGFvQ29sdW1uc1sgaUNvbCBdLnNUeXBlIHx8ICdzdHJpbmcnO1xuXHRcblx0XHRcdFx0aWYgKCBuZXN0ZWRTb3J0W2ldLl9pZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRuZXN0ZWRTb3J0W2ldLl9pZHggPSAkLmluQXJyYXkoIG5lc3RlZFNvcnRbaV1bMV0sIGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcgKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YVNvcnQucHVzaCgge1xuXHRcdFx0XHRcdHNyYzogICAgICAgc3JjQ29sLFxuXHRcdFx0XHRcdGNvbDogICAgICAgaUNvbCxcblx0XHRcdFx0XHRkaXI6ICAgICAgIG5lc3RlZFNvcnRbaV1bMV0sXG5cdFx0XHRcdFx0aW5kZXg6ICAgICBuZXN0ZWRTb3J0W2ldLl9pZHgsXG5cdFx0XHRcdFx0dHlwZTogICAgICBzVHlwZSxcblx0XHRcdFx0XHRmb3JtYXR0ZXI6IERhdGFUYWJsZS5leHQudHlwZS5vcmRlclsgc1R5cGUrXCItcHJlXCIgXVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gYVNvcnQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSB0YWJsZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqICBAdG9kbyBUaGlzIHJlYWxseSBuZWVkcyBzcGxpdCB1cCFcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnQgKCBvU2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyXG5cdFx0XHRpLCBpZW4sIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sXG5cdFx0XHRzRGF0YVR5cGUsIG5UaCxcblx0XHRcdGFpT3JpZyA9IFtdLFxuXHRcdFx0b0V4dFNvcnQgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsXG5cdFx0XHRhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhLFxuXHRcdFx0YW9Db2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRcdGFEYXRhU29ydCwgZGF0YSwgaUNvbCwgc1R5cGUsIG9Tb3J0LFxuXHRcdFx0Zm9ybWF0dGVycyA9IDAsXG5cdFx0XHRzb3J0Q29sLFxuXHRcdFx0ZGlzcGxheU1hc3RlciA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsXG5cdFx0XHRhU29ydDtcblx0XG5cdFx0Ly8gUmVzb2x2ZSBhbnkgY29sdW1uIHR5cGVzIHRoYXQgYXJlIHVua25vd24gZHVlIHRvIGFkZGl0aW9uIG9yIGludmFsaWRhdGlvblxuXHRcdC8vIEB0b2RvIENhbiB0aGlzIGJlIG1vdmVkIGludG8gYSAnZGF0YS1yZWFkeScgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlblxuXHRcdC8vICAgZGF0YSBpcyBnb2luZyB0byBiZSB1c2VkIGluIHRoZSB0YWJsZT9cblx0XHRfZm5Db2x1bW5UeXBlcyggb1NldHRpbmdzICk7XG5cdFxuXHRcdGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1hU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHNvcnRDb2wgPSBhU29ydFtpXTtcblx0XG5cdFx0XHQvLyBUcmFjayBpZiB3ZSBjYW4gdXNlIHRoZSBmYXN0IHNvcnQgYWxnb3JpdGhtXG5cdFx0XHRpZiAoIHNvcnRDb2wuZm9ybWF0dGVyICkge1xuXHRcdFx0XHRmb3JtYXR0ZXJzKys7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTG9hZCB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBzb3J0LCBmb3IgZWFjaCBjZWxsXG5cdFx0XHRfZm5Tb3J0RGF0YSggb1NldHRpbmdzLCBzb3J0Q29sLmNvbCApO1xuXHRcdH1cblx0XG5cdFx0LyogTm8gc29ydGluZyByZXF1aXJlZCBpZiBzZXJ2ZXItc2lkZSBvciBubyBzb3J0aW5nIGFycmF5ICovXG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDAgKVxuXHRcdHtcblx0XHRcdC8vIENyZWF0ZSBhIHZhbHVlIC0ga2V5IGFycmF5IG9mIHRoZSBjdXJyZW50IHJvdyBwb3NpdGlvbnMgc3VjaCB0aGF0IHdlIGNhbiB1c2UgdGhlaXJcblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gZHVyaW5nIHRoZSBzb3J0LCBpZiB2YWx1ZXMgbWF0Y2gsIGluIG9yZGVyIHRvIHBlcmZvcm0gc3RhYmxlIHNvcnRpbmdcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1kaXNwbGF5TWFzdGVyLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0YWlPcmlnWyBkaXNwbGF5TWFzdGVyW2ldIF0gPSBpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8qIERvIHRoZSBzb3J0IC0gaGVyZSB3ZSB3YW50IG11bHRpLWNvbHVtbiBzb3J0aW5nIGJhc2VkIG9uIGEgZ2l2ZW4gZGF0YSBzb3VyY2UgKGNvbHVtbilcblx0XHRcdCAqIGFuZCBzb3J0aW5nIGZ1bmN0aW9uIChmcm9tIG9Tb3J0KSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBJdCdzIHJlYXNvbmFibHkgY29tcGxleCB0b1xuXHRcdFx0ICogZm9sbG93IG9uIGl0J3Mgb3duLCBidXQgdGhpcyBpcyB3aGF0IHdlIHdhbnQgKGV4YW1wbGUgdHdvIGNvbHVtbiBzb3J0aW5nKTpcblx0XHRcdCAqICBmbkxvY2FsU29ydGluZyA9IGZ1bmN0aW9uKGEsYil7XG5cdFx0XHQgKiAgICB2YXIgaVRlc3Q7XG5cdFx0XHQgKiAgICBpVGVzdCA9IG9Tb3J0WydzdHJpbmctYXNjJ10oJ2RhdGExMScsICdkYXRhMTInKTtcblx0XHRcdCAqICAgICAgaWYgKGlUZXN0ICE9PSAwKVxuXHRcdFx0ICogICAgICAgIHJldHVybiBpVGVzdDtcblx0XHRcdCAqICAgIGlUZXN0ID0gb1NvcnRbJ251bWVyaWMtZGVzYyddKCdkYXRhMjEnLCAnZGF0YTIyJyk7XG5cdFx0XHQgKiAgICBpZiAoaVRlc3QgIT09IDApXG5cdFx0XHQgKiAgICAgIHJldHVybiBpVGVzdDtcblx0XHRcdCAqICAgIHJldHVybiBvU29ydFsnbnVtZXJpYy1hc2MnXSggYWlPcmlnW2FdLCBhaU9yaWdbYl0gKTtcblx0XHRcdCAqICB9XG5cdFx0XHQgKiBCYXNpY2FsbHkgd2UgaGF2ZSBhIHRlc3QgZm9yIGVhY2ggc29ydGluZyBjb2x1bW4sIGlmIHRoZSBkYXRhIGluIHRoYXQgY29sdW1uIGlzIGVxdWFsLFxuXHRcdFx0ICogdGVzdCB0aGUgbmV4dCBjb2x1bW4uIElmIGFsbCBjb2x1bW5zIG1hdGNoLCB0aGVuIHdlIHVzZSBhIG51bWVyaWMgc29ydCBvbiB0aGUgcm93XG5cdFx0XHQgKiBwb3NpdGlvbnMgaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgdG8gcHJvdmlkZSBhIHN0YWJsZSBzb3J0LlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgLSBJIGtub3cgaXQgc2VlbXMgZXhjZXNzaXZlIHRvIGhhdmUgdHdvIHNvcnRpbmcgbWV0aG9kcywgYnV0IHRoZSBmaXJzdCBpcyBhcm91bmRcblx0XHRcdCAqIDE1JSBmYXN0ZXIsIHNvIHRoZSBzZWNvbmQgaXMgb25seSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNvcnRpbmdcblx0XHRcdCAqIG1ldGhvZHMgd2hpY2ggZG8gbm90IGhhdmUgYSBwcmUtc29ydCBmb3JtYXR0aW5nIGZ1bmN0aW9uLlxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIGZvcm1hdHRlcnMgPT09IGFTb3J0Lmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gQWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uc1xuXHRcdFx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdHgsIHksIGssIHRlc3QsIHNvcnQsXG5cdFx0XHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cdFxuXHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXHRcblx0XHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblx0XG5cdFx0XHRcdFx0XHR0ZXN0ID0geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvcnQuZGlyID09PSAnYXNjJyA/IHRlc3QgOiAtdGVzdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIERlcHJlY2lhdGVkIC0gcmVtb3ZlIGluIDEuMTEgKHByb3ZpZGluZyBhIHBsdWctaW4gb3B0aW9uKVxuXHRcdFx0XHQvLyBOb3QgYWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIG1ldGhvZHMsIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGVpciBzb3J0aW5nXG5cdFx0XHRcdC8vIG1ldGhvZHMuXG5cdFx0XHRcdGRpc3BsYXlNYXN0ZXIuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0eCwgeSwgaywgbCwgdGVzdCwgc29ydCwgZm4sXG5cdFx0XHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cdFxuXHRcdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXHRcblx0XHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblx0XG5cdFx0XHRcdFx0XHRmbiA9IG9FeHRTb3J0WyBzb3J0LnR5cGUrXCItXCIrc29ydC5kaXIgXSB8fCBvRXh0U29ydFsgXCJzdHJpbmctXCIrc29ydC5kaXIgXTtcblx0XHRcdFx0XHRcdHRlc3QgPSBmbiggeCwgeSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0ZXN0ICE9PSAwICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHggPSBhaU9yaWdbYV07XG5cdFx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0LyogVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB0aGF0IHdlIGhhdmUgc29ydGVkIHRoZSBkYXRhICovXG5cdFx0b1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuU29ydEFyaWEgKCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgbGFiZWw7XG5cdFx0dmFyIG5leHRTb3J0O1xuXHRcdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHRcdHZhciBvQXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYTtcblx0XG5cdFx0Ly8gQVJJQSBhdHRyaWJ1dGVzIC0gbmVlZCB0byBsb29wIGFsbCBjb2x1bW5zLCB0byB1cGRhdGUgYWxsIChyZW1vdmluZyBvbGRcblx0XHQvLyBhdHRyaWJ1dGVzIGFzIG5lZWRlZClcblx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgY29sID0gY29sdW1uc1tpXTtcblx0XHRcdHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuXHRcdFx0dmFyIHNUaXRsZSA9IGNvbC5zVGl0bGUucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdHZhciB0aCA9IGNvbC5uVGg7XG5cdFxuXHRcdFx0Ly8gSUU3IGlzIHRocm93aW5nIGFuIGVycm9yIHdoZW4gc2V0dGluZyB0aGVzZSBwcm9wZXJ0aWVzIHdpdGggalF1ZXJ5J3Ncblx0XHRcdC8vIGF0dHIoKSBhbmQgcmVtb3ZlQXR0cigpIG1ldGhvZHMuLi5cblx0XHRcdHRoLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1zb3J0Jyk7XG5cdFxuXHRcdFx0LyogSW4gQVJJQSBvbmx5IHRoZSBmaXJzdCBzb3J0aW5nIGNvbHVtbiBjYW4gYmUgbWFya2VkIGFzIHNvcnRpbmcgLSBubyBtdWx0aS1zb3J0IG9wdGlvbiAqL1xuXHRcdFx0aWYgKCBjb2wuYlNvcnRhYmxlICkge1xuXHRcdFx0XHRpZiAoIGFTb3J0Lmxlbmd0aCA+IDAgJiYgYVNvcnRbMF0uY29sID09IGkgKSB7XG5cdFx0XHRcdFx0dGguc2V0QXR0cmlidXRlKCdhcmlhLXNvcnQnLCBhU29ydFswXS5kaXI9PVwiYXNjXCIgPyBcImFzY2VuZGluZ1wiIDogXCJkZXNjZW5kaW5nXCIgKTtcblx0XHRcdFx0XHRuZXh0U29ydCA9IGFzU29ydGluZ1sgYVNvcnRbMF0uaW5kZXgrMSBdIHx8IGFzU29ydGluZ1swXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRuZXh0U29ydCA9IGFzU29ydGluZ1swXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0bGFiZWwgPSBzVGl0bGUgKyAoIG5leHRTb3J0ID09PSBcImFzY1wiID9cblx0XHRcdFx0XHRvQXJpYS5zU29ydEFzY2VuZGluZyA6XG5cdFx0XHRcdFx0b0FyaWEuc1NvcnREZXNjZW5kaW5nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGFiZWwgPSBzVGl0bGU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dGguc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBydW4gb24gdXNlciBzb3J0IHJlcXVlc3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYXBwZW5kPWZhbHNlXSBBcHBlbmQgdGhlIHJlcXVlc3RlZCBzb3J0IHRvIHRoZSBleGlzdGluZ1xuXHQgKiAgICBzb3J0IGlmIHRydWUgKGkuZS4gbXVsdGktY29sdW1uIHNvcnQpXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNvcnRMaXN0ZW5lciAoIHNldHRpbmdzLCBjb2xJZHgsIGFwcGVuZCwgY2FsbGJhY2sgKVxuXHR7XG5cdFx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdFx0dmFyIHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0dmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XG5cdFx0dmFyIG5leHRTb3J0SWR4O1xuXHRcdHZhciBuZXh0ID0gZnVuY3Rpb24gKCBhLCBvdmVyZmxvdyApIHtcblx0XHRcdHZhciBpZHggPSBhLl9pZHg7XG5cdFx0XHRpZiAoIGlkeCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpZHggPSAkLmluQXJyYXkoIGFbMV0sIGFzU29ydGluZyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBpZHgrMSA8IGFzU29ydGluZy5sZW5ndGggP1xuXHRcdFx0XHRpZHgrMSA6XG5cdFx0XHRcdG92ZXJmbG93ID9cblx0XHRcdFx0XHRudWxsIDpcblx0XHRcdFx0XHQwO1xuXHRcdH07XG5cdFxuXHRcdC8vIENvbnZlcnQgdG8gMkQgYXJyYXkgaWYgbmVlZGVkXG5cdFx0aWYgKCB0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nID0gWyBzb3J0aW5nIF07XG5cdFx0fVxuXHRcblx0XHQvLyBJZiBhcHBlbmRpbmcgdGhlIHNvcnQgdGhlbiB3ZSBhcmUgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHRpZiAoIGFwcGVuZCAmJiBzZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnRNdWx0aSApIHtcblx0XHRcdC8vIEFyZSB3ZSBhbHJlYWR5IGRvaW5nIHNvbWUga2luZCBvZiBzb3J0IG9uIHRoaXMgY29sdW1uP1xuXHRcdFx0dmFyIHNvcnRJZHggPSAkLmluQXJyYXkoIGNvbElkeCwgX3BsdWNrKHNvcnRpbmcsICcwJykgKTtcblx0XG5cdFx0XHRpZiAoIHNvcnRJZHggIT09IC0xICkge1xuXHRcdFx0XHQvLyBZZXMsIG1vZGlmeSB0aGUgc29ydFxuXHRcdFx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbc29ydElkeF0sIHRydWUgKTtcblx0XG5cdFx0XHRcdGlmICggbmV4dFNvcnRJZHggPT09IG51bGwgJiYgc29ydGluZy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0bmV4dFNvcnRJZHggPSAwOyAvLyBjYW4ndCByZW1vdmUgc29ydGluZyBjb21wbGV0ZWx5XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmICggbmV4dFNvcnRJZHggPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0c29ydGluZy5zcGxpY2UoIHNvcnRJZHgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdFx0XHRcdHNvcnRpbmdbc29ydElkeF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gTm8gc29ydCBvbiB0aGlzIGNvbHVtbiB5ZXRcblx0XHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdLCAwIF0gKTtcblx0XHRcdFx0c29ydGluZ1tzb3J0aW5nLmxlbmd0aC0xXS5faWR4ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNvcnRpbmcubGVuZ3RoICYmIHNvcnRpbmdbMF1bMF0gPT0gY29sSWR4ICkge1xuXHRcdFx0Ly8gU2luZ2xlIGNvbHVtbiAtIGFscmVhZHkgc29ydGluZyBvbiB0aGlzIGNvbHVtbiwgbW9kaWZ5IHRoZSBzb3J0XG5cdFx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbMF0gKTtcblx0XG5cdFx0XHRzb3J0aW5nLmxlbmd0aCA9IDE7XG5cdFx0XHRzb3J0aW5nWzBdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdFx0c29ydGluZ1swXS5faWR4ID0gbmV4dFNvcnRJZHg7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gU2luZ2xlIGNvbHVtbiAtIHNvcnQgb25seSBvbiB0aGlzIGNvbHVtblxuXHRcdFx0c29ydGluZy5sZW5ndGggPSAwO1xuXHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdIF0gKTtcblx0XHRcdHNvcnRpbmdbMF0uX2lkeCA9IDA7XG5cdFx0fVxuXHRcblx0XHQvLyBSdW4gdGhlIHNvcnQgYnkgY2FsbGluZyBhIGZ1bGwgcmVkcmF3XG5cdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBjYWxsYmFjayB1c2VkIGZvciBhc3luYyB1c2VyIGludGVyYWN0aW9uXG5cdFx0aWYgKCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGNhbGxiYWNrKCBzZXR0aW5ncyApO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRhY2ggYSBzb3J0IGhhbmRsZXIgKGNsaWNrKSB0byBhIG5vZGVcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuXHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIgKCBzZXR0aW5ncywgYXR0YWNoVG8sIGNvbElkeCwgY2FsbGJhY2sgKVxuXHR7XG5cdFx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdFxuXHRcdF9mbkJpbmRBY3Rpb24oIGF0dGFjaFRvLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdC8qIElmIHRoZSBjb2x1bW4gaXMgbm90IHNvcnRhYmxlIC0gZG9uJ3QgdG8gYW55dGhpbmcgKi9cblx0XHRcdGlmICggY29sLmJTb3J0YWJsZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBJZiBwcm9jZXNzaW5nIGlzIGVuYWJsZWQgdXNlIGEgdGltZW91dCB0byBhbGxvdyB0aGUgcHJvY2Vzc2luZ1xuXHRcdFx0Ly8gZGlzcGxheSB0byBiZSBzaG93biAtIG90aGVyd2lzZSB0byBpdCBzeW5jaHJvbm91c2x5XG5cdFx0XHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZyApIHtcblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfZm5Tb3J0TGlzdGVuZXIoIHNldHRpbmdzLCBjb2xJZHgsIGUuc2hpZnRLZXksIGNhbGxiYWNrICk7XG5cdFxuXHRcdFx0XHRcdC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIHRoZSBkcmF3IGNhbGxiYWNrIHdpbGwgcmVtb3ZlIHRoZVxuXHRcdFx0XHRcdC8vIHByb2Nlc3NpbmcgZGlzcGxheVxuXHRcdFx0XHRcdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSAhPT0gJ3NzcCcgKSB7XG5cdFx0XHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0X2ZuU29ydExpc3RlbmVyKCBzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIHNvcnRpbmcgY2xhc3NlcyBvbiB0YWJsZSdzIGJvZHksIE5vdGU6IGl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXG5cdCAqIHdoZW4gYlNvcnQgYW5kIGJTb3J0Q2xhc3NlcyBhcmUgZmFsc2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBvbGRTb3J0ID0gc2V0dGluZ3MuYUxhc3RTb3J0O1xuXHRcdHZhciBzb3J0Q2xhc3MgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5zU29ydENvbHVtbjtcblx0XHR2YXIgc29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHRcdHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcblx0XHR2YXIgaSwgaWVuLCBjb2xJZHg7XG5cdFxuXHRcdGlmICggZmVhdHVyZXMuYlNvcnQgJiYgZmVhdHVyZXMuYlNvcnRDbGFzc2VzICkge1xuXHRcdFx0Ly8gUmVtb3ZlIG9sZCBzb3J0aW5nIGNsYXNzZXNcblx0XHRcdGZvciAoIGk9MCwgaWVuPW9sZFNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGNvbElkeCA9IG9sZFNvcnRbaV0uc3JjO1xuXHRcblx0XHRcdFx0Ly8gUmVtb3ZlIGNvbHVtbiBzb3J0aW5nXG5cdFx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIEFkZCBuZXcgY29sdW1uIHNvcnRpbmdcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGNvbElkeCA9IHNvcnRbaV0uc3JjO1xuXHRcblx0XHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggc29ydENsYXNzICsgKGk8MiA/IGkrMSA6IDMpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5hTGFzdFNvcnQgPSBzb3J0O1xuXHR9XG5cdFxuXHRcblx0Ly8gR2V0IHRoZSBkYXRhIHRvIHNvcnQgYSBjb2x1bW4sIGJlIGl0IGZyb20gY2FjaGUsIGZyZXNoIChwb3B1bGF0aW5nIHRoZVxuXHQvLyBjYWNoZSksIG9yIGZyb20gYSBzb3J0IGZvcm1hdHRlclxuXHRmdW5jdGlvbiBfZm5Tb3J0RGF0YSggc2V0dGluZ3MsIGlkeCApXG5cdHtcblx0XHQvLyBDdXN0b20gc29ydGluZyBmdW5jdGlvbiAtIHByb3ZpZGVkIGJ5IHRoZSBzb3J0IGRhdGEgdHlwZVxuXHRcdHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGlkeCBdO1xuXHRcdHZhciBjdXN0b21Tb3J0ID0gRGF0YVRhYmxlLmV4dC5vcmRlclsgY29sdW1uLnNTb3J0RGF0YVR5cGUgXTtcblx0XHR2YXIgY3VzdG9tRGF0YTtcblx0XG5cdFx0aWYgKCBjdXN0b21Tb3J0ICkge1xuXHRcdFx0Y3VzdG9tRGF0YSA9IGN1c3RvbVNvcnQuY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgaWR4LFxuXHRcdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGlkeCApXG5cdFx0XHQpO1xuXHRcdH1cblx0XG5cdFx0Ly8gVXNlIC8gcG9wdWxhdGUgY2FjaGVcblx0XHR2YXIgcm93LCBjZWxsRGF0YTtcblx0XHR2YXIgZm9ybWF0dGVyID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyWyBjb2x1bW4uc1R5cGUrXCItcHJlXCIgXTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblx0XG5cdFx0XHRpZiAoICEgcm93Ll9hU29ydERhdGEgKSB7XG5cdFx0XHRcdHJvdy5fYVNvcnREYXRhID0gW107XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhW2lkeF0gfHwgY3VzdG9tU29ydCApIHtcblx0XHRcdFx0Y2VsbERhdGEgPSBjdXN0b21Tb3J0ID9cblx0XHRcdFx0XHRjdXN0b21EYXRhW2ldIDogLy8gSWYgdGhlcmUgd2FzIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24sIHVzZSBkYXRhIGZyb20gdGhlcmVcblx0XHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIGksIGlkeCwgJ3NvcnQnICk7XG5cdFxuXHRcdFx0XHRyb3cuX2FTb3J0RGF0YVsgaWR4IF0gPSBmb3JtYXR0ZXIgP1xuXHRcdFx0XHRcdGZvcm1hdHRlciggY2VsbERhdGEgKSA6XG5cdFx0XHRcdFx0Y2VsbERhdGE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBTYXZlIHRoZSBzdGF0ZSBvZiBhIHRhYmxlXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNhdmVTdGF0ZSAoIHNldHRpbmdzIClcblx0e1xuXHRcdGlmICggIXNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlIHx8IHNldHRpbmdzLmJEZXN0cm95aW5nIClcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHQvKiBTdG9yZSB0aGUgaW50ZXJlc3RpbmcgdmFyaWFibGVzICovXG5cdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0dGltZTogICAgK25ldyBEYXRlKCksXG5cdFx0XHRzdGFydDogICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGxlbmd0aDogIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdG9yZGVyOiAgICQuZXh0ZW5kKCB0cnVlLCBbXSwgc2V0dGluZ3MuYWFTb3J0aW5nICksXG5cdFx0XHRzZWFyY2g6ICBfZm5TZWFyY2hUb0NhbWVsKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKSxcblx0XHRcdGNvbHVtbnM6ICQubWFwKCBzZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggY29sLCBpICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZpc2libGU6IGNvbC5iVmlzaWJsZSxcblx0XHRcdFx0XHRzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSApXG5cdFx0XHRcdH07XG5cdFx0XHR9IClcblx0XHR9O1xuXHRcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvU3RhdGVTYXZlUGFyYW1zXCIsICdzdGF0ZVNhdmVQYXJhbXMnLCBbc2V0dGluZ3MsIHN0YXRlXSApO1xuXHRcblx0XHRzZXR0aW5ncy5vU2F2ZWRTdGF0ZSA9IHN0YXRlO1xuXHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgc3RhdGUgKTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGxvYWQgYSBzYXZlZCB0YWJsZSBzdGF0ZVxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9Jbml0IERhdGFUYWJsZXMgaW5pdCBvYmplY3Qgc28gd2UgY2FuIG92ZXJyaWRlIHNldHRpbmdzXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZFxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5Mb2FkU3RhdGUgKCBzZXR0aW5ncywgb0luaXQsIGNhbGxiYWNrIClcblx0e1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdFx0dmFyIGxvYWRlZCA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdGlmICggISBzIHx8ICEgcy50aW1lICkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQWxsb3cgY3VzdG9tIGFuZCBwbHVnLWluIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgdG8gYWx0ZXIgdGhlIHNhdmVkIGRhdGEgc2V0IGFuZFxuXHRcdFx0Ly8gY2FuY2VsbGluZyBvZiBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHRcdFx0dmFyIGFiU3RhdGVMb2FkID0gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc10gKTtcblx0XHRcdGlmICggJC5pbkFycmF5KCBmYWxzZSwgYWJTdGF0ZUxvYWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBSZWplY3Qgb2xkIGRhdGFcblx0XHRcdHZhciBkdXJhdGlvbiA9IHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uO1xuXHRcdFx0aWYgKCBkdXJhdGlvbiA+IDAgJiYgcy50aW1lIDwgK25ldyBEYXRlKCkgLSAoZHVyYXRpb24qMTAwMCkgKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBOdW1iZXIgb2YgY29sdW1ucyBoYXZlIGNoYW5nZWQgLSBhbGwgYmV0cyBhcmUgb2ZmLCBubyByZXN0b3JlIG9mIHNldHRpbmdzXG5cdFx0XHRpZiAoIHMuY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCAhPT0gcy5jb2x1bW5zLmxlbmd0aCApIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFN0b3JlIHRoZSBzYXZlZCBzdGF0ZSBzbyBpdCBtaWdodCBiZSBhY2Nlc3NlZCBhdCBhbnkgdGltZVxuXHRcdFx0c2V0dGluZ3Mub0xvYWRlZFN0YXRlID0gJC5leHRlbmQoIHRydWUsIHt9LCBzICk7XG5cdFxuXHRcdFx0Ly8gUmVzdG9yZSBrZXkgZmVhdHVyZXMgLSB0b2RvIC0gZm9yIDEuMTEgdGhpcyBuZWVkcyB0byBiZSBkb25lIGJ5XG5cdFx0XHQvLyBzdWJzY3JpYmVkIGV2ZW50c1xuXHRcdFx0aWYgKCBzLnN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICAgID0gcy5zdGFydDtcblx0XHRcdFx0c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBzLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBzLmxlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggICA9IHMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE9yZGVyXG5cdFx0XHRpZiAoIHMub3JkZXIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG5cdFx0XHRcdCQuZWFjaCggcy5vcmRlciwgZnVuY3Rpb24gKCBpLCBjb2wgKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nLnB1c2goIGNvbFswXSA+PSBjb2x1bW5zLmxlbmd0aCA/XG5cdFx0XHRcdFx0XHRbIDAsIGNvbFsxXSBdIDpcblx0XHRcdFx0XHRcdGNvbFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWFyY2hcblx0XHRcdGlmICggcy5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0JC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgX2ZuU2VhcmNoVG9IdW5nKCBzLnNlYXJjaCApICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ29sdW1uc1xuXHRcdFx0Ly9cblx0XHRcdGlmICggcy5jb2x1bW5zICkge1xuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1zLmNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFyIGNvbCA9IHMuY29sdW1uc1tpXTtcblx0XG5cdFx0XHRcdFx0Ly8gVmlzaWJpbGl0eVxuXHRcdFx0XHRcdGlmICggY29sLnZpc2libGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGNvbHVtbnNbaV0uYlZpc2libGUgPSBjb2wudmlzaWJsZTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIFNlYXJjaFxuXHRcdFx0XHRcdGlmICggY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0JC5leHRlbmQoIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSwgX2ZuU2VhcmNoVG9IdW5nKCBjb2wuc2VhcmNoICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsICdzdGF0ZUxvYWRlZCcsIFtzZXR0aW5ncywgc10gKTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fTtcblx0XG5cdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlICkge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciBzdGF0ZSA9IHNldHRpbmdzLmZuU3RhdGVMb2FkQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgbG9hZGVkICk7XG5cdFxuXHRcdGlmICggc3RhdGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGxvYWRlZCggc3RhdGUgKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbG9hZGVkIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgcGFydGljdWxhciB0YWJsZVxuXHQgKiAgQHBhcmFtIHtub2RlfSB0YWJsZSB0YWJsZSB3ZSBhcmUgdXNpbmcgYXMgYSBkYXRhVGFibGVcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IFNldHRpbmdzIG9iamVjdCAtIG9yIG51bGwgaWYgbm90IGZvdW5kXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mblNldHRpbmdzRnJvbU5vZGUgKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggdGFibGUsIF9wbHVjayggc2V0dGluZ3MsICduVGFibGUnICkgKTtcblx0XG5cdFx0cmV0dXJuIGlkeCAhPT0gLTEgP1xuXHRcdFx0c2V0dGluZ3NbIGlkeCBdIDpcblx0XHRcdG51bGw7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogTG9nIGFuIGVycm9yIG1lc3NhZ2Vcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2Vcblx0ICogIEBwYXJhbSB7aW50fSB0biBUZWNobmljYWwgbm90ZSBpZCB0byBnZXQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IuXG5cdCAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkxvZyggc2V0dGluZ3MsIGxldmVsLCBtc2csIHRuIClcblx0e1xuXHRcdG1zZyA9ICdEYXRhVGFibGVzIHdhcm5pbmc6ICcrXG5cdFx0XHQoc2V0dGluZ3MgPyAndGFibGUgaWQ9JytzZXR0aW5ncy5zVGFibGVJZCsnIC0gJyA6ICcnKSttc2c7XG5cdFxuXHRcdGlmICggdG4gKSB7XG5cdFx0XHRtc2cgKz0gJy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBlcnJvciwgcGxlYXNlIHNlZSAnK1xuXHRcdFx0J2h0dHA6Ly9kYXRhdGFibGVzLm5ldC90bi8nK3RuO1xuXHRcdH1cblx0XG5cdFx0aWYgKCAhIGxldmVsICApIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSAxLjEwXG5cdFx0XHR2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcblx0XHRcdHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xuXHRcblx0XHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdlcnJvcicsIFsgc2V0dGluZ3MsIHRuLCBtc2cgXSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggdHlwZSA9PSAnYWxlcnQnICkge1xuXHRcdFx0XHRhbGVydCggbXNnICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PSAndGhyb3cnICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR0eXBlKCBzZXR0aW5ncywgdG4sIG1zZyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cgKSB7XG5cdFx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSByZXQgdGFyZ2V0IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBzb3VyY2Ugb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFttYXBwZWROYW1lXSBuYW1lIHRvIG1hcCB0b28gLSBvcHRpb25hbCwgbmFtZSB1c2VkIGlmIG5vdCBnaXZlblxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5NYXAoIHJldCwgc3JjLCBuYW1lLCBtYXBwZWROYW1lIClcblx0e1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0JC5lYWNoKCBuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0X2ZuTWFwKCByZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggbWFwcGVkTmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bWFwcGVkTmFtZSA9IG5hbWU7XG5cdFx0fVxuXHRcblx0XHRpZiAoIHNyY1tuYW1lXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBFeHRlbmQgb2JqZWN0cyAtIHZlcnkgc2ltaWxhciB0byBqUXVlcnkuZXh0ZW5kLCBidXQgZGVlcCBjb3B5IG9iamVjdHMsIGFuZFxuXHQgKiBzaGFsbG93IGNvcHkgYXJyYXlzLiBUaGUgcmVhc29uIHdlIG5lZWQgdG8gZG8gdGhpcywgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvXG5cdCAqIGRlZXAgY29weSBhcnJheSBpbml0IHZhbHVlcyAoc3VjaCBhcyBhYVNvcnRpbmcpIHNpbmNlIHRoZSBkZXYgd291bGRuJ3QgYmVcblx0ICogYWJsZSB0byBvdmVycmlkZSB0aGVtLCBidXQgd2UgZG8gd2FudCB0byBkZWVwIGNvcHkgYXJyYXlzLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG91dCBPYmplY3QgdG8gZXh0ZW5kXG5cdCAqICBAcGFyYW0ge29iamVjdH0gZXh0ZW5kZXIgT2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnRpZXMgd2lsbCBiZSBhcHBsaWVkIHRvXG5cdCAqICAgICAgb3V0XG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGJyZWFrUmVmcyBJZiB0cnVlLCB0aGVuIGFycmF5cyB3aWxsIGJlIHNsaWNlZCB0byB0YWtlIGFuXG5cdCAqICAgICAgaW5kZXBlbmRlbnQgY29weSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIGBkYXRhYCBvciBgYWFEYXRhYCBwYXJhbWV0ZXJzXG5cdCAqICAgICAgaWYgdGhleSBhcmUgcHJlc2VudC4gVGhpcyBpcyBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjb2xsZWN0aW9uIHRvXG5cdCAqICAgICAgRGF0YVRhYmxlcyBhbmQgaGF2ZSB0aGF0IHVzZWQgYXMgeW91ciBkYXRhIHNvdXJjZSB3aXRob3V0IGJyZWFraW5nIHRoZVxuXHQgKiAgICAgIHJlZmVyZW5jZXNcblx0ICogIEByZXR1cm5zIHtvYmplY3R9IG91dCBSZWZlcmVuY2UsIGp1c3QgZm9yIGNvbnZlbmllbmNlIC0gb3V0ID09PSB0aGUgcmV0dXJuLlxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqICBAdG9kbyBUaGlzIGRvZXNuJ3QgdGFrZSBhY2NvdW50IG9mIGFycmF5cyBpbnNpZGUgdGhlIGRlZXAgY29waWVkIG9iamVjdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5FeHRlbmQoIG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcyApXG5cdHtcblx0XHR2YXIgdmFsO1xuXHRcblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBleHRlbmRlciApIHtcblx0XHRcdGlmICggZXh0ZW5kZXIuaGFzT3duUHJvcGVydHkocHJvcCkgKSB7XG5cdFx0XHRcdHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xuXHRcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbCApICkge1xuXHRcdFx0XHRcdGlmICggISAkLmlzUGxhaW5PYmplY3QoIG91dFtwcm9wXSApICkge1xuXHRcdFx0XHRcdFx0b3V0W3Byb3BdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvdXRbcHJvcF0sIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBicmVha1JlZnMgJiYgcHJvcCAhPT0gJ2RhdGEnICYmIHByb3AgIT09ICdhYURhdGEnICYmIEFycmF5LmlzQXJyYXkodmFsKSApIHtcblx0XHRcdFx0XHRvdXRbcHJvcF0gPSB2YWwuc2xpY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvdXRbcHJvcF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogQmluZCBhbiBldmVudCBoYW5kZXJzIHRvIGFsbG93IGEgY2xpY2sgb3IgcmV0dXJuIGtleSB0byBhY3RpdmF0ZSB0aGUgY2FsbGJhY2suXG5cdCAqIFRoaXMgaXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSBzaW5jZSBhIHJldHVybiBvbiB0aGUga2V5Ym9hcmQgd2lsbCBoYXZlIHRoZVxuXHQgKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXG5cdCAqICBAcGFyYW0ge2VsZW1lbnR9IG4gRWxlbWVudCB0byBiaW5kIHRoZSBhY3Rpb24gdG9cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvRGF0YSBEYXRhIG9iamVjdCB0byBwYXNzIHRvIHRoZSB0cmlnZ2VyZWQgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuXHQgKi9cblx0ZnVuY3Rpb24gX2ZuQmluZEFjdGlvbiggbiwgb0RhdGEsIGZuIClcblx0e1xuXHRcdCQobilcblx0XHRcdC5vbiggJ2NsaWNrLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0JChuKS50cmlnZ2VyKCdibHVyJyk7IC8vIFJlbW92ZSBmb2N1cyBvdXRsaW5lIGZvciBtb3VzZSB1c2Vyc1xuXHRcdFx0XHRcdGZuKGUpO1xuXHRcdFx0XHR9IClcblx0XHRcdC5vbiggJ2tleXByZXNzLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKXtcblx0XHRcdFx0XHRpZiAoIGUud2hpY2ggPT09IDEzICkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0Zm4oZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IClcblx0XHRcdC5vbiggJ3NlbGVjdHN0YXJ0LkRUJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8qIFRha2UgdGhlIGJydXRhbCBhcHByb2FjaCB0byBjYW5jZWxsaW5nIHRleHQgc2VsZWN0aW9uICovXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG5cdCAqIGFuIGFycmF5IHN0b3JlIG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGNhbiB0aGVuIGFsbCBiZSBjYWxsZWQgdG9nZXRoZXIuXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc1N0b3JlIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW4gb1NldHRpbmdzXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYmFja1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNOYW1lIElkZW50aWZ5aW5nIG5hbWUgZm9yIHRoZSBjYWxsYmFjayAoaS5lLiBhIGxhYmVsKVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCBzU3RvcmUsIGZuLCBzTmFtZSApXG5cdHtcblx0XHRpZiAoIGZuIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3Nbc1N0b3JlXS5wdXNoKCB7XG5cdFx0XHRcdFwiZm5cIjogZm4sXG5cdFx0XHRcdFwic05hbWVcIjogc05hbWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKipcblx0ICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcblx0ICogY2FsbGJhY2sgYXJyYXkgc3RvcmUgaXMgZG9uZSBiYWNrd2FyZHMhIEZ1cnRoZXIgbm90ZSB0aGF0IHlvdSBkbyBub3Qgd2FudCB0b1xuXHQgKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXG5cdCAqIGFzIGl0cyBzbG93LlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxuXHQgKiAgICAgIG9TZXR0aW5nc1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBqUXVlcnkgY3VzdG9tIGV2ZW50IHRvIHRyaWdnZXIuIElmXG5cdCAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXG5cdCAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXG5cdCAqICAgICAgdHJpZ2dlclxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBjYWxsYmFja0FyciwgZXZlbnROYW1lLCBhcmdzIClcblx0e1xuXHRcdHZhciByZXQgPSBbXTtcblx0XG5cdFx0aWYgKCBjYWxsYmFja0FyciApIHtcblx0XHRcdHJldCA9ICQubWFwKCBzZXR0aW5nc1tjYWxsYmFja0Fycl0uc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uICh2YWwsIGkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbC5mbi5hcHBseSggc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGV2ZW50TmFtZSAhPT0gbnVsbCApIHtcblx0XHRcdHZhciBlID0gJC5FdmVudCggZXZlbnROYW1lKycuZHQnICk7XG5cdFxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLnRyaWdnZXIoIGUsIGFyZ3MgKTtcblx0XG5cdFx0XHRyZXQucHVzaCggZS5yZXN1bHQgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXQ7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZm5MZW5ndGhPdmVyZmxvdyAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRcdGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdFx0bGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoO1xuXHRcblx0XHQvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG5cdFx0aWYgKCBzdGFydCA+PSBlbmQgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gZW5kIC0gbGVuO1xuXHRcdH1cblx0XG5cdFx0Ly8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRzdGFydCAtPSAoc3RhcnQgJSBsZW4pO1xuXHRcblx0XHRpZiAoIGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHRcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCB0eXBlIClcblx0e1xuXHRcdHZhciByZW5kZXJlciA9IHNldHRpbmdzLnJlbmRlcmVyO1xuXHRcdHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblx0XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHJlbmRlcmVyICkgJiYgcmVuZGVyZXJbdHlwZV0gKSB7XG5cdFx0XHQvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG5cdFx0XHQvLyB0aGUgZGVmYXVsdC5cblx0XHRcdHJldHVybiBob3N0W3JlbmRlcmVyW3R5cGVdXSB8fCBob3N0Ll87XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgcmVuZGVyZXIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0Ly8gQ29tbW9uIHJlbmRlcmVyIC0gaWYgdGhlcmUgaXMgb25lIGF2YWlsYWJsZSBmb3IgdGhpcyB0eXBlIHVzZSBpdCxcblx0XHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcblx0XHRcdHJldHVybiBob3N0W3JlbmRlcmVyXSB8fCBob3N0Ll87XG5cdFx0fVxuXHRcblx0XHQvLyBVc2UgdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gaG9zdC5fO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIERldGVjdCB0aGUgZGF0YSBzb3VyY2UgYmVpbmcgdXNlZCBmb3IgdGhlIHRhYmxlLiBVc2VkIHRvIHNpbXBsaWZ5IHRoZSBjb2RlXG5cdCAqIGEgbGl0dGxlIChhamF4KSBhbmQgdG8gbWFrZSBpdCBjb21wcmVzcyBhIGxpdHRsZSBzbWFsbGVyLlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBEYXRhIHNvdXJjZVxuXHQgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG5cdCAqL1xuXHRmdW5jdGlvbiBfZm5EYXRhU291cmNlICggc2V0dGluZ3MgKVxuXHR7XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0XHRyZXR1cm4gJ3NzcCc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZXR0aW5ncy5hamF4IHx8IHNldHRpbmdzLnNBamF4U291cmNlICkge1xuXHRcdFx0cmV0dXJuICdhamF4Jztcblx0XHR9XG5cdFx0cmV0dXJuICdkb20nO1xuXHR9XG5cdFxuXG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbXB1dGVkIHN0cnVjdHVyZSBvZiB0aGUgRGF0YVRhYmxlcyBBUEksIGRlZmluZWQgYnkgdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG5cdCAqIGBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKClgIHdoZW4gYnVpbGRpbmcgdGhlIEFQSS5cblx0ICpcblx0ICogVGhlIHN0cnVjdHVyZSBpcyBidWlsdCBpbiBvcmRlciB0byBzcGVlZCBjcmVhdGlvbiBhbmQgZXh0ZW5zaW9uIG9mIHRoZSBBcGlcblx0ICogb2JqZWN0cyBzaW5jZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZWZmZWN0aXZlbHkgcHJlLXBhcnNlZC5cblx0ICpcblx0ICogVGhlIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSwgd2hlcmUgdGhpc1xuXHQgKiBiYXNlIGFycmF5IHJlcHJlc2VudHMgdGhlIEFwaSBwcm90b3R5cGUgYmFzZTpcblx0ICpcblx0ICogICAgIFtcblx0ICogICAgICAge1xuXHQgKiAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuXHQgKiAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG5cdCAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuXHQgKiAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG5cdCAqICAgICAgIH0sXG5cdCAqICAgICAgIHtcblx0ICogICAgICAgICBuYW1lOiAgICAgJ3Jvdydcblx0ICogICAgICAgICB2YWw6ICAgICAgIHt9LFxuXHQgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0ICogICAgICAgICBwcm9wRXh0OiAgIFtcblx0ICogICAgICAgICAgIHtcblx0ICogICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcblx0ICogICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcblx0ICogICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQgKiAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cblx0ICogICAgICAgICAgIH0sXG5cdCAqICAgICAgICAgICAuLi5cblx0ICogICAgICAgICBdXG5cdCAqICAgICAgIH1cblx0ICogICAgIF1cblx0ICpcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHR2YXIgX19hcGlTdHJ1Y3QgPSBbXTtcblx0XG5cdFxuXHQvKipcblx0ICogYEFycmF5LnByb3RvdHlwZWAgcmVmZXJlbmNlLlxuXHQgKlxuXHQgKiBAdHlwZSBvYmplY3Rcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0XG5cdFxuXHQvKipcblx0ICogQWJzdHJhY3Rpb24gZm9yIGBjb250ZXh0YCBwYXJhbWV0ZXIgb2YgdGhlIGBBcGlgIGNvbnN0cnVjdG9yIHRvIGFsbG93IGl0IHRvXG5cdCAqIHRha2Ugc2V2ZXJhbCBkaWZmZXJlbnQgZm9ybXMgZm9yIGVhc2Ugb2YgdXNlLlxuXHQgKlxuXHQgKiBFYWNoIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdHlwZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhVGFibGVzIHNldHRpbmdzXG5cdCAqIG9iamVjdCB3aGVyZSBwb3NzaWJsZS5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfG5vZGV8alF1ZXJ5fG9iamVjdH0gbWl4ZWQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIENhbiBiZSBvbmVcblx0ICogICBvZjpcblx0ICpcblx0ICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdCAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuXHQgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG5cdCAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuXHQgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgICogYERhdGFUYWJsZXMuQXBpYCAtIEFQSSBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHthcnJheXxudWxsfSBNYXRjaGluZyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuIGBudWxsYCBvclxuXHQgKiAgIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIGlmIG5vIG1hdGNoaW5nIERhdGFUYWJsZSBpcyBmb3VuZC5cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF90b1NldHRpbmdzID0gZnVuY3Rpb24gKCBtaXhlZCApXG5cdHtcblx0XHR2YXIgaWR4LCBqcTtcblx0XHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0dmFyIHRhYmxlcyA9ICQubWFwKCBzZXR0aW5ncywgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gZWwublRhYmxlO1xuXHRcdH0gKTtcblx0XG5cdFx0aWYgKCAhIG1peGVkICkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQublRhYmxlICYmIG1peGVkLm9BcGkgKSB7XG5cdFx0XHQvLyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0cmV0dXJuIFsgbWl4ZWQgXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScgKSB7XG5cdFx0XHQvLyBUYWJsZSBub2RlXG5cdFx0XHRpZHggPSAkLmluQXJyYXkoIG1peGVkLCB0YWJsZXMgKTtcblx0XHRcdHJldHVybiBpZHggIT09IC0xID8gWyBzZXR0aW5nc1tpZHhdIF0gOiBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmICggbWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIG1peGVkLnNldHRpbmdzKCkudG9BcnJheSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIG1peGVkID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIGpRdWVyeSBzZWxlY3RvclxuXHRcdFx0anEgPSAkKG1peGVkKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG1peGVkIGluc3RhbmNlb2YgJCApIHtcblx0XHRcdC8vIGpRdWVyeSBvYmplY3QgKGFsc28gRGF0YVRhYmxlcyBpbnN0YW5jZSlcblx0XHRcdGpxID0gbWl4ZWQ7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGpxICkge1xuXHRcdFx0cmV0dXJuIGpxLm1hcCggZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRpZHggPSAkLmluQXJyYXkoIHRoaXMsIHRhYmxlcyApO1xuXHRcdFx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IHNldHRpbmdzW2lkeF0gOiBudWxsO1xuXHRcdFx0fSApLnRvQXJyYXkoKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcblx0ICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXG5cdCAqXG5cdCAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXG5cdCAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcblx0ICogYSBcImNvbnRleHRcIiAtIGkuZS4gdGhlIHRhYmxlcyB0aGF0IGl0IHdpbGwgb3BlcmF0ZSBvbi4gVGhpcyBjb3VsZCBiZSBhIHNpbmdsZVxuXHQgKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWxseSB0aGUgQVBJIGlzIGRlc2lnbmVkIHRvIGFsbG93IHlvdSB0byBlYXNpbHkgd29yayB3aXRoIHRoZSBkYXRhIGluXG5cdCAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XG5cdCAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxuXHQgKiBhcnJheSBkZXBlbmQgdXBvbiB0aGUgYWN0aW9ucyByZXF1ZXN0ZWQgYnkgZWFjaCBtZXRob2QgKGZvciBleGFtcGxlXG5cdCAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXG5cdCAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3Ncblx0ICogY29uZmlndXJhdGlvbikuIFRoZSBBUEkgb2JqZWN0IGhhcyBhIG51bWJlciBvZiBhcnJheSBsaWtlIG1ldGhvZHMgKGBwdXNoYCxcblx0ICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxuXHQgKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXG5cdCAqXG5cdCAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcblx0ICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxuXHQgKiB0b3AgbGV2ZWwgb2JqZWN0IGhhZC4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3byBjYWxscyBhcmUgZXF1aXZhbGVudDpcblx0ICpcblx0ICogICAgIC8vIE5vdCBjaGFpbmVkXG5cdCAqICAgICBhcGkucm93LmFkZCggey4uLn0gKTtcblx0ICogICAgIGFwaS5kcmF3KCk7XG5cdCAqXG5cdCAqICAgICAvLyBDaGFpbmVkXG5cdCAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBEYXRhVGFibGUuQXBpXG5cdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcblx0ICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXG5cdCAqICAgQ2FuIGJlIG9uZSBvZjpcblx0ICpcblx0ICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdCAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuXHQgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG5cdCAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuXHQgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXG5cdCAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3Rcblx0ICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5hcGkoKTtcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBJbml0aWFsaXNhdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG5cdCAqICAgdmFyIGFwaSA9IG5ldyAkLmZuLkRhdGFUYWJsZS5BcGkoICd0YWJsZS5kYXRhVGFibGUnICk7XG5cdCAqL1xuXHRfQXBpID0gZnVuY3Rpb24gKCBjb250ZXh0LCBkYXRhIClcblx0e1xuXHRcdGlmICggISAodGhpcyBpbnN0YW5jZW9mIF9BcGkpICkge1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCBjb250ZXh0LCBkYXRhICk7XG5cdFx0fVxuXHRcblx0XHR2YXIgc2V0dGluZ3MgPSBbXTtcblx0XHR2YXIgY3R4U2V0dGluZ3MgPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0XHR2YXIgYSA9IF90b1NldHRpbmdzKCBvICk7XG5cdFx0XHRpZiAoIGEgKSB7XG5cdFx0XHRcdHNldHRpbmdzLnB1c2guYXBwbHkoIHNldHRpbmdzLCBhICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49Y29udGV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Y3R4U2V0dGluZ3MoIGNvbnRleHRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dCApO1xuXHRcdH1cblx0XG5cdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHR0aGlzLmNvbnRleHQgPSBfdW5pcXVlKCBzZXR0aW5ncyApO1xuXHRcblx0XHQvLyBJbml0aWFsIGRhdGFcblx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHQkLm1lcmdlKCB0aGlzLCBkYXRhICk7XG5cdFx0fVxuXHRcblx0XHQvLyBzZWxlY3RvclxuXHRcdHRoaXMuc2VsZWN0b3IgPSB7XG5cdFx0XHRyb3dzOiBudWxsLFxuXHRcdFx0Y29sczogbnVsbCxcblx0XHRcdG9wdHM6IG51bGxcblx0XHR9O1xuXHRcblx0XHRfQXBpLmV4dGVuZCggdGhpcywgdGhpcywgX19hcGlTdHJ1Y3QgKTtcblx0fTtcblx0XG5cdERhdGFUYWJsZS5BcGkgPSBfQXBpO1xuXHRcblx0Ly8gRG9uJ3QgZGVzdHJveSB0aGUgZXhpc3RpbmcgcHJvdG90eXBlLCBqdXN0IGV4dGVuZCBpdC4gUmVxdWlyZWQgZm9yIGpRdWVyeSAyJ3Ncblx0Ly8gaXNQbGFpbk9iamVjdC5cblx0JC5leHRlbmQoIF9BcGkucHJvdG90eXBlLCB7XG5cdFx0YW55OiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLmNvdW50KCkgIT09IDA7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGNvbmNhdDogIF9fYXJyYXlQcm90by5jb25jYXQsXG5cdFxuXHRcblx0XHRjb250ZXh0OiBbXSwgLy8gYXJyYXkgb2YgdGFibGUgc2V0dGluZ3Mgb2JqZWN0c1xuXHRcblx0XG5cdFx0Y291bnQ6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XG5cdFx0ZWFjaDogZnVuY3Rpb24gKCBmbiApXG5cdFx0e1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW47IGkrKyApIHtcblx0XHRcdFx0Zm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRlcTogZnVuY3Rpb24gKCBpZHggKVxuXHRcdHtcblx0XHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggPiBpZHggP1xuXHRcdFx0XHRuZXcgX0FwaSggY3R4W2lkeF0sIHRoaXNbaWR4XSApIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9LFxuXHRcblx0XG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiAoIGZuIClcblx0XHR7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcblx0XHRcdGlmICggX19hcnJheVByb3RvLmZpbHRlciApIHtcblx0XHRcdFx0YSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCggdGhpcywgZm4sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXRoaXMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHRoaXNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRmbGF0dGVuOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYS5jb25jYXQuYXBwbHkoIGEsIHRoaXMudG9BcnJheSgpICkgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0am9pbjogICAgX19hcnJheVByb3RvLmpvaW4sXG5cdFxuXHRcblx0XHRpbmRleE9mOiBfX2FycmF5UHJvdG8uaW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0XHR7XG5cdFx0XHRmb3IgKCB2YXIgaT0oc3RhcnQgfHwgMCksIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHRoaXNbaV0gPT09IG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH0sXG5cdFxuXHRcdGl0ZXJhdG9yOiBmdW5jdGlvbiAoIGZsYXR0ZW4sIHR5cGUsIGZuLCBhbHdheXNOZXcgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0YSA9IFtdLCByZXQsXG5cdFx0XHRcdGksIGllbiwgaiwgamVuLFxuXHRcdFx0XHRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuXHRcdFx0XHRyb3dzLCBpdGVtcywgaXRlbSxcblx0XHRcdFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXHRcblx0XHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0XHRpZiAoIHR5cGVvZiBmbGF0dGVuID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWx3YXlzTmV3ID0gZm47XG5cdFx0XHRcdGZuID0gdHlwZTtcblx0XHRcdFx0dHlwZSA9IGZsYXR0ZW47XG5cdFx0XHRcdGZsYXR0ZW4gPSBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKCBjb250ZXh0W2ldICk7XG5cdFxuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICd0YWJsZScgKSB7XG5cdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaSApO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW5zJyB8fCB0eXBlID09PSAncm93cycgKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBoYXMgc2FtZSBsZW5ndGggYXMgY29udGV4dCAtIG9uZSBlbnRyeSBmb3IgZWFjaCB0YWJsZVxuXHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkgKTtcblx0XG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnY29sdW1uJyB8fCB0eXBlID09PSAnY29sdW1uLXJvd3MnIHx8IHR5cGUgPT09ICdyb3cnIHx8IHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHQvLyBjb2x1bW5zIGFuZCByb3dzIHNoYXJlIHRoZSBzYW1lIHN0cnVjdHVyZS5cblx0XHRcdFx0XHQvLyAndGhpcycgaXMgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgZm9yIGVhY2ggY29udGV4dFxuXHRcdFx0XHRcdGl0ZW1zID0gdGhpc1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY29sdW1uLXJvd3MnICkge1xuXHRcdFx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggY29udGV4dFtpXSwgc2VsZWN0b3Iub3B0cyApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Zm9yICggaj0wLCBqZW49aXRlbXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRpdGVtID0gaXRlbXNbal07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MgKTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggYS5sZW5ndGggfHwgYWx3YXlzTmV3ICkge1xuXHRcdFx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIGNvbnRleHQsIGZsYXR0ZW4gPyBhLmNvbmNhdC5hcHBseSggW10sIGEgKSA6IGEgKTtcblx0XHRcdFx0dmFyIGFwaVNlbGVjdG9yID0gYXBpLnNlbGVjdG9yO1xuXHRcdFx0XHRhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcblx0XHRcdFx0YXBpU2VsZWN0b3IuY29scyA9IHNlbGVjdG9yLmNvbHM7XG5cdFx0XHRcdGFwaVNlbGVjdG9yLm9wdHMgPSBzZWxlY3Rvci5vcHRzO1xuXHRcdFx0XHRyZXR1cm4gYXBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGxhc3RJbmRleE9mOiBfX2FycmF5UHJvdG8ubGFzdEluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpXG5cdFx0e1xuXHRcdFx0Ly8gQml0IGNoZWVreS4uLlxuXHRcdFx0cmV0dXJuIHRoaXMuaW5kZXhPZi5hcHBseSggdGhpcy50b0FycmF5LnJldmVyc2UoKSwgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdGxlbmd0aDogIDAsXG5cdFxuXHRcblx0XHRtYXA6IGZ1bmN0aW9uICggZm4gKVxuXHRcdHtcblx0XHRcdHZhciBhID0gW107XG5cdFxuXHRcdFx0aWYgKCBfX2FycmF5UHJvdG8ubWFwICkge1xuXHRcdFx0XHRhID0gX19hcnJheVByb3RvLm1hcC5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhLnB1c2goIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0cGx1Y2s6IGZ1bmN0aW9uICggcHJvcCApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbiAoIGVsICkge1xuXHRcdFx0XHRyZXR1cm4gZWxbIHByb3AgXTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXHRcblx0XHRwb3A6ICAgICBfX2FycmF5UHJvdG8ucG9wLFxuXHRcblx0XG5cdFx0cHVzaDogICAgX19hcnJheVByb3RvLnB1c2gsXG5cdFxuXHRcblx0XHQvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXG5cdFx0cmVkdWNlOiBfX2FycmF5UHJvdG8ucmVkdWNlIHx8IGZ1bmN0aW9uICggZm4sIGluaXQgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCAwLCB0aGlzLmxlbmd0aCwgMSApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHRyZWR1Y2VSaWdodDogX19hcnJheVByb3RvLnJlZHVjZVJpZ2h0IHx8IGZ1bmN0aW9uICggZm4sIGluaXQgKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCB0aGlzLmxlbmd0aC0xLCAtMSwgLTEgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0cmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXG5cdFxuXHRcblx0XHQvLyBPYmplY3Qgd2l0aCByb3dzLCBjb2x1bW5zIGFuZCBvcHRzXG5cdFx0c2VsZWN0b3I6IG51bGwsXG5cdFxuXHRcblx0XHRzaGlmdDogICBfX2FycmF5UHJvdG8uc2hpZnQsXG5cdFxuXHRcblx0XHRzbGljZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0c29ydDogICAgX19hcnJheVByb3RvLnNvcnQsIC8vID8gbmFtZSAtIG9yZGVyP1xuXHRcblx0XG5cdFx0c3BsaWNlOiAgX19hcnJheVByb3RvLnNwbGljZSxcblx0XG5cdFxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9fYXJyYXlQcm90by5zbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fSxcblx0XG5cdFxuXHRcdHRvJDogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR0b0pRdWVyeTogZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHRcdH0sXG5cdFxuXHRcblx0XHR1bmlxdWU6IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIF91bmlxdWUodGhpcykgKTtcblx0XHR9LFxuXHRcblx0XG5cdFx0dW5zaGlmdDogX19hcnJheVByb3RvLnVuc2hpZnRcblx0fSApO1xuXHRcblx0XG5cdF9BcGkuZXh0ZW5kID0gZnVuY3Rpb24gKCBzY29wZSwgb2JqLCBleHQgKVxuXHR7XG5cdFx0Ly8gT25seSBleHRlbmQgQVBJIGluc3RhbmNlcyBhbmQgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEFQSVxuXHRcdGlmICggISBleHQubGVuZ3RoIHx8ICEgb2JqIHx8ICggISAob2JqIGluc3RhbmNlb2YgX0FwaSkgJiYgISBvYmouX19kdF93cmFwcGVyICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGksIGllbixcblx0XHRcdHN0cnVjdCxcblx0XHRcdG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IGZuLmFwcGx5KCBzY29wZSwgYXJndW1lbnRzICk7XG5cdFxuXHRcdFx0XHRcdC8vIE1ldGhvZCBleHRlbnNpb25cblx0XHRcdFx0XHRfQXBpLmV4dGVuZCggcmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCApO1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cdFxuXHRcdFx0Ly8gVmFsdWVcblx0XHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHN0cnVjdC50eXBlID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0bWV0aG9kU2NvcGluZyggc2NvcGUsIHN0cnVjdC52YWwsIHN0cnVjdCApIDpcblx0XHRcdFx0c3RydWN0LnR5cGUgPT09ICdvYmplY3QnID9cblx0XHRcdFx0XHR7fSA6XG5cdFx0XHRcdFx0c3RydWN0LnZhbDtcblx0XG5cdFx0XHRvYmpbIHN0cnVjdC5uYW1lIF0uX19kdF93cmFwcGVyID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBQcm9wZXJ0eSBleHRlbnNpb25cblx0XHRcdF9BcGkuZXh0ZW5kKCBzY29wZSwgb2JqWyBzdHJ1Y3QubmFtZSBdLCBzdHJ1Y3QucHJvcEV4dCApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvLyBAdG9kbyAtIElzIHRoZXJlIG5lZWQgZm9yIGFuIGF1Z21lbnQgZnVuY3Rpb24/XG5cdC8vIF9BcGkuYXVnbWVudCA9IGZ1bmN0aW9uICggaW5zdCwgbmFtZSApXG5cdC8vIHtcblx0Ly8gXHQvLyBGaW5kIHNyYyBvYmplY3QgaW4gdGhlIHN0cnVjdHVyZSBmcm9tIHRoZSBuYW1lXG5cdC8vIFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcblx0Ly8gXHRfQXBpLmV4dGVuZCggaW5zdCwgb2JqICk7XG5cdC8vIH07XG5cdFxuXHRcblx0Ly8gICAgIFtcblx0Ly8gICAgICAge1xuXHQvLyAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuXHQvLyAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG5cdC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuXHQvLyAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG5cdC8vICAgICAgIH0sXG5cdC8vICAgICAgIHtcblx0Ly8gICAgICAgICBuYW1lOiAgICAgJ3Jvdydcblx0Ly8gICAgICAgICB2YWw6ICAgICAgIHt9LFxuXHQvLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcblx0Ly8gICAgICAgICBwcm9wRXh0OiAgIFtcblx0Ly8gICAgICAgICAgIHtcblx0Ly8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcblx0Ly8gICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcblx0Ly8gICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuXHQvLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cblx0Ly8gICAgICAgICAgIH0sXG5cdC8vICAgICAgICAgICAuLi5cblx0Ly8gICAgICAgICBdXG5cdC8vICAgICAgIH1cblx0Ly8gICAgIF1cblx0XG5cdF9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKCBuYW1lLCB2YWwgKVxuXHR7XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49bmFtZS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0X0FwaS5yZWdpc3RlciggbmFtZVtqXSwgdmFsICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdGksIGllbixcblx0XHRcdGhlaXIgPSBuYW1lLnNwbGl0KCcuJyksXG5cdFx0XHRzdHJ1Y3QgPSBfX2FwaVN0cnVjdCxcblx0XHRcdGtleSwgbWV0aG9kO1xuXHRcblx0XHR2YXIgZmluZCA9IGZ1bmN0aW9uICggc3JjLCBuYW1lICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNyYy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzcmNbaV0ubmFtZSA9PT0gbmFtZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcblx0XHRmb3IgKCBpPTAsIGllbj1oZWlyLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0bWV0aG9kID0gaGVpcltpXS5pbmRleE9mKCcoKScpICE9PSAtMTtcblx0XHRcdGtleSA9IG1ldGhvZCA/XG5cdFx0XHRcdGhlaXJbaV0ucmVwbGFjZSgnKCknLCAnJykgOlxuXHRcdFx0XHRoZWlyW2ldO1xuXHRcblx0XHRcdHZhciBzcmMgPSBmaW5kKCBzdHJ1Y3QsIGtleSApO1xuXHRcdFx0aWYgKCAhIHNyYyApIHtcblx0XHRcdFx0c3JjID0ge1xuXHRcdFx0XHRcdG5hbWU6ICAgICAga2V5LFxuXHRcdFx0XHRcdHZhbDogICAgICAge30sXG5cdFx0XHRcdFx0bWV0aG9kRXh0OiBbXSxcblx0XHRcdFx0XHRwcm9wRXh0OiAgIFtdLFxuXHRcdFx0XHRcdHR5cGU6ICAgICAgJ29iamVjdCdcblx0XHRcdFx0fTtcblx0XHRcdFx0c3RydWN0LnB1c2goIHNyYyApO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICggaSA9PT0gaWVuLTEgKSB7XG5cdFx0XHRcdHNyYy52YWwgPSB2YWw7XG5cdFx0XHRcdHNyYy50eXBlID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdFx0J2Z1bmN0aW9uJyA6XG5cdFx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCB2YWwgKSA/XG5cdFx0XHRcdFx0XHQnb2JqZWN0JyA6XG5cdFx0XHRcdFx0XHQnb3RoZXInO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHN0cnVjdCA9IG1ldGhvZCA/XG5cdFx0XHRcdFx0c3JjLm1ldGhvZEV4dCA6XG5cdFx0XHRcdFx0c3JjLnByb3BFeHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0X0FwaS5yZWdpc3RlclBsdXJhbCA9IF9hcGlfcmVnaXN0ZXJQbHVyYWwgPSBmdW5jdGlvbiAoIHBsdXJhbE5hbWUsIHNpbmd1bGFyTmFtZSwgdmFsICkge1xuXHRcdF9BcGkucmVnaXN0ZXIoIHBsdXJhbE5hbWUsIHZhbCApO1xuXHRcblx0XHRfQXBpLnJlZ2lzdGVyKCBzaW5ndWxhck5hbWUsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciByZXQgPSB2YWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcblx0XHRcdGlmICggcmV0ID09PSB0aGlzICkge1xuXHRcdFx0XHQvLyBSZXR1cm5lZCBpdGVtIGlzIHRoZSBBUEkgaW5zdGFuY2UgdGhhdCB3YXMgcGFzc2VkIGluLCByZXR1cm4gaXRcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcmV0IGluc3RhbmNlb2YgX0FwaSApIHtcblx0XHRcdFx0Ly8gTmV3IEFQSSBpbnN0YW5jZSByZXR1cm5lZCwgd2FudCB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlbVxuXHRcdFx0XHQvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXG5cdFx0XHRcdHJldHVybiByZXQubGVuZ3RoID9cblx0XHRcdFx0XHRBcnJheS5pc0FycmF5KCByZXRbMF0gKSA/XG5cdFx0XHRcdFx0XHRuZXcgX0FwaSggcmV0LmNvbnRleHQsIHJldFswXSApIDogLy8gQXJyYXkgcmVzdWx0cyBhcmUgJ2VuaGFuY2VkJ1xuXHRcdFx0XHRcdFx0cmV0WzBdIDpcblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gTm9uLUFQSSByZXR1cm4gLSBqdXN0IGZpcmUgaXQgYmFja1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9ICk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNlbGVjdG9yIGZvciBIVE1MIHRhYmxlcy4gQXBwbHkgdGhlIGdpdmVuIHNlbGVjdG9yIHRvIHRoZSBnaXZlIGFycmF5IG9mXG5cdCAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW3NlbGVjdG9yXSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIG9yIGludGVnZXJcblx0ICogQHBhcmFtICB7YXJyYXl9IEFycmF5IG9mIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cyB0byBiZSBmaWx0ZXJlZFxuXHQgKiBAcmV0dXJuIHthcnJheX1cblx0ICogQGlnbm9yZVxuXHQgKi9cblx0dmFyIF9fdGFibGVfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNlbGVjdG9yLCBhIClcblx0e1xuXHRcdGlmICggQXJyYXkuaXNBcnJheShzZWxlY3RvcikgKSB7XG5cdFx0XHRyZXR1cm4gJC5tYXAoIHNlbGVjdG9yLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gX190YWJsZV9zZWxlY3RvcihpdGVtLCBhKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdudW1iZXInICkge1xuXHRcdFx0cmV0dXJuIFsgYVsgc2VsZWN0b3IgXSBdO1xuXHRcdH1cblx0XG5cdFx0Ly8gUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgdGFibGUgbm9kZXNcblx0XHR2YXIgbm9kZXMgPSAkLm1hcCggYSwgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gZWwublRhYmxlO1xuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuICQobm9kZXMpXG5cdFx0XHQuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHQvLyBOZWVkIHRvIHRyYW5zbGF0ZSBiYWNrIGZyb20gdGhlIHRhYmxlIG5vZGUgdG8gdGhlIHNldHRpbmdzXG5cdFx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHRoaXMsIG5vZGVzICk7XG5cdFx0XHRcdHJldHVybiBhWyBpZHggXTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblx0fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIENvbnRleHQgc2VsZWN0b3IgZm9yIHRoZSBBUEkncyBjb250ZXh0IChpLmUuIHRoZSB0YWJsZXMgdGhlIEFQSSBpbnN0YW5jZVxuXHQgKiByZWZlcnMgdG8uXG5cdCAqXG5cdCAqIEBuYW1lICAgIERhdGFUYWJsZS5BcGkjdGFibGVzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXG5cdCAqICAgc2hvdWxkIG9wZXJhdGUgb24uIElmIG5vdCBnaXZlbiwgYWxsIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGFyZVxuXHQgKiAgIHVzZWQuIFRoaXMgY2FuIGJlIGdpdmVuIGFzIGEgalF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSBgJzpndCgwKSdgKSB0b1xuXHQgKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGUuQXBpfSBSZXR1cm5zIGEgbmV3IEFQSSBpbnN0YW5jZSBpZiBhIHNlbGVjdG9yIGlzIGdpdmVuLlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlcygpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0XHQvLyBBIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGlmIHRoZXJlIHdhcyBhIHNlbGVjdG9yIHNwZWNpZmllZFxuXHRcdHJldHVybiBzZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdG9yICE9PSBudWxsID9cblx0XHRcdG5ldyBfQXBpKCBfX3RhYmxlX3NlbGVjdG9yKCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkgKSA6XG5cdFx0XHR0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuXHRcdHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyggc2VsZWN0b3IgKTtcblx0XHR2YXIgY3R4ID0gdGFibGVzLmNvbnRleHQ7XG5cdFxuXHRcdC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggP1xuXHRcdFx0bmV3IF9BcGkoIGN0eFswXSApIDpcblx0XHRcdHRhYmxlcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ub2RlcygpJywgJ3RhYmxlKCkubm9kZSgpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UYWJsZTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuYm9keSgpJywgJ3RhYmxlKCkuYm9keSgpJyAsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRyZXR1cm4gY3R4Lm5UQm9keTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuaGVhZGVyKCknLCAndGFibGUoKS5oZWFkZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVEhlYWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmZvb3RlcigpJywgJ3RhYmxlKCkuZm9vdGVyKCknICwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdHJldHVybiBjdHgublRGb290O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5jb250YWluZXJzKCknLCAndGFibGUoKS5jb250YWluZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdFx0cmV0dXJuIGN0eC5uVGFibGVXcmFwcGVyO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHQvKipcblx0ICogUmVkcmF3IHRoZSB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdkcmF3KCknLCBmdW5jdGlvbiAoIHBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGlmICggcGFnaW5nID09PSAncGFnZScgKSB7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgcGFnaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRwYWdpbmcgPSBwYWdpbmcgPT09ICdmdWxsLWhvbGQnID9cblx0XHRcdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0XHRcdHRydWU7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIHBhZ2luZz09PWZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cblx0ICpcblx0ICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkKVxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXG5cdCAqIG5vdCB0aHJvdyBhbiBlcnJvciwgYnV0IHJhdGhlciByZXNldCB0aGUgcGFnaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxuXHQgKiAgKiBgaW50ZWdlcmAgLSBUaGUgcGFnZSBpbmRleCB0byBqdW1wIHRvXG5cdCAqICAqIGBzdHJpbmdgIC0gQW4gYWN0aW9uIHRvIHRha2U6XG5cdCAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cblx0ICogICAgKiBgbmV4dGAgLSBKdW1wIHRvIHRoZSBuZXh0IHBhZ2Vcblx0ICogICAgKiBgcHJldmlvdXNgIC0gSnVtcCB0byBwcmV2aW91cyBwYWdlXG5cdCAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlKCknLCBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0XHRpZiAoIGFjdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFnZS5pbmZvKCkucGFnZTsgLy8gbm90IGFuIGV4cGVuc2l2ZSBjYWxsXG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlLCBoYXZlIGFuIGFjdGlvbiB0byB0YWtlIG9uIGFsbCB0YWJsZXNcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBhY3Rpb24gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvKipcblx0ICogUGFnaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogSWYgeW91IHJlcXVpcmUgcGFnaW5nIGluZm9ybWF0aW9uIGZvciBhbm90aGVyIHRhYmxlLCB1c2UgdGhlIGB0YWJsZSgpYCBtZXRob2Rcblx0ICogd2l0aCBhIHN1aXRhYmxlIHNlbGVjdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBzZXQ6XG5cdCAqICAqIGBwYWdlYCAtIEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZCAtIGkuZS4gdGhlIGZpcnN0IHBhZ2UgaXMgYDBgKVxuXHQgKiAgKiBgcGFnZXNgIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzXG5cdCAqICAqIGBzdGFydGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgZmlyc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0ICogICogYGVuZGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgbGFzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxuXHQgKiAgKiBgbGVuZ3RoYCAtIERpc3BsYXkgbGVuZ3RoIChudW1iZXIgb2YgcmVjb3JkcykuIE5vdGUgdGhhdCBnZW5lcmFsbHkgYHN0YXJ0XG5cdCAqICAgICsgbGVuZ3RoID0gZW5kYCwgYnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0cnVlLCBmb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmVcblx0ICogICAgb25seSAyIHJlY29yZHMgdG8gc2hvdyBvbiB0aGUgZmluYWwgcGFnZSwgd2l0aCBhIGxlbmd0aCBvZiAxMC5cblx0ICogICogYHJlY29yZHNUb3RhbGAgLSBGdWxsIGRhdGEgc2V0IGxlbmd0aFxuXHQgKiAgKiBgcmVjb3Jkc0Rpc3BsYXlgIC0gRGF0YSBzZXQgbGVuZ3RoIG9uY2UgdGhlIGN1cnJlbnQgZmlsdGVyaW5nIGNyaXRlcmlvblxuXHQgKiAgICBhcmUgYXBwbGllZC5cblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdwYWdlLmluZm8oKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRcdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHR2YXJcblx0XHRcdHNldHRpbmdzICAgPSB0aGlzLmNvbnRleHRbMF0sXG5cdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3Mub0ZlYXR1cmVzLmJQYWdpbmF0ZSA/IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6IC0xLFxuXHRcdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0XCJwYWdlXCI6ICAgICAgICAgICBhbGwgPyAwIDogTWF0aC5mbG9vciggc3RhcnQgLyBsZW4gKSxcblx0XHRcdFwicGFnZXNcIjogICAgICAgICAgYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFx0XCJzdGFydFwiOiAgICAgICAgICBzdGFydCxcblx0XHRcdFwiZW5kXCI6ICAgICAgICAgICAgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XHRcImxlbmd0aFwiOiAgICAgICAgIGxlbixcblx0XHRcdFwicmVjb3Jkc1RvdGFsXCI6ICAgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcdFwicmVjb3Jkc0Rpc3BsYXlcIjogdmlzUmVjb3Jkcyxcblx0XHRcdFwic2VydmVyU2lkZVwiOiAgICAgX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCdcblx0XHR9O1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cblx0ICpcblx0ICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGxlbmd0aC4gTm90ZSBgLTFgIGluZGljYXRlcyB0aGF0IGFsbCByZWNvcmRzXG5cdCAqICAgYXJlIHRvIGJlIHNob3duLlxuXHQgKi8vKipcblx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAncGFnZS5sZW4oKScsIGZ1bmN0aW9uICggbGVuICkge1xuXHRcdC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoaXMgZnVuY3Rpb24gJ2xlbmd0aCgpJyBiZWNhdXNlIGBsZW5ndGhgXG5cdFx0Ly8gaXMgYSBKYXZhc2NyaXB0IHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmVzIGhvdyBtYW55IGFyZ3VtZW50c1xuXHRcdC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzLlxuXHRcdGlmICggbGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdHRoaXMuY29udGV4dFswXS5faURpc3BsYXlMZW5ndGggOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBlbHNlLCBzZXQgdGhlIHBhZ2UgbGVuZ3RoXG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCBsZW4gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0dmFyIF9fcmVsb2FkID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uLCBjYWxsYmFjayApIHtcblx0XHQvLyBVc2UgdGhlIGRyYXcgZXZlbnQgdG8gdHJpZ2dlciBhIGNhbGxiYWNrXG5cdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblx0XG5cdFx0XHRhcGkub25lKCAnZHJhdycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y2FsbGJhY2soIGFwaS5hamF4Lmpzb24oKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cdFxuXHRcdFx0Ly8gQ2FuY2VsIGFuIGV4aXN0aW5nIHJlcXVlc3Rcblx0XHRcdHZhciB4aHIgPSBzZXR0aW5ncy5qcVhIUjtcblx0XHRcdGlmICggeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUcmlnZ2VyIHhoclxuXHRcdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywgW10sIGZ1bmN0aW9uKCBqc29uICkge1xuXHRcdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0dmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBsYXN0IEFqYXggcmVxdWVzdCB0aGF0IERhdGFUYWJsZXMgbWFkZSB0byB0aGVcblx0ICogc2VydmVyLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBKU09OIGZyb20gdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50XG5cdCAqIGNvbnRleHQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gSlNPTiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRcdHJldHVybiBjdHhbMF0uanNvbjtcblx0XHR9XG5cdFxuXHRcdC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcblx0fSApO1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgc3VibWl0dGVkIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgucGFyYW1zKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRcdHJldHVybiBjdHhbMF0ub0FqYXhEYXRhO1xuXHRcdH1cblx0XG5cdFx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlbG9hZCB0YWJsZXMgZnJvbSB0aGUgQWpheCBkYXRhIHNvdXJjZS4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlLWRyYXcgdGhlIHRhYmxlIHdoZW4gdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9dHJ1ZV0gUmVzZXQgKGRlZmF1bHQpIG9yIGhvbGQgdGhlIGN1cnJlbnQgcGFnaW5nXG5cdCAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcblx0ICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ2FqYXgucmVsb2FkKCknLCBmdW5jdGlvbiAoIGNhbGxiYWNrLCByZXNldFBhZ2luZyApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG5cdFx0XHRfX3JlbG9hZCggc2V0dGluZ3MsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgVVJMIGZyb20gdGhlIGZpcnN0XG5cdCAqIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBBamF4IHNvdXJjZSBVUkxcblx0ICovLyoqXG5cdCAqIFNldCB0aGUgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2V0IHRoZSBVUkwgZm9yIGFsbCB0YWJsZXMgaW4gdGhlXG5cdCAqIGN1cnJlbnQgY29udGV4dC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpJywgZnVuY3Rpb24gKCB1cmwgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIGdldFxuXHRcdFx0aWYgKCBjdHgubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Y3R4ID0gY3R4WzBdO1xuXHRcblx0XHRcdHJldHVybiBjdHguYWpheCA/XG5cdFx0XHRcdCQuaXNQbGFpbk9iamVjdCggY3R4LmFqYXggKSA/XG5cdFx0XHRcdFx0Y3R4LmFqYXgudXJsIDpcblx0XHRcdFx0XHRjdHguYWpheCA6XG5cdFx0XHRcdGN0eC5zQWpheFNvdXJjZTtcblx0XHR9XG5cdFxuXHRcdC8vIHNldFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKSApIHtcblx0XHRcdFx0c2V0dGluZ3MuYWpheC51cmwgPSB1cmw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2V0dGluZ3MuYWpheCA9IHVybDtcblx0XHRcdH1cblx0XHRcdC8vIE5vIG5lZWQgdG8gY29uc2lkZXIgc0FqYXhTb3VyY2UgaGVyZSBzaW5jZSBEYXRhVGFibGVzIGdpdmVzIHByaW9yaXR5XG5cdFx0XHQvLyB0byBgYWpheGAgb3ZlciBgc0FqYXhTb3VyY2VgLiBTbyBzZXR0aW5nIGBhamF4YCBoZXJlLCByZW5kZXJzIGFueVxuXHRcdFx0Ly8gdmFsdWUgb2YgYHNBamF4U291cmNlYCByZWR1bmRhbnQuXG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIExvYWQgZGF0YSBmcm9tIHRoZSBuZXdseSBzZXQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5XG5cdCAqIGF2YWlsYWJsZSB3aGVuIGBhamF4LnVybCgpYCBpcyB1c2VkIHRvIHNldCBhIFVSTC4gQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZFxuXHQgKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGNhbGxpbmcgYGFqYXgucmVsb2FkKClgIGJ1dCBpcyBwcm92aWRlZCBmb3Jcblx0ICogY29udmVuaWVuY2Ugd2hlbiBzZXR0aW5nIGEgbmV3IFVSTC4gTGlrZSBgYWpheC5yZWxvYWQoKWAgaXQgd2lsbFxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyB0aGUgdGFibGUgb25jZSB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpLmxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRcdC8vIFNhbWUgYXMgYSByZWxvYWQsIGJ1dCBtYWtlcyBzZW5zZSB0byBwcmVzZW50IGl0IGZvciBlYXN5IGFjY2VzcyBhZnRlciBhXG5cdFx0Ly8gdXJsIGNoYW5nZVxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdF9fcmVsb2FkKCBjdHgsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX3J1biA9IGZ1bmN0aW9uICggdHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cyApXG5cdHtcblx0XHR2YXJcblx0XHRcdG91dCA9IFtdLCByZXMsXG5cdFx0XHRhLCBpLCBpZW4sIGosIGplbixcblx0XHRcdHNlbGVjdG9yVHlwZSA9IHR5cGVvZiBzZWxlY3Rvcjtcblx0XG5cdFx0Ly8gQ2FuJ3QganVzdCBjaGVjayBmb3IgaXNBcnJheSBoZXJlLCBhcyBhbiBBUEkgb3IgalF1ZXJ5IGluc3RhbmNlIG1pZ2h0IGJlXG5cdFx0Ly8gZ2l2ZW4gd2l0aCB0aGVpciBhcnJheSBsaWtlIGxvb2tcblx0XHRpZiAoICEgc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzZWxlY3RvciA9IFsgc2VsZWN0b3IgXTtcblx0XHR9XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPXNlbGVjdG9yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Ly8gT25seSBzcGxpdCBvbiBzaW1wbGUgc3RyaW5ncyAtIGNvbXBsZXggZXhwcmVzc2lvbnMgd2lsbCBiZSBqUXVlcnkgc2VsZWN0b3JzXG5cdFx0XHRhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgJiYgISBzZWxlY3RvcltpXS5tYXRjaCgvW1xcW1xcKDpdLykgP1xuXHRcdFx0XHRzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcblx0XHRcdFx0WyBzZWxlY3RvcltpXSBdO1xuXHRcblx0XHRcdGZvciAoIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHJlcyA9IHNlbGVjdEZuKCB0eXBlb2YgYVtqXSA9PT0gJ3N0cmluZycgPyAoYVtqXSkudHJpbSgpIDogYVtqXSApO1xuXHRcblx0XHRcdFx0aWYgKCByZXMgJiYgcmVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRvdXQgPSBvdXQuY29uY2F0KCByZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gc2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHRcdHZhciBleHQgPSBfZXh0LnNlbGVjdG9yWyB0eXBlIF07XG5cdFx0aWYgKCBleHQubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaT0wLCBpZW49ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRvdXQgPSBleHRbaV0oIHNldHRpbmdzLCBvcHRzLCBvdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBfdW5pcXVlKCBvdXQgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAoIG9wdHMgKVxuXHR7XG5cdFx0aWYgKCAhIG9wdHMgKSB7XG5cdFx0XHRvcHRzID0ge307XG5cdFx0fVxuXHRcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXG5cdFx0Ly8gdGhhbiBzZWFyY2hcblx0XHRpZiAoIG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuICQuZXh0ZW5kKCB7XG5cdFx0XHRzZWFyY2g6ICdub25lJyxcblx0XHRcdG9yZGVyOiAnY3VycmVudCcsXG5cdFx0XHRwYWdlOiAnYWxsJ1xuXHRcdH0sIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKCBpbnN0IClcblx0e1xuXHRcdC8vIFJlZHVjZSB0aGUgQVBJIGluc3RhbmNlIHRvIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWluc3QubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGluc3RbaV0ubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0Ly8gQXNzaWduIHRoZSBmaXJzdCBlbGVtZW50IHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBpbnN0YW5jZVxuXHRcdFx0XHQvLyBhbmQgdHJ1bmNhdGUgdGhlIGluc3RhbmNlIGFuZCBjb250ZXh0XG5cdFx0XHRcdGluc3RbMF0gPSBpbnN0W2ldO1xuXHRcdFx0XHRpbnN0WzBdLmxlbmd0aCA9IDE7XG5cdFx0XHRcdGluc3QubGVuZ3RoID0gMTtcblx0XHRcdFx0aW5zdC5jb250ZXh0ID0gWyBpbnN0LmNvbnRleHRbaV0gXTtcblx0XG5cdFx0XHRcdHJldHVybiBpbnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0Ly8gTm90IGZvdW5kIC0gcmV0dXJuIGFuIGVtcHR5IGluc3RhbmNlXG5cdFx0aW5zdC5sZW5ndGggPSAwO1xuXHRcdHJldHVybiBpbnN0O1xuXHR9O1xuXHRcblx0XG5cdHZhciBfc2VsZWN0b3Jfcm93X2luZGV4ZXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzIClcblx0e1xuXHRcdHZhclxuXHRcdFx0aSwgaWVuLCB0bXAsIGE9W10sXG5cdFx0XHRkaXNwbGF5RmlsdGVyZWQgPSBzZXR0aW5ncy5haURpc3BsYXksXG5cdFx0XHRkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHRcblx0XHR2YXJcblx0XHRcdHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuXHRcdFx0b3JkZXIgID0gb3B0cy5vcmRlciwgICAvLyBhcHBsaWVkLCBjdXJyZW50LCBpbmRleCAob3JpZ2luYWwgLSBjb21wYXRpYmlsaXR5IHdpdGggMS45KVxuXHRcdFx0cGFnZSAgID0gb3B0cy5wYWdlOyAgICAvLyBhbGwsIGN1cnJlbnRcblx0XG5cdFx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdFx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlLCBtb3N0IG9wdGlvbnMgYXJlIGlycmVsZXZhbnQgc2luY2Vcblx0XHRcdC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcblx0XHRcdC8vIFJlbW92ZWQgaXMgYSBzcGVjaWFsIGNhc2UgLSBmb3IgY29uc2lzdGVuY3kganVzdCByZXR1cm4gYW4gZW1wdHlcblx0XHRcdC8vIGFycmF5XG5cdFx0XHRyZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuXHRcdFx0XHRbXSA6XG5cdFx0XHRcdF9yYW5nZSggMCwgZGlzcGxheU1hc3Rlci5sZW5ndGggKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHBhZ2UgPT0gJ2N1cnJlbnQnICkge1xuXHRcdFx0Ly8gQ3VycmVudCBwYWdlIGltcGxpZXMgdGhhdCBvcmRlcj1jdXJyZW50IGFuZCBmaXRsZXI9YXBwbGllZCwgc2luY2UgaXQgaXNcblx0XHRcdC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxuXHRcdFx0Ly8gYXJlXG5cdFx0XHRmb3IgKCBpPXNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LCBpZW49c2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkgOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YS5wdXNoKCBkaXNwbGF5RmlsdGVyZWRbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcgKSB7XG5cdFx0XHRpZiAoIHNlYXJjaCA9PSAnbm9uZScpIHtcblx0XHRcdFx0YSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWFyY2ggPT0gJ2FwcGxpZWQnICkge1xuXHRcdFx0XHRhID0gZGlzcGxheUZpbHRlcmVkLnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VhcmNoID09ICdyZW1vdmVkJyApIHtcblx0XHRcdFx0Ly8gTyhuK20pIHNvbHV0aW9uIGJ5IGNyZWF0aW5nIGEgaGFzaCBtYXBcblx0XHRcdFx0dmFyIGRpc3BsYXlGaWx0ZXJlZE1hcCA9IHt9O1xuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRpc3BsYXlGaWx0ZXJlZC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRkaXNwbGF5RmlsdGVyZWRNYXBbZGlzcGxheUZpbHRlcmVkW2ldXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGEgPSAkLm1hcCggZGlzcGxheU1hc3RlciwgZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEgZGlzcGxheUZpbHRlcmVkTWFwLmhhc093blByb3BlcnR5KGVsKSA/XG5cdFx0XHRcdFx0XHRlbCA6XG5cdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcmRlciA9PSAnaW5kZXgnIHx8IG9yZGVyID09ICdvcmlnaW5hbCcgKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2VhcmNoID09ICdub25lJyApIHtcblx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcblx0XHRcdFx0XHR0bXAgPSAkLmluQXJyYXkoIGksIGRpc3BsYXlGaWx0ZXJlZCApO1xuXHRcblx0XHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHRcdCh0bXAgPj0gMCAgICYmIHNlYXJjaCA9PSAnYXBwbGllZCcpIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcblx0XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBSb3dzXG5cdCAqXG5cdCAqIHt9ICAgICAgICAgIC0gbm8gc2VsZWN0b3IgLSB1c2UgYWxsIGF2YWlsYWJsZSByb3dzXG5cdCAqIHtpbnRlZ2VyfSAgIC0gcm93IGFvRGF0YSBpbmRleFxuXHQgKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcblx0ICoge3N0cmluZ30gICAgLSBqUXVlcnkgc2VsZWN0b3IgdG8gYXBwbHkgdG8gdGhlIFRSIGVsZW1lbnRzXG5cdCAqIHthcnJheX0gICAgIC0galF1ZXJ5IGFycmF5IG9mIG5vZGVzLCBvciBzaW1wbHkgYW4gYXJyYXkgb2YgVFIgbm9kZXNcblx0ICpcblx0ICovXG5cdHZhciBfX3Jvd19zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcblx0e1xuXHRcdHZhciByb3dzO1xuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIHNlbCApIHtcblx0XHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzZWwgKTtcblx0XHRcdHZhciBpLCBpZW47XG5cdFx0XHR2YXIgYW9EYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcblx0XHRcdC8vIFNob3J0IGN1dCAtIHNlbGVjdG9yIGlzIGEgbnVtYmVyIGFuZCBubyBvcHRpb25zIHByb3ZpZGVkIChkZWZhdWx0IGlzXG5cdFx0XHQvLyBhbGwgcmVjb3Jkcywgc28gbm8gbmVlZCB0byBjaGVjayBpZiB0aGUgaW5kZXggaXMgaW4gdGhlcmUsIHNpbmNlIGl0XG5cdFx0XHQvLyBtdXN0IGJlIC0gZGV2IGVycm9yIGlmIHRoZSBpbmRleCBkb2Vzbid0IGV4aXN0KS5cblx0XHRcdGlmICggc2VsSW50ICE9PSBudWxsICYmICEgb3B0cyApIHtcblx0XHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCAhIHJvd3MgKSB7XG5cdFx0XHRcdHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgJC5pbkFycmF5KCBzZWxJbnQsIHJvd3MgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIFNlbGVjdG9yIC0gaW50ZWdlclxuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWwgPT09IG51bGwgfHwgc2VsID09PSB1bmRlZmluZWQgfHwgc2VsID09PSAnJyApIHtcblx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBub25lXG5cdFx0XHRcdHJldHVybiByb3dzO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cblx0XHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuICQubWFwKCByb3dzLCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdFx0dmFyIHJvdyA9IGFvRGF0YVsgaWR4IF07XG5cdFx0XHRcdFx0cmV0dXJuIHNlbCggaWR4LCByb3cuX2FEYXRhLCByb3cublRyICkgPyBpZHggOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBub2RlXG5cdFx0XHRpZiAoIHNlbC5ub2RlTmFtZSApIHtcblx0XHRcdFx0dmFyIHJvd0lkeCA9IHNlbC5fRFRfUm93SW5kZXg7ICAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcblx0XHRcdFx0dmFyIGNlbGxJZHggPSBzZWwuX0RUX0NlbGxJbmRleDtcblx0XG5cdFx0XHRcdGlmICggcm93SWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIHJvdyBpcyBhY3R1YWxseSBzdGlsbCBwcmVzZW50IGluIHRoZSB0YWJsZVxuXHRcdFx0XHRcdHJldHVybiBhb0RhdGFbIHJvd0lkeCBdICYmIGFvRGF0YVsgcm93SWR4IF0ublRyID09PSBzZWwgP1xuXHRcdFx0XHRcdFx0WyByb3dJZHggXSA6XG5cdFx0XHRcdFx0XHRbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggY2VsbElkeCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYW9EYXRhWyBjZWxsSWR4LnJvdyBdICYmIGFvRGF0YVsgY2VsbElkeC5yb3cgXS5uVHIgPT09IHNlbC5wYXJlbnROb2RlID9cblx0XHRcdFx0XHRcdFsgY2VsbElkeC5yb3cgXSA6XG5cdFx0XHRcdFx0XHRbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgaG9zdCA9ICQoc2VsKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0XHRcdHJldHVybiBob3N0Lmxlbmd0aCA/XG5cdFx0XHRcdFx0XHRbIGhvc3QuZGF0YSgnZHQtcm93JykgXSA6XG5cdFx0XHRcdFx0XHRbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIElEIHNlbGVjdG9yLiBXYW50IHRvIGFsd2F5cyBiZSBhYmxlIHRvIHNlbGVjdCByb3dzIGJ5IGlkLCByZWdhcmRsZXNzXG5cdFx0XHQvLyBvZiBpZiB0aGUgdHIgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIG5vdCwgc28gY2FuJ3QgcmVseSB1cG9uXG5cdFx0XHQvLyBqUXVlcnkgaGVyZSAtIGhlbmNlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLiBUaGlzIGRvZXMgbm90IG1hdGNoXG5cdFx0XHQvLyBTaXp6bGUncyBmYXN0IHNlbGVjdG9yIG9yIEhUTUw0IC0gaW4gSFRNTDUgdGhlIElEIGNhbiBiZSBhbnl0aGluZyxcblx0XHRcdC8vIGJ1dCB0byBzZWxlY3QgaXQgdXNpbmcgYSBDU1Mgc2VsZWN0b3IgZW5naW5lIChsaWtlIFNpenpsZSBvclxuXHRcdFx0Ly8gcXVlcnlTZWxlY3QpIGl0IHdvdWxkIG5lZWQgdG8gbmVlZCB0byBiZSBlc2NhcGVkIGZvciBzb21lIGNoYXJhY3RlcnMuXG5cdFx0XHQvLyBEYXRhVGFibGVzIHNpbXBsaWZpZXMgdGhpcyBmb3Igcm93IHNlbGVjdG9ycyBzaW5jZSB5b3UgY2FuIHNlbGVjdFxuXHRcdFx0Ly8gb25seSBhIHJvdy4gQSAjIGluZGljYXRlcyBhbiBpZCBhbnkgYW55dGhpbmcgdGhhdCBmb2xsb3dzIGlzIHRoZSBpZCAtXG5cdFx0XHQvLyB1bmVzY2FwZWQuXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWwgPT09ICdzdHJpbmcnICYmIHNlbC5jaGFyQXQoMCkgPT09ICcjJyApIHtcblx0XHRcdFx0Ly8gZ2V0IHJvdyBpbmRleCBmcm9tIGlkXG5cdFx0XHRcdHZhciByb3dPYmogPSBzZXR0aW5ncy5hSWRzWyBzZWwucmVwbGFjZSggL14jLywgJycgKSBdO1xuXHRcdFx0XHRpZiAoIHJvd09iaiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBbIHJvd09iai5pZHggXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gbmVlZCB0byBmYWxsIHRocm91Z2ggdG8galF1ZXJ5IGluIGNhc2UgdGhlcmUgaXMgRE9NIGlkIHRoYXRcblx0XHRcdFx0Ly8gbWF0Y2hlc1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcblx0XHRcdHZhciBub2RlcyA9IF9yZW1vdmVFbXB0eShcblx0XHRcdFx0X3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICduVHInIClcblx0XHRcdCk7XG5cdFxuXHRcdFx0Ly8gU2VsZWN0b3IgLSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nLCBhcnJheSBvZiBub2RlcyBvciBqUXVlcnkgb2JqZWN0L1xuXHRcdFx0Ly8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxuXHRcdFx0Ly8gaXQgYWxzbyBhbGxvd3MgYXJyYXlzLCBzbyB0aGlzIHdpbGwgY29wZSB3aXRoIGFsbCB0aHJlZSBvcHRpb25zXG5cdFx0XHRyZXR1cm4gJChub2Rlcylcblx0XHRcdFx0LmZpbHRlciggc2VsIClcblx0XHRcdFx0Lm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9EVF9Sb3dJbmRleDtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50b0FycmF5KCk7XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9ydW4oICdyb3cnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSAnJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcblx0XHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblx0XG5cdFx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9fcm93X3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX19yb3dfc2VsZWN0b3I/XG5cdFx0aW5zdC5zZWxlY3Rvci5yb3dzID0gc2VsZWN0b3I7XG5cdFx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblx0XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3dzKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdLm5UciB8fCB1bmRlZmluZWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93cygpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggdHJ1ZSwgJ3Jvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3dzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnX2FEYXRhJyApO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5jYWNoZSgpJywgJ3JvdygpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0XHR2YXIgciA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ3NlYXJjaCcgPyByLl9hRmlsdGVyRGF0YSA6IHIuX2FTb3J0RGF0YTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW52YWxpZGF0ZSgpJywgJ3JvdygpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uICggc3JjICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0X2ZuSW52YWxpZGF0ZSggc2V0dGluZ3MsIHJvdywgc3JjICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmluZGV4ZXMoKScsICdyb3coKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdFx0cmV0dXJuIHJvdztcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaWRzKCknLCAncm93KCkuaWQoKScsIGZ1bmN0aW9uICggaGFzaCApIHtcblx0XHR2YXIgYSA9IFtdO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHQvLyBgaXRlcmF0b3JgIHdpbGwgZHJvcCB1bmRlZmluZWQgdmFsdWVzLCBidXQgaW4gdGhpcyBjYXNlIHdlIHdhbnQgdGhlbVxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Zm9yICggdmFyIGo9MCwgamVuPXRoaXNbaV0ubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHZhciBpZCA9IGNvbnRleHRbaV0ucm93SWRGbiggY29udGV4dFtpXS5hb0RhdGFbIHRoaXNbaV1bal0gXS5fYURhdGEgKTtcblx0XHRcdFx0YS5wdXNoKCAoaGFzaCA9PT0gdHJ1ZSA/ICcjJyA6ICcnICkrIGlkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gbmV3IF9BcGkoIGNvbnRleHQsIGEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5yZW1vdmUoKScsICdyb3coKS5yZW1vdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFxuXHRcdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIHRoYXRJZHggKSB7XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHRcdHZhciByb3dEYXRhID0gZGF0YVsgcm93IF07XG5cdFx0XHR2YXIgaSwgaWVuLCBqLCBqZW47XG5cdFx0XHR2YXIgbG9vcFJvdywgbG9vcENlbGxzO1xuXHRcblx0XHRcdGRhdGEuc3BsaWNlKCByb3csIDEgKTtcblx0XG5cdFx0XHQvLyBVcGRhdGUgdGhlIGNhY2hlZCBpbmRleGVzXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRsb29wUm93ID0gZGF0YVtpXTtcblx0XHRcdFx0bG9vcENlbGxzID0gbG9vcFJvdy5hbkNlbGxzO1xuXHRcblx0XHRcdFx0Ly8gUm93c1xuXHRcdFx0XHRpZiAoIGxvb3BSb3cublRyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdGxvb3BSb3cublRyLl9EVF9Sb3dJbmRleCA9IGk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIENlbGxzXG5cdFx0XHRcdGlmICggbG9vcENlbGxzICE9PSBudWxsICkge1xuXHRcdFx0XHRcdGZvciAoIGo9MCwgamVuPWxvb3BDZWxscy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdGxvb3BDZWxsc1tqXS5fRFRfQ2VsbEluZGV4LnJvdyA9IGk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRGVsZXRlIGZyb20gdGhlIGRpc3BsYXkgYXJyYXlzXG5cdFx0XHRfZm5EZWxldGVJbmRleCggc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLCByb3cgKTtcblx0XHRcdF9mbkRlbGV0ZUluZGV4KCBzZXR0aW5ncy5haURpc3BsYXksIHJvdyApO1xuXHRcdFx0X2ZuRGVsZXRlSW5kZXgoIHRoYXRbIHRoYXRJZHggXSwgcm93LCBmYWxzZSApOyAvLyBtYWludGFpbiBsb2NhbCBpbmRleGVzXG5cdFxuXHRcdFx0Ly8gRm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzIC0gc3VidHJhY3QgdGhlIGRlbGV0ZWQgcm93IGZyb20gdGhlIGNvdW50XG5cdFx0XHRpZiAoIHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPiAwICkge1xuXHRcdFx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5LS07XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGFuICdvdmVyZmxvdycgdGhleSBjYXNlIGZvciBkaXNwbGF5aW5nIHRoZSB0YWJsZVxuXHRcdFx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSByb3cncyBJRCByZWZlcmVuY2UgaWYgdGhlcmUgaXMgb25lXG5cdFx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCByb3dEYXRhLl9hRGF0YSApO1xuXHRcdFx0aWYgKCBpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgc2V0dGluZ3MuYUlkc1sgaWQgXTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRzZXR0aW5ncy5hb0RhdGFbaV0uaWR4ID0gaTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3Jvd3MuYWRkKCknLCBmdW5jdGlvbiAoIHJvd3MgKSB7XG5cdFx0dmFyIG5ld1Jvd3MgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0XHR2YXIgcm93LCBpLCBpZW47XG5cdFx0XHRcdHZhciBvdXQgPSBbXTtcblx0XG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0cm93ID0gcm93c1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCByb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicgKSB7XG5cdFx0XHRcdFx0XHRvdXQucHVzaCggX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBvdXQ7XG5cdFx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCBzbyByb3dzKCkubm9kZXMoKSBldGMgY2FuIGJlIHVzZWRcblx0XHR2YXIgbW9kUm93cyA9IHRoaXMucm93cyggLTEgKTtcblx0XHRtb2RSb3dzLnBvcCgpO1xuXHRcdCQubWVyZ2UoIG1vZFJvd3MsIG5ld1Jvd3MgKTtcblx0XG5cdFx0cmV0dXJuIG1vZFJvd3M7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0XG5cdFxuXHQvKipcblx0ICpcblx0ICovXG5cdF9hcGlfcmVnaXN0ZXIoICdyb3coKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5yb3dzKCBzZWxlY3Rvciwgb3B0cyApICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAncm93KCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gR2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fYURhdGEgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBTZXRcblx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdO1xuXHRcdHJvdy5fYURhdGEgPSBkYXRhO1xuXHRcblx0XHQvLyBJZiB0aGUgRE9NIGhhcyBhbiBpZCwgYW5kIHRoZSBkYXRhIHNvdXJjZSBpcyBhbiBhcnJheVxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YSApICYmIHJvdy5uVHIgJiYgcm93Lm5Uci5pZCApIHtcblx0XHRcdF9mblNldE9iamVjdERhdGFGbiggY3R4WzBdLnJvd0lkICkoIGRhdGEsIHJvdy5uVHIuaWQgKTtcblx0XHR9XG5cdFxuXHRcdC8vIEF1dG9tYXRpY2FsbHkgaW52YWxpZGF0ZVxuXHRcdF9mbkludmFsaWRhdGUoIGN0eFswXSwgdGhpc1swXSwgJ2RhdGEnICk7XG5cdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3JvdygpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0ublRyIHx8IG51bGwgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdyb3cuYWRkKCknLCBmdW5jdGlvbiAoIHJvdyApIHtcblx0XHQvLyBBbGxvdyBhIGpRdWVyeSBvYmplY3QgdG8gYmUgcGFzc2VkIGluIC0gb25seSBhIHNpbmdsZSByb3cgaXMgYWRkZWQgZnJvbVxuXHRcdC8vIGl0IHRob3VnaCAtIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcblx0XHRpZiAoIHJvdyBpbnN0YW5jZW9mICQgJiYgcm93Lmxlbmd0aCApIHtcblx0XHRcdHJvdyA9IHJvd1swXTtcblx0XHR9XG5cdFxuXHRcdHZhciByb3dzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdGlmICggcm93Lm5vZGVOYW1lICYmIHJvdy5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVFInICkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICk7XG5cdFx0fSApO1xuXHRcblx0XHQvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgcm93IHNlbGVjdGVkXG5cdFx0cmV0dXJuIHRoaXMucm93KCByb3dzWzBdICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19hZGQgPSBmdW5jdGlvbiAoIGN0eCwgcm93LCBkYXRhLCBrbGFzcyApXG5cdHtcblx0XHQvLyBDb252ZXJ0IHRvIGFycmF5IG9mIFRSIGVsZW1lbnRzXG5cdFx0dmFyIHJvd3MgPSBbXTtcblx0XHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCByLCBrICkge1xuXHRcdFx0Ly8gUmVjdXJzaW9uIHRvIGFsbG93IGZvciBhcnJheXMgb2YgalF1ZXJ5IG9iamVjdHNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggciApIHx8IHIgaW5zdGFuY2VvZiAkICkge1xuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRhZGRSb3coIHJbaV0sIGsgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHRcdC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcblx0XHRcdGlmICggci5ub2RlTmFtZSAmJiByLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicgKSB7XG5cdFx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdFx0dmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkPjwvdGQ+PC90cj4nKS5hZGRDbGFzcyggayApO1xuXHRcdFx0XHQkKCd0ZCcsIGNyZWF0ZWQpXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBrIClcblx0XHRcdFx0XHQuaHRtbCggciApXG5cdFx0XHRcdFx0WzBdLmNvbFNwYW4gPSBfZm5WaXNibGVDb2x1bW5zKCBjdHggKTtcblx0XG5cdFx0XHRcdHJvd3MucHVzaCggY3JlYXRlZFswXSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGFkZFJvdyggZGF0YSwga2xhc3MgKTtcblx0XG5cdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRyb3cuX2RldGFpbHMuZGV0YWNoKCk7XG5cdFx0fVxuXHRcblx0XHRyb3cuX2RldGFpbHMgPSAkKHJvd3MpO1xuXHRcblx0XHQvLyBJZiB0aGUgY2hpbGRyZW4gd2VyZSBhbHJlYWR5IHNob3duLCB0aGF0IHN0YXRlIHNob3VsZCBiZSByZXRhaW5lZFxuXHRcdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHR2YXIgX19kZXRhaWxzX3JlbW92ZSA9IGZ1bmN0aW9uICggYXBpLCBpZHggKVxuXHR7XG5cdFx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggKSB7XG5cdFx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgaWR4ICE9PSB1bmRlZmluZWQgPyBpZHggOiBhcGlbMF0gXTtcblx0XG5cdFx0XHRpZiAoIHJvdyAmJiByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRcdHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcblx0XG5cdFx0XHRcdHJvdy5fZGV0YWlsc1Nob3cgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJvdy5fZGV0YWlscyA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19kaXNwbGF5ID0gZnVuY3Rpb24gKCBhcGksIHNob3cgKSB7XG5cdFx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggJiYgYXBpLmxlbmd0aCApIHtcblx0XHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBhcGlbMF0gXTtcblx0XG5cdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHNob3c7XG5cdFxuXHRcdFx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfX2RldGFpbHNfZXZlbnRzKCBjdHhbMF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fZGV0YWlsc19ldmVudHMgPSBmdW5jdGlvbiAoIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblx0XHR2YXIgbmFtZXNwYWNlID0gJy5kdC5EVF9kZXRhaWxzJztcblx0XHR2YXIgZHJhd0V2ZW50ID0gJ2RyYXcnK25hbWVzcGFjZTtcblx0XHR2YXIgY29sdmlzRXZlbnQgPSAnY29sdW1uLXZpc2liaWxpdHknK25hbWVzcGFjZTtcblx0XHR2YXIgZGVzdHJveUV2ZW50ID0gJ2Rlc3Ryb3knK25hbWVzcGFjZTtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XG5cdFx0YXBpLm9mZiggZHJhd0V2ZW50ICsnICcrIGNvbHZpc0V2ZW50ICsnICcrIGRlc3Ryb3lFdmVudCApO1xuXHRcblx0XHRpZiAoIF9wbHVjayggZGF0YSwgJ19kZXRhaWxzJyApLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHQvLyBPbiBlYWNoIGRyYXcsIGluc2VydCB0aGUgcmVxdWlyZWQgZWxlbWVudHMgaW50byB0aGUgZG9jdW1lbnRcblx0XHRcdGFwaS5vbiggZHJhd0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0YXBpLnJvd3MoIHtwYWdlOidjdXJyZW50J30gKS5lcSgwKS5lYWNoKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdFx0Ly8gSW50ZXJuYWwgZGF0YSBncmFiXG5cdFx0XHRcdFx0dmFyIHJvdyA9IGRhdGFbIGlkeCBdO1xuXHRcblx0XHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlsc1Nob3cgKSB7XG5cdFx0XHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHQvLyBDb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2UgLSB1cGRhdGUgdGhlIGNvbHNwYW5cblx0XHRcdGFwaS5vbiggY29sdmlzRXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4LCBpZHgsIHZpcyApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBjb2xzcGFuIGZvciB0aGUgZGV0YWlscyByb3dzIChub3RlLCBvbmx5IGlmIGl0IGFscmVhZHkgaGFzXG5cdFx0XHRcdC8vIGEgY29sc3Bhbilcblx0XHRcdFx0dmFyIHJvdywgdmlzaWJsZSA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0cm93ID0gZGF0YVtpXTtcblx0XG5cdFx0XHRcdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRcdFx0XHRyb3cuX2RldGFpbHMuY2hpbGRyZW4oJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIHZpc2libGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XG5cdFx0XHQvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXG5cdFx0XHRhcGkub24oIGRlc3Ryb3lFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVtpXS5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRcdF9fZGV0YWlsc19yZW1vdmUoIGFwaSwgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fTtcblx0XG5cdC8vIFN0cmluZ3MgZm9yIHRoZSBtZXRob2QgbmFtZXMgdG8gaGVscCBtaW5pZmljYXRpb25cblx0dmFyIF9lbXAgPSAnJztcblx0dmFyIF9jaGlsZF9vYmogPSBfZW1wKydyb3coKS5jaGlsZCc7XG5cdHZhciBfY2hpbGRfbXRoID0gX2NoaWxkX29iaisnKCknO1xuXHRcblx0Ly8gZGF0YSBjYW4gYmU6XG5cdC8vICB0clxuXHQvLyAgc3RyaW5nXG5cdC8vICBqUXVlcnkgb3IgYXJyYXkgb2YgYW55IG9mIHRoZSBhYm92ZVxuXHRfYXBpX3JlZ2lzdGVyKCBfY2hpbGRfbXRoLCBmdW5jdGlvbiAoIGRhdGEsIGtsYXNzICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG5cdFx0XHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlscyA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRhdGEgPT09IHRydWUgKSB7XG5cdFx0XHQvLyBzaG93XG5cdFx0XHR0aGlzLmNoaWxkLnNob3coKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRhdGEgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gcmVtb3ZlXG5cdFx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0Ly8gc2V0XG5cdFx0XHRfX2RldGFpbHNfYWRkKCBjdHhbMF0sIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXSwgZGF0YSwga2xhc3MgKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5zaG93KCknLFxuXHRcdF9jaGlsZF9tdGgrJy5zaG93KCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcblx0XSwgZnVuY3Rpb24gKCBzaG93ICkgeyAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIHRydWUgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHRfY2hpbGRfb2JqKycuaGlkZSgpJyxcblx0XHRfY2hpbGRfbXRoKycuaGlkZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5cdF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRcdF9fZGV0YWlsc19kaXNwbGF5KCB0aGlzLCBmYWxzZSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggW1xuXHRcdF9jaGlsZF9vYmorJy5yZW1vdmUoKScsXG5cdFx0X2NoaWxkX210aCsnLnJlbW92ZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5cdF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdFx0X19kZXRhaWxzX3JlbW92ZSggdGhpcyApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggX2NoaWxkX29iaisnLmlzU2hvd24oKScsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0XHQvLyBfZGV0YWlsc1Nob3duIGFzIGZhbHNlIG9yIHVuZGVmaW5lZCB3aWxsIGZhbGwgdGhyb3VnaCB0byByZXR1cm4gZmFsc2Vcblx0XHRcdHJldHVybiBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0uX2RldGFpbHNTaG93IHx8IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIENvbHVtbnNcblx0ICpcblx0ICoge2ludGVnZXJ9ICAgICAgICAgICAtIGNvbHVtbiBpbmRleCAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcblx0ICogXCJ7aW50ZWdlcn06dmlzSWR4XCIgIC0gdmlzaWJsZSBjb2x1bW4gaW5kZXggKGkuZS4gdHJhbnNsYXRlIHRvIGNvbHVtbiBpbmRleCkgICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuXHQgKiBcIntpbnRlZ2VyfTp2aXNpYmxlXCIgLSBhbGlhcyBmb3Ige2ludGVnZXJ9OnZpc0lkeCAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG5cdCAqIFwie3N0cmluZ306bmFtZVwiICAgICAtIGNvbHVtbiBuYW1lXG5cdCAqIFwie3N0cmluZ31cIiAgICAgICAgICAtIGpRdWVyeSBzZWxlY3RvciBvbiBjb2x1bW4gaGVhZGVyIG5vZGVzXG5cdCAqXG5cdCAqL1xuXHRcblx0Ly8gY2FuIGJlIGFuIGFycmF5IG9mIHRoZXNlIGl0ZW1zLCBjb21tYSBzZXBhcmF0ZWQgbGlzdCwgb3IgYW4gYXJyYXkgb2YgY29tbWFcblx0Ly8gc2VwYXJhdGVkIGxpc3RzXG5cdFxuXHR2YXIgX19yZV9jb2x1bW5fc2VsZWN0b3IgPSAvXihbXjpdKyk6KG5hbWV8dmlzSWR4fHZpc2libGUpJC87XG5cdFxuXHRcblx0Ly8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXG5cdC8vIGl0ZXJhdG9yIGNhbGxiYWNrIGluIGNvbHVtbnMoKS5kYXRhKClcblx0dmFyIF9fY29sdW1uRGF0YSA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgcjEsIHIyLCByb3dzICkge1xuXHRcdHZhciBhID0gW107XG5cdFx0Zm9yICggdmFyIHJvdz0wLCBpZW49cm93cy5sZW5ndGggOyByb3c8aWVuIDsgcm93KysgKSB7XG5cdFx0XHRhLnB1c2goIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93c1tyb3ddLCBjb2x1bW4gKSApO1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fTtcblx0XG5cdFxuXHR2YXIgX19jb2x1bW5fc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG5cdHtcblx0XHR2YXJcblx0XHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0XHRuYW1lcyA9IF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApLFxuXHRcdFx0bm9kZXMgPSBfcGx1Y2soIGNvbHVtbnMsICduVGgnICk7XG5cdFxuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0XHR2YXIgc2VsSW50ID0gX2ludFZhbCggcyApO1xuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gYWxsXG5cdFx0XHRpZiAoIHMgPT09ICcnICkge1xuXHRcdFx0XHRyZXR1cm4gX3JhbmdlKCBjb2x1bW5zLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gaW5kZXhcblx0XHRcdGlmICggc2VsSW50ICE9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gWyBzZWxJbnQgPj0gMCA/XG5cdFx0XHRcdFx0c2VsSW50IDogLy8gQ291bnQgZnJvbSBsZWZ0XG5cdFx0XHRcdFx0Y29sdW1ucy5sZW5ndGggKyBzZWxJbnQgLy8gQ291bnQgZnJvbSByaWdodCAoKyBiZWNhdXNlIGl0cyBhIG5lZ2F0aXZlIHZhbHVlKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFNlbGVjdG9yID0gZnVuY3Rpb25cblx0XHRcdGlmICggdHlwZW9mIHMgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcblx0XHRcdFx0cmV0dXJuICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpZHgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcyhcblx0XHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0XHRfX2NvbHVtbkRhdGEoIHNldHRpbmdzLCBpZHgsIDAsIDAsIHJvd3MgKSxcblx0XHRcdFx0XHRcdFx0bm9kZXNbIGlkeCBdXG5cdFx0XHRcdFx0XHQpID8gaWR4IDogbnVsbDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3Jcblx0XHRcdHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdHMubWF0Y2goIF9fcmVfY29sdW1uX3NlbGVjdG9yICkgOlxuXHRcdFx0XHQnJztcblx0XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRzd2l0Y2goIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdGNhc2UgJ3Zpc0lkeCc6XG5cdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XG5cdFx0XHRcdFx0XHR2YXIgaWR4ID0gcGFyc2VJbnQoIG1hdGNoWzFdLCAxMCApO1xuXHRcdFx0XHRcdFx0Ly8gVmlzaWJsZSBpbmRleCBnaXZlbiwgY29udmVydCB0byBjb2x1bW4gaW5kZXhcblx0XHRcdFx0XHRcdGlmICggaWR4IDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgcmlnaHRcblx0XHRcdFx0XHRcdFx0dmFyIHZpc0NvbHVtbnMgPSAkLm1hcCggY29sdW1ucywgZnVuY3Rpb24gKGNvbCxpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbC5iVmlzaWJsZSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIHZpc0NvbHVtbnNbIHZpc0NvbHVtbnMubGVuZ3RoICsgaWR4IF0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENvdW50aW5nIGZyb20gdGhlIGxlZnRcblx0XHRcdFx0XHRcdHJldHVybiBbIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBzZXR0aW5ncywgaWR4ICkgXTtcblx0XG5cdFx0XHRcdFx0Y2FzZSAnbmFtZSc6XG5cdFx0XHRcdFx0XHQvLyBtYXRjaCBieSBuYW1lLiBgbmFtZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0XHRcdHJldHVybiAkLm1hcCggbmFtZXMsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuYW1lID09PSBtYXRjaFsxXSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQ2VsbCBpbiB0aGUgdGFibGUgYm9keVxuXHRcdFx0aWYgKCBzLm5vZGVOYW1lICYmIHMuX0RUX0NlbGxJbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIFsgcy5fRFRfQ2VsbEluZGV4LmNvbHVtbiBdO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgVEggZWxlbWVudHMgZm9yIHRoZSBjb2x1bW5zXG5cdFx0XHR2YXIganFSZXN1bHQgPSAkKCBub2RlcyApXG5cdFx0XHRcdC5maWx0ZXIoIHMgKVxuXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSggdGhpcywgbm9kZXMgKTsgLy8gYG5vZGVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQudG9BcnJheSgpO1xuXHRcblx0XHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE90aGVyd2lzZSBhIG5vZGUgd2hpY2ggbWlnaHQgaGF2ZSBhIGBkdC1jb2x1bW5gIGRhdGEgYXR0cmlidXRlLCBvciBiZVxuXHRcdFx0Ly8gYSBjaGlsZCBvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdHZhciBob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtY29sdW1uXScpO1xuXHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0WyBob3N0LmRhdGEoJ2R0LWNvbHVtbicpIF0gOlxuXHRcdFx0XHRbXTtcblx0XHR9O1xuXHRcblx0XHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ2NvbHVtbicsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cdH07XG5cdFxuXHRcblx0dmFyIF9fc2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKSB7XG5cdFx0dmFyXG5cdFx0XHRjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdFx0Y29sICA9IGNvbHNbIGNvbHVtbiBdLFxuXHRcdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YSxcblx0XHRcdHJvdywgY2VsbHMsIGksIGllbiwgdHI7XG5cdFxuXHRcdC8vIEdldFxuXHRcdGlmICggdmlzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gY29sLmJWaXNpYmxlO1xuXHRcdH1cblx0XG5cdFx0Ly8gU2V0XG5cdFx0Ly8gTm8gY2hhbmdlXG5cdFx0aWYgKCBjb2wuYlZpc2libGUgPT09IHZpcyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGlmICggdmlzICkge1xuXHRcdFx0Ly8gSW5zZXJ0IGNvbHVtblxuXHRcdFx0Ly8gTmVlZCB0byBkZWNpZGUgaWYgd2Ugc2hvdWxkIHVzZSBhcHBlbmRDaGlsZCBvciBpbnNlcnRCZWZvcmVcblx0XHRcdHZhciBpbnNlcnRCZWZvcmUgPSAkLmluQXJyYXkoIHRydWUsIF9wbHVjayhjb2xzLCAnYlZpc2libGUnKSwgY29sdW1uKzEgKTtcblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHR0ciA9IGRhdGFbaV0ublRyO1xuXHRcdFx0XHRjZWxscyA9IGRhdGFbaV0uYW5DZWxscztcblx0XG5cdFx0XHRcdGlmICggdHIgKSB7XG5cdFx0XHRcdFx0Ly8gaW5zZXJ0QmVmb3JlIGNhbiBhY3QgbGlrZSBhcHBlbmRDaGlsZCBpZiAybmQgYXJnIGlzIG51bGxcblx0XHRcdFx0XHR0ci5pbnNlcnRCZWZvcmUoIGNlbGxzWyBjb2x1bW4gXSwgY2VsbHNbIGluc2VydEJlZm9yZSBdIHx8IG51bGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlbW92ZSBjb2x1bW5cblx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbHVtbiApICkuZGV0YWNoKCk7XG5cdFx0fVxuXHRcblx0XHQvLyBDb21tb24gYWN0aW9uc1xuXHRcdGNvbC5iVmlzaWJsZSA9IHZpcztcblx0fTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1ucygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0XHQvLyBhcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHNlbGVjdG9yID0gJyc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRvcHRzID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9ICcnO1xuXHRcdH1cblx0XG5cdFx0b3B0cyA9IF9zZWxlY3Rvcl9vcHRzKCBvcHRzICk7XG5cdFxuXHRcdHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHJldHVybiBfX2NvbHVtbl9zZWxlY3Rvciggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzICk7XG5cdFx0fSwgMSApO1xuXHRcblx0XHQvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9yb3dfc2VsZWN0b3I/XG5cdFx0aW5zdC5zZWxlY3Rvci5jb2xzID0gc2VsZWN0b3I7XG5cdFx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblx0XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UaDtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UZjtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YSgpJywgJ2NvbHVtbigpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgX19jb2x1bW5EYXRhLCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YVNyYygpJywgJ2NvbHVtbigpLmRhdGFTcmMoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5tRGF0YTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXG5cdFx0XHRcdHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxuXHRcdFx0KTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdhbkNlbGxzJywgY29sdW1uICkgO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS52aXNpYmxlKCknLCAnY29sdW1uKCkudmlzaWJsZSgpJywgZnVuY3Rpb24gKCB2aXMsIGNhbGMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciByZXQgPSB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1sgY29sdW1uIF0uYlZpc2libGU7XG5cdFx0XHR9IC8vIGVsc2Vcblx0XHRcdF9fc2V0Q29sdW1uVmlzKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKTtcblx0XHR9ICk7XG5cdFxuXHRcdC8vIEdyb3VwIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2VzXG5cdFx0aWYgKCB2aXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRcdC8vIFJlZHJhdyB0aGUgaGVhZGVyIGFmdGVyIGNoYW5nZXNcblx0XHRcdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdFx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyICk7XG5cdFx0XG5cdFx0XHRcdC8vIFVwZGF0ZSBjb2xzcGFuIGZvciBubyByZWNvcmRzIGRpc3BsYXkuIENoaWxkIHJvd3MgYW5kIGV4dGVuc2lvbnMgd2lsbCB1c2UgdGhlaXIgb3duXG5cdFx0XHRcdC8vIGxpc3RlbmVycyB0byBkbyB0aGlzIC0gb25seSBuZWVkIHRvIHVwZGF0ZSB0aGUgZW1wdHkgdGFibGUgaXRlbSBoZXJlXG5cdFx0XHRcdGlmICggISBzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoICkge1xuXHRcdFx0XHRcdCQoc2V0dGluZ3MublRCb2R5KS5maW5kKCd0ZFtjb2xzcGFuXScpLmF0dHIoJ2NvbHNwYW4nLCBfZm5WaXNibGVDb2x1bW5zKHNldHRpbmdzKSk7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdFx0Ly8gU2Vjb25kIGxvb3Agb25jZSB0aGUgZmlyc3QgaXMgZG9uZSBmb3IgZXZlbnRzXG5cdFx0XHRcdHRoYXQuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi12aXNpYmlsaXR5JywgW3NldHRpbmdzLCBjb2x1bW4sIHZpcywgY2FsY10gKTtcblx0XHRcdFx0fSApO1xuXHRcblx0XHRcdFx0aWYgKCBjYWxjID09PSB1bmRlZmluZWQgfHwgY2FsYyApIHtcblx0XHRcdFx0XHR0aGF0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHJldDtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5pbmRleGVzKCknLCAnY29sdW1uKCkuaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiB0eXBlID09PSAndmlzaWJsZScgP1xuXHRcdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApIDpcblx0XHRcdFx0Y29sdW1uO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NvbHVtbnMuYWRqdXN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY29sdW1uLmluZGV4KCknLCBmdW5jdGlvbiAoIHR5cGUsIGlkeCApIHtcblx0XHRpZiAoIHRoaXMuY29udGV4dC5sZW5ndGggIT09IDAgKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcblx0XHRcdGlmICggdHlwZSA9PT0gJ2Zyb21WaXNpYmxlJyB8fCB0eXBlID09PSAndG9EYXRhJyApIHtcblx0XHRcdFx0cmV0dXJuIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBjdHgsIGlkeCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdmcm9tRGF0YScgfHwgdHlwZSA9PT0gJ3RvVmlzaWJsZScgKSB7XG5cdFx0XHRcdHJldHVybiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggY3R4LCBpZHggKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjb2x1bW4oKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jb2x1bW5zKCBzZWxlY3Rvciwgb3B0cyApICk7XG5cdH0gKTtcblx0XG5cdHZhciBfX2NlbGxfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG5cdHtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0XHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0XHR2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoIF9wbHVja19vcmRlciggZGF0YSwgcm93cywgJ2FuQ2VsbHMnICkgKTtcblx0XHR2YXIgYWxsQ2VsbHMgPSAkKF9mbGF0dGVuKCBbXSwgY2VsbHMgKSk7XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdFx0dmFyIGEsIGksIGllbiwgaiwgbywgaG9zdDtcblx0XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRcdHZhciBmblNlbGVjdG9yID0gdHlwZW9mIHMgPT09ICdmdW5jdGlvbic7XG5cdFxuXHRcdFx0aWYgKCBzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCB8fCBmblNlbGVjdG9yICkge1xuXHRcdFx0XHQvLyBBbGwgY2VsbHMgYW5kIGZ1bmN0aW9uIHNlbGVjdG9yc1xuXHRcdFx0XHRhID0gW107XG5cdFxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cdFxuXHRcdFx0XHRcdGZvciAoIGo9MCA7IGo8Y29sdW1ucyA7IGorKyApIHtcblx0XHRcdFx0XHRcdG8gPSB7XG5cdFx0XHRcdFx0XHRcdHJvdzogcm93LFxuXHRcdFx0XHRcdFx0XHRjb2x1bW46IGpcblx0XHRcdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBmblNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdGhvc3QgPSBkYXRhWyByb3cgXTtcblx0XG5cdFx0XHRcdFx0XHRcdGlmICggcyggbywgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgaiksIGhvc3QuYW5DZWxscyA/IGhvc3QuYW5DZWxsc1tqXSA6IG51bGwgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRhLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlbGVjdG9yIC0gYWxsXG5cdFx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFNlbGVjdG9yIC0gaW5kZXhcblx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzICkgKSB7XG5cdFx0XHRcdC8vIFZhbGlkIGNlbGwgaW5kZXggYW5kIGl0cyBpbiB0aGUgYXJyYXkgb2Ygc2VsZWN0YWJsZSByb3dzXG5cdFx0XHRcdHJldHVybiBzLmNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIHMucm93ICE9PSB1bmRlZmluZWQgJiYgJC5pbkFycmF5KCBzLnJvdywgcm93cyApICE9PSAtMSA/XG5cdFx0XHRcdFx0W3NdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBmaWx0ZXJlZCBjZWxsc1xuXHRcdFx0dmFyIGpxUmVzdWx0ID0gYWxsQ2VsbHNcblx0XHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHRcdC5tYXAoIGZ1bmN0aW9uIChpLCBlbCkge1xuXHRcdFx0XHRcdHJldHVybiB7IC8vIHVzZSBhIG5ldyBvYmplY3QsIGluIGNhc2Ugc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZXNcblx0XHRcdFx0XHRcdHJvdzogICAgZWwuX0RUX0NlbGxJbmRleC5yb3csXG5cdFx0XHRcdFx0XHRjb2x1bW46IGVsLl9EVF9DZWxsSW5kZXguY29sdW1uXG5cdCBcdFx0XHRcdH07XG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQudG9BcnJheSgpO1xuXHRcblx0XHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIE90aGVyd2lzZSB0aGUgc2VsZWN0b3IgaXMgYSBub2RlLCBhbmQgdGhlcmUgaXMgb25lIGxhc3Qgb3B0aW9uIC0gdGhlXG5cdFx0XHQvLyBlbGVtZW50IG1pZ2h0IGJlIGEgY2hpbGQgb2YgYW4gZWxlbWVudCB3aGljaCBoYXMgZHQtcm93IGFuZCBkdC1jb2x1bW5cblx0XHRcdC8vIGRhdGEgYXR0cmlidXRlc1xuXHRcdFx0aG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcblx0XHRcdHJldHVybiBob3N0Lmxlbmd0aCA/XG5cdFx0XHRcdFsge1xuXHRcdFx0XHRcdHJvdzogaG9zdC5kYXRhKCdkdC1yb3cnKSxcblx0XHRcdFx0XHRjb2x1bW46IGhvc3QuZGF0YSgnZHQtY29sdW1uJylcblx0XHRcdFx0fSBdIDpcblx0XHRcdFx0W107XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9ydW4oICdjZWxsJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblx0fTtcblx0XG5cdFxuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxscygpJywgZnVuY3Rpb24gKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggcm93U2VsZWN0b3IgKSApIHtcblx0XHRcdC8vIEluZGV4ZXNcblx0XHRcdGlmICggcm93U2VsZWN0b3Iucm93ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIFNlbGVjdG9yIG9wdGlvbnMgaW4gZmlyc3QgcGFyYW1ldGVyXG5cdFx0XHRcdG9wdHMgPSByb3dTZWxlY3Rvcjtcblx0XHRcdFx0cm93U2VsZWN0b3IgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIENlbGwgaW5kZXggb2JqZWN0cyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBjb2x1bW5TZWxlY3RvciApICkge1xuXHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ2VsbCBzZWxlY3RvclxuXHRcdGlmICggY29sdW1uU2VsZWN0b3IgPT09IG51bGwgfHwgY29sdW1uU2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0XHRyZXR1cm4gX19jZWxsX3NlbGVjdG9yKCBzZXR0aW5ncywgcm93U2VsZWN0b3IsIF9zZWxlY3Rvcl9vcHRzKCBvcHRzICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFxuXHRcdC8vIFRoZSBkZWZhdWx0IGJ1aWx0IGluIG9wdGlvbnMgbmVlZCB0byBhcHBseSB0byByb3cgYW5kIGNvbHVtbnNcblx0XHR2YXIgaW50ZXJuYWxPcHRzID0gb3B0cyA/IHtcblx0XHRcdHBhZ2U6IG9wdHMucGFnZSxcblx0XHRcdG9yZGVyOiBvcHRzLm9yZGVyLFxuXHRcdFx0c2VhcmNoOiBvcHRzLnNlYXJjaFxuXHRcdH0gOiB7fTtcblx0XG5cdFx0Ly8gUm93ICsgY29sdW1uIHNlbGVjdG9yXG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0XHR2YXIgcm93cyA9IHRoaXMucm93cyggcm93U2VsZWN0b3IsIGludGVybmFsT3B0cyApO1xuXHRcdHZhciBpLCBpZW4sIGosIGplbjtcblx0XG5cdFx0dmFyIGNlbGxzTm9PcHRzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaWR4ICkge1xuXHRcdFx0dmFyIGEgPSBbXTtcblx0XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzW2lkeF0ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGo9MCwgamVuPWNvbHVtbnNbaWR4XS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRcdHJvdzogICAgcm93c1tpZHhdW2ldLFxuXHRcdFx0XHRcdFx0Y29sdW1uOiBjb2x1bW5zW2lkeF1bal1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9LCAxICk7XG5cdFxuXHRcdC8vIFRoZXJlIGlzIGN1cnJlbnRseSBvbmx5IG9uZSBleHRlbnNpb24gd2hpY2ggdXNlcyBhIGNlbGwgc2VsZWN0b3IgZXh0ZW5zaW9uXG5cdFx0Ly8gSXQgaXMgYSBfbWFqb3JfIHBlcmZvcm1hbmNlIGRyYWcgdG8gcnVuIHRoaXMgaWYgaXQgaXNuJ3QgbmVlZGVkLCBzbyB0aGlzIGlzXG5cdFx0Ly8gYW4gZXh0ZW5zaW9uIHNwZWNpZmljIGNoZWNrIGF0IHRoZSBtb21lbnRcblx0XHR2YXIgY2VsbHMgPSBvcHRzICYmIG9wdHMuc2VsZWN0ZWQgP1xuXHRcdFx0dGhpcy5jZWxscyggY2VsbHNOb09wdHMsIG9wdHMgKSA6XG5cdFx0XHRjZWxsc05vT3B0cztcblx0XG5cdFx0JC5leHRlbmQoIGNlbGxzLnNlbGVjdG9yLCB7XG5cdFx0XHRjb2xzOiBjb2x1bW5TZWxlY3Rvcixcblx0XHRcdHJvd3M6IHJvd1NlbGVjdG9yLFxuXHRcdFx0b3B0czogb3B0c1xuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGNlbGxzO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkubm9kZXMoKScsICdjZWxsKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdO1xuXHRcblx0XHRcdHJldHVybiBkYXRhICYmIGRhdGEuYW5DZWxscyA/XG5cdFx0XHRcdGRhdGEuYW5DZWxsc1sgY29sdW1uIF0gOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NlbGxzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKTtcblx0XHR9LCAxICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jYWNoZSgpJywgJ2NlbGwoKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdWyB0eXBlIF1bIGNvbHVtbiBdO1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvdywgY29sdW1uLCB0eXBlICk7XG5cdFx0fSwgMSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW5kZXhlcygpJywgJ2NlbGwoKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cm93OiByb3csXG5cdFx0XHRcdGNvbHVtbjogY29sdW1uLFxuXHRcdFx0XHRjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApXG5cdFx0XHR9O1xuXHRcdH0sIDEgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMsIGNvbHVtbiApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnY2VsbCgpJywgZnVuY3Rpb24gKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jZWxscyggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdjZWxsKCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFx0dmFyIGNlbGwgPSB0aGlzWzBdO1xuXHRcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIEdldFxuXHRcdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgY2VsbC5sZW5ndGggP1xuXHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4gKSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cdFxuXHRcdC8vIFNldFxuXHRcdF9mblNldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiwgZGF0YSApO1xuXHRcdF9mbkludmFsaWRhdGUoIGN0eFswXSwgY2VsbFswXS5yb3csICdkYXRhJywgY2VsbFswXS5jb2x1bW4gKTtcblx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCBjdXJyZW50IG9yZGVyaW5nIChzb3J0aW5nKSB0aGF0IGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7YXJyYXl9IDJEIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvcnRpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdFxuXHQgKiAgIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuIEVhY2ggZWxlbWVudCBpbiB0aGUgcGFyZW50IGFycmF5IHJlcHJlc2VudHNcblx0ICogICBhIGNvbHVtbiBiZWluZyBzb3J0ZWQgdXBvbiAoaS5lLiBtdWx0aS1zb3J0aW5nIHdpdGggdHdvIGNvbHVtbnMgd291bGQgaGF2ZVxuXHQgKiAgIDIgaW5uZXIgYXJyYXlzKS4gVGhlIGlubmVyIGFycmF5cyBtYXkgaGF2ZSAyIG9yIDMgZWxlbWVudHMuIFRoZSBmaXJzdCBpc1xuXHQgKiAgIHRoZSBjb2x1bW4gaW5kZXggdGhhdCB0aGUgc29ydGluZyBjb25kaXRpb24gYXBwbGllcyB0bywgdGhlIHNlY29uZCBpcyB0aGVcblx0ICogICBkaXJlY3Rpb24gb2YgdGhlIHNvcnQgKGBkZXNjYCBvciBgYXNjYCkgYW5kLCBvcHRpb25hbGx5LCB0aGUgdGhpcmQgaXMgdGhlXG5cdCAqICAgaW5kZXggb2YgdGhlIHNvcnRpbmcgb3JkZXIgZnJvbSB0aGUgYGNvbHVtbi5zb3J0aW5nYCBpbml0aWFsaXNhdGlvbiBhcnJheS5cblx0ICovLyoqXG5cdCAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cblx0ICpcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBvcmRlciBDb2x1bW4gaW5kZXggdG8gc29ydCB1cG9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIERpcmVjdGlvbiBvZiB0aGUgc29ydCB0byBiZSBhcHBsaWVkIChgYXNjYCBvciBgZGVzY2ApXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAxRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG5cdCAqIEBwYXJhbSB7YXJyYXl9IFsuLi5dIE9wdGlvbmFsIGFkZGl0aW9uYWwgc29ydGluZyBjb25kaXRpb25zXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi8vKipcblx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fSBvcmRlciAyRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG5cdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJ29yZGVyKCknLCBmdW5jdGlvbiAoIG9yZGVyLCBkaXIgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XG5cdFx0aWYgKCBvcmRlciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gZ2V0XG5cdFx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdGN0eFswXS5hYVNvcnRpbmcgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXHRcblx0XHQvLyBzZXRcblx0XHRpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHQvLyBTaW1wbGUgY29sdW1uIC8gZGlyZWN0aW9uIHBhc3NlZCBpblxuXHRcdFx0b3JkZXIgPSBbIFsgb3JkZXIsIGRpciBdIF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcmRlci5sZW5ndGggJiYgISBBcnJheS5pc0FycmF5KCBvcmRlclswXSApICkge1xuXHRcdFx0Ly8gQXJndW1lbnRzIHBhc3NlZCBpbiAobGlzdCBvZiAxRCBhcnJheXMpXG5cdFx0XHRvcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlIGEgMkQgYXJyYXkgd2FzIHBhc3NlZCBpblxuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IG9yZGVyLnNsaWNlKCk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0LyoqXG5cdCAqIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudCBmb3IgYSBnaXZlbiBjb2x1bW5cblx0ICpcblx0ICogQHBhcmFtIHtub2RlfGpRdWVyeXxzdHJpbmd9IG5vZGUgSWRlbnRpZmllciBmb3IgdGhlIGVsZW1lbnQocykgdG8gYXR0YWNoIHRoZVxuXHQgKiAgIGxpc3RlbmVyIHRvLiBUaGlzIGNhbiB0YWtlIHRoZSBmb3JtIG9mIGEgc2luZ2xlIERPTSBub2RlLCBhIGpRdWVyeVxuXHQgKiAgIGNvbGxlY3Rpb24gb2Ygbm9kZXMgb3IgYSBqUXVlcnkgc2VsZWN0b3Igd2hpY2ggd2lsbCBpZGVudGlmeSB0aGUgbm9kZShzKS5cblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBjb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gc29ydCBpcyBydW5cblx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG5cdCAqL1xuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIubGlzdGVuZXIoKScsIGZ1bmN0aW9uICggbm9kZSwgY29sdW1uLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lciggc2V0dGluZ3MsIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2sgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnb3JkZXIuZml4ZWQoKScsIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdGlmICggISBzZXQgKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcdFx0dmFyIGZpeGVkID0gY3R4Lmxlbmd0aCA/XG5cdFx0XHRcdGN0eFswXS5hYVNvcnRpbmdGaXhlZCA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSggZml4ZWQgKSA/XG5cdFx0XHRcdHsgcHJlOiBmaXhlZCB9IDpcblx0XHRcdFx0Zml4ZWQ7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gJC5leHRlbmQoIHRydWUsIHt9LCBzZXQgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG5cdF9hcGlfcmVnaXN0ZXIoIFtcblx0XHQnY29sdW1ucygpLm9yZGVyKCknLFxuXHRcdCdjb2x1bW4oKS5vcmRlcigpJ1xuXHRdLCBmdW5jdGlvbiAoIGRpciApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpICkge1xuXHRcdFx0dmFyIHNvcnQgPSBbXTtcblx0XG5cdFx0XHQkLmVhY2goIHRoYXRbaV0sIGZ1bmN0aW9uIChqLCBjb2wpIHtcblx0XHRcdFx0c29ydC5wdXNoKCBbIGNvbCwgZGlyIF0gKTtcblx0XHRcdH0gKTtcblx0XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBzb3J0O1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc2VhcmNoKCknLCBmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRcblx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBnZXRcblx0XHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdFx0Y3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblx0XG5cdFx0Ly8gc2V0XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCB7XG5cdFx0XHRcdFwic1NlYXJjaFwiOiBpbnB1dCtcIlwiLFxuXHRcdFx0XHRcImJSZWdleFwiOiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0fSApLCAxICk7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlclBsdXJhbChcblx0XHQnY29sdW1ucygpLnNlYXJjaCgpJyxcblx0XHQnY29sdW1uKCkuc2VhcmNoKCknLFxuXHRcdGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdHZhciBwcmVTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdFxuXHRcdFx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0XG5cdFx0XHRcdFx0cmV0dXJuIHByZVNlYXJjaFsgY29sdW1uIF0uc1NlYXJjaDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gc2V0XG5cdFx0XHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCB7XG5cdFx0XHRcdFx0XCJzU2VhcmNoXCI6IGlucHV0K1wiXCIsXG5cdFx0XHRcdFx0XCJiUmVnZXhcIjogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHRcdH0gKTtcblx0XG5cdFx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCAxICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHQpO1xuXHRcblx0Lypcblx0ICogU3RhdGUgQVBJIG1ldGhvZHNcblx0ICovXG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5jbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gU2F2ZSBhbiBlbXB0eSBvYmplY3Rcblx0XHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywge30gKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuXHRcdFx0dGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XG5cdFx0XHRudWxsO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ3N0YXRlLnNhdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXG5cdCAqIHVzZWQsIGluIG9yZGVyIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuXHQgKlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cblx0ICogICAgTm90ZSB0aGF0IHRoZSBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG5cdCAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxuXHQgKiAgICBzdWl0YWJsZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuXHQgKi9cblx0RGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uIClcblx0e1xuXHRcdHZhciBhVGhpcyA9IERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGFUaGF0ID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuXHRcdHZhciBpVGhpcywgaVRoYXQ7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGlMZW49YVRoYXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0aVRoaXMgPSBwYXJzZUludCggYVRoaXNbaV0sIDEwICkgfHwgMDtcblx0XHRcdGlUaGF0ID0gcGFyc2VJbnQoIGFUaGF0W2ldLCAxMCApIHx8IDA7XG5cdFxuXHRcdFx0Ly8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuXHRcdFx0aWYgKGlUaGlzID09PSBpVGhhdCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBQYXJ0cyBhcmUgZGlmZmVyZW50LCByZXR1cm4gaW1tZWRpYXRlbHlcblx0XHRcdHJldHVybiBpVGhpcyA+IGlUaGF0O1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXG5cdCAqXG5cdCAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcblx0ICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxuXHQgKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG5cdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxuXHQgKiAgQHN0YXRpY1xuXHQgKiAgQGR0b3B0IEFQSS1TdGF0aWNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH1cblx0ICovXG5cdERhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IERhdGFUYWJsZS5mbklzRGF0YVRhYmxlID0gZnVuY3Rpb24gKCB0YWJsZSApXG5cdHtcblx0XHR2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcblx0XHR2YXIgaXMgPSBmYWxzZTtcblx0XG5cdFx0aWYgKCB0YWJsZSBpbnN0YW5jZW9mIERhdGFUYWJsZS5BcGkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFxuXHRcdCQuZWFjaCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAoaSwgbykge1xuXHRcdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0XHR2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcblx0XG5cdFx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdFx0aXMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XG5cdFx0cmV0dXJuIGlzO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cblx0ICogc2VsZWN0IHRvIGdldCBvbmx5IGN1cnJlbnRseSB2aXNpYmxlIHRhYmxlcy5cblx0ICpcblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxuXHQgKiAgICBvciB2aXNpYmxlIHRhYmxlcyBvbmx5LlxuXHQgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG5cdCAqICAgIERhdGFUYWJsZXNcblx0ICogIEBzdGF0aWNcblx0ICogIEBkdG9wdCBBUEktU3RhdGljXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdERhdGFUYWJsZS50YWJsZXMgPSBEYXRhVGFibGUuZm5UYWJsZXMgPSBmdW5jdGlvbiAoIHZpc2libGUgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IGZhbHNlO1xuXHRcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmlzaWJsZSApICkge1xuXHRcdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0XHR2aXNpYmxlID0gdmlzaWJsZS52aXNpYmxlO1xuXHRcdH1cblx0XG5cdFx0dmFyIGEgPSAkLm1hcCggRGF0YVRhYmxlLnNldHRpbmdzLCBmdW5jdGlvbiAobykge1xuXHRcdFx0aWYgKCAhdmlzaWJsZSB8fCAodmlzaWJsZSAmJiAkKG8ublRhYmxlKS5pcygnOnZpc2libGUnKSkgKSB7XG5cdFx0XHRcdHJldHVybiBvLm5UYWJsZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFxuXHRcdHJldHVybiBhcGkgP1xuXHRcdFx0bmV3IF9BcGkoIGEgKSA6XG5cdFx0XHRhO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xuXHQgKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcblx0ICogZWl0aGVyIHRoZSAxLjkgc3R5bGUgSHVuZ2FyaWFuIG5vdGF0aW9uLCBvciB0aGUgMS4xMCsgc3R5bGUgY2FtZWxDYXNlXG5cdCAqIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcblx0ICogICAgbWFwcGVkLlxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG5cdCAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuXHQgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcblx0ICogICAgd29uJ3QgYmUuXG5cdCAqL1xuXHREYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XG5cdFxuXHRcblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0X2FwaV9yZWdpc3RlciggJyQoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdFx0dmFyXG5cdFx0XHRyb3dzICAgPSB0aGlzLnJvd3MoIG9wdHMgKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3Ncblx0XHRcdGpxUm93cyA9ICQocm93cyk7XG5cdFxuXHRcdHJldHVybiAkKCBbXS5jb25jYXQoXG5cdFx0XHRqcVJvd3MuZmlsdGVyKCBzZWxlY3RvciApLnRvQXJyYXkoKSxcblx0XHRcdGpxUm93cy5maW5kKCBzZWxlY3RvciApLnRvQXJyYXkoKVxuXHRcdCkgKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG5cdCQuZWFjaCggWyAnb24nLCAnb25lJywgJ29mZicgXSwgZnVuY3Rpb24gKGksIGtleSkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIGtleSsnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovICkge1xuXHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcblx0XHRcdC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdGFyZ3NbMF0gPSAkLm1hcCggYXJnc1swXS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0XHRyZXR1cm4gISBlLm1hdGNoKC9cXC5kdFxcYi8pID9cblx0XHRcdFx0XHRlKycuZHQnIDpcblx0XHRcdFx0XHRlO1xuXHRcdFx0XHR9ICkuam9pbiggJyAnICk7XG5cdFxuXHRcdFx0dmFyIGluc3QgPSAkKCB0aGlzLnRhYmxlcygpLm5vZGVzKCkgKTtcblx0XHRcdGluc3Rba2V5XS5hcHBseSggaW5zdCwgYXJncyApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0X2FwaV9yZWdpc3RlciggJ2NsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdzZXR0aW5ncygpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQgKTtcblx0fSApO1xuXHRcblx0XG5cdF9hcGlfcmVnaXN0ZXIoICdpbml0KCknLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHRcdH0gKS5mbGF0dGVuKCk7XG5cdH0gKTtcblx0XG5cdFxuXHRfYXBpX3JlZ2lzdGVyKCAnZGVzdHJveSgpJywgZnVuY3Rpb24gKCByZW1vdmUgKSB7XG5cdFx0cmVtb3ZlID0gcmVtb3ZlIHx8IGZhbHNlO1xuXHRcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBvcmlnICAgICAgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgY2xhc3NlcyAgID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XHR2YXIgdGFibGUgICAgID0gc2V0dGluZ3MublRhYmxlO1xuXHRcdFx0dmFyIHRib2R5ICAgICA9IHNldHRpbmdzLm5UQm9keTtcblx0XHRcdHZhciB0aGVhZCAgICAgPSBzZXR0aW5ncy5uVEhlYWQ7XG5cdFx0XHR2YXIgdGZvb3QgICAgID0gc2V0dGluZ3MublRGb290O1xuXHRcdFx0dmFyIGpxVGFibGUgICA9ICQodGFibGUpO1xuXHRcdFx0dmFyIGpxVGJvZHkgICA9ICQodGJvZHkpO1xuXHRcdFx0dmFyIGpxV3JhcHBlciA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cdFx0XHR2YXIgcm93cyAgICAgID0gJC5tYXAoIHNldHRpbmdzLmFvRGF0YSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIublRyOyB9ICk7XG5cdFx0XHR2YXIgaSwgaWVuO1xuXHRcblx0XHRcdC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXG5cdFx0XHQvLyBzaG91bGQgYmUgdGFrZW5cblx0XHRcdHNldHRpbmdzLmJEZXN0cm95aW5nID0gdHJ1ZTtcblx0XG5cdFx0XHQvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSApO1xuXHRcblx0XHRcdC8vIElmIG5vdCBiZWluZyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LCBtYWtlIGFsbCBjb2x1bW5zIHZpc2libGVcblx0XHRcdGlmICggISByZW1vdmUgKSB7XG5cdFx0XHRcdG5ldyBfQXBpKCBzZXR0aW5ncyApLmNvbHVtbnMoKS52aXNpYmxlKCB0cnVlICk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gQmxpdHogYWxsIGBEVGAgbmFtZXNwYWNlZCBldmVudHMgKHRoZXNlIGFyZSBpbnRlcm5hbCBldmVudHMsIHRoZVxuXHRcdFx0Ly8gbG93ZXJjYXNlLCBgZHRgIGV2ZW50cyBhcmUgdXNlciBzdWJzY3JpYmVkIGFuZCB0aGV5IGFyZSByZXNwb25zaWJsZVxuXHRcdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRcdGpxV3JhcHBlci5vZmYoJy5EVCcpLmZpbmQoJzpub3QodGJvZHkgKiknKS5vZmYoJy5EVCcpO1xuXHRcdFx0JCh3aW5kb3cpLm9mZignLkRULScrc2V0dGluZ3Muc0luc3RhbmNlKTtcblx0XG5cdFx0XHQvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxuXHRcdFx0aWYgKCB0YWJsZSAhPSB0aGVhZC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0XHRqcVRhYmxlLmFwcGVuZCggdGhlYWQgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHRmb290ICYmIHRhYmxlICE9IHRmb290LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3Rmb290JykuZGV0YWNoKCk7XG5cdFx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSBbXTtcblx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApO1xuXHRcblx0XHRcdCQoIHJvd3MgKS5yZW1vdmVDbGFzcyggc2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcblx0XHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKS5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zU29ydGFibGUrJyAnK1xuXHRcdFx0XHRjbGFzc2VzLnNTb3J0YWJsZUFzYysnICcrY2xhc3Nlcy5zU29ydGFibGVEZXNjKycgJytjbGFzc2VzLnNTb3J0YWJsZU5vbmVcblx0XHRcdCk7XG5cdFxuXHRcdFx0Ly8gQWRkIHRoZSBUUiBlbGVtZW50cyBiYWNrIGludG8gdGhlIHRhYmxlIGluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0XHRqcVRib2R5LmFwcGVuZCggcm93cyApO1xuXHRcblx0XHRcdC8vIFJlbW92ZSB0aGUgRGF0YVRhYmxlcyBnZW5lcmF0ZWQgbm9kZXMsIGV2ZW50cyBhbmQgY2xhc3Nlc1xuXHRcdFx0dmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuXHRcdFx0anFUYWJsZVsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFx0XHRqcVdyYXBwZXJbIHJlbW92ZWRNZXRob2QgXSgpO1xuXHRcblx0XHRcdC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdFx0aWYgKCAhIHJlbW92ZSAmJiBvcmlnICkge1xuXHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSApO1xuXHRcblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXG5cdFx0XHRcdC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcblx0XHRcdFx0anFUYWJsZVxuXHRcdFx0XHRcdC5jc3MoICd3aWR0aCcsIHNldHRpbmdzLnNEZXN0cm95V2lkdGggKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zVGFibGUgKTtcblx0XG5cdFx0XHRcdC8vIElmIHRoZSB3ZXJlIG9yaWdpbmFsbHkgc3RyaXBlIGNsYXNzZXMgLSB0aGVuIHdlIGFkZCB0aGVtIGJhY2sgaGVyZS5cblx0XHRcdFx0Ly8gTm90ZSB0aGlzIGlzIG5vdCBmb29sIHByb29mIChmb3IgZXhhbXBsZSBpZiBub3QgYWxsIHJvd3MgaGFkIHN0cmlwZVxuXHRcdFx0XHQvLyBjbGFzc2VzIC0gYnV0IGl0J3MgYSBnb29kIGVmZm9ydCB3aXRob3V0IGdldHRpbmcgY2FycmllZCBhd2F5XG5cdFx0XHRcdGllbiA9IHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMubGVuZ3RoO1xuXHRcblx0XHRcdFx0aWYgKCBpZW4gKSB7XG5cdFx0XHRcdFx0anFUYm9keS5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKCBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzW2kgJSBpZW5dICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MgKTtcblx0XHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdFx0RGF0YVRhYmxlLnNldHRpbmdzLnNwbGljZSggaWR4LCAxICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cdFxuXHRcblx0Ly8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuXHQkLmVhY2goIFsgJ2NvbHVtbicsICdyb3cnLCAnY2VsbCcgXSwgZnVuY3Rpb24gKCBpLCB0eXBlICkge1xuXHRcdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xuXHRcdFx0dmFyIGFwaSA9IHRoaXM7XG5cdFxuXHRcdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoIHR5cGUsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQgKSB7XG5cdFx0XHRcdC8vIFJvd3MgYW5kIGNvbHVtbnM6XG5cdFx0XHRcdC8vICBhcmcxIC0gaW5kZXhcblx0XHRcdFx0Ly8gIGFyZzIgLSB0YWJsZSBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmczIC0gbG9vcCBjb3VudGVyXG5cdFx0XHRcdC8vICBhcmc0IC0gdW5kZWZpbmVkXG5cdFx0XHRcdC8vIENlbGxzOlxuXHRcdFx0XHQvLyAgYXJnMSAtIHJvdyBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMiAtIGNvbHVtbiBpbmRleFxuXHRcdFx0XHQvLyAgYXJnMyAtIHRhYmxlIGNvdW50ZXJcblx0XHRcdFx0Ly8gIGFyZzQgLSBsb29wIGNvdW50ZXJcblx0XHRcdFx0Zm4uY2FsbChcblx0XHRcdFx0XHRhcGlbIHR5cGUgXShcblx0XHRcdFx0XHRcdGFyZzEsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gYXJnMiA6IG9wdHMsXG5cdFx0XHRcdFx0XHR0eXBlPT09J2NlbGwnID8gb3B0cyA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0YXJnMSwgYXJnMiwgYXJnMywgYXJnNFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSApO1xuXHRcblx0XG5cdC8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcblx0Ly8gRGF0YVRhYmxlXG5cdF9hcGlfcmVnaXN0ZXIoICdpMThuKCknLCBmdW5jdGlvbiAoIHRva2VuLCBkZWYsIHBsdXJhbCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXHRcblx0XHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXNvbHZlZCA9IGRlZjtcblx0XHR9XG5cdFxuXHRcdGlmICggcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdFx0cmVzb2x2ZWQgPSByZXNvbHZlZFsgcGx1cmFsIF0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRcdHJlc29sdmVkLl87XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHR9ICk7XG5cdC8qKlxuXHQgKiBWZXJzaW9uIHN0cmluZyBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgY29tcGF0aWJpbGl0eS4gQWxsb3dlZCBmb3JtYXQgaXNcblx0ICogYGEuYi5jLWRgIHdoZXJlOiBhOmludCwgYjppbnQsIGM6aW50LCBkOnN0cmluZyhkZXZ8YmV0YXxhbHBoYSkuIGBkYCBpcyB1c2VkXG5cdCAqIG9ubHkgZm9yIG5vbi1yZWxlYXNlIGJ1aWxkcy4gU2VlIGh0dHA6Ly9zZW12ZXIub3JnLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogIEBtZW1iZXJcblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgVmVyc2lvbiBudW1iZXJcblx0ICovXG5cdERhdGFUYWJsZS52ZXJzaW9uID0gXCIxLjEwLjIyXCI7XG5cblx0LyoqXG5cdCAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcblx0ICogY3JlYXRlZCBmb3IgdGhlIHRhYmxlcyBvbiBhIGdpdmVuIHBhZ2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIHRocm91Z2ggd2hpY2ggaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZFxuXHQgKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0RGF0YVRhYmxlLnNldHRpbmdzID0gW107XG5cblx0LyoqXG5cdCAqIE9iamVjdCBtb2RlbHMgY29udGFpbmVyLCBmb3IgdGhlIHZhcmlvdXMgbW9kZWxzIHRoYXQgRGF0YVRhYmxlcyBoYXNcblx0ICogYXZhaWxhYmxlIHRvIGl0LiBUaGVzZSBtb2RlbHMgZGVmaW5lIHRoZSBvYmplY3RzIHRoYXQgYXJlIHVzZWQgdG8gaG9sZFxuXHQgKiB0aGUgYWN0aXZlIHN0YXRlIGFuZCBjb25maWd1cmF0aW9uIG9mIHRoZSB0YWJsZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMgPSB7fTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG5cdCAqIHNlYXJjaCBpbmZvcm1hdGlvbiBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggPSB7XG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogdHJ1ZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXBwbGllZCBzZWFyY2ggdGVybVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqL1xuXHRcdFwic1NlYXJjaFwiOiBcIlwiLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuXHRcdCAqIHJlZ3VsYXIgZXhwcmVzc2lvbiAodHJ1ZSkgb3Igbm90IChmYWxzZSkgYW5kIHRoZXJlZm9yZSBhbmQgc3BlY2lhbFxuXHRcdCAqIHJlZ2V4IGNoYXJhY3RlcnMgZXNjYXBlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYlJlZ2V4XCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIERhdGFUYWJsZXMgaXMgdG8gdXNlIGl0cyBzbWFydCBmaWx0ZXJpbmcgb3Igbm90LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRcImJTbWFydFwiOiB0cnVlXG5cdH07XG5cdFxuXHRcblx0XG5cdFxuXHQvKipcblx0ICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcblx0ICogZWFjaCBpbmRpdmlkdWFsIHJvdy4gVGhpcyBpcyB0aGUgb2JqZWN0IGZvcm1hdCB1c2VkIGZvciB0aGUgc2V0dGluZ3Ncblx0ICogYW9EYXRhIGFycmF5LlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLm1vZGVscy5vUm93ID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRSIGVsZW1lbnQgZm9yIHRoZSByb3dcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVHJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxuXHRcdCAqIGNyZWF0ZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5IG5vZGVzXG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhbkNlbGxzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERhdGEgb2JqZWN0IGZyb20gdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93LiBUaGlzIGlzIGVpdGhlclxuXHRcdCAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuXHRcdCAqIHVzaW5nIG1EYXRhIG9wdGlvbnMuIFRoZSBleGFjdCB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBwYXNzZWQgaW5cblx0XHQgKiBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlLCBvciB3aWxsIGJlIGFuIGFycmF5IGlmIHVzaW5nIERPTSBhIGRhdGFcblx0XHQgKiBzb3VyY2UuXG5cdFx0ICogIEB0eXBlIGFycmF5fG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiX2FEYXRhXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIGRhdGEgY2FjaGUgLSB0aGlzIGFycmF5IGlzIG9zdGVuc2libHkgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuXHRcdCAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXG5cdFx0ICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcblx0XHQgKiByb3cuIFdlIGRvIHRoaXMgY2FjaGUgZ2VuZXJhdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNvcnQgaW4gb3JkZXIgdGhhdFxuXHRcdCAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXG5cdFx0ICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xuXHRcdCAqIG90aGVyIHRoYW4gdGhlIG1hc3RlciBzb3J0aW5nIG1ldGhvZHMuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9hU29ydERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVyIGNlbGwgZmlsdGVyaW5nIGRhdGEgY2FjaGUuIEFzIHBlciB0aGUgc29ydCBkYXRhIGNhY2hlLCB1c2VkIHRvXG5cdFx0ICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlc1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYUZpbHRlckRhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyaW5nIGRhdGEgY2FjaGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGNlbGwgZmlsdGVyaW5nIGNhY2hlLCBidXRcblx0XHQgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcblx0XHQgKiBhIGpvaW4gb24gYF9hRmlsdGVyRGF0YWAsIGJ1dCBpcyBwcm92aWRlZCBhcyBhIGNhY2hlIHNvIHRoZSBqb2luIGlzbid0XG5cdFx0ICogbmVlZGVkIG9uIGV2ZXJ5IHNlYXJjaCAobWVtb3J5IHRyYWRlZCBmb3IgcGVyZm9ybWFuY2UpXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9zRmlsdGVyUm93XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIG9mIHRoZSBjbGFzcyBuYW1lIHRoYXQgRGF0YVRhYmxlcyBoYXMgYXBwbGllZCB0byB0aGUgcm93LCBzbyB3ZVxuXHRcdCAqIGNhbiBxdWlja2x5IGxvb2sgYXQgdGhpcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBuZWVkaW5nIHRvIGRvIGEgRE9NIGNoZWNrXG5cdFx0ICogb24gY2xhc3NOYW1lIGZvciB0aGUgblRyIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NSb3dTdHJpcGVcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2Vcblx0XHQgKiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3IgaW52YWxpZGF0aW5nIGRhdGEsIHNvIERhdGFUYWJsZXMgY2FuXG5cdFx0ICogYXV0b21hdGljYWxseSByZWFkIGRhdGEgZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlLCB1bmxlc3MgdW5pbnN0cnVjdGVkXG5cdFx0ICogb3RoZXJ3aXNlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwic3JjXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IGluIHRoZSBhb0RhdGEgYXJyYXkuIFRoaXMgc2F2ZXMgYW4gaW5kZXhPZiBsb29rdXAgd2hlbiB3ZSBoYXZlIHRoZVxuXHRcdCAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IC0xXG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIGNvbHVtbiBpbmZvcm1hdGlvbiBvYmplY3QgaW4gRGF0YVRhYmxlcy4gVGhpcyBvYmplY3Rcblx0ICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcblx0ICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cblx0ICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cblx0ICogSXQgc2hvdWxkIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZFxuXHQgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHREYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XG5cdFx0LyoqXG5cdFx0ICogQ29sdW1uIGluZGV4LiBUaGlzIGNvdWxkIGJlIHdvcmtlZCBvdXQgb24tdGhlLWZseSB3aXRoICQuaW5BcnJheSwgYnV0IGl0XG5cdFx0ICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiaWR4XCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0XHQgKiBpcyBzb3J0ZWQuIFRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheSBhbGxvd3MgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHQgKiB0byBiZSBkZWZpbmVkIGZvciBhIGNvbHVtbiAoZm9yIGV4YW1wbGUgZmlyc3QgbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zXG5cdFx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0XHQgKiBjb2x1bW5zIHRvIGJlIHNvcnRlZCBvbiAodHlwaWNhbGx5IGl0IHdpbGwgYmUgYSBzaW5nbGUgaW50ZWdlciBwb2ludGluZ1xuXHRcdCAqIGF0IGl0c2VsZiwgYnV0IHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIHRoZSBjYXNlKS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFEYXRhU29ydFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgdGhlIHNvcnRpbmcgZGlyZWN0aW9ucyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBjb2x1bW4sIGluIHNlcXVlbmNlXG5cdFx0ICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuXHRcdCAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cblx0XHQgKiBTb3J0IGl0IGFnYWluIChjbGljayBhZ2FpbikgYW5kIGl0IHdpbGwgbW92ZSBvbiB0byB0aGUgbmV4dCBpbmRleC5cblx0XHQgKiBSZXBlYXQgdW50aWwgbG9vcC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc2VhcmNoYWJsZSwgYW5kIHRodXMgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdFx0ICogaW4gdGhlIGZpbHRlcmluZyBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTZWFyY2hhYmxlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJTb3J0YWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBmb3IgbWFudWFsIHR5cGUgYXNzaWdubWVudCB1c2luZyB0aGUgYGNvbHVtbi50eXBlYCBvcHRpb24uIFRoaXNcblx0XHQgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX3NNYW51YWxUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXG5cdFx0ICogc291cmNlIGZvciBmaWx0ZXJpbmcgb3Igc29ydGluZy4gVHJ1ZSBpcyBlaXRoZXIgYXJlLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0XCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHRcdCAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcblx0XHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHRcdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2VsZW1lbnR9IG5UZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcblx0XHQgKiAgQHBhcmFtIHsqfSBzRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcblx0XHQgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHRcdCAqIGFjY2VzcyBkYXRhIGRpcmVjdGx5IHRocm91Z2ggX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xuXHRcdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHRcdCAqIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxuXHRcdCAqICAgICdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0J1xuXHRcdCAqICBAcmV0dXJucyB7Kn0gVGhlIGRhdGEgZm9yIHRoZSBjZWxsIGZyb20gdGhlIGdpdmVuIHJvdydzIGRhdGFcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5HZXREYXRhXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0XHQgKiBzZXQgdGhlIGRhdGEgZGlyZWN0bHkgdG8gX2FEYXRhIGludGVybmFsbHkgaW4gRGF0YVRhYmxlcyAtIGFsd2F5cyB1c2Vcblx0XHQgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXG5cdFx0ICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0XHQgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG5cdFx0ICogIEBwYXJhbSB7Kn0gc1ZhbHVlIFZhbHVlIHRvIHNldFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJmblNldERhdGFcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcblx0XHQgKiBzb3VyY2UgYXJyYXkgLyBvYmplY3QuIElmIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgY29udGVudCBpcyB1c2VkLCBpZiBhXG5cdFx0ICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcblx0XHQgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcblx0XHQgKiAnc2V0JyBvcHRpb24sIGFuZCBhbHNvIHRoZSBkYXRhIGZlZCB0byBpdCBpcyB0aGUgcmVzdWx0IGZyb20gbURhdGEuXG5cdFx0ICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcblx0XHQgKiBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byAoaWYgc29ydGluZyBpcyBlbmFibGVkLilcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVGhcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIGZvb3RlciBUSC9URCBlbGVtZW50IGZvciB0aGlzIGNvbHVtbiAoaWYgdGhlcmUgaXMgb25lKS4gTm90IHVzZWRcblx0XHQgKiBpbiBEYXRhVGFibGVzIGFzIHN1Y2gsIGJ1dCBjYW4gYmUgdXNlZCBmb3IgcGx1Zy1pbnMgdG8gcmVmZXJlbmNlIHRoZVxuXHRcdCAqIGZvb3RlciBmb3IgZWFjaCBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRmXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNDbGFzc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdFx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHRcdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHRcdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdFx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHRcdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0XHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdFx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXG5cdFx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIG1EYXRhXG5cdFx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOYW1lIGZvciB0aGUgY29sdW1uLCBhbGxvd2luZyByZWZlcmVuY2UgdG8gdGhlIGNvbHVtbiBieSBuYW1lIGFzIHdlbGwgYXNcblx0XHQgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICovXG5cdFx0XCJzTmFtZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDdXN0b20gc29ydGluZyBkYXRhIHR5cGUgLSBkZWZpbmVzIHdoaWNoIG9mIHRoZSBhdmFpbGFibGUgcGx1Zy1pbnMgaW5cblx0XHQgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqL1xuXHRcdFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzU29ydGluZ0NsYXNzXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXG5cdFx0ICogd2hlbiBqUXVlcnkgVUkgdGhlbWluZyBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1NvcnRpbmdDbGFzc0pVSVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb2x1bW4gc29ydGluZyBhbmQgZmlsdGVyaW5nIHR5cGVcblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic1dpZHRoT3JpZ1wiOiBudWxsXG5cdH07XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiwgdGhhdCB3YXMgdXNlZCBhcyB0aGUgaW50ZXJmYWNlIGZvciBEYXRhVGFibGVzIHByaW9yIHRvIHYxLjEwLCBob3dldmVyXG5cdCAqIGZyb20gdjEuMTAgb253YXJkcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgaXMgY2FtZWwgY2FzZS4gSW4gb3JkZXIgdG8gYXZvaWRcblx0ICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG5cdCAqIHZlcnNpb24gaXMgc3RpbGwsIGludGVybmFsbHkgdGhlIHByaW1hcnkgaW50ZXJmYWNlLCBidXQgaXMgaXMgbm90IGRvY3VtZW50ZWRcblx0ICogLSBoZW5jZSB0aGUgQG5hbWUgdGFncyBpbiBlYWNoIGRvYyBjb21tZW50LiBUaGlzIGFsbG93cyBhIEphdmFzY3JpcHQgZnVuY3Rpb25cblx0ICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cblx0ICogd291bGQgcmVxdWlyZSBlYWNoIHByb3BlcnR5IHRvIGJlIGxpc3RlZCwgd2hpY2ggd291bGQgYWRkIGFyb3VuZCAzSyB0byB0aGUgc2l6ZVxuXHQgKiBvZiBEYXRhVGFibGVzLCB3aGlsZSB0aGlzIG1ldGhvZCBpcyBhYm91dCBhIDAuNUsgaGl0KS5cblx0ICpcblx0ICogVWx0aW1hdGVseSB0aGlzIGRvZXMgcGF2ZSB0aGUgd2F5IGZvciBIdW5nYXJpYW4gbm90YXRpb24gdG8gYmUgZHJvcHBlZFxuXHQgKiBjb21wbGV0ZWx5LCBidXQgdGhhdCBpcyBhIG1hc3NpdmUgYW1vdW50IG9mIHdvcmsgYW5kIHdpbGwgYnJlYWsgY3VycmVudFxuXHQgKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXNhdGlvbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb25cblx0ICogdGltZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5kZWZhdWx0cyA9IHtcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBkYXRhIHRvIHVzZSBmb3IgdGhlIHRhYmxlLCBwYXNzZWQgaW4gYXQgaW5pdGlhbGlzYXRpb24gd2hpY2hcblx0XHQgKiB3aWxsIGJlIHVzZWQgaW4gcHJlZmVyZW5jZSB0byBhbnkgZGF0YSB3aGljaCBpcyBhbHJlYWR5IGluIHRoZSBET00uIFRoaXMgaXNcblx0XHQgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3Jcblx0XHQgKiBleGFtcGxlIHdpdGggYSBjdXN0b20gQWpheCBjYWxsLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGF0YVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYSAyRCBhcnJheSBkYXRhIHNvdXJjZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRhdGFcIjogW1xuXHRcdCAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA0LjAnLCAnV2luIDk1KycsIDQsICdYJ10sXG5cdFx0ICogICAgICAgICAgWydUcmlkZW50JywgJ0ludGVybmV0IEV4cGxvcmVyIDUuMCcsICdXaW4gOTUrJywgNSwgJ0MnXSxcblx0XHQgKiAgICAgICAgXSxcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYXMgYSBkYXRhIHNvdXJjZSAoYGRhdGFgKVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImRhdGFcIjogW1xuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG5cdFx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNC4wXCIsXG5cdFx0ICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxuXHRcdCAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA0LFxuXHRcdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIlhcIlxuXHRcdCAqICAgICAgICAgIH0sXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJlbmdpbmVcIjogICBcIlRyaWRlbnRcIixcblx0XHQgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA1LjBcIixcblx0XHQgKiAgICAgICAgICAgIFwicGxhdGZvcm1cIjogXCJXaW4gOTUrXCIsXG5cdFx0ICogICAgICAgICAgICBcInZlcnNpb25cIjogIDUsXG5cdFx0ICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiQ1wiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdLFxuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkVuZ2luZVwiLCAgIFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiLCAgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiUGxhdGZvcm1cIiwgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlZlcnNpb25cIiwgIFwiZGF0YVwiOiBcInZlcnNpb25cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIsICAgIFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWFEYXRhXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiBvcmRlcmluZyBpcyBlbmFibGVkLCB0aGVuIERhdGFUYWJsZXMgd2lsbCBwZXJmb3JtIGEgZmlyc3QgcGFzcyBzb3J0IG9uXG5cdFx0ICogaW5pdGlhbGlzYXRpb24uIFlvdSBjYW4gZGVmaW5lIHdoaWNoIGNvbHVtbihzKSB0aGUgc29ydCBpcyBwZXJmb3JtZWRcblx0XHQgKiB1cG9uLCBhbmQgdGhlIHNvcnRpbmcgZGlyZWN0aW9uLCB3aXRoIHRoaXMgdmFyaWFibGUuIFRoZSBgc29ydGluZ2AgYXJyYXlcblx0XHQgKiBzaG91bGQgY29udGFpbiBhbiBhcnJheSBmb3IgZWFjaCBjb2x1bW4gdG8gYmUgc29ydGVkIGluaXRpYWxseSBjb250YWluaW5nXG5cdFx0ICogdGhlIGNvbHVtbidzIGluZGV4IGFuZCBhIGRpcmVjdGlvbiBzdHJpbmcgKCdhc2MnIG9yICdkZXNjJykuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtbMCwnYXNjJ11dXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNvcnQgYnkgM3JkIGNvbHVtbiBmaXJzdCwgYW5kIHRoZW4gNHRoIGNvbHVtblxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJcIjogW1syLCdhc2MnXSwgWzMsJ2Rlc2MnXV1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICAvLyBObyBpbml0aWFsIHNvcnRpbmdcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcIm9yZGVyXCI6IFtdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nXCI6IFtbMCwnYXNjJ11dLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCB0byB0aGUgYHNvcnRpbmdgIHBhcmFtZXRlciwgYnV0XG5cdFx0ICogY2Fubm90IGJlIG92ZXJyaWRkZW4gYnkgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0YWJsZS4gV2hhdCB0aGlzIG1lYW5zXG5cdFx0ICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXG5cdFx0ICogd2lsbCBhbHdheXMgYmUgZm9yY2VkIG9uIGZpcnN0IC0gYW55IHNvcnRpbmcgYWZ0ZXIgdGhhdCAoZnJvbSB0aGUgdXNlcilcblx0XHQgKiB3aWxsIHRoZW4gYmUgcGVyZm9ybWVkIGFzIHJlcXVpcmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGdyb3VwaW5nIHJvd3Ncblx0XHQgKiB0b2dldGhlci5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyRml4ZWRcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJGaXhlZFwiOiBbWzAsJ2FzYyddXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEYXRhVGFibGVzIGNhbiBiZSBpbnN0cnVjdGVkIHRvIGxvYWQgZGF0YSB0byBkaXNwbGF5IGluIHRoZSB0YWJsZSBmcm9tIGFcblx0XHQgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXG5cdFx0ICpcblx0XHQgKiBUaGUgYGFqYXhgIHByb3BlcnR5IGhhcyB0aHJlZSBkaWZmZXJlbnQgbW9kZXMgb2Ygb3BlcmF0aW9uLCBkZXBlbmRpbmcgb25cblx0XHQgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxuXHRcdCAqXG5cdFx0ICogKiBgc3RyaW5nYCAtIFNldCB0aGUgVVJMIGZyb20gd2hlcmUgdGhlIGRhdGEgc2hvdWxkIGJlIGxvYWRlZCBmcm9tLlxuXHRcdCAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cblx0XHQgKiAqIGBmdW5jdGlvbmAgLSBDdXN0b20gZGF0YSBnZXQgZnVuY3Rpb25cblx0XHQgKlxuXHRcdCAqIGBzdHJpbmdgXG5cdFx0ICogLS0tLS0tLS1cblx0XHQgKlxuXHRcdCAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxuXHRcdCAqIERhdGFUYWJsZXMgd2lsbCBsb2FkIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBgb2JqZWN0YFxuXHRcdCAqIC0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xuXHRcdCAqIFtqUXVlcnkuYWpheF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4LykgYWxsb3dpbmcgZmluZSBjb250cm9sXG5cdFx0ICogb2YgdGhlIEFqYXggcmVxdWVzdC4gRGF0YVRhYmxlcyBoYXMgYSBudW1iZXIgb2YgZGVmYXVsdCBwYXJhbWV0ZXJzIHdoaWNoXG5cdFx0ICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcblx0XHQgKiBkb2N1bWVudGF0aW9uIGZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnMgYXZhaWxhYmxlLCBhbHRob3VnaFxuXHRcdCAqIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBwcm92aWRlIGFkZGl0aW9uYWwgb3B0aW9ucyBpbiBEYXRhVGFibGVzIG9yXG5cdFx0ICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG5cdFx0ICpcblx0XHQgKiAqIGBkYXRhYCAtIEFzIHdpdGggalF1ZXJ5LCBgZGF0YWAgY2FuIGJlIHByb3ZpZGVkIGFzIGFuIG9iamVjdCwgYnV0IGl0XG5cdFx0ICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG5cdFx0ICogICB0byB0aGUgc2VydmVyLiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLCBhbiBvYmplY3Qgb2Zcblx0XHQgKiAgIHBhcmFtZXRlcnMgd2l0aCB0aGUgdmFsdWVzIHRoYXQgRGF0YVRhYmxlcyBoYXMgcmVhZGllZCBmb3Igc2VuZGluZy4gQW5cblx0XHQgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuXHRcdCAqICAgZGVmYXVsdHMsIG9yIHlvdSBjYW4gYWRkIHRoZSBpdGVtcyB0byB0aGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpbiBhbmRcblx0XHQgKiAgIG5vdCByZXR1cm4gYW55dGhpbmcgZnJvbSB0aGUgZnVuY3Rpb24uIFRoaXMgc3VwZXJzZWRlcyBgZm5TZXJ2ZXJQYXJhbXNgXG5cdFx0ICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cblx0XHQgKlxuXHRcdCAqICogYGRhdGFTcmNgIC0gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3Jcblx0XHQgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG5cdFx0ICogICBmcm9tIGFuIEFqYXggc291cmNlIG9yIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdGhpcyBwYXJhbWV0ZXJcblx0XHQgKiAgIGFsbG93cyB0aGF0IHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkXG5cdFx0ICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuXHRcdCAqICAgaXQgbXkgYmUgdXNlZCBhcyBhIGZ1bmN0aW9uLiBBcyBhIGZ1bmN0aW9uIGl0IHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlcixcblx0XHQgKiAgIHRoZSBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciwgd2hpY2ggY2FuIGJlIG1hbmlwdWxhdGVkIGFzXG5cdFx0ICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG5cdFx0ICogICBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIHN1cGVyc2VkZXMgYHNBamF4RGF0YVByb3BgIGZyb21cblx0XHQgKiAgIERhdGFUYWJsZXMgMS45LS5cblx0XHQgKlxuXHRcdCAqICogYHN1Y2Nlc3NgIC0gU2hvdWxkIG5vdCBiZSBvdmVycmlkZGVuIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBpblxuXHRcdCAqICAgRGF0YVRhYmxlcy4gVG8gbWFuaXB1bGF0ZSAvIHRyYW5zZm9ybSB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG5cdFx0ICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cblx0XHQgKlxuXHRcdCAqIGBmdW5jdGlvbmBcblx0XHQgKiAtLS0tLS0tLS0tXG5cdFx0ICpcblx0XHQgKiBBcyBhIGZ1bmN0aW9uLCBtYWtpbmcgdGhlIEFqYXggY2FsbCBpcyBsZWZ0IHVwIHRvIHlvdXJzZWxmIGFsbG93aW5nXG5cdFx0ICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXG5cdFx0ICogdGhhbiBBamF4IGNvdWxkIGJlIHVzZWQgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhLCBzdWNoIGFzIFdlYiBzdG9yYWdlXG5cdFx0ICogb3IgYW4gQUlSIGRhdGFiYXNlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9uIGlzIGdpdmVuIGZvdXIgcGFyYW1ldGVycyBhbmQgbm8gcmV0dXJuIGlzIHJlcXVpcmVkLiBUaGVcblx0XHQgKiBwYXJhbWV0ZXJzIGFyZTpcblx0XHQgKlxuXHRcdCAqIDEuIF9vYmplY3RfIC0gRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAyLiBfZnVuY3Rpb25fIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBtdXN0IGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHJlcXVpcmVkXG5cdFx0ICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcblx0XHQgKiAgICBhcyB0aGUgb25seSBwYXJhbWV0ZXJcblx0XHQgKiAzLiBfb2JqZWN0XyAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyRGF0YWAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFxuXHRcdCAqICBAc2luY2UgMS4xMC4wXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheC5cblx0XHQgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXG5cdFx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICBcImFqYXhcIjogXCJkYXRhLmpzb25cIlxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2Vcblx0XHQgKiAgIC8vIGBkYXRhYCB0byBgdGFibGVEYXRhYCAoaS5lLiBgeyB0YWJsZURhdGE6IFsgLi4uZGF0YS4uLiBdIH1gKVxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBcInRhYmxlRGF0YVwiXG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gcmVhZCBkYXRhXG5cdFx0ICogICAvLyBmcm9tIGEgcGxhaW4gYXJyYXkgcmF0aGVyIHRoYW4gYW4gYXJyYXkgaW4gYW4gb2JqZWN0XG5cdFx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICBcImFqYXhcIjoge1xuXHRcdCAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXG5cdFx0ICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfSApO1xuXHRcdCAqXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgIC8vIE1hbmlwdWxhdGUgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIC0gYWRkIGEgbGluayB0byBkYXRhXG5cdFx0ICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xuXHRcdCAqICAgLy8gaXMganVzdCBhIHNpbXBsZSBleGFtcGxlIG9mIGhvdyB0aGUgZGF0YSBjYW4gYmUgbWFuaXB1bGF0ZWQpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVNyY1wiOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0ICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHQgKiAgICAgICAgICAganNvbltpXVswXSA9ICc8YSBocmVmPVwiL21lc3NhZ2UvJytqc29uW2ldWzBdKyc+VmlldyBtZXNzYWdlPC9hPic7XG5cdFx0ICogICAgICAgICB9XG5cdFx0ICogICAgICAgICByZXR1cm4ganNvbjtcblx0XHQgKiAgICAgICB9XG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0ICogICAgICAgICByZXR1cm4ge1xuXHRcdCAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxuXHRcdCAqICAgICAgICAgfTtcblx0XHQgKiAgICAgICB9XG5cdFx0ICogICAgIH1cblx0XHQgKiAgIH0gKTtcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogICAvLyBTZW5kIHJlcXVlc3QgYXMgUE9TVFxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IHtcblx0XHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHRcdCAqICAgICAgIFwidHlwZVwiOiBcIlBPU1RcIlxuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gbG9jYWxTdG9yYWdlIChjb3VsZCBpbnRlcmZhY2Ugd2l0aCBhIGZvcm0gZm9yXG5cdFx0ICogICAvLyBhZGRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIHJvd3MpLlxuXHRcdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgXCJhamF4XCI6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaywgc2V0dGluZ3MpIHtcblx0XHQgKiAgICAgICBjYWxsYmFjayhcblx0XHQgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcblx0XHQgKiAgICAgICApO1xuXHRcdCAqICAgICB9XG5cdFx0ICogICB9ICk7XG5cdFx0ICovXG5cdFx0XCJhamF4XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHJlYWRpbHkgc3BlY2lmeSB0aGUgZW50cmllcyBpbiB0aGUgbGVuZ3RoIGRyb3Bcblx0XHQgKiBkb3duIG1lbnUgdGhhdCBEYXRhVGFibGVzIHNob3dzIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLiBJdCBjYW4gYmVcblx0XHQgKiBlaXRoZXIgYSAxRCBhcnJheSBvZiBvcHRpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYm90aCB0aGUgZGlzcGxheWVkXG5cdFx0ICogb3B0aW9uIGFuZCB0aGUgdmFsdWUsIG9yIGEgMkQgYXJyYXkgd2hpY2ggd2lsbCB1c2UgdGhlIGFycmF5IGluIHRoZSBmaXJzdFxuXHRcdCAqIHBvc2l0aW9uIGFzIHRoZSB2YWx1ZSwgYW5kIHRoZSBhcnJheSBpbiB0aGUgc2Vjb25kIHBvc2l0aW9uIGFzIHRoZVxuXHRcdCAqIGRpc3BsYXllZCBvcHRpb25zICh1c2VmdWwgZm9yIGxhbmd1YWdlIHN0cmluZ3Mgc3VjaCBhcyAnQWxsJykuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgdGhlIGBwYWdlTGVuZ3RoYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZVxuXHRcdCAqIGZpcnN0IHZhbHVlIGdpdmVuIGluIHRoaXMgYXJyYXksIHVubGVzcyBgcGFnZUxlbmd0aGAgaXMgYWxzbyBwcm92aWRlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgWyAxMCwgMjUsIDUwLCAxMDAgXVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25cblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aE1lbnVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGVuZ3RoTWVudVwiOiBbWzEwLCAyNSwgNTAsIC0xXSwgWzEwLCAyNSwgNTAsIFwiQWxsXCJdXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFMZW5ndGhNZW51XCI6IFsgMTAsIDI1LCA1MCwgMTAwIF0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgYGNvbHVtbnNgIG9wdGlvbiBpbiB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gZGVmaW5lXG5cdFx0ICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxuXHRcdCAqIGNvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCwgcGxlYXNlIHNlZVxuXHRcdCAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufS4gTm90ZSB0aGF0IGlmIHlvdSB1c2UgYGNvbHVtbnNgIHRvXG5cdFx0ICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxuXHRcdCAqIGNvbHVtbiB0aGF0IHlvdSBoYXZlIGluIHlvdXIgdGFibGUgKHRoZXNlIGNhbiBiZSBudWxsIGlmIHlvdSBkb24ndCB3aGljaFxuXHRcdCAqIHRvIHNwZWNpZnkgYW55IG9wdGlvbnMpLlxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtblxuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5zXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXG5cdFx0ICogY29sdW1uLCBtdWx0aXBsZSBjb2x1bW5zLCBvciBhbGwgY29sdW1ucywgdXNpbmcgdGhlIGB0YXJnZXRzYCBwcm9wZXJ0eSBvZlxuXHRcdCAqIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVGhpcyBhbGxvd3MgZ3JlYXQgZmxleGliaWxpdHkgd2hlbiBjcmVhdGluZ1xuXHRcdCAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcblx0XHQgKiBjb2x1bW5zIHlvdSBzcGVjaWZpY2FsbHkgd2FudC4gYGNvbHVtbkRlZnNgIG1heSB1c2UgYW55IG9mIHRoZSBjb2x1bW5cblx0XHQgKiBvcHRpb25zIGF2YWlsYWJsZToge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LCBidXQgaXQgX211c3RfXG5cdFx0ICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXG5cdFx0ICogYXJyYXkgbWF5IGJlOlxuXHRcdCAqICAgPHVsPlxuXHRcdCAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxuXHRcdCAqICAgICA8bGk+MCBvciBhIHBvc2l0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgbGVmdDwvbGk+XG5cdFx0ICogICAgIDxsaT5hIG5lZ2F0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgcmlnaHQ8L2xpPlxuXHRcdCAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEBtZW1iZXJcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uRGVmc1xuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5EZWZzXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgYHNlYXJjaGAsIHRoaXMgcGFyYW1ldGVyIGRlZmluZXMgdGhlIGluZGl2aWR1YWwgY29sdW1uXG5cdFx0ICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcblx0XHQgKiBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMsIGFuZCBlYWNoIGVsZW1lbnQgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHBhcmFtZXRlcnNcblx0XHQgKiBgc2VhcmNoYCBhbmQgYGVzY2FwZVJlZ2V4YCAodGhlIGxhdHRlciBpcyBvcHRpb25hbCkuICdudWxsJyBpcyBhbHNvXG5cdFx0ICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hDb2xzXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlYXJjaENvbHNcIjogW1xuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwic2VhcmNoXCI6IFwiXlswLTldXCIsIFwiZXNjYXBlUmVnZXhcIjogZmFsc2UgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJhb1NlYXJjaENvbHNcIjogW10sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiBDU1MgY2xhc3NlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGRpc3BsYXllZCByb3dzLiBUaGlzXG5cdFx0ICogYXJyYXkgbWF5IGJlIG9mIGFueSBsZW5ndGgsIGFuZCBEYXRhVGFibGVzIHdpbGwgYXBwbHkgZWFjaCBjbGFzc1xuXHRcdCAqIHNlcXVlbnRpYWxseSwgbG9vcGluZyB3aGVuIHJlcXVpcmVkLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPldpbGwgdGFrZSB0aGUgdmFsdWVzIGRldGVybWluZWQgYnkgdGhlIGBvQ2xhc3Nlcy5zdHJpcGUqYFxuXHRcdCAqICAgIG9wdGlvbnM8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvblxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RyaXBlQ2xhc3Nlc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdHJpcGVDbGFzc2VzXCI6IFsgJ3N0cmlwMScsICdzdHJpcDInLCAnc3RyaXAzJyBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIGF1dG9tYXRpYyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24uIFRoaXMgY2FuIGJlIGRpc2FibGVkXG5cdFx0ICogYXMgYW4gb3B0aW1pc2F0aW9uIChpdCB0YWtlcyBzb21lIHRpbWUgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aHMpIGlmIHRoZVxuXHRcdCAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYXV0b1dpZHRoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJhdXRvV2lkdGhcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiQXV0b1dpZHRoXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZlcnJlZCByZW5kZXJpbmcgY2FuIHByb3ZpZGUgRGF0YVRhYmxlcyB3aXRoIGEgaHVnZSBzcGVlZCBib29zdCB3aGVuIHlvdVxuXHRcdCAqIGFyZSB1c2luZyBhbiBBamF4IG9yIEpTIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuIFRoaXMgb3B0aW9uLCB3aGVuIHNldCB0b1xuXHRcdCAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxuXHRcdCAqIGVhY2ggcm93IHVudGlsIHRoZXkgYXJlIG5lZWRlZCBmb3IgYSBkcmF3IC0gc2F2aW5nIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mXG5cdFx0ICogdGltZS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJSZW5kZXJcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxuXHRcdCAqICAgICAgICBcImRlZmVyUmVuZGVyXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiRGVmZXJSZW5kZXJcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIGEgRGF0YVRhYmxlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCByZXBsYWNlIGl0IHdpdGhcblx0XHQgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cblx0XHQgKiB0YWJsZSBtYXRjaGVzIHRoZSBzZWxlY3RvciwgdGhlbiB0aGUgbmV3IERhdGFUYWJsZSB3aWxsIGJlIGNvbnN0cnVjdGVkIGFzXG5cdFx0ICogcGVyIG5vcm1hbC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZXN0cm95XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICAgICAgLy8gU29tZSB0aW1lIGxhdGVyLi4uLlxuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmaWx0ZXJcIjogZmFsc2UsXG5cdFx0ICogICAgICAgIFwiZGVzdHJveVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkRlc3Ryb3lcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXG5cdFx0ICogdGhhdCBpdCBhbGxvd3MgdGhlIGVuZCB1c2VyIHRvIGlucHV0IG11bHRpcGxlIHdvcmRzIChzcGFjZSBzZXBhcmF0ZWQpIGFuZFxuXHRcdCAqIHdpbGwgbWF0Y2ggYSByb3cgY29udGFpbmluZyB0aG9zZSB3b3JkcywgZXZlbiBpZiBub3QgaW4gdGhlIG9yZGVyIHRoYXQgd2FzXG5cdFx0ICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxuXHRcdCAqIHdpc2ggdG8gdXNlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzIHRoaXMgbXVzdCByZW1haW4gJ3RydWUnIC0gdG8gcmVtb3ZlIHRoZVxuXHRcdCAqIGRlZmF1bHQgZmlsdGVyaW5nIGlucHV0IGJveCBhbmQgcmV0YWluIGZpbHRlcmluZyBhYmlsaXRpZXMsIHBsZWFzZSB1c2Vcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiRmlsdGVyXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgdGFibGUgaW5mb3JtYXRpb24gZGlzcGxheS4gVGhpcyBzaG93cyBpbmZvcm1hdGlvblxuXHRcdCAqIGFib3V0IHRoZSBkYXRhIHRoYXQgaXMgY3VycmVudGx5IHZpc2libGUgb24gdGhlIHBhZ2UsIGluY2x1ZGluZyBpbmZvcm1hdGlvblxuXHRcdCAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImluZm9cIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiSW5mb1wiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHRoZSBlbmQgdXNlciB0byBzZWxlY3QgdGhlIHNpemUgb2YgYSBmb3JtYXR0ZWQgcGFnZSBmcm9tIGEgc2VsZWN0XG5cdFx0ICogbWVudSAoc2l6ZXMgYXJlIDEwLCAyNSwgNTAgYW5kIDEwMCkuIFJlcXVpcmVzIHBhZ2luYXRpb24gKGBwYWdpbmF0ZWApLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aENoYW5nZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGVuZ3RoQ2hhbmdlXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgcGFnaW5hdGlvbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJQYWdpbmF0ZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgYSAncHJvY2Vzc2luZycgaW5kaWNhdG9yIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0ICogYmVpbmcgcHJvY2Vzc2VkIChlLmcuIGEgc29ydCkuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgdGFibGVzIHdpdGhcblx0XHQgKiBsYXJnZSBhbW91bnRzIG9mIGRhdGEgd2hlcmUgaXQgY2FuIHRha2UgYSBub3RpY2VhYmxlIGFtb3VudCBvZiB0aW1lIHRvIHNvcnRcblx0XHQgKiB0aGUgZW50cmllcy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJvY2Vzc2luZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicHJvY2Vzc2luZ1wiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXRyaWV2ZSB0aGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoZSBnaXZlbiBzZWxlY3Rvci4gTm90ZSB0aGF0IGlmIHRoZVxuXHRcdCAqIHRhYmxlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQsIHRoaXMgcGFyYW1ldGVyIHdpbGwgY2F1c2UgRGF0YVRhYmxlc1xuXHRcdCAqIHRvIHNpbXBseSByZXR1cm4gdGhlIG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2V0IHVwIC0gaXQgd2lsbCBub3QgdGFrZVxuXHRcdCAqIGFjY291bnQgb2YgYW55IGNoYW5nZXMgeW91IG1pZ2h0IGhhdmUgbWFkZSB0byB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0XG5cdFx0ICogcGFzc2VkIHRvIERhdGFUYWJsZXMgKHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpcyBhbiBhY2tub3dsZWRnZW1lbnRcblx0XHQgKiB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoaXMpLiBgZGVzdHJveWAgY2FuIGJlIHVzZWQgdG8gcmVpbml0aWFsaXNlIGEgdGFibGUgaWZcblx0XHQgKiB5b3UgbmVlZC5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yZXRyaWV2ZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgaW5pdFRhYmxlKCk7XG5cdFx0ICogICAgICB0YWJsZUFjdGlvbnMoKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgICBmdW5jdGlvbiBpbml0VGFibGUgKClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwcHhcIixcblx0XHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcblx0XHQgKiAgICAgICAgXCJyZXRyaWV2ZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfVxuXHRcdCAqXG5cdFx0ICogICAgZnVuY3Rpb24gdGFibGVBY3Rpb25zICgpXG5cdFx0ICogICAge1xuXHRcdCAqICAgICAgdmFyIHRhYmxlID0gaW5pdFRhYmxlKCk7XG5cdFx0ICogICAgICAvLyBwZXJmb3JtIEFQSSBvcGVyYXRpb25zIHdpdGggb1RhYmxlXG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdFwiYlJldHJpZXZlXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiB2ZXJ0aWNhbCAoeSkgc2Nyb2xsaW5nIGlzIGVuYWJsZWQsIERhdGFUYWJsZXMgd2lsbCBmb3JjZSB0aGUgaGVpZ2h0IG9mXG5cdFx0ICogdGhlIHRhYmxlJ3Mgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGhlaWdodCBhdCBhbGwgdGltZXMgKHVzZWZ1bCBmb3IgbGF5b3V0KS5cblx0XHQgKiBIb3dldmVyLCB0aGlzIGNhbiBsb29rIG9kZCB3aGVuIGZpbHRlcmluZyBkYXRhIGRvd24gdG8gYSBzbWFsbCBkYXRhIHNldCxcblx0XHQgKiBhbmQgdGhlIGZvb3RlciBpcyBsZWZ0IFwiZmxvYXRpbmdcIiBmdXJ0aGVyIGRvd24uIFRoaXMgcGFyYW1ldGVyICh3aGVuXG5cdFx0ICogZW5hYmxlZCkgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGNvbGxhcHNlIHRoZSB0YWJsZSdzIHZpZXdwb3J0IGRvd24gd2hlblxuXHRcdCAqIHRoZSByZXN1bHQgc2V0IHdpbGwgZml0IHdpdGhpbiB0aGUgZ2l2ZW4gWSBoZWlnaHQuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsQ29sbGFwc2Vcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMFwiLFxuXHRcdCAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2Nyb2xsQ29sbGFwc2VcIjogZmFsc2UsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxuXHRcdCAqIGBhamF4YCBwYXJhbWV0ZXIgbXVzdCBhbHNvIGJlIGdpdmVuIGluIG9yZGVyIHRvIGdpdmUgRGF0YVRhYmxlcyBhXG5cdFx0ICogc291cmNlIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgZWFjaCBkcmF3LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyU2lkZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcImFqYXhcIjogXCJ4aHIucGhwXCJcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIHNvcnRpbmcgb2YgY29sdW1ucy4gU29ydGluZyBvZiBpbmRpdmlkdWFsIGNvbHVtbnMgY2FuIGJlXG5cdFx0ICogZGlzYWJsZWQgYnkgdGhlIGBzb3J0YWJsZWAgb3B0aW9uIGZvciBlYWNoIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlcmluZ1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJpbmdcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydFwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc3BsYXkgRGF0YVRhYmxlcycgYWJpbGl0eSB0byBzb3J0IG11bHRpcGxlIGNvbHVtbnMgYXQgdGhlXG5cdFx0ICogc2FtZSB0aW1lIChhY3RpdmF0ZWQgYnkgc2hpZnQtY2xpY2sgYnkgdGhlIHVzZXIpLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJNdWx0aVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRGlzYWJsZSBtdWx0aXBsZSBjb2x1bW4gc29ydGluZyBhYmlsaXR5XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJNdWx0aVwiOiBmYWxzZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImJTb3J0TXVsdGlcIjogdHJ1ZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBjb250cm9sIG92ZXIgd2hldGhlciBEYXRhVGFibGVzIHNob3VsZCB1c2UgdGhlIHRvcCAodHJ1ZSkgdW5pcXVlXG5cdFx0ICogY2VsbCB0aGF0IGlzIGZvdW5kIGZvciBhIHNpbmdsZSBjb2x1bW4sIG9yIHRoZSBib3R0b20gKGZhbHNlIC0gZGVmYXVsdCkuXG5cdFx0ICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJDZWxsc1RvcFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJvcmRlckNlbGxzVG9wXCI6IHRydWVcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU29ydENlbGxzVG9wXCI6IGZhbHNlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGFkZGl0aW9uIG9mIHRoZSBjbGFzc2VzIGBzb3J0aW5nXFxfMWAsIGBzb3J0aW5nXFxfMmAgYW5kXG5cdFx0ICogYHNvcnRpbmdcXF8zYCB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGJlaW5nIHNvcnRlZCBvbi4gVGhpcyBpc1xuXHRcdCAqIHByZXNlbnRlZCBhcyBhIGZlYXR1cmUgc3dpdGNoIGFzIGl0IGNhbiBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUgKHdoaWxlXG5cdFx0ICogY2xhc3NlcyBhcmUgcmVtb3ZlZCBhbmQgYWRkZWQpIHNvIGZvciBsYXJnZSBkYXRhIHNldHMgeW91IG1pZ2h0IHdhbnQgdG9cblx0XHQgKiB0dXJuIHRoaXMgb2ZmLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IHRydWVcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2xhc3Nlc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwib3JkZXJDbGFzc2VzXCI6IGZhbHNlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRDbGFzc2VzXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzdGF0ZSBzYXZpbmcuIFdoZW4gZW5hYmxlZCBIVE1MNSBgbG9jYWxTdG9yYWdlYCB3aWxsIGJlXG5cdFx0ICogdXNlZCB0byBzYXZlIHRhYmxlIGRpc3BsYXkgaW5mb3JtYXRpb24gc3VjaCBhcyBwYWdpbmF0aW9uIGluZm9ybWF0aW9uLFxuXHRcdCAqIGRpc3BsYXkgbGVuZ3RoLCBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuIEFzIHN1Y2ggd2hlbiB0aGUgZW5kIHVzZXIgcmVsb2Fkc1xuXHRcdCAqIHRoZSBwYWdlIHRoZSBkaXNwbGF5IGRpc3BsYXkgd2lsbCBtYXRjaCB3aGF0IHRoeSBoYWQgcHJldmlvdXNseSBzZXQgdXAuXG5cdFx0ICpcblx0XHQgKiBEdWUgdG8gdGhlIHVzZSBvZiBgbG9jYWxTdG9yYWdlYCB0aGUgZGVmYXVsdCBzdGF0ZSBzYXZpbmcgaXMgbm90IHN1cHBvcnRlZFxuXHRcdCAqIGluIElFNiBvciA3LiBJZiBzdGF0ZSBzYXZpbmcgaXMgcmVxdWlyZWQgaW4gdGhvc2UgYnJvd3NlcnMsIHVzZVxuXHRcdCAqIGBzdGF0ZVNhdmVDYWxsYmFja2AgdG8gcHJvdmlkZSBhIHN0b3JhZ2Ugc29sdXRpb24gc3VjaCBhcyBjb29raWVzLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlN0YXRlU2F2ZVwiOiBmYWxzZSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYSBUUiBlbGVtZW50IGlzIGNyZWF0ZWQgKGFuZCBhbGwgVEQgY2hpbGRcblx0XHQgKiBlbGVtZW50cyBoYXZlIGJlZW4gaW5zZXJ0ZWQpLCBvciByZWdpc3RlcmVkIGlmIHVzaW5nIGEgRE9NIHNvdXJjZSwgYWxsb3dpbmdcblx0XHQgKiBtYW5pcHVsYXRpb24gb2YgdGhlIFRSIGVsZW1lbnQgKGFkZGluZyBjbGFzc2VzIGV0YykuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBSYXcgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhpcyByb3cgaW4gdGhlIGludGVybmFsIGFvRGF0YSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNyZWF0ZWRSb3dcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY3JlYXRlZFJvd1wiOiBmdW5jdGlvbiggcm93LCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgICAgLy8gQm9sZCB0aGUgZ3JhZGUgZm9yIGFsbCAnQScgZ3JhZGUgYnJvd3NlcnNcblx0XHQgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKVxuXHRcdCAqICAgICAgICAgIHtcblx0XHQgKiAgICAgICAgICAgICQoJ3RkOmVxKDQpJywgcm93KS5odG1sKCAnPGI+QTwvYj4nICk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5DcmVhdGVkUm93XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXG5cdFx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IGFueSBhc3BlY3QgeW91IHdhbnQgYWJvdXQgdGhlIGNyZWF0ZWQgRE9NLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kcmF3Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIHJlZHJhd24gdGhlIHRhYmxlJyApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5EcmF3Q2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElkZW50aWNhbCB0byBmbkhlYWRlckNhbGxiYWNrKCkgYnV0IGZvciB0aGUgdGFibGUgZm9vdGVyIHRoaXMgZnVuY3Rpb25cblx0XHQgKiBhbGxvd3MgeW91IHRvIG1vZGlmeSB0aGUgdGFibGUgZm9vdGVyIG9uIGV2ZXJ5ICdkcmF3JyBldmVudC5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtub2RlfSBmb290IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgZm9vdGVyXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXG5cdFx0ICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcblx0XHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdFx0ICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0XHQgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZm9vdGVyQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiZm9vdGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHRmb290LCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHRcdCAqICAgICAgICAgIHRmb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiU3RhcnRpbmcgaW5kZXggaXMgXCIrc3RhcnQ7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImZuRm9vdGVyQ2FsbGJhY2tcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gcmVuZGVyaW5nIGxhcmdlIG51bWJlcnMgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuXHRcdCAqIChpLmUuIFwiU2hvd2luZyAxIHRvIDEwIG9mIDU3IGVudHJpZXNcIikgRGF0YVRhYmxlcyB3aWxsIHJlbmRlciBsYXJnZSBudW1iZXJzXG5cdFx0ICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xuXHRcdCAqIHJlbmRlcmVkIGFzIFwiMSwwMDAsMDAwXCIpIHRvIGhlbHAgcmVhZGFiaWxpdHkgZm9yIHRoZSBlbmQgdXNlci4gVGhpc1xuXHRcdCAqIGZ1bmN0aW9uIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbWV0aG9kIERhdGFUYWJsZXMgdXNlcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge2ludH0gdG9Gb3JtYXQgbnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuXHRcdCAqICBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBEYXRhVGFibGVzIHRvIHNob3cgdGhlIG51bWJlclxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvcm1hdE51bWJlclxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIGEgc2luZ2xlIHF1b3RlIGZvciB0aGUgc2VwYXJhdG9yIChub3RlIHRoYXRcblx0XHQgKiAgICAvLyB0aGlzIGNhbiBhbHNvIGJlIGRvbmUgd2l0aCB0aGUgbGFuZ3VhZ2UudGhvdXNhbmRzIG9wdGlvbilcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0ICogICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCInXCJcblx0XHQgKiAgICAgICAgICApO1xuXHRcdCAqICAgICAgICB9O1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XG5cdFx0XHRyZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcblx0XHRcdFx0dGhpcy5vTGFuZ3VhZ2Uuc1Rob3VzYW5kc1xuXHRcdFx0KTtcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHRcdCAqIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgaGVhZGVyIHJvdy4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgYW5kXG5cdFx0ICogZGlzcGxheSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IGhlYWQgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBoZWFkZXJcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBGdWxsIHRhYmxlIGRhdGEgKGFzIGRlcml2ZWQgZnJvbSB0aGUgb3JpZ2luYWwgSFRNTClcblx0XHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxuXHRcdCAqICAgIGRpc3BsYXkgYXJyYXlcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGVuZCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBlbmRpbmcgcG9pbnQgaW4gdGhlXG5cdFx0ICogICAgZGlzcGxheSBhcnJheVxuXHRcdCAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxuXHRcdCAqICAgIHRvIHRoZSBmdWxsIGRhdGEgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5oZWFkZXJDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJmaGVhZGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIGhlYWQsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XG5cdFx0ICogICAgICAgICAgaGVhZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIkRpc3BsYXlpbmcgXCIrKGVuZC1zdGFydCkrXCIgcmVjb3Jkc1wiO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJmbkhlYWRlckNhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaW5mb3JtYXRpb24gZWxlbWVudCBjYW4gYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRcblx0XHQgKiBzdGF0ZSBvZiB0aGUgdGFibGUuIEFsdGhvdWdoIHRoZSBpbnRlcm5hdGlvbmFsaXNhdGlvbiBvcHRpb25zIHByZXNlbnRlZCBieVxuXHRcdCAqIERhdGFUYWJsZXMgYXJlIHF1aXRlIGNhcGFibGUgb2YgZGVhbGluZyB3aXRoIG1vc3QgY3VzdG9taXNhdGlvbnMsIHRoZXJlIG1heVxuXHRcdCAqIGJlIHRpbWVzIHdoZXJlIHlvdSB3aXNoIHRvIGN1c3RvbWlzZSB0aGUgc3RyaW5nIGZ1cnRoZXIuIFRoaXMgY2FsbGJhY2tcblx0XHQgKiBhbGxvd3MgeW91IHRvIGRvIGV4YWN0bHkgdGhhdC5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgU3RhcnRpbmcgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGVuZCBFbmQgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcblx0XHQgKiAgQHBhcmFtIHtpbnR9IG1heCBUb3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGFibGUgKHJlZ2FyZGxlc3Mgb2Zcblx0XHQgKiAgICBmaWx0ZXJpbmcpXG5cdFx0ICogIEBwYXJhbSB7aW50fSB0b3RhbCBUb3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgZGF0YSBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICBAcGFyYW0ge3N0cmluZ30gcHJlIFRoZSBzdHJpbmcgdGhhdCBEYXRhVGFibGVzIGhhcyBmb3JtYXR0ZWQgdXNpbmcgaXQnc1xuXHRcdCAqICAgIG93biBydWxlc1xuXHRcdCAqICBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvQ2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICBcImluZm9DYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIHByZSApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIHN0YXJ0ICtcIiB0byBcIisgZW5kO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsZWQgd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuIE5vcm1hbGx5IERhdGFUYWJsZXMgd2lsbFxuXHRcdCAqIGluaXRpYWxpc2Ugc2VxdWVudGlhbGx5IGFuZCB0aGVyZSB3aWxsIGJlIG5vIG5lZWQgZm9yIHRoaXMgZnVuY3Rpb24sXG5cdFx0ICogaG93ZXZlciwgdGhpcyBkb2VzIG5vdCBob2xkIHRydWUgd2hlbiB1c2luZyBleHRlcm5hbCBsYW5ndWFnZSBpbmZvcm1hdGlvblxuXHRcdCAqIHNpbmNlIHRoYXQgaXMgb2J0YWluZWQgdXNpbmcgYW4gYXN5bmMgWEhSIGNhbGwuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgSlNPTiBvYmplY3QgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIgLSBvbmx5XG5cdFx0ICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5pdENvbXBsZXRlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImluaXRDb21wbGV0ZVwiOiBmdW5jdGlvbihzZXR0aW5ncywganNvbikge1xuXHRcdCAqICAgICAgICAgIGFsZXJ0KCAnRGF0YVRhYmxlcyBoYXMgZmluaXNoZWQgaXRzIGluaXRpYWxpc2F0aW9uLicgKTtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiZm5Jbml0Q29tcGxldGVcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxlZCBhdCB0aGUgdmVyeSBzdGFydCBvZiBlYWNoIHRhYmxlIGRyYXcgYW5kIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGVcblx0XHQgKiBkcmF3IGJ5IHJldHVybmluZyBmYWxzZSwgYW55IG90aGVyIHJldHVybiAoaW5jbHVkaW5nIHVuZGVmaW5lZCkgcmVzdWx0cyBpblxuXHRcdCAqIHRoZSBmdWxsIGRyYXcgb2NjdXJyaW5nKS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSBGYWxzZSB3aWxsIGNhbmNlbCB0aGUgZHJhdywgYW55dGhpbmcgZWxzZSAoaW5jbHVkaW5nIG5vXG5cdFx0ICogICAgcmV0dXJuKSB3aWxsIGFsbG93IGl0IHRvIGNvbXBsZXRlLlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByZURyYXdDYWxsYmFja1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwcmVEcmF3Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdCAqICAgICAgICAgIGlmICggJCgnI3Rlc3QnKS52YWwoKSA9PSAxICkge1xuXHRcdCAqICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImZuUHJlRHJhd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gJ3Bvc3QgcHJvY2VzcycgZWFjaCByb3cgYWZ0ZXIgaXQgaGF2ZSBiZWVuXG5cdFx0ICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXG5cdFx0ICogZnVuY3Rpb24gbWlnaHQgYmUgdXNlZCBmb3Igc2V0dGluZyB0aGUgcm93IGNsYXNzIG5hbWUgZXRjLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG5cdFx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSBkaXNwbGF5SW5kZXggVGhlIGRpc3BsYXkgaW5kZXggZm9yIHRoZSBjdXJyZW50IHRhYmxlIGRyYXdcblx0XHQgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleEZ1bGwgVGhlIGluZGV4IG9mIHRoZSBkYXRhIGluIHRoZSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiAgICByb3dzIChhZnRlciBmaWx0ZXJpbmcpXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93Q2FsbGJhY2tcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwicm93Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGlzcGxheUluZGV4LCBkaXNwbGF5SW5kZXhGdWxsICkge1xuXHRcdCAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXG5cdFx0ICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiICkge1xuXHRcdCAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblJvd0NhbGxiYWNrXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIHdoaWNoIG9idGFpbnNcblx0XHQgKiB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgc28gc29tZXRoaW5nIG1vcmUgc3VpdGFibGUgZm9yIHlvdXIgYXBwbGljYXRpb24uXG5cdFx0ICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIHVzZSBQT1NUIGRhdGEsIG9yIHB1bGwgaW5mb3JtYXRpb24gZnJvbSBhIEdlYXJzIG9yXG5cdFx0ICogQUlSIGRhdGFiYXNlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgSFRUUCBzb3VyY2UgdG8gb2J0YWluIHRoZSBkYXRhIGZyb20gKGBhamF4YClcblx0XHQgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBBIGtleS92YWx1ZSBwYWlyIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIHRvIHNlbmRcblx0XHQgKiAgICB0byB0aGUgc2VydmVyXG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9mIHRoZSBkYXRhIGdldFxuXHRcdCAqICAgIHByb2Nlc3MgdGhhdCB3aWxsIGRyYXcgdGhlIGRhdGEgb24gdGhlIHBhZ2UuXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJEYXRhXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJmblNlcnZlckRhdGFcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHRcdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHQgKlxuXHRcdCAqICBJdCBpcyBvZnRlbiB1c2VmdWwgdG8gc2VuZCBleHRyYSBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBtYWtpbmcgYW4gQWpheFxuXHRcdCAqIHJlcXVlc3QgLSBmb3IgZXhhbXBsZSBjdXN0b20gZmlsdGVyaW5nIGluZm9ybWF0aW9uLCBhbmQgdGhpcyBjYWxsYmFja1xuXHRcdCAqIGZ1bmN0aW9uIG1ha2VzIGl0IHRyaXZpYWwgdG8gc2VuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgc2VydmVyLiBUaGVcblx0XHQgKiBwYXNzZWQgaW4gcGFyYW1ldGVyIGlzIHRoZSBkYXRhIHNldCB0aGF0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGJ5XG5cdFx0ICogRGF0YVRhYmxlcywgYW5kIHlvdSBjYW4gYWRkIHRvIHRoaXMgb3IgbW9kaWZ5IGl0IGFzIHlvdSByZXF1aXJlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgYXJyYXkgKGFycmF5IG9mIG9iamVjdHMgd2hpY2ggYXJlIG5hbWUvdmFsdWVcblx0XHQgKiAgICBwYWlycykgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieSBEYXRhVGFibGVzIGFuZCB3aWxsIGJlIHNlbnQgdG8gdGhlXG5cdFx0ICogICAgc2VydmVyLiBJbiB0aGUgY2FzZSBvZiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHQgKiAgICB0aGlzIHdpbGwgYmUgYW4gZW1wdHkgYXJyYXksIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZXJlIHdpbGwgYmUgYVxuXHRcdCAqICAgIHNpZ25pZmljYW50IG51bWJlciBvZiBwYXJhbWV0ZXJzIVxuXHRcdCAqICBAcmV0dXJucyB7dW5kZWZpbmVkfSBFbnN1cmUgdGhhdCB5b3UgbW9kaWZ5IHRoZSBkYXRhIGFycmF5IHBhc3NlZCBpbixcblx0XHQgKiAgICBhcyB0aGlzIGlzIHBhc3NlZCBieSByZWZlcmVuY2UuXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclBhcmFtc1xuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwiZm5TZXJ2ZXJQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXG5cdFx0ICogc3RhdGUgb2YgYSB0YWJsZSBpcyBsb2FkZWQuIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvYWQgZnJvbSBgbG9jYWxTdG9yYWdlYFxuXHRcdCAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAbWVtYmVyXG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCBjYW4gYmUgZXhlY3V0ZWQgd2hlbiBkb25lLiBJdFxuXHRcdCAqICAgIHNob3VsZCBiZSBwYXNzZWQgdGhlIGxvYWRlZCBzdGF0ZSBvYmplY3QuXG5cdFx0ICogIEByZXR1cm4ge29iamVjdH0gVGhlIERhdGFUYWJsZXMgc3RhdGUgb2JqZWN0IHRvIGJlIGxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZENhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgY2FsbGJhY2spIHtcblx0XHQgKiAgICAgICAgICAkLmFqYXgoIHtcblx0XHQgKiAgICAgICAgICAgIFwidXJsXCI6IFwiL3N0YXRlX2xvYWRcIixcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0ICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcblx0XHQgKiAgICAgICAgICAgICAgY2FsbGJhY2soIGpzb24gKTtcblx0XHQgKiAgICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgICB9ICk7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShcblx0XHRcdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXG5cdFx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgcHJpb3IgdG8gbG9hZGluZyB0aGF0IHN0YXRlLlxuXHRcdCAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkIGRhdGEsIGJ1dFxuXHRcdCAqIHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlLiBOb3RlIHRoYXQgZm9yXG5cdFx0ICogcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYHN0YXRlTG9hZFBhcmFtc2AgZXZlbnQgdG8gbG9hZCBwYXJhbWV0ZXJzIGZvclxuXHRcdCAqIGEgcGx1Zy1pbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCBpcyB0byBiZSBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRQYXJhbXNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIGxvYWRlZFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIERpc2FsbG93IHN0YXRlIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRQYXJhbXNcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzdGF0ZSBzYXZpbmcgbWV0aG9kXG5cdFx0ICogYW5kIHRoZSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBhcyBhIHJlc3VsdCBvZiB0aGUgbG9hZGVkIHN0YXRlLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IHdhcyBsb2FkZWRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRlZFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gU2hvdyBhbiBhbGVydCB3aXRoIHRoZSBmaWx0ZXJpbmcgdmFsdWUgdGhhdCB3YXMgc2F2ZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlTG9hZGVkXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIGFsZXJ0KCAnU2F2ZWQgZmlsdGVyIHdhczogJytkYXRhLm9TZWFyY2guc1NlYXJjaCApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZUxvYWRlZFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2F2ZSB0aGUgdGFibGUgc3RhdGUuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBkZWZpbmUgd2hlcmUgYW5kIGhvdyB0aGUgc3RhdGVcblx0XHQgKiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlIGlzIHN0b3JlZCBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCB1c2UgYGxvY2FsU3RvcmFnZWBcblx0XHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQG1lbWJlclxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZUNhbGxiYWNrXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHRcdCAqICAgICAgICAgIC8vIFNlbmQgYW4gQWpheCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgd2l0aCB0aGUgc3RhdGUgb2JqZWN0XG5cdFx0ICogICAgICAgICAgJC5hamF4KCB7XG5cdFx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9zYXZlXCIsXG5cdFx0ICogICAgICAgICAgICBcImRhdGFcIjogZGF0YSxcblx0XHQgKiAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0ICogICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIlxuXHRcdCAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uICgpIHt9XG5cdFx0ICogICAgICAgICAgfSApO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzLCBkYXRhICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5zZXRJdGVtKFxuXHRcdFx0XHRcdCdEYXRhVGFibGVzXycrc2V0dGluZ3Muc0luc3RhbmNlKydfJytsb2NhdGlvbi5wYXRobmFtZSxcblx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeSggZGF0YSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXG5cdFx0ICogaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZC4gVGhpcyBtZXRob2QgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZlxuXHRcdCAqIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0IHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Jcblx0XHQgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcblx0XHQgKiB1c2UgdGhlIGBzdGF0ZVNhdmVQYXJhbXNgIGV2ZW50IHRvIHNhdmUgcGFyYW1ldGVycyBmb3IgYSBwbHVnLWluLlxuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZVBhcmFtc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgc2F2ZWRcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuXHRcdCAqICAgICAgICBcInN0YXRlU2F2ZVBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0XHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmblN0YXRlU2F2ZVBhcmFtc1wiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkLiBBZnRlciB0aGlzIHBlcmlvZFxuXHRcdCAqIGhhcyBlbGFwc2VkIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHRvIHRoZSBkZWZhdWx0LlxuXHRcdCAqIFZhbHVlIGlzIGdpdmVuIGluIHNlY29uZHMuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCA3MjAwIDxpPigyIGhvdXJzKTwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVEdXJhdGlvblxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzdGF0ZUR1cmF0aW9uXCI6IDYwKjYwKjI0OyAvLyAxIGRheVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwiaVN0YXRlRHVyYXRpb25cIjogNzIwMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGwgbm90IG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgZm9yIHRoZSBmaXJzdFxuXHRcdCAqIHBhZ2UgZHJhdyAtIHJhdGhlciBpdCB3aWxsIHVzZSB0aGUgZGF0YSBhbHJlYWR5IG9uIHRoZSBwYWdlIChubyBzb3J0aW5nIGV0Y1xuXHRcdCAqIHdpbGwgYmUgYXBwbGllZCB0byBpdCksIHRodXMgc2F2aW5nIG9uIGFuIFhIUiBhdCBsb2FkIHRpbWUuIGBkZWZlckxvYWRpbmdgXG5cdFx0ICogaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGRlZmVycmVkIGxvYWRpbmcgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBhbHNvIHVzZWRcblx0XHQgKiB0byB0ZWxsIERhdGFUYWJsZXMgaG93IG1hbnkgcmVjb3JkcyB0aGVyZSBhcmUgaW4gdGhlIGZ1bGwgdGFibGUgKGFsbG93aW5nXG5cdFx0ICogdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgYW5kIHBhZ2luYXRpb24gdG8gYmUgZGlzcGxheWVkIGNvcnJlY3RseSkuIEluIHRoZSBjYXNlXG5cdFx0ICogd2hlcmUgYSBmaWx0ZXJpbmcgaXMgYXBwbGllZCB0byB0aGUgdGFibGUgb24gaW5pdGlhbCBsb2FkLCB0aGlzIGNhbiBiZVxuXHRcdCAqIGluZGljYXRlZCBieSBnaXZpbmcgdGhlIHBhcmFtZXRlciBhcyBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcblx0XHQgKiB0aGUgbnVtYmVyIG9mIHJlY29yZHMgYXZhaWxhYmxlIGFmdGVyIGZpbHRlcmluZyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZVxuXHRcdCAqIG51bWJlciBvZiByZWNvcmRzIHdpdGhvdXQgZmlsdGVyaW5nIChhbGxvd2luZyB0aGUgdGFibGUgaW5mb3JtYXRpb24gZWxlbWVudFxuXHRcdCAqIHRvIGJlIHNob3duIGNvcnJlY3RseSkuXG5cdFx0ICogIEB0eXBlIGludCB8IGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGVmZXJMb2FkaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyA1NyByZWNvcmRzIGF2YWlsYWJsZSBpbiB0aGUgdGFibGUsIG5vIGZpbHRlcmluZyBhcHBsaWVkXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdFx0ICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IDU3XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gNTcgcmVjb3JkcyBhZnRlciBmaWx0ZXJpbmcsIDEwMCB3aXRob3V0IGZpbHRlcmluZyAoYW4gaW5pdGlhbCBmaWx0ZXIgYXBwbGllZClcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0XHQgKiAgICAgICAgXCJhamF4XCI6IFwic2NyaXB0cy9zZXJ2ZXJfcHJvY2Vzc2luZy5waHBcIixcblx0XHQgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogWyA1NywgMTAwIF0sXG5cdFx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcblx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIm15X2ZpbHRlclwiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJpRGVmZXJMb2FkaW5nXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IG9uIGEgc2luZ2xlIHBhZ2Ugd2hlbiB1c2luZyBwYWdpbmF0aW9uLiBJZlxuXHRcdCAqIGZlYXR1cmUgZW5hYmxlZCAoYGxlbmd0aENoYW5nZWApIHRoZW4gdGhlIGVuZCB1c2VyIHdpbGwgYmUgYWJsZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoaXMgdG8gYSBjdXN0b20gc2V0dGluZyB1c2luZyBhIHBvcC11cCBtZW51LlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMTBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnZUxlbmd0aFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJwYWdlTGVuZ3RoXCI6IDUwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJpRGlzcGxheUxlbmd0aFwiOiAxMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGRhdGEgZGlzcGxheSB3aGVuIHVzaW5nIERhdGFUYWJsZXMgd2l0aFxuXHRcdCAqIHBhZ2luYXRpb24uIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJhdGhlciB0aGFuXG5cdFx0ICogdGhlIHBhZ2UgbnVtYmVyLCBzbyBpZiB5b3UgaGF2ZSAxMCByZWNvcmRzIHBlciBwYWdlIGFuZCB3YW50IHRvIHN0YXJ0IG9uXG5cdFx0ICogdGhlIHRoaXJkIHBhZ2UsIGl0IHNob3VsZCBiZSBcIjIwXCIuXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRpc3BsYXlTdGFydFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkaXNwbGF5U3RhcnRcIjogMjBcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9IClcblx0XHQgKi9cblx0XHRcImlEaXNwbGF5U3RhcnRcIjogMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcblx0XHQgKiBhbmQgZmlsdGVyaW5nKSBieSBhZGRpbmcgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSB0byB0aGUgcmVxdWlyZWQgZWxlbWVudHMuIFRoaXNcblx0XHQgKiBhbGxvd3MgeW91IHRvIHRhYiB0aHJvdWdoIHRoZSBjb250cm9scyBhbmQgcHJlc3MgdGhlIGVudGVyIGtleSB0byBhY3RpdmF0ZSB0aGVtLlxuXHRcdCAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuXHRcdCAqIFlvdSBjYW4gb3ZlcnJ1bGUgdGhpcyB1c2luZyB0aGlzIHBhcmFtZXRlciBpZiB5b3Ugd2lzaC4gVXNlIGEgdmFsdWUgb2YgLTEgdG9cblx0XHQgKiBkaXNhYmxlIGJ1aWx0LWluIGtleWJvYXJkIG5hdmlnYXRpb24uXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnRhYkluZGV4XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInRhYkluZGV4XCI6IDFcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJpVGFiSW5kZXhcIjogMCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsYXNzZXMgdGhhdCBEYXRhVGFibGVzIGFzc2lnbnMgdG8gdGhlIHZhcmlvdXMgY29tcG9uZW50cyBhbmQgZmVhdHVyZXNcblx0XHQgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxuXHRcdCAqIGR1cmluZyBpbml0aWFsaXNhdGlvbiBpbiBhZGRpdGlvbiB0byB0aHJvdWdoIHRoZSBzdGF0aWNcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vU3RkQ2xhc3Nlc30gb2JqZWN0KS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY2xhc3Nlc1xuXHRcdCAqL1xuXHRcdFwib0NsYXNzZXNcIjoge30sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBBbGwgc3RyaW5ncyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbiB0aGUgdXNlciBpbnRlcmZhY2UgdGhhdCBpdCBjcmVhdGVzXG5cdFx0ICogYXJlIGRlZmluZWQgaW4gdGhpcyBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBtb2RpZmllZCB0aGVtIGluZGl2aWR1YWxseSBvclxuXHRcdCAqIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGVtIGFsbCBhcyByZXF1aXJlZC5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Vcblx0XHQgKi9cblx0XHRcIm9MYW5ndWFnZVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG5cdFx0XHQgKiBhY3R1YWxseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBidXQgd2lsbCBiZSByZWFkIGJ5IHNjcmVlbnJlYWRlcnMsIGFuZCB0aHVzXG5cdFx0XHQgKiBtdXN0IGJlIGludGVybmF0aW9uYWxpc2VkIGFzIHdlbGwpLlxuXHRcdFx0ICogIEBuYW1lc3BhY2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYVxuXHRcdFx0ICovXG5cdFx0XHRcIm9BcmlhXCI6IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXG5cdFx0XHRcdCAqIHNvcnRlZCBhc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG5cdFx0XHRcdCAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cblx0XHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0XHQgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydEFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInNvcnRBc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBhc2NlbmRpbmdcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcIixcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIG1heSBiZVxuXHRcdFx0XHQgKiBzb3J0ZWQgZGVzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cblx0XHRcdFx0ICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0RGVzY2VuZGluZ1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcInNvcnREZXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgZGVzY2VuZGluZ1wiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic1NvcnREZXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBkZXNjZW5kaW5nXCJcblx0XHRcdH0sXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYWdpbmF0aW9uIHN0cmluZyB1c2VkIGJ5IERhdGFUYWJsZXMgZm9yIHRoZSBidWlsdC1pbiBwYWdpbmF0aW9uXG5cdFx0XHQgKiBjb250cm9sIHR5cGVzLlxuXHRcdFx0ICogIEBuYW1lc3BhY2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGVcblx0XHRcdCAqL1xuXHRcdFx0XCJvUGFnaW5hdGVcIjoge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGV4dCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ2Z1bGxfbnVtYmVycycgdHlwZSBvZiBwYWdpbmF0aW9uIGZvciB0aGVcblx0XHRcdFx0ICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGZpcnN0IHBhZ2UuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IEZpcnN0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5maXJzdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgICAgXCJmaXJzdFwiOiBcIkZpcnN0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNGaXJzdFwiOiBcIkZpcnN0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG5cdFx0XHRcdCAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBsYXN0IHBhZ2UuXG5cdFx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdFx0ICogIEBkZWZhdWx0IExhc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmxhc3Rcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwibGFzdFwiOiBcIkxhc3QgcGFnZVwiXG5cdFx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdFx0ICogICAgICAgIH1cblx0XHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHRcdCAqICAgIH0gKTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdFwic0xhc3RcIjogXCJMYXN0XCIsXG5cdFxuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ25leHQnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvIHRoZVxuXHRcdFx0XHQgKiBuZXh0IHBhZ2UpLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBOZXh0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5uZXh0XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdFx0ICogICAgICAgICAgICBcIm5leHRcIjogXCJOZXh0IHBhZ2VcIlxuXHRcdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgICB9XG5cdFx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0XHQgKiAgICB9ICk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRcInNOZXh0XCI6IFwiTmV4dFwiLFxuXHRcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICdwcmV2aW91cycgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG9cblx0XHRcdFx0ICogdGhlIHByZXZpb3VzIHBhZ2UpLlxuXHRcdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHRcdCAqICBAZGVmYXVsdCBQcmV2aW91c1xuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUucHJldmlvdXNcblx0XHRcdFx0ICpcblx0XHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHRcdCAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuXHRcdFx0XHQgKiAgICAgICAgICAgIFwicHJldmlvdXNcIjogXCJQcmV2aW91cyBwYWdlXCJcblx0XHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdFx0ICogICAgfSApO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0XCJzUHJldmlvdXNcIjogXCJQcmV2aW91c1wiXG5cdFx0XHR9LFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBzdHJpbmcgaXMgc2hvd24gaW4gcHJlZmVyZW5jZSB0byBgemVyb1JlY29yZHNgIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0XHQgKiBlbXB0eSBvZiBkYXRhIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuIE5vdGUgdGhhdCB0aGlzIGlzIGFuIG9wdGlvbmFsXG5cdFx0XHQgKiBwYXJhbWV0ZXIgLSBpZiBpdCBpcyBub3QgZ2l2ZW4sIHRoZSB2YWx1ZSBvZiBgemVyb1JlY29yZHNgIHdpbGwgYmUgdXNlZFxuXHRcdFx0ICogaW5zdGVhZCAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGdpdmVuIHZhbHVlKS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZW1wdHlUYWJsZVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJlbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIHN0cmluZyBnaXZlcyBpbmZvcm1hdGlvbiB0byB0aGUgZW5kIHVzZXIgYWJvdXQgdGhlIGluZm9ybWF0aW9uXG5cdFx0XHQgKiB0aGF0IGlzIGN1cnJlbnQgb24gZGlzcGxheSBvbiB0aGUgcGFnZS4gVGhlIGZvbGxvd2luZyB0b2tlbnMgY2FuIGJlXG5cdFx0XHQgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXG5cdFx0XHQgKiBkaXNwbGF5IHVwZGF0ZXMuIFRoaXMgdG9rZW5zIGNhbiBiZSBwbGFjZWQgYW55d2hlcmUgaW4gdGhlIHN0cmluZywgb3Jcblx0XHRcdCAqIHJlbW92ZWQgYXMgbmVlZGVkIGJ5IHRoZSBsYW5ndWFnZSByZXF1aXJlczpcblx0XHRcdCAqXG5cdFx0XHQgKiAqIGBcXF9TVEFSVFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBmaXJzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdFx0ICogKiBgXFxfRU5EXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGxhc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHRcdCAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcblx0XHRcdCAqICogYFxcX01BWFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgd2l0aG91dCBmaWx0ZXJpbmdcblx0XHRcdCAqICogYFxcX1BBR0VcXF9gIC0gQ3VycmVudCBwYWdlIG51bWJlclxuXHRcdFx0ICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiaW5mb1wiOiBcIlNob3dpbmcgcGFnZSBfUEFHRV8gb2YgX1BBR0VTX1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9cIjogXCJTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGlzcGxheSBpbmZvcm1hdGlvbiBzdHJpbmcgZm9yIHdoZW4gdGhlIHRhYmxlIGlzIGVtcHR5LiBUeXBpY2FsbHkgdGhlXG5cdFx0XHQgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9FbXB0eVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJpbmZvRW1wdHlcIjogXCJObyBlbnRyaWVzIHRvIHNob3dcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvRW1wdHlcIjogXCJTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxuXHRcdFx0ICogdG8gdGhlIGluZm9ybWF0aW9uIChgaW5mb2ApIHRvIGdpdmUgYW4gaWRlYSBvZiBob3cgc3Ryb25nIHRoZSBmaWx0ZXJpbmdcblx0XHRcdCAqIGlzLiBUaGUgdmFyaWFibGUgX01BWF8gaXMgZHluYW1pY2FsbHkgdXBkYXRlZC5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCAoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0ZpbHRlcmVkXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9GaWx0ZXJlZFwiOiBcIiAtIGZpbHRlcmluZyBmcm9tIF9NQVhfIHJlY29yZHNcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNJbmZvRmlsdGVyZWRcIjogXCIoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIElmIGNhbiBiZSB1c2VmdWwgdG8gYXBwZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBpbmZvIHN0cmluZyBhdCB0aW1lcyxcblx0XHRcdCAqIGFuZCB0aGlzIHZhcmlhYmxlIGRvZXMgZXhhY3RseSB0aGF0LiBUaGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgYXBwZW5kZWQgdG9cblx0XHRcdCAqIHRoZSBgaW5mb2AgKGBpbmZvRW1wdHlgIGFuZCBgaW5mb0ZpbHRlcmVkYCBpbiB3aGF0ZXZlciBjb21iaW5hdGlvbiB0aGV5IGFyZVxuXHRcdFx0ICogYmVpbmcgdXNlZCkgYXQgYWxsIHRpbWVzLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9Qb3N0Rml4XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImluZm9Qb3N0Rml4XCI6IFwiQWxsIHJlY29yZHMgc2hvd24gYXJlIGRlcml2ZWQgZnJvbSByZWFsIGluZm9ybWF0aW9uLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBkZWNpbWFsIHBsYWNlIG9wZXJhdG9yIGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlclxuXHRcdFx0ICogbGFuZ3VhZ2Ugb3B0aW9ucyBzaW5jZSBEYXRhVGFibGVzIGRvZXNuJ3Qgb3V0cHV0IGZsb2F0aW5nIHBvaW50XG5cdFx0XHQgKiBudW1iZXJzLCBzbyBpdCB3b24ndCBldmVyIHVzZSB0aGlzIGZvciBkaXNwbGF5IG9mIGEgbnVtYmVyLiBSYXRoZXIsXG5cdFx0XHQgKiB3aGF0IHRoaXMgcGFyYW1ldGVyIGRvZXMgaXMgbW9kaWZ5IHRoZSBzb3J0IG1ldGhvZHMgb2YgdGhlIHRhYmxlIHNvXG5cdFx0XHQgKiB0aGF0IG51bWJlcnMgd2hpY2ggYXJlIGluIGEgZm9ybWF0IHdoaWNoIGhhcyBhIGNoYXJhY3RlciBvdGhlciB0aGFuXG5cdFx0XHQgKiBhIHBlcmlvZCAoYC5gKSBhcyBhIGRlY2ltYWwgcGxhY2Ugd2lsbCBiZSBzb3J0ZWQgbnVtZXJpY2FsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogTm90ZSB0aGF0IG51bWJlcnMgd2l0aCBkaWZmZXJlbnQgZGVjaW1hbCBwbGFjZXMgY2Fubm90IGJlIHNob3duIGluXG5cdFx0XHQgKiB0aGUgc2FtZSB0YWJsZSBhbmQgc3RpbGwgYmUgc29ydGFibGUsIHRoZSB0YWJsZSBtdXN0IGJlIGNvbnNpc3RlbnQuXG5cdFx0XHQgKiBIb3dldmVyLCBtdWx0aXBsZSBkaWZmZXJlbnQgdGFibGVzIG9uIHRoZSBwYWdlIGNhbiB1c2UgZGlmZmVyZW50XG5cdFx0XHQgKiBkZWNpbWFsIHBsYWNlIGNoYXJhY3RlcnMuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5kZWNpbWFsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImRlY2ltYWxcIjogXCIsXCJcblx0XHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0RlY2ltYWxcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEYXRhVGFibGVzIGhhcyBhIGJ1aWxkIGluIG51bWJlciBmb3JtYXR0ZXIgKGBmb3JtYXROdW1iZXJgKSB3aGljaCBpc1xuXHRcdFx0ICogdXNlZCB0byBmb3JtYXQgbGFyZ2UgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0YWJsZSBpbmZvcm1hdGlvbi5cblx0XHRcdCAqIEJ5IGRlZmF1bHQgYSBjb21tYSBpcyB1c2VkLCBidXQgdGhpcyBjYW4gYmUgdHJpdmlhbGx5IGNoYW5nZWQgdG8gYW55XG5cdFx0XHQgKiBjaGFyYWN0ZXIgeW91IHdpc2ggd2l0aCB0aGlzIHBhcmFtZXRlci5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCAsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS50aG91c2FuZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiJ1wiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1Rob3VzYW5kc1wiOiBcIixcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXRhaWwgdGhlIGFjdGlvbiB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgZHJvcCBkb3duIG1lbnUgZm9yIHRoZVxuXHRcdFx0ICogcGFnaW5hdGlvbiBsZW5ndGggb3B0aW9uIGlzIGNoYW5nZWQuIFRoZSAnX01FTlVfJyB2YXJpYWJsZSBpcyByZXBsYWNlZFxuXHRcdFx0ICogd2l0aCBhIGRlZmF1bHQgc2VsZWN0IGxpc3Qgb2YgMTAsIDI1LCA1MCBhbmQgMTAwLCBhbmQgY2FuIGJlIHJlcGxhY2VkXG5cdFx0XHQgKiB3aXRoIGEgY3VzdG9tIHNlbGVjdCBib3ggaWYgcmVxdWlyZWQuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgU2hvdyBfTUVOVV8gZW50cmllc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubGVuZ3RoTWVudVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTGFuZ3VhZ2UgY2hhbmdlIG9ubHlcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiBcIkRpc3BsYXkgX01FTlVfIHJlY29yZHNcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTGFuZ3VhZ2UgYW5kIG9wdGlvbnMgY2hhbmdlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogJ0Rpc3BsYXkgPHNlbGVjdD4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjIwXCI+MjA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjMwXCI+MzA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjQwXCI+NDA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjUwXCI+NTA8L29wdGlvbj4nK1xuXHRcdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIi0xXCI+QWxsPC9vcHRpb24+Jytcblx0XHRcdCAqICAgICAgICAgICAgJzwvc2VsZWN0PiByZWNvcmRzJ1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNMZW5ndGhNZW51XCI6IFwiU2hvdyBfTUVOVV8gZW50cmllc1wiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZW4gdXNpbmcgQWpheCBzb3VyY2VkIGRhdGEgYW5kIGR1cmluZyB0aGUgZmlyc3QgZHJhdyB3aGVuIERhdGFUYWJsZXMgaXNcblx0XHRcdCAqIGdhdGhlcmluZyB0aGUgZGF0YSwgdGhpcyBtZXNzYWdlIGlzIHNob3duIGluIGFuIGVtcHR5IHJvdyBpbiB0aGUgdGFibGUgdG9cblx0XHRcdCAqIGluZGljYXRlIHRvIHRoZSBlbmQgdXNlciB0aGUgdGhlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLiBOb3RlIHRoYXQgdGhpc1xuXHRcdFx0ICogcGFyYW1ldGVyIGlzIG5vdCB1c2VkIHdoZW4gbG9hZGluZyBkYXRhIGJ5IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIGp1c3Rcblx0XHRcdCAqIEFqYXggc291cmNlZCBkYXRhIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBMb2FkaW5nLi4uXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sb2FkaW5nUmVjb3Jkc1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJsb2FkaW5nUmVjb3Jkc1wiOiBcIlBsZWFzZSB3YWl0IC0gbG9hZGluZy4uLlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTG9hZGluZy4uLlwiLFxuXHRcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFRleHQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYmxlIGlzIHByb2Nlc3NpbmcgYSB1c2VyIGFjdGlvblxuXHRcdFx0ICogKHVzdWFsbHkgYSBzb3J0IGNvbW1hbmQgb3Igc2ltaWxhcikuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgUHJvY2Vzc2luZy4uLlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucHJvY2Vzc2luZ1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJwcm9jZXNzaW5nXCI6IFwiRGF0YVRhYmxlcyBpcyBjdXJyZW50bHkgYnVzeVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1Byb2Nlc3NpbmdcIjogXCJQcm9jZXNzaW5nLi4uXCIsXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRGV0YWlscyB0aGUgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgdXNlciB0eXBlcyBpbnRvIHRoZVxuXHRcdFx0ICogZmlsdGVyaW5nIGlucHV0IHRleHQgYm94LiBUaGUgdmFyaWFibGUgXCJfSU5QVVRfXCIsIGlmIHVzZWQgaW4gdGhlIHN0cmluZyxcblx0XHRcdCAqIGlzIHJlcGxhY2VkIHdpdGggdGhlIEhUTUwgdGV4dCBib3ggZm9yIHRoZSBmaWx0ZXJpbmcgaW5wdXQgYWxsb3dpbmdcblx0XHRcdCAqIGNvbnRyb2wgb3ZlciB3aGVyZSBpdCBhcHBlYXJzIGluIHRoZSBzdHJpbmcuIElmIFwiX0lOUFVUX1wiIGlzIG5vdCBnaXZlblxuXHRcdFx0ICogdGhlbiB0aGUgaW5wdXQgYm94IGlzIGFwcGVuZGVkIHRvIHRoZSBzdHJpbmcgYXV0b21hdGljYWxseS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBTZWFyY2g6XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIElucHV0IHRleHQgYm94IHdpbGwgYmUgYXBwZW5kZWQgYXQgdGhlIGVuZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkZpbHRlciByZWNvcmRzOlwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBTcGVjaWZ5IHdoZXJlIHRoZSBmaWx0ZXIgc2hvdWxkIGFwcGVhclxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJBcHBseSBmaWx0ZXIgX0lOUFVUXyB0byB0YWJsZVwiXG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1NlYXJjaFwiOiBcIlNlYXJjaDpcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoUGxhY2Vob2xkZXJcblx0XHRcdCAqL1xuXHRcdFx0XCJzU2VhcmNoUGxhY2Vob2xkZXJcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbGwgb2YgdGhlIGxhbmd1YWdlIGluZm9ybWF0aW9uIGNhbiBiZSBzdG9yZWQgaW4gYSBmaWxlIG9uIHRoZVxuXHRcdFx0ICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cblx0XHRcdCAqIEl0IG11c3Qgc3RvcmUgdGhlIFVSTCBvZiB0aGUgbGFuZ3VhZ2UgZmlsZSwgd2hpY2ggaXMgaW4gYSBKU09OIGZvcm1hdCxcblx0XHRcdCAqIGFuZCB0aGUgb2JqZWN0IGhhcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBvTGFuZ3VhZ2Ugb2JqZWN0IGluIHRoZVxuXHRcdFx0ICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxuXHRcdFx0ICogdGhlIGV4YW1wbGUgbGFuZ3VhZ2UgZmlsZXMgdG8gc2VlIGhvdyB0aGlzIHdvcmtzIGluIGFjdGlvbi5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudXJsXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInVybFwiOiBcImh0dHA6Ly93d3cuc3ByeW1lZGlhLmNvLnVrL2RhdGFUYWJsZXMvbGFuZy50eHRcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNVcmxcIjogXCJcIixcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHNob3duIGluc2lkZSB0aGUgdGFibGUgcmVjb3JkcyB3aGVuIHRoZSBpcyBubyBpbmZvcm1hdGlvbiB0byBiZVxuXHRcdFx0ICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXG5cdFx0XHQgKiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFibGUgYXQgYWxsIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFxuXHRcdFx0ICpcblx0XHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuemVyb1JlY29yZHNcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHRcdCAqICAgICAgICAgIFwiemVyb1JlY29yZHNcIjogXCJObyByZWNvcmRzIHRvIGRpc3BsYXlcIlxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNaZXJvUmVjb3Jkc1wiOiBcIk5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcIlxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGhhdmUgZGVmaW5lIHRoZSBnbG9iYWwgZmlsdGVyaW5nIHN0YXRlIGF0XG5cdFx0ICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuXHRcdCAqIGRlZmluZWQsIGJ1dCBhbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFdoZW4gYHJlZ2V4YCBpcyB0cnVlLFxuXHRcdCAqIHRoZSBzZWFyY2ggc3RyaW5nIHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgd2hlbiBmYWxzZVxuXHRcdCAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuXHRcdCAqIERhdGFUYWJsZXMgd2lsbCB1c2UgaXQncyBzbWFydCBmaWx0ZXJpbmcgbWV0aG9kcyAodG8gd29yZCBtYXRjaCBhdFxuXHRcdCAqIGFueSBwb2ludCBpbiB0aGUgZGF0YSksIHdoZW4gZmFsc2UgdGhpcyB3aWxsIG5vdCBiZSBkb25lLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJvU2VhcmNoXCI6ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoICksXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0XHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0ICpcblx0XHQgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvciBgYWFEYXRhYCBmb3Jcblx0XHQgKiBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhIGZyb20gYW4gQWpheFxuXHRcdCAqIHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyIGFsbG93cyB0aGF0XG5cdFx0ICogcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWQgb2JqZWN0IG5vdGF0aW9uIHRvXG5cdFx0ICogZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgZGF0YVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheERhdGFQcm9wXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJzQWpheERhdGFQcm9wXCI6IFwiZGF0YVwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogWW91IGNhbiBpbnN0cnVjdCBEYXRhVGFibGVzIHRvIGxvYWQgZGF0YSBmcm9tIGFuIGV4dGVybmFsXG5cdFx0ICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxuXHRcdCAqIGFscmVhZHkgaGF2ZSkuIFNpbXBseSBwcm92aWRlIGEgdXJsIGEgSlNPTiBvYmplY3QgY2FuIGJlIG9idGFpbmVkIGZyb20uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4U291cmNlXG5cdFx0ICpcblx0XHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdFx0ICovXG5cdFx0XCJzQWpheFNvdXJjZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpbml0aWFsaXNhdGlvbiB2YXJpYWJsZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgZXhhY3RseSB3aGVyZSBpbiB0aGVcblx0XHQgKiBET00geW91IHdhbnQgRGF0YVRhYmxlcyB0byBpbmplY3QgdGhlIHZhcmlvdXMgY29udHJvbHMgaXQgYWRkcyB0byB0aGUgcGFnZVxuXHRcdCAqIChmb3IgZXhhbXBsZSB5b3UgbWlnaHQgd2FudCB0aGUgcGFnaW5hdGlvbiBjb250cm9scyBhdCB0aGUgdG9wIG9mIHRoZVxuXHRcdCAqIHRhYmxlKS4gRElWIGVsZW1lbnRzICh3aXRoIG9yIHdpdGhvdXQgYSBjdXN0b20gY2xhc3MpIGNhbiBhbHNvIGJlIGFkZGVkIHRvXG5cdFx0ICogYWlkIHN0eWxpbmcuIFRoZSBmb2xsb3cgc3ludGF4IGlzIHVzZWQ6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGFsbG93ZWQ6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSBhbGxvd2VkOlxuXHRcdCAqICAgICAgIDx1bD5cblx0XHQgKiAgICAgICAgIDxsaT4nSCcgLSBqUXVlcnlVSSB0aGVtZSBcImhlYWRlclwiIGNsYXNzZXMgKCdmZy10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10ciB1aS1oZWxwZXItY2xlYXJmaXgnKTwvbGk+XG5cdFx0ICogICAgICAgICA8bGk+J0YnIC0galF1ZXJ5VUkgdGhlbWUgXCJmb290ZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuXHRcdCAqICAgICAgIDwvdWw+XG5cdFx0ICogICAgIDwvbGk+XG5cdFx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIHN5bnRheCBpcyBleHBlY3RlZDpcblx0XHQgKiAgICAgICA8dWw+XG5cdFx0ICogICAgICAgICA8bGk+JyZsdDsnIGFuZCAnJmd0OycgLSBkaXYgZWxlbWVudHM8L2xpPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCJjbGFzc1wiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhIGNsYXNzPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O1wiI2lkXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGFuIElEPC9saT5cblx0XHQgKiAgICAgICA8L3VsPlxuXHRcdCAqICAgICA8L2xpPlxuXHRcdCAqICAgICA8bGk+RXhhbXBsZXM6XG5cdFx0ICogICAgICAgPHVsPlxuXHRcdCAqICAgICAgICAgPGxpPicmbHQ7XCJ3cmFwcGVyXCJmbGlwdCZndDsnPC9saT5cblx0XHQgKiAgICAgICAgIDxsaT4nJmx0O2xmJmx0O3QmZ3Q7aXAmZ3Q7JzwvbGk+XG5cdFx0ICogICAgICAgPC91bD5cblx0XHQgKiAgICAgPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBsZnJ0aXAgPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyBmYWxzZSk8L2k+IDxiPm9yPC9iPlxuXHRcdCAqICAgIDxcIkhcImxmcj50PFwiRlwiaXA+IDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgdHJ1ZSk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJkb21cIjogJyZsdDtcInRvcFwiaSZndDtydCZsdDtcImJvdHRvbVwiZmxwJmd0OyZsdDtcImNsZWFyXCImZ3Q7J1xuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNEb21cIjogXCJsZnJ0aXBcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBkZWxheSBvcHRpb24uIFRoaXMgd2lsbCB0aHJvdHRsZSBmdWxsIHRhYmxlIHNlYXJjaGVzIHRoYXQgdXNlIHRoZVxuXHRcdCAqIERhdGFUYWJsZXMgcHJvdmlkZWQgc2VhcmNoIGlucHV0IGVsZW1lbnQgKGl0IGRvZXMgbm90IGVmZmVjdCBjYWxscyB0b1xuXHRcdCAqIGBkdC1hcGkgc2VhcmNoKClgLCBwcm92aWRpbmcgYSBkZWxheSBiZWZvcmUgdGhlIHNlYXJjaCBpcyBtYWRlLlxuXHRcdCAqICBAdHlwZSBpbnRlZ2VyXG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoRGVsYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2VhcmNoRGVsYXlcIjogMjAwXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApXG5cdFx0ICovXG5cdFx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBmZWF0dXJlcyBzaXggZGlmZmVyZW50IGJ1aWx0LWluIG9wdGlvbnMgZm9yIHRoZSBidXR0b25zIHRvXG5cdFx0ICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxuXHRcdCAqXG5cdFx0ICogKiBgbnVtYmVyc2AgLSBQYWdlIG51bWJlciBidXR0b25zIG9ubHlcblx0XHQgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxuXHRcdCAqICogJ3NpbXBsZV9udW1iZXJzYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHRcdCAqICogYGZ1bGxgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9uc1xuXHRcdCAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHRcdCAqICogYGZpcnN0X2xhc3RfbnVtYmVyc2AgLSAnRmlyc3QnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0XHQgKiAgXG5cdFx0ICogRnVydGhlciBtZXRob2RzIGNhbiBiZSBhZGRlZCB1c2luZyB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vUGFnaW5hdGlvbn0uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBzaW1wbGVfbnVtYmVyc1xuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBPcHRpb25zXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdUeXBlXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInBhZ2luZ1R5cGVcIjogXCJmdWxsX251bWJlcnNcIlxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKVxuXHRcdCAqL1xuXHRcdFwic1BhZ2luYXRpb25UeXBlXCI6IFwic2ltcGxlX251bWJlcnNcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZy4gV2hlbiBhIHRhYmxlIGlzIHRvbyB3aWRlIHRvIGZpdCBpbnRvIGFcblx0XHQgKiBjZXJ0YWluIGxheW91dCwgb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUsIHlvdVxuXHRcdCAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXG5cdFx0ICogc2Nyb2xsZWQuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGB0cnVlYCB3aGljaCB3aWxsIGFsbG93IHRoZSB0YWJsZSB0b1xuXHRcdCAqIHNjcm9sbCBob3Jpem9udGFsbHkgd2hlbiBuZWVkZWQsIG9yIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoXG5cdFx0ICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxuXHRcdCAqIGlzIHJlY29tbWVuZGVkLlxuXHRcdCAqICBAdHlwZSBib29sZWFufHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWFxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTY3JvbGxYXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgRGF0YVRhYmxlIHRvIHVzZSBtb3JlIHdpZHRoIHRoYW4gaXRcblx0XHQgKiBtaWdodCBvdGhlcndpc2UgZG8gd2hlbiB4LXNjcm9sbGluZyBpcyBlbmFibGVkLiBGb3IgZXhhbXBsZSBpZiB5b3UgaGF2ZSBhXG5cdFx0ICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3Jcblx0XHQgKiBcIm92ZXItc2l6aW5nXCIgdGhlIHRhYmxlLCBhbmQgdGh1cyBmb3JjaW5nIHNjcm9sbGluZy4gVGhpcyBwcm9wZXJ0eSBjYW4gYnlcblx0XHQgKiBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsXG5cdFx0ICogbWVhc3VyZW1lbnQpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWElubmVyXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcInNjcm9sbFhcIjogXCIxMDAlXCIsXG5cdFx0ICogICAgICAgIFwic2Nyb2xsWElubmVyXCI6IFwiMTEwJVwiXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1Njcm9sbFhJbm5lclwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIHdpbGwgY29uc3RyYWluIHRoZSBEYXRhVGFibGVcblx0XHQgKiB0byB0aGUgZ2l2ZW4gaGVpZ2h0LCBhbmQgZW5hYmxlIHNjcm9sbGluZyBmb3IgYW55IGRhdGEgd2hpY2ggb3ZlcmZsb3dzIHRoZVxuXHRcdCAqIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFnaW5nIHRvIGRpc3BsYXlcblx0XHQgKiBhIGxvdCBvZiBkYXRhIGluIGEgc21hbGwgYXJlYSAoYWx0aG91Z2ggcGFnaW5nIGFuZCBzY3JvbGxpbmcgY2FuIGJvdGggYmVcblx0XHQgKiBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUpLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyXG5cdFx0ICogKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG5cdFx0ICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2Vcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2Nyb2xsWVwiOiBcIlwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdFx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdCAqXG5cdFx0ICogU2V0IHRoZSBIVFRQIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gbWFrZSB0aGUgQWpheCBjYWxsIGZvciBzZXJ2ZXItc2lkZVxuXHRcdCAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBHRVRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgT3B0aW9uc1xuXHRcdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlck1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBcIkdFVFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxuXHRcdCAqIGEgdGFibGUuIFRoZXNlIHJlbmRlcmVycyBjYW4gYmUgYWRkZWQgb3IgbW9kaWZpZWQgYnkgcGx1Zy1pbnMgdG9cblx0XHQgKiBnZW5lcmF0ZSBzdWl0YWJsZSBtYXJrLXVwIGZvciBhIHNpdGUuIEZvciBleGFtcGxlIHRoZSBCb290c3RyYXBcblx0XHQgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXG5cdFx0ICogZGlzcGxheSBwYWdpbmF0aW9uIGJ1dHRvbnMgaW4gdGhlIG1hcmstdXAgcmVxdWlyZWQgYnkgQm9vdHN0cmFwLlxuXHRcdCAqXG5cdFx0ICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXG5cdFx0ICogRGF0YVRhYmxlLmV4dC5yZW5kZXJlclxuXHRcdCAqICBAdHlwZSBzdHJpbmd8b2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmVuZGVyZXJcblx0XHQgKlxuXHRcdCAqL1xuXHRcdFwicmVuZGVyZXJcIjogbnVsbCxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgZGF0YSBwcm9wZXJ0eSBuYW1lIHRoYXQgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRvIGdldCBhIHJvdydzIGlkXG5cdFx0ICogdG8gc2V0IGFzIHRoZSBgaWRgIHByb3BlcnR5IGluIHRoZSBub2RlLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgRFRfUm93SWRcblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93SWRcblx0XHQgKi9cblx0XHRcInJvd0lkXCI6IFwiRFRfUm93SWRcIlxuXHR9O1xuXHRcblx0X2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMgKTtcblx0XG5cdFxuXHRcblx0Lypcblx0ICogRGV2ZWxvcGVyIG5vdGUgLSBTZWUgbm90ZSBpbiBtb2RlbC5kZWZhdWx0cy5qcyBhYm91dCB0aGUgdXNlIG9mIEh1bmdhcmlhblxuXHQgKiBub3RhdGlvbiBhbmQgY2FtZWwgY2FzZS5cblx0ICovXG5cdFxuXHQvKipcblx0ICogQ29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiA9IHtcblx0XHQvKipcblx0XHQgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXG5cdFx0ICogYWxsb3dzIGEgY29sdW1uJ3Mgb3JkZXJpbmcgdG8gdGFrZSBtdWx0aXBsZSBjb2x1bW5zIGludG8gYWNjb3VudCB3aGVuXG5cdFx0ICogZG9pbmcgYSBzb3J0IG9yIHVzZSB0aGUgZGF0YSBmcm9tIGEgZGlmZmVyZW50IGNvbHVtbi4gRm9yIGV4YW1wbGUgZmlyc3Rcblx0XHQgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXG5cdFx0ICogdHdvIGNvbHVtbnMuXG5cdFx0ICogIEB0eXBlIGFycmF5fGludFxuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPlRha2VzIHRoZSB2YWx1ZSBvZiB0aGUgY29sdW1uIGluZGV4IGF1dG9tYXRpY2FsbHk8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyLCBcInRhcmdldHNcIjogWyAyIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMCwgMSBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cdFx0XCJpRGF0YVNvcnRcIjogLTEsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBZb3UgY2FuIGNvbnRyb2wgdGhlIGRlZmF1bHQgb3JkZXJpbmcgZGlyZWN0aW9uLCBhbmQgZXZlbiBhbHRlciB0aGVcblx0XHQgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXG5cdFx0ICogdXNpbmcgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFsgJ2FzYycsICdkZXNjJyBdXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlclNlcXVlbmNlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAxIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMyBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSB9LFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcImFzU29ydGluZ1wiOiBbICdhc2MnLCAnZGVzYycgXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvbiB0aGUgZGF0YSBpbiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5zZWFyY2hhYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiU2VhcmNoYWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIG9yIGRpc2FibGUgb3JkZXJpbmcgb24gdGhpcyBjb2x1bW4uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJhYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF0gfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyYWJsZVwiOiBmYWxzZSB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXSB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwiYlNvcnRhYmxlXCI6IHRydWUsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCB0cnVlXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi52aXNpYmxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlIH0sXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbFxuXHRcdCAqICAgICAgICBdIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJiVmlzaWJsZVwiOiB0cnVlLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG5cdFx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHRcdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdFx0ICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBwYXJhbSB7ZWxlbWVudH0gdGQgVGhlIFREIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXG5cdFx0ICogIEBwYXJhbSB7Kn0gY2VsbERhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXG5cdFx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSByb3dEYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdFx0ICogIEBwYXJhbSB7aW50fSByb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXG5cdFx0ICogIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBpbmRleCBmb3IgYW9Db2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jcmVhdGVkQ2VsbFxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbM10sXG5cdFx0ICogICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhLCByb3csIGNvbCkge1xuXHRcdCAqICAgICAgICAgICAgaWYgKCBjZWxsRGF0YSA9PSBcIjEuN1wiICkge1xuXHRcdCAqICAgICAgICAgICAgICAkKHRkKS5jc3MoJ2NvbG9yJywgJ2JsdWUnKVxuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9KTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBoYXMgYmVlbiByZXBsYWNlZCBieSBgZGF0YWAgaW4gRGF0YVRhYmxlcyB0byBlbnN1cmUgbmFtaW5nXG5cdFx0ICogY29uc2lzdGVuY3kuIGBkYXRhUHJvcGAgY2FuIHN0aWxsIGJlIHVzZWQsIGFzIHRoZXJlIGlzIGJhY2t3YXJkc1xuXHRcdCAqIGNvbXBhdGliaWxpdHkgaW4gRGF0YVRhYmxlcyBmb3IgdGhpcyBvcHRpb24sIGJ1dCBpdCBpcyBzdHJvbmdseVxuXHRcdCAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBgZGF0YWAgaW4gcHJlZmVyZW5jZSB0byBgZGF0YVByb3BgLlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFQcm9wXG5cdFx0ICovXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHJlYWQgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSBwcm9wZXJ0eSxcblx0XHQgKiBpbmNsdWRpbmcgZGVlcGx5IG5lc3RlZCBvYmplY3RzIC8gcHJvcGVydGllcy4gYGRhdGFgIGNhbiBiZSBnaXZlbiBpbiBhXG5cdFx0ICogbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHdoaWNoIGVmZmVjdCBpdHMgYmVoYXZpb3VyOlxuXHRcdCAqXG5cdFx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdFx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHRcdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdFx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdFx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdFx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdFx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdFx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0XHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdFx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHRcdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHRcdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0XHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdFx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0XHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHRcdCAqICAgICAgcmV0dXJuZWQuXG5cdFx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHRcdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0XHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0XHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0XHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LiBOb3RlIHRoYXRcblx0XHQgKiAgICAgIGZ1bmN0aW9uIG5vdGF0aW9uIGlzIHJlY29tbWVuZGVkIGZvciB1c2UgaW4gYHJlbmRlcmAgcmF0aGVyIHRoYW5cblx0XHQgKiAgICAgIGBkYXRhYCBhcyBpdCBpcyBtdWNoIHNpbXBsZXIgdG8gdXNlIGFzIGEgcmVuZGVyZXIuXG5cdFx0ICogKiBgbnVsbGAgLSB1c2UgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IHJhdGhlciB0aGFuIHBsdWNraW5nXG5cdFx0ICogICBkYXRhIGRpcmVjdGx5IGZyb20gaXQuIFRoaXMgYWN0aW9uIGhhcyBlZmZlY3RzIG9uIHR3byBvdGhlclxuXHRcdCAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9uczpcblx0XHQgKiAgICAqIGBkZWZhdWx0Q29udGVudGAgLSBXaGVuIG51bGwgaXMgZ2l2ZW4gYXMgdGhlIGBkYXRhYCBvcHRpb24gYW5kXG5cdFx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHZhbHVlIGRlZmluZWQgYnlcblx0XHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgd2lsbCBiZSB1c2VkIGZvciB0aGUgY2VsbC5cblx0XHQgKiAgICAqIGByZW5kZXJgIC0gV2hlbiBudWxsIGlzIHVzZWQgZm9yIHRoZSBgZGF0YWAgb3B0aW9uIGFuZCB0aGUgYHJlbmRlcmBcblx0XHQgKiAgICAgIG9wdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB3aG9sZSBkYXRhIHNvdXJjZSBmb3IgdGhlXG5cdFx0ICogICAgICByb3cgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLlxuXHRcdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0XHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0XHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdFx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHRcdCAqICAgICAgKiBge2FycmF5fG9iamVjdH1gIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvd1xuXHRcdCAqICAgICAgKiBge3N0cmluZ31gIFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ3NldCcgd2hlblxuXHRcdCAqICAgICAgICBzZXR0aW5nIGRhdGEgb3IgJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnLCAnc29ydCcgb3IgdW5kZWZpbmVkXG5cdFx0ICogICAgICAgIHdoZW4gZ2F0aGVyaW5nIGRhdGEuIE5vdGUgdGhhdCB3aGVuIGB1bmRlZmluZWRgIGlzIGdpdmVuIGZvciB0aGVcblx0XHQgKiAgICAgICAgdHlwZSBEYXRhVGFibGVzIGV4cGVjdHMgdG8gZ2V0IHRoZSByYXcgZGF0YSBmb3IgdGhlIG9iamVjdCBiYWNrPFxuXHRcdCAqICAgICAgKiBgeyp9YCBEYXRhIHRvIHNldCB3aGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzICdzZXQnLlxuXHRcdCAqICAgICogUmV0dXJuOlxuXHRcdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuICdzZXQnIGlzXG5cdFx0ICogICAgICAgIHRoZSB0eXBlIG9mIGNhbGwsIGJ1dCBvdGhlcndpc2UgdGhlIHJldHVybiBpcyB3aGF0IHdpbGwgYmUgdXNlZFxuXHRcdCAqICAgICAgICBmb3IgdGhlIGRhdGEgcmVxdWVzdGVkLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGBkYXRhYCBpcyBhIGdldHRlciBhbmQgc2V0dGVyIG9wdGlvbi4gSWYgeW91IGp1c3QgcmVxdWlyZVxuXHRcdCAqIGZvcm1hdHRpbmcgb2YgZGF0YSBmb3Igb3V0cHV0LCB5b3Ugd2lsbCBsaWtlbHkgd2FudCB0byB1c2UgYHJlbmRlcmAgd2hpY2hcblx0XHQgKiBpcyBzaW1wbHkgYSBnZXR0ZXIgYW5kIHRodXMgc2ltcGxlciB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgcHJpb3IgdG8gRGF0YVRhYmxlcyAxLjkuMiBgZGF0YWAgd2FzIGNhbGxlZCBgbURhdGFQcm9wYC4gVGhlXG5cdFx0ICogbmFtZSBjaGFuZ2UgcmVmbGVjdHMgdGhlIGZsZXhpYmlsaXR5IG9mIHRoaXMgcHJvcGVydHkgYW5kIGlzIGNvbnNpc3RlbnRcblx0XHQgKiB3aXRoIHRoZSBuYW1pbmcgb2YgbVJlbmRlci4gSWYgJ21EYXRhUHJvcCcgaXMgZ2l2ZW4sIHRoZW4gaXQgd2lsbCBzdGlsbFxuXHRcdCAqIGJlIHVzZWQgYnkgRGF0YVRhYmxlcywgYXMgaXQgYXV0b21hdGljYWxseSBtYXBzIHRoZSBvbGQgbmFtZSB0byB0aGUgbmV3XG5cdFx0ICogaWYgcmVxdWlyZWQuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGludHxmdW5jdGlvbnxudWxsXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+VXNlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBjb2x1bW4gaW5kZXg8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBSZWFkIHRhYmxlIGRhdGEgZnJvbSBvYmplY3RzXG5cdFx0ICogICAgLy8gSlNPTiBzdHJ1Y3R1cmUgZm9yIGVhY2ggcm93OlxuXHRcdCAqICAgIC8vICAge1xuXHRcdCAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwiYnJvd3NlclwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJwbGF0Zm9ybVwiOiB7dmFsdWV9LFxuXHRcdCAqICAgIC8vICAgICAgXCJ2ZXJzaW9uXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImdyYWRlXCI6IHt2YWx1ZX1cblx0XHQgKiAgICAvLyAgIH1cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL29iamVjdHMudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybVwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gUmVhZCBpbmZvcm1hdGlvbiBmcm9tIGRlZXBseSBuZXN0ZWQgb2JqZWN0c1xuXHRcdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0XHQgKiAgICAvLyAgIHtcblx0XHQgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG5cdFx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0XHQgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge1xuXHRcdCAqICAgIC8vICAgICAgICAgXCJpbm5lclwiOiB7dmFsdWV9XG5cdFx0ICogICAgLy8gICAgICB9LFxuXHRcdCAqICAgIC8vICAgICAgXCJkZXRhaWxzXCI6IFtcblx0XHQgKiAgICAvLyAgICAgICAgIHt2YWx1ZX0sIHt2YWx1ZX1cblx0XHQgKiAgICAvLyAgICAgIF1cblx0XHQgKiAgICAvLyAgIH1cblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybS5pbm5lclwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJkZXRhaWxzLjBcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZGV0YWlscy4xXCIgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGRhdGFgIGFzIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBkaWZmZXJlbnQgaW5mb3JtYXRpb24gZm9yXG5cdFx0ICogICAgLy8gc29ydGluZywgZmlsdGVyaW5nIGFuZCBkaXNwbGF5LiBJbiB0aGlzIGNhc2UsIGN1cnJlbmN5IChwcmljZSlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIHNvdXJjZSwgdHlwZSwgdmFsICkge1xuXHRcdCAqICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQnKSB7XG5cdFx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZSA9IHZhbDtcblx0XHQgKiAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvbXB1dGVkIGRpc2xheSBhbmQgZmlsdGVyIHZhbHVlcyBmb3IgZWZmaWNpZW5jeVxuXHRcdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZGlzcGxheSA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKTtcblx0XHQgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlX2ZpbHRlciAgPSB2YWw9PVwiXCIgPyBcIlwiIDogXCIkXCIrbnVtYmVyRm9ybWF0KHZhbCkrXCIgXCIrdmFsO1xuXHRcdCAqICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZGlzcGxheScpIHtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9kaXNwbGF5O1xuXHRcdCAqICAgICAgICAgICAgfVxuXHRcdCAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2ZpbHRlcicpIHtcblx0XHQgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9maWx0ZXI7XG5cdFx0ICogICAgICAgICAgICB9XG5cdFx0ICogICAgICAgICAgICAvLyAnc29ydCcsICd0eXBlJyBhbmQgdW5kZWZpbmVkIGFsbCBqdXN0IHVzZSB0aGUgaW50ZWdlclxuXHRcdCAqICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGRlZmF1bHQgY29udGVudFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0XHQgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG5cdFx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkNsaWNrIHRvIGVkaXRcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBhcnJheSBub3RhdGlvbiAtIG91dHB1dHRpbmcgYSBsaXN0IGZyb20gYW4gYXJyYXlcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBcIm5hbWVbLCBdXCJcblx0XHQgKiAgICAgICAgfSBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICovXG5cdFx0XCJtRGF0YVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxuXHRcdCAqIHdoZW4geW91IHdhbnQgdG8gbWFuaXB1bGF0ZSBkYXRhIGZvciBkaXNwbGF5IChpbmNsdWRpbmcgZmlsdGVyaW5nLFxuXHRcdCAqIHNvcnRpbmcgZXRjKSB3aXRob3V0IGFsdGVyaW5nIHRoZSB1bmRlcmx5aW5nIGRhdGEgZm9yIHRoZSB0YWJsZSwgdXNlIHRoaXNcblx0XHQgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXG5cdFx0ICogYGRhdGFgIHdoaWNoIGlzIHJlYWQgLyB3cml0ZSAodGhlbiBhcyBzdWNoIG1vcmUgY29tcGxleCkuIExpa2UgYGRhdGFgXG5cdFx0ICogdGhpcyBvcHRpb24gY2FuIGJlIGdpdmVuIGluIGEgbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHRvIGVmZmVjdCBpdHNcblx0XHQgKiBiZWhhdmlvdXI6XG5cdFx0ICpcblx0XHQgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcblx0XHQgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG5cdFx0ICogKiBgc3RyaW5nYCAtIHJlYWQgYW4gb2JqZWN0IHByb3BlcnR5IGZyb20gdGhlIGRhdGEgc291cmNlLiBUaGVyZSBhcmVcblx0XHQgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcblx0XHQgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcblx0XHQgKiAgICAqIGAuYCAtIERvdHRlZCBKYXZhc2NyaXB0IG5vdGF0aW9uLiBKdXN0IGFzIHlvdSB1c2UgYSBgLmAgaW5cblx0XHQgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcblx0XHQgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuXHRcdCAqICAgICAgYGJyb3dzZXIubmFtZWAuIElmIHlvdXIgb2JqZWN0IHBhcmFtZXRlciBuYW1lIGNvbnRhaW5zIGEgcGVyaW9kLCB1c2Vcblx0XHQgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG5cdFx0ICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG5cdFx0ICogICAgICBmcm9tIGFuZCBhcnJheSBzb3VyY2UsIGpvaW5pbmcgdGhlIGRhdGEgd2l0aCB0aGUgY2hhcmFjdGVycyBwcm92aWRlZFxuXHRcdCAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcblx0XHQgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuXHRcdCAqICAgICAgYXJlIHByb3ZpZGVkIGJldHdlZW4gdGhlIGJyYWNrZXRzLCB0aGUgb3JpZ2luYWwgYXJyYXkgc291cmNlIGlzXG5cdFx0ICogICAgICByZXR1cm5lZC5cblx0XHQgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG5cdFx0ICogICAgICBleGVjdXRlIGEgZnVuY3Rpb24gb2YgdGhlIG5hbWUgZ2l2ZW4uIEZvciBleGFtcGxlOiBgYnJvd3NlcigpYCBmb3IgYVxuXHRcdCAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuXHRcdCAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuXHRcdCAqICAgICAgb2JqZWN0IHByb3BlcnR5IGlmIHRoZSBmdW5jdGlvbiBjYWxsZWQgcmV0dXJucyBhbiBvYmplY3QuXG5cdFx0ICogKiBgb2JqZWN0YCAtIHVzZSBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHJlcXVlc3RlZCBieVxuXHRcdCAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xuXHRcdCAqICAgb2YgdGhlIG9iamVjdCBpcyB0aGUgZGF0YSB0eXBlIHRoZSBwcm9wZXJ0eSByZWZlcnMgdG8gYW5kIHRoZSB2YWx1ZSBjYW5cblx0XHQgKiAgIGRlZmluZWQgdXNpbmcgYW4gaW50ZWdlciwgc3RyaW5nIG9yIGZ1bmN0aW9uIHVzaW5nIHRoZSBzYW1lIHJ1bGVzIGFzXG5cdFx0ICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxuXHRcdCAqICAgVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgeW91IGhhdmVuJ3Qgc3BlY2lmaWVkIGEgdmFsdWUgZm9yXG5cdFx0ICogICB0aGUgZGF0YSB0eXBlIHJlcXVlc3RlZCBieSBEYXRhVGFibGVzLlxuXHRcdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0XHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0XHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdFx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHRcdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKGJhc2VkIG9uIGBkYXRhYClcblx0XHQgKiAgICAgICoge3N0cmluZ30gVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnZmlsdGVyJyxcblx0XHQgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxuXHRcdCAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZnVsbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAobm90IGJhc2VkIG9uXG5cdFx0ICogICAgICAgIGBkYXRhYClcblx0XHQgKiAgICAqIFJldHVybjpcblx0XHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyB3aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlXG5cdFx0ICogICAgICAgIGRhdGEgcmVxdWVzdGVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258b2JqZWN0fG51bGxcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCBVc2UgdGhlIGRhdGEgc291cmNlIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ucmVuZGVyXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBDcmVhdGUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHNcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IFwicGxhdGZvcm1cIixcblx0XHQgKiAgICAgICAgICAgIFwicmVuZGVyXCI6IFwiWywgXS5uYW1lXCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIGRhdGFcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLCAvLyBVc2UgdGhlIGZ1bGwgZGF0YSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgcmVuZGVyZXIncyBzb3VyY2Vcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiBcImJyb3dzZXJOYW1lKClcIlxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBBcyBhbiBvYmplY3QsIGV4dHJhY3RpbmcgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgdHlwZXNcblx0XHQgKiAgICAvLyBUaGlzIHdvdWxkIGJlIHVzZWQgd2l0aCBhIGRhdGEgc291cmNlIHN1Y2ggYXM6XG5cdFx0ICogICAgLy8gICB7IFwicGhvbmVcIjogNTU1MjM2OCwgXCJwaG9uZV9maWx0ZXJcIjogXCI1NTUyMzY4IDU1NS0yMzY4XCIsIFwicGhvbmVfZGlzcGxheVwiOiBcIjU1NS0yMzY4XCIgfVxuXHRcdCAqICAgIC8vIEhlcmUgdGhlIGBwaG9uZWAgaW50ZWdlciBpcyB1c2VkIGZvciBzb3J0aW5nIGFuZCB0eXBlIGRldGVjdGlvbiwgd2hpbGUgYHBob25lX2ZpbHRlcmBcblx0XHQgKiAgICAvLyAod2hpY2ggaGFzIGJvdGggZm9ybXMpIGlzIHVzZWQgZm9yIGZpbHRlcmluZyBmb3IgaWYgYSB1c2VyIGlucHV0cyBlaXRoZXIgZm9ybWF0LCB3aGlsZVxuXHRcdCAqICAgIC8vIHRoZSBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyIGlzIHRoZSBvbmUgdGhhdCBpcyBzaG93biBpbiB0aGUgdGFibGUuXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuXHRcdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0XHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXG5cdFx0ICogICAgICAgICAgXCJyZW5kZXJcIjoge1xuXHRcdCAqICAgICAgICAgICAgXCJfXCI6IFwicGhvbmVcIixcblx0XHQgKiAgICAgICAgICAgIFwiZmlsdGVyXCI6IFwicGhvbmVfZmlsdGVyXCIsXG5cdFx0ICogICAgICAgICAgICBcImRpc3BsYXlcIjogXCJwaG9uZV9kaXNwbGF5XCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzZSBhcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGUgZGF0YSBzb3VyY2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiZGF0YVwiOiBcImRvd25sb2FkX2xpbmtcIixcblx0XHQgKiAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoIGRhdGEsIHR5cGUsIGZ1bGwgKSB7XG5cdFx0ICogICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCInK2RhdGErJ1wiPkRvd25sb2FkPC9hPic7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICB9IF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJtUmVuZGVyXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDaGFuZ2UgdGhlIGNlbGwgdHlwZSBjcmVhdGVkIGZvciB0aGUgY29sdW1uIC0gZWl0aGVyIFREIGNlbGxzIG9yIFRIIGNlbGxzLiBUaGlzXG5cdFx0ICogY2FuIGJlIHVzZWZ1bCBhcyBUSCBjZWxscyBoYXZlIHNlbWFudGljIG1lYW5pbmcgaW4gdGhlIHRhYmxlIGJvZHksIGFsbG93aW5nIHRoZW1cblx0XHQgKiB0byBhY3QgYXMgYSBoZWFkZXIgZm9yIGEgcm93ICh5b3UgbWF5IHdpc2ggdG8gYWRkIHNjb3BlPSdyb3cnIHRvIHRoZSBUSCBlbGVtZW50cykuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCB0ZFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2VsbFR5cGVcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE1ha2UgdGhlIGZpcnN0IGNvbHVtbiB1c2UgVEggY2VsbHNcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdFx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHRcdCAqICAgICAgICAgIFwiY2VsbFR5cGVcIjogXCJ0aFwiXG5cdFx0ICogICAgICAgIH0gXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNDZWxsVHlwZVwiOiBcInRkXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGFzcyB0byBnaXZlIHRvIGVhY2ggY2VsbCBpbiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNsYXNzXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIgfSxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsXG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ2xhc3NcIjogXCJcIixcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuXHRcdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0XHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0XHQgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuXHRcdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0XHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdFx0ICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuXHRcdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdFx0ICogR2VuZXJhbGx5IHlvdSBzaG91bGRuJ3QgbmVlZCB0aGlzIVxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPGk+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jb250ZW50UGFkZGluZ1xuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICB7XG5cdFx0ICogICAgICAgICAgICBcImNvbnRlbnRQYWRkaW5nXCI6IFwibW1tXCJcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzQ29udGVudFBhZGRpbmdcIjogXCJcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHRcdCAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBgZGF0YWBcblx0XHQgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGVmYXVsdENvbnRlbnRcblx0XHQgKiAgQGR0b3B0IENvbHVtbnNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiLFxuXHRcdCAqICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgLTEgXVxuXHRcdCAqICAgICAgICAgIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAge1xuXHRcdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdFx0ICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiXG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHVzZWQgaW4gRGF0YVRhYmxlcycgc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gSXQgY2FuXG5cdFx0ICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcblx0XHQgKiBjbGllbnQgc2lkZSwgYW5kIHRvIG1hcCB0aGVzZSB0byBkYXRhYmFzZSBmaWVsZHMuIFdoZW4gZGVmaW5lZCwgdGhlIG5hbWVzXG5cdFx0ICogYWxzbyBhbGxvdyBEYXRhVGFibGVzIHRvIHJlb3JkZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyIGlmIGl0IGNvbWVzXG5cdFx0ICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcblx0XHQgKiBjbGllbnQtc2lkZSwgeW91ciBzZXJ2ZXItc2lkZSBjb2RlIGRvZXMgbm90IGFsc28gbmVlZCB1cGRhdGluZykuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5uYW1lXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYnJvd3NlclwiLCBcInRhcmdldHNcIjogWyAxIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImdyYWRlXCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9XG5cdFx0ICogICAgICAgIF1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGxhdGZvcm1cIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNOYW1lXCI6IFwiXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGEgZGF0YSBzb3VyY2UgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWRcblx0XHQgKiByZWFsLXRpbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgdGFibGUgKHVwZGF0aW5nIHRoZSBpbnRlcm5hbGx5IGNhY2hlZFxuXHRcdCAqIHZlcnNpb24pIHByaW9yIHRvIG9yZGVyaW5nLiBUaGlzIGFsbG93cyBvcmRlcmluZyB0byBvY2N1ciBvbiB1c2VyXG5cdFx0ICogZWRpdGFibGUgZWxlbWVudHMgc3VjaCBhcyBmb3JtIGlucHV0cy5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHN0ZFxuXHRcdCAqXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhVHlwZVxuXHRcdCAqICBAZHRvcHQgQ29sdW1uc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidGFyZ2V0c1wiOiBbIDIsIDMgXSB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwibnVtZXJpY1wiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1zZWxlY3RcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiwgXCJ0YXJnZXRzXCI6IFsgNSBdIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiB9LFxuXHRcdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0eXBlXCI6IFwibnVtZXJpY1wiIH0sXG5cdFx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIgfSxcblx0XHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiIH1cblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNTb3J0RGF0YVR5cGVcIjogXCJzdGRcIixcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0aXRsZSBvZiB0aGlzIGNvbHVtbi5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IG51bGwgPGk+RGVyaXZlZCBmcm9tIHRoZSAnVEgnIHZhbHVlIGZvciB0aGlzIGNvbHVtbiBpbiB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBIVE1MIHRhYmxlLjwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnRpdGxlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUaXRsZVwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGhvdyB0aGUgZGF0YSBmb3IgdGhpcyBjb2x1bW4gd2lsbCBiZVxuXHRcdCAqIG9yZGVyZWQuIEZvdXIgdHlwZXMgKHN0cmluZywgbnVtZXJpYywgZGF0ZSBhbmQgaHRtbCAod2hpY2ggd2lsbCBzdHJpcFxuXHRcdCAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxuXHRcdCAqIGZvcm1hdHMgdW5kZXJzdG9vZCBieSBKYXZhc2NyaXB0J3MgRGF0ZSgpIG9iamVjdCB3aWxsIGJlIGFjY2VwdGVkIGFzIHR5cGVcblx0XHQgKiBkYXRlLiBGb3IgZXhhbXBsZTogXCJNYXIgMjYsIDIwMDggNTowMyBQTVwiLiBNYXkgdGFrZSB0aGUgdmFsdWVzOiAnc3RyaW5nJyxcblx0XHQgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcblx0XHQgKiB0aHJvdWdoIHBsdWctaW5zLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvLWRldGVjdGVkIGZyb20gcmF3IGRhdGE8L2k+XG5cdFx0ICpcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi50eXBlXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUeXBlXCI6IG51bGwsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBEZWZpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiwgdGhpcyBwYXJhbWV0ZXIgbWF5IHRha2UgYW55IENTUyB2YWx1ZVxuXHRcdCAqICgzZW0sIDIwcHggZXRjKS4gRGF0YVRhYmxlcyBhcHBsaWVzICdzbWFydCcgd2lkdGhzIHRvIGNvbHVtbnMgd2hpY2ggaGF2ZSBub3Rcblx0XHQgKiBiZWVuIGdpdmVuIGEgc3BlY2lmaWMgd2lkdGggdGhyb3VnaCB0aGlzIGludGVyZmFjZSBlbnN1cmluZyB0aGF0IHRoZSB0YWJsZVxuXHRcdCAqIHJlbWFpbnMgcmVhZGFibGUuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsIDxpPkF1dG9tYXRpYzwvaT5cblx0XHQgKlxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLndpZHRoXG5cdFx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHRcdCAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHRcdCAqICAgICAgICBdXG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0XHQgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiB9LFxuXHRcdCAqICAgICAgICAgIG51bGwsXG5cdFx0ICogICAgICAgICAgbnVsbCxcblx0XHQgKiAgICAgICAgICBudWxsLFxuXHRcdCAqICAgICAgICAgIG51bGxcblx0XHQgKiAgICAgICAgXVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNXaWR0aFwiOiBudWxsXG5cdH07XG5cdFxuXHRfZm5IdW5nYXJpYW5NYXAoIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gKTtcblx0XG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IC0gdGhpcyBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYVxuXHQgKiBnaXZlbiB0YWJsZSwgaW5jbHVkaW5nIGNvbmZpZ3VyYXRpb24sIGRhdGEgYW5kIGN1cnJlbnQgYXBwbGljYXRpb24gb2YgdGhlXG5cdCAqIHRhYmxlIG9wdGlvbnMuIERhdGFUYWJsZXMgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgZWFjaCBEYXRhVGFibGVcblx0ICogd2l0aCB0aGUgc2V0dGluZ3MgYXR0YWNoZWQgdG8gdGhhdCBpbnN0YW5jZSwgYnV0IHJhdGhlciBpbnN0YW5jZXMgb2YgdGhlXG5cdCAqIERhdGFUYWJsZSBcImNsYXNzXCIgYXJlIGNyZWF0ZWQgb24tdGhlLWZseSBhcyBuZWVkZWQgKHR5cGljYWxseSBieSBhXG5cdCAqICQoKS5kYXRhVGFibGUoKSBjYWxsKSBhbmQgdGhlIHNldHRpbmdzIG9iamVjdCBpcyB0aGVuIGFwcGxpZWQgdG8gdGhhdFxuXHQgKiBpbnN0YW5jZS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30gYnV0IHRoaXNcblx0ICogb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy4gSXQgc2hvdWxkXG5cdCAqIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBkb25lXG5cdCAqIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqICBAdG9kbyBSZWFsbHkgc2hvdWxkIGF0dGFjaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRvIGluZGl2aWR1YWwgaW5zdGFuY2VzIHNvIHdlXG5cdCAqICAgIGRvbid0IG5lZWQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb24gZWFjaCAkKCkuZGF0YVRhYmxlKCkgY2FsbCAoaWYgdGhlXG5cdCAqICAgIHRhYmxlIGFscmVhZHkgZXhpc3RzKS4gSXQgd291bGQgYWxzbyBzYXZlIHBhc3Npbmcgb1NldHRpbmdzIGFyb3VuZCBhbmRcblx0ICogICAgaW50byBldmVyeSBzaW5nbGUgZnVuY3Rpb24uIEhvd2V2ZXIsIHRoaXMgaXMgYSB2ZXJ5IHNpZ25pZmljYW50XG5cdCAqICAgIGFyY2hpdGVjdHVyZSBjaGFuZ2UgZm9yIERhdGFUYWJsZXMgYW5kIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBicmVha1xuXHQgKiAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMuIFRoaXMgaXMgc29tZXRoaW5nIHRoYXRcblx0ICogICAgd2lsbCBiZSBkb25lIGluIDIuMC5cblx0ICovXG5cdERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzID0ge1xuXHRcdC8qKlxuXHRcdCAqIFByaW1hcnkgZmVhdHVyZXMgb2YgRGF0YVRhYmxlcyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0ZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdFwib0ZlYXR1cmVzXCI6IHtcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEZsYWcgdG8gc2F5IGlmIERhdGFUYWJsZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGNhbGN1bGF0ZSB0aGVcblx0XHRcdCAqIG9wdGltdW0gdGFibGUgYW5kIGNvbHVtbnMgd2lkdGhzICh0cnVlKSBvciBub3QgKGZhbHNlKS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiQXV0b1dpZHRoXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZWxheSB0aGUgY3JlYXRpb24gb2YgVFIgYW5kIFREIGVsZW1lbnRzIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5XG5cdFx0XHQgKiBuZWVkZWQgYnkgYSBkcml2ZW4gcGFnZSBkcmF3LiBUaGlzIGNhbiBnaXZlIGEgc2lnbmlmaWNhbnQgc3BlZWRcblx0XHRcdCAqIGluY3JlYXNlIGZvciBBamF4IHNvdXJjZSBhbmQgSmF2YXNjcmlwdCBzb3VyY2UgZGF0YSwgYnV0IG1ha2VzIG5vXG5cdFx0XHQgKiBkaWZmZXJlbmNlIGF0IGFsbCBmcm8gRE9NIGFuZCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiRGVmZXJSZW5kZXJcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSBmaWx0ZXJpbmcgb24gdGhlIHRhYmxlIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWRcblx0XHRcdCAqIHRoZW4gdGhlcmUgaXMgbm8gZmlsdGVyaW5nIGF0IGFsbCBvbiB0aGUgdGFibGUsIGluY2x1ZGluZyBmbkZpbHRlci5cblx0XHRcdCAqIFRvIGp1c3QgcmVtb3ZlIHRoZSBmaWx0ZXJpbmcgaW5wdXQgdXNlIHNEb20gYW5kIHJlbW92ZSB0aGUgJ2YnIG9wdGlvbi5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiRmlsdGVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50ICh0aGUgJ1Nob3dpbmcgeCBvZiB5IHJlY29yZHMnIGRpdikgZW5hYmxlXG5cdFx0XHQgKiBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJJbmZvXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQcmVzZW50IGEgdXNlciBjb250cm9sIGFsbG93aW5nIHRoZSBlbmQgdXNlciB0byBjaGFuZ2UgdGhlIHBhZ2Ugc2l6ZVxuXHRcdFx0ICogd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYkxlbmd0aENoYW5nZVwiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUGFnaW5hdGlvbiBlbmFibGVkIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWQgdGhlbiBsZW5ndGhcblx0XHRcdCAqIGNoYW5naW5nIG11c3QgYWxzbyBiZSBkaXNhYmxlZC5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiUGFnaW5hdGVcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFByb2Nlc3NpbmcgaW5kaWNhdG9yIGVuYWJsZSBmbGFnIHdoZW5ldmVyIERhdGFUYWJsZXMgaXMgZW5hY3RpbmcgYVxuXHRcdFx0ICogdXNlciByZXF1ZXN0IC0gdHlwaWNhbGx5IGFuIEFqYXggcmVxdWVzdCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiUHJvY2Vzc2luZ1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBlbmFibGVkIGZsYWcgLSB3aGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsXG5cdFx0XHQgKiBnZXQgYWxsIGRhdGEgZnJvbSB0aGUgc2VydmVyIGZvciBldmVyeSBkcmF3IC0gdGhlcmUgaXMgbm8gZmlsdGVyaW5nLFxuXHRcdFx0ICogc29ydGluZyBvciBwYWdpbmcgZG9uZSBvbiB0aGUgY2xpZW50LXNpZGUuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKi9cblx0XHRcdFwiYlNlcnZlclNpZGVcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFNvcnRpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0XCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0TXVsdGlcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFwcGx5IGEgY2xhc3MgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGJlaW5nIHNvcnRlZCB0byBwcm92aWRlIGFcblx0XHRcdCAqIHZpc3VhbCBoaWdobGlnaHQgb3Igbm90LiBUaGlzIGNhbiBzbG93IHRoaW5ncyBkb3duIHdoZW4gZW5hYmxlZCBzaW5jZVxuXHRcdFx0ICogdGhlcmUgaXMgYSBsb3Qgb2YgRE9NIGludGVyYWN0aW9uLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdFx0ICovXG5cdFx0XHRcImJTb3J0Q2xhc3Nlc1wiOiBudWxsLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RhdGUgc2F2aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiU3RhdGVTYXZlXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogU2Nyb2xsaW5nIHNldHRpbmdzIGZvciBhIHRhYmxlLlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvU2Nyb2xsXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiB0aGUgdGFibGUgaXMgc2hvcnRlciBpbiBoZWlnaHQgdGhhbiBzU2Nyb2xsWSwgY29sbGFwc2UgdGhlXG5cdFx0XHQgKiB0YWJsZSBjb250YWluZXIgZG93biB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSAod2hlbiB0cnVlKS5cblx0XHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqL1xuXHRcdFx0XCJiQ29sbGFwc2VcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdpZHRoIG9mIHRoZSBzY3JvbGxiYXIgZm9yIHRoZSB3ZWItYnJvd3NlcidzIHBsYXRmb3JtLiBDYWxjdWxhdGVkXG5cdFx0XHQgKiBkdXJpbmcgdGFibGUgaW5pdGlhbGlzYXRpb24uXG5cdFx0XHQgKiAgQHR5cGUgaW50XG5cdFx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdFx0ICovXG5cdFx0XHRcImlCYXJXaWR0aFwiOiAwLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVmlld3BvcnQgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nLiBIb3Jpem9udGFsIHNjcm9sbGluZyBpc1xuXHRcdFx0ICogZGlzYWJsZWQgaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKi9cblx0XHRcdFwic1hcIjogbnVsbCxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFdpZHRoIHRvIGV4cGFuZCB0aGUgdGFibGUgdG8gd2hlbiB1c2luZyB4LXNjcm9sbGluZy4gVHlwaWNhbGx5IHlvdVxuXHRcdFx0ICogc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHRcdCAqL1xuXHRcdFx0XCJzWElubmVyXCI6IG51bGwsXG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBWaWV3cG9ydCBoZWlnaHQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG5cdFx0XHQgKiBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqL1xuXHRcdFx0XCJzWVwiOiBudWxsXG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogTGFuZ3VhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZS5cblx0XHQgKiAgQG5hbWVzcGFjZVxuXHRcdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlXG5cdFx0ICovXG5cdFx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbmZvcm1hdGlvbiBjYWxsYmFjayBmdW5jdGlvbi4gU2VlXG5cdFx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmZuSW5mb0NhbGxiYWNrfVxuXHRcdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGxcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBCcm93c2VyIHN1cHBvcnQgcGFyYW1ldGVyc1xuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICovXG5cdFx0XCJvQnJvd3NlclwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEluZGljYXRlIGlmIHRoZSBicm93c2VyIGluY29ycmVjdGx5IGNhbGN1bGF0ZXMgd2lkdGg6MTAwJSBpbnNpZGUgYVxuXHRcdFx0ICogc2Nyb2xsaW5nIGVsZW1lbnQgKElFNi83KVxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJTY3JvbGxPdmVyc2l6ZVwiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERldGVybWluZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSByaWdodCBvciBsZWZ0IG9mIHRoZVxuXHRcdFx0ICogc2Nyb2xsaW5nIGNvbnRhaW5lciAtIG5lZWRlZCBmb3IgcnRsIGxhbmd1YWdlIGxheW91dCwgYWx0aG91Z2ggbm90XG5cdFx0XHQgKiBhbGwgYnJvd3NlcnMgbW92ZSB0aGUgc2Nyb2xsYmFyIChTYWZhcmkpLlxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJTY3JvbGxiYXJMZWZ0XCI6IGZhbHNlLFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRmxhZyBmb3IgaWYgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgaXMgZnVsbHkgc3VwcG9ydGVkIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdFx0ICovXG5cdFx0XHRcImJCb3VuZGluZ1wiOiBmYWxzZSxcblx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEJyb3dzZXIgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdFx0ICogIEBkZWZhdWx0IDBcblx0XHRcdCAqL1xuXHRcdFx0XCJiYXJXaWR0aFwiOiAwXG5cdFx0fSxcblx0XG5cdFxuXHRcdFwiYWpheFwiOiBudWxsLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgcmVmZXJlbmNpbmcgdGhlIG5vZGVzIHdoaWNoIGFyZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMuIFRoZVxuXHRcdCAqIHBhcmFtZXRlcnMgb2YgdGhpcyBvYmplY3QgbWF0Y2ggd2hhdCBpcyBhbGxvd2VkIGJ5IHNEb20gLSBpLmUuXG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxuXHRcdCAqICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0XHQgKiAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxuXHRcdCAqICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxuXHRcdCAqICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdFx0ICogICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhYW5GZWF0dXJlc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcblx0XHQgKiBpbmZvcm1hdGlvbi5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGF0YVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgaW5kZXhlcyB3aGljaCBhcmUgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSAoYWZ0ZXIgZmlsdGVyaW5nIGV0Yylcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFpRGlzcGxheVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgaW5kZXhlcyBmb3IgZGlzcGxheSAtIG5vIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYWlEaXNwbGF5TWFzdGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBNYXAgb2Ygcm93IGlkcyB0byBkYXRhIGluZGV4ZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJhSWRzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIGNvbHVtbiB0aGF0IGlzIGluIHVzZVxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Db2x1bW5zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBoZWFkZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSGVhZGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBmb290ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRm9vdGVyXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSB0aGUgYXBwbGllZCBnbG9iYWwgc2VhcmNoIGluZm9ybWF0aW9uIGluIGNhc2Ugd2Ugd2FudCB0byBmb3JjZSBhXG5cdFx0ICogcmVzZWFyY2ggb3IgY29tcGFyZSB0aGUgb2xkIHNlYXJjaCB0byBhIG5ldyBvbmUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAbmFtZXNwYWNlXG5cdFx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxuXHRcdCAqL1xuXHRcdFwib1ByZXZpb3VzU2VhcmNoXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZSB0aGUgYXBwbGllZCBzZWFyY2ggZm9yIGVhY2ggY29sdW1uIC0gc2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaH0gZm9yIHRoZSBmb3JtYXQgdGhhdCBpcyB1c2VkIGZvciB0aGVcblx0XHQgKiBmaWx0ZXJpbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9QcmVTZWFyY2hDb2xzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxuXHRcdCAqIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBtYW5uZXI6XG5cdFx0ICogPHVsPlxuXHRcdCAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cblx0XHQgKiAgIDxsaT5JbmRleCAxIC0gY3VycmVudCBzb3J0aW5nIGRpcmVjdGlvbjwvbGk+XG5cdFx0ICogPC91bD5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcblx0XHQgKi9cblx0XHRcImFhU29ydGluZ1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIHRoYXQgaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIChpLmUuIHByZWZpeGVkIGluIGZyb250IG9mXG5cdFx0ICogYWFTb3J0aW5nKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhYVNvcnRpbmdGaXhlZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xhc3NlcyB0byB1c2UgZm9yIHRoZSBzdHJpcGluZyBvZiBhIHRhYmxlLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFzU3RyaXBlQ2xhc3Nlc1wiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFzRGVzdHJveVN0cmlwZXNcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHdpZHRoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJzRGVzdHJveVdpZHRoXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBhcnJheSBmb3IgZXZlcnkgdGltZSBhIHJvdyBpcyBpbnNlcnRlZCAoaS5lLiBvbiBhIGRyYXcpLlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9Sb3dDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvSGVhZGVyQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZm9vdGVyIG9uIGVhY2ggZHJhdy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRm9vdGVyQ2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZHJhdyBjYWxsYmFjayBmdW5jdGlvbnNcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRHJhd0NhbGxiYWNrXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1Jvd0NyZWF0ZWRDYWxsYmFja1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciBqdXN0IGJlZm9yZSB0aGUgdGFibGUgaXMgcmVkcmF3bi4gQSByZXR1cm4gb2Zcblx0XHQgKiBmYWxzZSB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3LlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9QcmVEcmF3Q2FsbGJhY2tcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb0luaXRDb21wbGV0ZVwiOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0byBiZSBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZywgcHJpb3IgdG9cblx0XHQgKiBzYXZpbmcgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlU2F2ZVBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRoYXQgaGF2ZSBiZWVuIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nXG5cdFx0ICogcHJpb3IgdG8gdXNpbmcgdGhlIHN0b3JlZCB2YWx1ZXMgdG8gcmVzdG9yZSB0aGUgc3RhdGUuXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlTG9hZFBhcmFtc1wiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxuXHRcdCAqIGxvYWRlZFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRlZFwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgdGhlIHRhYmxlIElEIGZvciBxdWljayBhY2Nlc3Ncblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0XHQgKi9cblx0XHRcInNUYWJsZUlkXCI6IFwiXCIsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBUQUJMRSBub2RlIGZvciB0aGUgbWFpbiB0YWJsZVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UYWJsZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0aGVhZCBlbGVtZW50XG5cdFx0ICogIEB0eXBlIG5vZGVcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiblRIZWFkXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRmb290IGVsZW1lbnQgLSBpZiBpdCBleGlzdHNcblx0XHQgKiAgQHR5cGUgbm9kZVxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJuVEZvb3RcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGJvZHkgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UQm9keVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWNoZSB0aGUgd3JhcHBlciBub2RlIChjb250YWlucyBhbGwgRGF0YVRhYmxlcyBjb250cm9sbGVkIGVsZW1lbnRzKVxuXHRcdCAqICBAdHlwZSBub2RlXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm5UYWJsZVdyYXBwZXJcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgd2hlbiB1c2luZyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZSBsb2FkaW5nIG9mIGRhdGFcblx0XHQgKiBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIHNlY29uZCBkcmF3LlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkRlZmVyTG9hZGluZ1wiOiBmYWxzZSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGhhcyBiZWVuIHJlYWQgaW5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkluaXRpYWxpc2VkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmZvcm1hdGlvbiBhYm91dCBvcGVuIHJvd3MuIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSBoYXMgdGhlIHBhcmFtZXRlcnNcblx0XHQgKiAnblRyJyBhbmQgJ25QYXJlbnQnXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb09wZW5Sb3dzXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBEaWN0YXRlIHRoZSBwb3NpdGlvbmluZyBvZiBEYXRhVGFibGVzJyBjb250cm9sIGVsZW1lbnRzIC0gc2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbC5vSW5pdC5zRG9tfS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzRG9tXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaCBkZWxheSAoaW4gbVMpXG5cdFx0ICogIEB0eXBlIGludGVnZXJcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogV2hpY2ggdHlwZSBvZiBwYWdpbmF0aW9uIHNob3VsZCBiZSB1c2VkLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IHR3b19idXR0b25cblx0XHQgKi9cblx0XHRcInNQYWdpbmF0aW9uVHlwZVwiOiBcInR3b19idXR0b25cIixcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0YXRlIGR1cmF0aW9uIChmb3IgYHN0YXRlU2F2ZWApIGluIHNlY29uZHMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdFwiaVN0YXRlRHVyYXRpb25cIjogMCxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBzYXZpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHRcdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0XHQgKiAgIDx1bD5cblx0XHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHRcdCAqICAgICAgIGFuZCB0aGUgSlNPTiBzdHJpbmcgdG8gc2F2ZSB0aGF0IGhhcyBiZWVuIHRodXMgZmFyIGNyZWF0ZWQuIFJldHVybnNcblx0XHQgKiAgICAgICBhIEpTT04gc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gYSBqc29uIG9iamVjdFxuXHRcdCAqICAgICAgIChpLmUuICdcInBhcmFtXCI6IFsgMCwgMSwgMl0nKTwvbGk+XG5cdFx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0XHQgKiAgIDwvdWw+XG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhb1N0YXRlU2F2ZVwiOiBbXSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBsb2FkaW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0XHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdFx0ICogICA8dWw+XG5cdFx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0XHQgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxuXHRcdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdFx0ICogICA8L3VsPlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYW9TdGF0ZUxvYWRcIjogW10sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFN0YXRlIHRoYXQgd2FzIHNhdmVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJvU2F2ZWRTdGF0ZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdGF0ZSB0aGF0IHdhcyBsb2FkZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2Vcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcIm9Mb2FkZWRTdGF0ZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBTb3VyY2UgdXJsIGZvciBBSkFYIGRhdGEgZm9yIHRoZSB0YWJsZS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJzQWpheFNvdXJjZVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVhZCB0aGUgdGFibGUgZGF0YSBmcm9tLiBUaGlzXG5cdFx0ICogY2FuIGJlIGFuIGVtcHR5IHN0cmluZyAod2hlbiBub3Qgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyksIGluIHdoaWNoIGNhc2Vcblx0XHQgKiBpdCBpcyAgYXNzdW1lZCBhbiBhbiBhcnJheSBpcyBnaXZlbiBkaXJlY3RseS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic0FqYXhEYXRhUHJvcFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBOb3RlIGlmIGRyYXcgc2hvdWxkIGJlIGJsb2NrZWQgd2hpbGUgZ2V0dGluZyBkYXRhXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqL1xuXHRcdFwiYkFqYXhEYXRhR2V0XCI6IHRydWUsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IGpRdWVyeSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgZm9yIHNlcnZlci1zaWRlIGRhdGEgZ2F0aGVyaW5nLlxuXHRcdCAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHdvcmtpbmcgd2l0aCB0aGUgWEhSIGluZm9ybWF0aW9uIGluIG9uZSBvZiB0aGVcblx0XHQgKiBjYWxsYmFja3Ncblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcImpxWEhSXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0XCJqc29uXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdCAqL1xuXHRcdFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBwcmlvciB0byBzZW5kaW5nIGFuIEFqYXggcmVxdWVzdCBzbyBleHRyYVxuXHRcdCAqIHBhcmFtZXRlcnMgY2FuIGVhc2lseSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvU2VydmVyUGFyYW1zXCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTZW5kIHRoZSBYSFIgSFRUUCBtZXRob2QgLSBHRVQgb3IgUE9TVCAoY291bGQgYmUgUFVUIG9yIERFTEVURSBpZlxuXHRcdCAqIHJlcXVpcmVkKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdFwic1NlcnZlck1ldGhvZFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBGb3JtYXQgbnVtYmVycyBmb3IgZGlzcGxheS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHVzZXIgc2VsZWN0YWJsZSBsZW5ndGggbWVudS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICogIEBkZWZhdWx0IFtdXG5cdFx0ICovXG5cdFx0XCJhTGVuZ3RoTWVudVwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3Jcblx0XHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJpRHJhd1wiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZSBpZiBhIHJlZHJhdyBpcyBiZWluZyBkb25lIC0gdXNlZnVsIGZvciBBamF4XG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHRcImJEcmF3aW5nXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBEcmF3IGluZGV4IChpRHJhdykgb2YgdGhlIGxhc3QgZXJyb3Igd2hlbiBwYXJzaW5nIHRoZSByZXR1cm5lZCBkYXRhXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAtMVxuXHRcdCAqL1xuXHRcdFwiaURyYXdFcnJvclwiOiAtMSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUGFnaW5nIGRpc3BsYXkgbGVuZ3RoXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAxMFxuXHRcdCAqL1xuXHRcdFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXHRcblx0XHQvKipcblx0XHQgKiBQYWdpbmcgc3RhcnQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHRcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgcmVzdWx0IHNldFxuXHRcdCAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cblx0XHQgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG5cdFx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0XHQgKiAgQHR5cGUgaW50XG5cdFx0ICogIEBkZWZhdWx0IDBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0XHRcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxuXHRcdCAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgMFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdFwiX2lSZWNvcmRzRGlzcGxheVwiOiAwLFxuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY2xhc3NlcyB0byB1c2UgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKi9cblx0XHRcIm9DbGFzc2VzXCI6IHt9LFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHRcdCAqIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqICBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxuXHRcblx0XHQvKipcblx0XHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHRcdCAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0XHQgKiBldmVudHMuXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJTb3J0ZWRcIjogZmFsc2UsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIHRoYXQgaWYgbXVsdGlwbGUgcm93cyBhcmUgaW4gdGhlIGhlYWRlciBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuXG5cdFx0ICogb25lIHVuaXF1ZSBjZWxsIHBlciBjb2x1bW4sIGlmIHRoZSB0b3Agb25lICh0cnVlKSBvciBib3R0b20gb25lIChmYWxzZSlcblx0XHQgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU29ydENlbGxzVG9wXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luaXRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBjYWxsYmFjayBmdW5jdGlvbnMgLSBmb3IgcGx1Zy1pbnMgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG8gdGhlXG5cdFx0ICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKi9cblx0XHRcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0XCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XG5cdFx0XHRcdHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICBAdHlwZSBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0XHR0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcblx0XHRcdFx0dGhpcy5haURpc3BsYXkubGVuZ3RoO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZGlzcGxheSBlbmQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKi9cblx0XHRcImZuRGlzcGxheUVuZFwiOiBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdHZhclxuXHRcdFx0XHRsZW4gICAgICA9IHRoaXMuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRzdGFydCAgICA9IHRoaXMuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRcdHJlY29yZHMgID0gdGhpcy5haURpc3BsYXkubGVuZ3RoLFxuXHRcdFx0XHRmZWF0dXJlcyA9IHRoaXMub0ZlYXR1cmVzLFxuXHRcdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblx0XG5cdFx0XHRpZiAoIGZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRcdHN0YXJ0ICsgcmVjb3JkcyA6XG5cdFx0XHRcdFx0TWF0aC5taW4oIHN0YXJ0K2xlbiwgdGhpcy5faVJlY29yZHNEaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuICEgcGFnaW5hdGUgfHwgY2FsYz5yZWNvcmRzIHx8IGxlbj09PS0xID9cblx0XHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0XHRjYWxjO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwib0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcblx0XHQgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cblx0XHQgKiBpbmNyZW1lbnRpbmcgaW50ZXJuYWwgY291bnRlciBpcyB1c2VkLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwic0luc3RhbmNlXCI6IG51bGwsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcblx0XHQgKiBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSBhbmQgaXRzIGNvbnRyb2xzLlxuXHRcdCAqL1xuXHRcdFwiaVRhYkluZGV4XCI6IDAsXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHRcdCAqL1xuXHRcdFwiblNjcm9sbEhlYWRcIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXG5cdFx0ICovXG5cdFx0XCJuU2Nyb2xsRm9vdFwiOiBudWxsLFxuXHRcblx0XHQvKipcblx0XHQgKiBMYXN0IGFwcGxpZWQgc29ydFxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqICBAZGVmYXVsdCBbXVxuXHRcdCAqL1xuXHRcdFwiYUxhc3RTb3J0XCI6IFtdLFxuXHRcblx0XHQvKipcblx0XHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0XCJvUGx1Z2luc1wiOiB7fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRnVuY3Rpb24gdXNlZCB0byBnZXQgYSByb3cncyBpZCBmcm9tIHRoZSByb3cncyBkYXRhXG5cdFx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRcInJvd0lkRm5cIjogbnVsbCxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSBhIHJvdydzIGlkXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0XCJyb3dJZFwiOiBudWxsXG5cdH07XG5cblx0LyoqXG5cdCAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcblx0ICogYGpRdWVyeS5mbi5kYXRhVGFibGUuZXh0YCB3aGVyZSBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkLiBJdCBpc1xuXHQgKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5leHRcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgZXh0ZW5zaW9uc1xuXHQgKiBcblx0ICogVGhpcyBuYW1lc3BhY2UgYWN0cyBhcyBhIGNvbGxlY3Rpb24gYXJlYSBmb3IgcGx1Zy1pbnMgdGhhdCBjYW4gYmUgdXNlZCB0b1xuXHQgKiBleHRlbmQgRGF0YVRhYmxlcyBjYXBhYmlsaXRpZXMuIEluZGVlZCBtYW55IG9mIHRoZSBidWlsZCBpbiBtZXRob2RzXG5cdCAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3Jcblx0ICogZXhhbXBsZSkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XG5cdCAqIHJlYXNvbnNcblx0ICpcblx0ICogIEBuYW1lc3BhY2Vcblx0ICovXG5cdERhdGFUYWJsZS5leHQgPSBfZXh0ID0ge1xuXHRcdC8qKlxuXHRcdCAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcblx0XHQgKiBkZWZpbmVkIGhlcmUgc28gb3RoZXIgZXh0ZW5zaW9ucyBjYW4gZGVmaW5lIGJ1dHRvbnMgcmVnYXJkbGVzcyBvZiBsb2FkXG5cdFx0ICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGJ1dHRvbnM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRWxlbWVudCBjbGFzcyBuYW1lc1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqL1xuXHRcdGNsYXNzZXM6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBidWlsZCB0eXBlIChleHBhbmRlZCBieSB0aGUgZG93bmxvYWQgYnVpbGRlcilcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRidWlsZGVyOiBcIi1zb3VyY2UtXCIsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdFx0ICogXG5cdFx0ICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXG5cdFx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG5cdFx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdFx0ICovXG5cdFx0ZXJyTW9kZTogXCJhbGVydFwiLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggZGVzY3JpYmUgdGhlIGZlYXR1cmUgcGx1Zy1pbnMgdGhhdCBhcmVcblx0XHQgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG5cdFx0ICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cblx0XHQgKiBcblx0XHQgKiBFYWNoIGZlYXR1cmUgcGx1Zy1pbiBpcyBkZXNjcmliZWQgYnkgYW4gb2JqZWN0IHdoaWNoIG11c3QgaGF2ZSB0aGVcblx0XHQgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBcblx0XHQgKiAqIGBmbkluaXRgIC0gZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHBsdWctaW4sXG5cdFx0ICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXG5cdFx0ICogICBpbnN0aWxsYXRpb24gb3B0aW9uLiBUaGlzIGlzIGNhc2Ugc2Vuc2l0aXZlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICpcblx0XHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdFx0ICogXG5cdFx0ICogKiB7bm9kZXxudWxsfSBUaGUgZWxlbWVudCB3aGljaCBjb250YWlucyB5b3VyIGZlYXR1cmUuIE5vdGUgdGhhdCB0aGVcblx0XHQgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcblx0XHQgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxuXHRcdCAqICAgYmUgdXNlZnVsIHdoZW4gZGV2ZWxvcGluZyBhIHBsdWctaW4gd2hpY2ggYWxsb3dzIHRhYmxlIGNvbnRyb2wgdmlhXG5cdFx0ICogICBrZXlib2FyZCBlbnRyeVxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQuZmVhdHVyZXMucHVzaCgge1xuXHRcdCAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdGZlYXR1cmU6IFtdLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogUm93IHNlYXJjaGluZy5cblx0XHQgKiBcblx0XHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdFx0ICogc2VhcmNoaW5nLCBhbmQgYSBsb3QgbW9yZSBjb21wcmVoZW5zaXZlIGFzIGl0IGFsbG93cyB5b3UgY29tcGxldGUgY29udHJvbFxuXHRcdCAqIG92ZXIgdGhlIHNlYXJjaGluZyBsb2dpYy4gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXMgYSBmdW5jdGlvblxuXHRcdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdFx0ICogYW5kIHlvdXIgbG9naWMgZGVjaWRlcyBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaGluZyBkYXRhIHNldFxuXHRcdCAqIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIFNlYXJjaGluZyBmdW5jdGlvbnMgaGF2ZSB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0XHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdFx0ICogMi4gYHthcnJheXxvYmplY3R9YCBEYXRhIGZvciB0aGUgcm93IHRvIGJlIHByb2Nlc3NlZCAoc2FtZSBhcyB0aGVcblx0XHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0XHQgKiAgICBmcm9tIGEgRE9NIGRhdGEgc291cmNlXG5cdFx0ICogMy4gYHtpbnR9YCBSb3cgaW5kZXggKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncy5hb0RhdGF9KSwgd2hpY2hcblx0XHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHRcdCAqXG5cdFx0ICogKiB7Ym9vbGVhbn0gSW5jbHVkZSB0aGUgcm93IGluIHRoZSBzZWFyY2hlZCByZXN1bHQgc2V0ICh0cnVlKSBvciBub3Rcblx0XHQgKiAgIChmYWxzZSlcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBhcyB3aXRoIHRoZSBtYWluIHNlYXJjaCBhYmlsaXR5IGluIERhdGFUYWJsZXMsIHRlY2huaWNhbGx5IHRoaXNcblx0XHQgKiBpcyBcImZpbHRlcmluZ1wiLCBzaW5jZSBpdCBpcyBzdWJ0cmFjdGl2ZS4gSG93ZXZlciwgZm9yIGNvbnNpc3RlbmN5IGluXG5cdFx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKiAgQGRlZmF1bHQgW11cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdFx0ICogICAgLy8gZm91cnRoIGNvbHVtbiAoaS5lLiB0aGUgZGF0YVszXSBpbmRleCkgYmFzZWQgb24gdHdvIGlucHV0IHZhbHVlc1xuXHRcdCAqICAgIC8vIGZyb20gdGhlIGVuZC11c2VyLCBtYXRjaGluZyB0aGUgZGF0YSBpbiBhIGNlcnRhaW4gcmFuZ2UuXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHRcdCAqICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XG5cdFx0ICogICAgICAgIHZhciBtaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluJykudmFsdWUgKiAxO1xuXHRcdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0XHQgKiAgICAgICAgdmFyIHZlcnNpb24gPSBkYXRhWzNdID09IFwiLVwiID8gMCA6IGRhdGFbM10qMTtcblx0XHQgKlxuXHRcdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0c2VhcmNoOiBbXSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcblx0XHQgKlxuXHRcdCAqIFRoZSBgc2VsZWN0b3JgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGVcblx0XHQgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcblx0XHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHRcdCAqIHRoZWlyIHBsdXJhbCBjb3VudGVycGFydHMpLiBGb3IgZXhhbXBsZSB0aGUgU2VsZWN0IGV4dGVuc2lvbiB1c2VzIHRoaXNcblx0XHQgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcblx0XHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIGJ1aWx0IGluIHNlbGVjdG9yXG5cdFx0ICogb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggcHJvcGVydHkgaXMgYW4gYXJyYXkgdG8gd2hpY2ggZnVuY3Rpb25zIGNhbiBiZSBwdXNoZWQuIFRoZSBmdW5jdGlvbnNcblx0XHQgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XG5cdFx0ICpcblx0XHQgKiAqIFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcblx0XHQgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxuXHRcdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdFx0ICpcblx0XHQgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cblx0XHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqL1xuXHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRjZWxsOiBbXSxcblx0XHRcdGNvbHVtbjogW10sXG5cdFx0XHRyb3c6IFtdXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIGZ1bmN0aW9ucywgZXhwb3NlZCBmb3IgdXNlZCBpbiBwbHVnLWlucy5cblx0XHQgKiBcblx0XHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoZSBpbnRlcm5hbCBtZXRob2RzIGZvclxuXHRcdCAqIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbHVnLWluIChhbmQgZXZlbiB0aGVuLCB0cnkgdG8gYXZvaWQgaWYgcG9zc2libGUpLlxuXHRcdCAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICovXG5cdFx0aW50ZXJuYWw6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogTGVnYWN5IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gRW5hYmxlIGFuZCBkaXNhYmxlIGxlZ2FjeSBvcHRpb25zIHRoYXRcblx0XHQgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICovXG5cdFx0bGVnYWN5OiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0XHQgKiByZXF1ZXN0c1xuXHRcdFx0ICpcblx0XHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRhamF4OiBudWxsXG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxuXHRcdCAqIFxuXHRcdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHRcdCAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnZUJ1dHRvbn0uIFRoZSByZW5kZXJlciBhZGRyZXNzZXMgaG93IHRoZVxuXHRcdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdFx0ICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXG5cdFx0ICogZGVzY3JpcHRpb25zICh3aGF0IGVhY2ggYnV0dG9uIHdpbGwgZG8pLlxuXHRcdCAqXG5cdFx0ICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxuXHRcdCAqIG9wdGlvbnMgZGVmaW5lZCBoZXJlKSBjYW4gYmUgdXNlZCB0aHJvdWdoIHRoZSBgcGFnaW5hdGlvblR5cGVgXG5cdFx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0XHQgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxuXHRcdCAqIDIuIGB7aW50fSBwYWdlc2AgVGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcblx0XHQgKiBhcnJheSBjYW4gYmUgb25lIG9mOlxuXHRcdCAqXG5cdFx0ICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdFx0ICogKiBgbGFzdGAgLSBKdW1wIHRvIGxhc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHRcdCAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0XHQgKiAqIGB7aW50fWAgLSBTaG93IHBhZ2Ugb2YgdGhlIGluZGV4IGdpdmVuXG5cdFx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHRcdCAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdFx0ICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcblx0XHQgKiBhYmlsaXR5IGlzIHN0aWxsIHN1cHBvcnRlZCBieSBEYXRhVGFibGVzIDEuMTArIHRvIHByb3ZpZGUgYmFja3dhcmRzXG5cdFx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHRcdCAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZUV4dC5vUGFnaW5hdGlvbi5jdXJyZW50ID0gZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHRcdCAqICAgIH07XG5cdFx0ICovXG5cdFx0cGFnZXI6IHt9LFxuXHRcblx0XG5cdFx0cmVuZGVyZXI6IHtcblx0XHRcdHBhZ2VCdXR0b246IHt9LFxuXHRcdFx0aGVhZGVyOiB7fVxuXHRcdH0sXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBPcmRlcmluZyBwbHVnLWlucyAtIGN1c3RvbSBkYXRhIHNvdXJjZVxuXHRcdCAqIFxuXHRcdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdFx0ICogdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvcmRlcmluZyB0aGF0IERhdGFUYWJsZXMgdHlwaWNhbGx5IHVzZXMuIEl0XG5cdFx0ICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuXHRcdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0XHQgKiBcblx0XHQgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcblx0XHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdFx0ICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cblx0XHQgKiBcblx0XHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdFx0ICogd2lzaCB0byBiZSBvcmRlcmluZyBmb3IgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhhdFxuXHRcdCAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cblx0XHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdFx0ICogZnVuY3Rpb24gaXMgcnVuIGhlcmUgZGVwZW5kcyBvbiB0aGUgYGR0LWluaXQgY29sdW1ucy5vcmRlckRhdGFUeXBlYFxuXHRcdCAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHRcdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHRcdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0XHQgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5OlxuXHRcdCAqXG5cdFx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0XHQgKiAgICB7XG5cdFx0ICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XG5cdFx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0b3JkZXI6IHt9LFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBwbHVnLWlucy5cblx0XHQgKlxuXHRcdCAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xuXHRcdCAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cblx0XHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0XHQgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqL1xuXHRcdHR5cGU6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuXHRcdFx0ICogYSBjb2x1bW4ncyB0eXBlLCBtYWtpbmcgaW5pdGlhbGlzYXRpb24gb2YgRGF0YVRhYmxlcyBzdXBlciBlYXN5LCBldmVuXG5cdFx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxuXHRcdCAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdFx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0XHQgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXG5cdFx0ICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG5cdFx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuXHRcdFx0ICogICBwYXNzIGl0IG9uIHRvIHRoZSBvdGhlciB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuXHRcdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnB1c2goXG5cdFx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuXHRcdFx0ICogICAgICAgIGlmICggISBkYXRhLnN1YnN0cmluZygxKS5tYXRjaCgvWzAtOV0vKSApIHtcblx0XHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqXG5cdFx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHRcdCAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG5cdFx0XHQgKiAgICAgICAgICByZXR1cm4gJ2N1cnJlbmN5Jztcblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgICk7XG5cdFx0XHQgKi9cblx0XHRcdGRldGVjdDogW10sXG5cdFxuXHRcblx0XHRcdC8qKlxuXHRcdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXG5cdFx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHRcdCAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdFx0ICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG5cdFx0XHQgKiBcblx0XHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdFx0ICogZm9yIGEgY29sdW1uIChvciBoYXZlIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIHlvdSBieSBEYXRhVGFibGVzXG5cdFx0XHQgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3Jcblx0XHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHRcdCAqIGJ5IGFsbG93aW5nIHlvdSB0byBwcmUtcHJvY2Vzc2luZyB0aGUgZGF0YSBhbmQgcmV0dXJuaW5nIHRoZSBkYXRhIGluXG5cdFx0XHQgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcblx0XHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHRcdCAqIGZvciB0aGF0IHRhcmdldCBjb2x1bW4uIFRoaXMgaXMgdGhlIGNvcm9sbGFyeSBvZiA8aT5hZm5Tb3J0RGF0YTwvaT5cblx0XHRcdCAqIGZvciBzZWFyY2hpbmcgZGF0YS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0XHQgKiAgQGRlZmF1bHQge31cblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0ICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqL1xuXHRcdFx0c2VhcmNoOiB7fSxcblx0XG5cdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXG5cdFx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0XHQgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdFx0ICogdGhpcyBvYmplY3Q6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdFx0ICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHRcdCAqXG5cdFx0XHQgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXG5cdFx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHRcdCAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuXHRcdFx0ICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBBbmQgcmV0dXJuOlxuXHRcdFx0ICpcblx0XHRcdCAqICogYHsqfWAgRGF0YSB0byBiZSBzb3J0ZWQgdXBvblxuXHRcdFx0ICpcblx0XHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdFx0ICogZnVuY3Rpb25zLCB0YWtpbmcgdHdvIHBhcmFtZXRlcnM6XG5cdFx0XHQgKlxuXHRcdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdFx0ICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0ICpcblx0XHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0XHQgKlxuXHRcdFx0ICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcblx0XHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdFx0ICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuXHRcdFx0ICogICBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBcblx0XHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuXHRcdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XG5cdFx0XHQgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuXHRcdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0XHQgKiAgICAgIH1cblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2Rcblx0XHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0XHQgKiAgICAgIH0sXG5cdFx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHRcdCAqICAgICAgfVxuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRvcmRlcjoge31cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBpbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF91bmlxdWU6IDAsXG5cdFxuXHRcblx0XHQvL1xuXHRcdC8vIERlcHJlY2lhdGVkXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBvbmx5LlxuXHRcdC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcblx0XHQvLyB2ZXJzaW9uXG5cdFx0Ly9cblx0XG5cdFx0LyoqXG5cdFx0ICogVmVyc2lvbiBjaGVjayBmdW5jdGlvbi5cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcblx0XHQgKi9cblx0XHRmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxuXHRcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kZXggZm9yIHdoYXQgJ3RoaXMnIGluZGV4IEFQSSBmdW5jdGlvbnMgc2hvdWxkIHVzZVxuXHRcdCAqICBAdHlwZSBpbnRcblx0XHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0XHQgKi9cblx0XHRpQXBpSW5kZXg6IDAsXG5cdFxuXHRcblx0XHQvKipcblx0XHQgKiBqUXVlcnkgVUkgY2xhc3MgY29udGFpbmVyXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHRcdCAqL1xuXHRcdG9KVUlDbGFzc2VzOiB7fSxcblx0XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNvZnR3YXJlIHZlcnNpb25cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdFx0ICovXG5cdFx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG5cdH07XG5cdFxuXHRcblx0Ly9cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEFsaWFzIHRvIHByZSAxLjEwIEh1bmdhcmlhbiBub3RhdGlvbiBjb3VudGVyIHBhcnRzXG5cdC8vXG5cdCQuZXh0ZW5kKCBfZXh0LCB7XG5cdFx0YWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcblx0XHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdFx0b2ZuU2VhcmNoOiAgICBfZXh0LnR5cGUuc2VhcmNoLFxuXHRcdG9Tb3J0OiAgICAgICAgX2V4dC50eXBlLm9yZGVyLFxuXHRcdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0XHRhb0ZlYXR1cmVzOiAgIF9leHQuZmVhdHVyZSxcblx0XHRvQXBpOiAgICAgICAgIF9leHQuaW50ZXJuYWwsXG5cdFx0b1N0ZENsYXNzZXM6ICBfZXh0LmNsYXNzZXMsXG5cdFx0b1BhZ2luYXRpb246ICBfZXh0LnBhZ2VyXG5cdH0gKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdFx0XCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcblx0XHRcInNOb0Zvb3RlclwiOiBcIm5vLWZvb3RlclwiLFxuXHRcblx0XHQvKiBQYWdpbmcgYnV0dG9ucyAqL1xuXHRcdFwic1BhZ2VCdXR0b25cIjogXCJwYWdpbmF0ZV9idXR0b25cIixcblx0XHRcInNQYWdlQnV0dG9uQWN0aXZlXCI6IFwiY3VycmVudFwiLFxuXHRcdFwic1BhZ2VCdXR0b25EaXNhYmxlZFwiOiBcImRpc2FibGVkXCIsXG5cdFxuXHRcdC8qIFN0cmlwaW5nIGNsYXNzZXMgKi9cblx0XHRcInNTdHJpcGVPZGRcIjogXCJvZGRcIixcblx0XHRcInNTdHJpcGVFdmVuXCI6IFwiZXZlblwiLFxuXHRcblx0XHQvKiBFbXB0eSByb3cgKi9cblx0XHRcInNSb3dFbXB0eVwiOiBcImRhdGFUYWJsZXNfZW1wdHlcIixcblx0XG5cdFx0LyogRmVhdHVyZXMgKi9cblx0XHRcInNXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc193cmFwcGVyXCIsXG5cdFx0XCJzRmlsdGVyXCI6IFwiZGF0YVRhYmxlc19maWx0ZXJcIixcblx0XHRcInNJbmZvXCI6IFwiZGF0YVRhYmxlc19pbmZvXCIsXG5cdFx0XCJzUGFnaW5nXCI6IFwiZGF0YVRhYmxlc19wYWdpbmF0ZSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cblx0XHRcInNMZW5ndGhcIjogXCJkYXRhVGFibGVzX2xlbmd0aFwiLFxuXHRcdFwic1Byb2Nlc3NpbmdcIjogXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmdcIixcblx0XG5cdFx0LyogU29ydGluZyAqL1xuXHRcdFwic1NvcnRBc2NcIjogXCJzb3J0aW5nX2FzY1wiLFxuXHRcdFwic1NvcnREZXNjXCI6IFwic29ydGluZ19kZXNjXCIsXG5cdFx0XCJzU29ydGFibGVcIjogXCJzb3J0aW5nXCIsIC8qIFNvcnRhYmxlIGluIGJvdGggZGlyZWN0aW9ucyAqL1xuXHRcdFwic1NvcnRhYmxlQXNjXCI6IFwic29ydGluZ19hc2NfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0YWJsZURlc2NcIjogXCJzb3J0aW5nX2Rlc2NfZGlzYWJsZWRcIixcblx0XHRcInNTb3J0YWJsZU5vbmVcIjogXCJzb3J0aW5nX2Rpc2FibGVkXCIsXG5cdFx0XCJzU29ydENvbHVtblwiOiBcInNvcnRpbmdfXCIsIC8qIE5vdGUgdGhhdCBhbiBpbnQgaXMgcG9zdGZpeGVkIGZvciB0aGUgc29ydGluZyBvcmRlciAqL1xuXHRcblx0XHQvKiBGaWx0ZXJpbmcgKi9cblx0XHRcInNGaWx0ZXJJbnB1dFwiOiBcIlwiLFxuXHRcblx0XHQvKiBQYWdlIGxlbmd0aCAqL1xuXHRcdFwic0xlbmd0aFNlbGVjdFwiOiBcIlwiLFxuXHRcblx0XHQvKiBTY3JvbGxpbmcgKi9cblx0XHRcInNTY3JvbGxXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxcIixcblx0XHRcInNTY3JvbGxIZWFkXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkXCIsXG5cdFx0XCJzU2Nyb2xsSGVhZElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkSW5uZXJcIixcblx0XHRcInNTY3JvbGxCb2R5XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxCb2R5XCIsXG5cdFx0XCJzU2Nyb2xsRm9vdFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdFwiLFxuXHRcdFwic1Njcm9sbEZvb3RJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdElubmVyXCIsXG5cdFxuXHRcdC8qIE1pc2MgKi9cblx0XHRcInNIZWFkZXJUSFwiOiBcIlwiLFxuXHRcdFwic0Zvb3RlclRIXCI6IFwiXCIsXG5cdFxuXHRcdC8vIERlcHJlY2F0ZWRcblx0XHRcInNTb3J0SlVJQXNjXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSURlc2NcIjogXCJcIixcblx0XHRcInNTb3J0SlVJXCI6IFwiXCIsXG5cdFx0XCJzU29ydEpVSUFzY0FsbG93ZWRcIjogXCJcIixcblx0XHRcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogXCJcIixcblx0XHRcInNTb3J0SlVJV3JhcHBlclwiOiBcIlwiLFxuXHRcdFwic1NvcnRJY29uXCI6IFwiXCIsXG5cdFx0XCJzSlVJSGVhZGVyXCI6IFwiXCIsXG5cdFx0XCJzSlVJRm9vdGVyXCI6IFwiXCJcblx0fSApO1xuXHRcblx0XG5cdHZhciBleHRQYWdpbmF0aW9uID0gRGF0YVRhYmxlLmV4dC5wYWdlcjtcblx0XG5cdGZ1bmN0aW9uIF9udW1iZXJzICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0dmFyXG5cdFx0XHRudW1iZXJzID0gW10sXG5cdFx0XHRidXR0b25zID0gZXh0UGFnaW5hdGlvbi5udW1iZXJzX2xlbmd0aCxcblx0XHRcdGhhbGYgPSBNYXRoLmZsb29yKCBidXR0b25zIC8gMiApLFxuXHRcdFx0aSA9IDE7XG5cdFxuXHRcdGlmICggcGFnZXMgPD0gYnV0dG9ucyApIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UoIDAsIHBhZ2VzICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlIDw9IGhhbGYgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBidXR0b25zLTIgKTtcblx0XHRcdG51bWJlcnMucHVzaCggJ2VsbGlwc2lzJyApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBwYWdlID49IHBhZ2VzIC0gMSAtIGhhbGYgKSB7XG5cdFx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlcy0oYnV0dG9ucy0yKSwgcGFnZXMgKTtcblx0XHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAnZWxsaXBzaXMnICk7IC8vIG5vIHVuc2hpZnQgaW4gaWU2XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UoIHBhZ2UtaGFsZisyLCBwYWdlK2hhbGYtMSApO1xuXHRcdFx0bnVtYmVycy5wdXNoKCAnZWxsaXBzaXMnICk7XG5cdFx0XHRudW1iZXJzLnB1c2goIHBhZ2VzLTEgKTtcblx0XHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAnZWxsaXBzaXMnICk7XG5cdFx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHRcdH1cblx0XG5cdFx0bnVtYmVycy5EVF9lbCA9ICdzcGFuJztcblx0XHRyZXR1cm4gbnVtYmVycztcblx0fVxuXHRcblx0XG5cdCQuZXh0ZW5kKCBleHRQYWdpbmF0aW9uLCB7XG5cdFx0c2ltcGxlOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ3ByZXZpb3VzJywgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbDogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICAnZmlyc3QnLCAncHJldmlvdXMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFxuXHRcdG51bWJlcnM6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHRyZXR1cm4gWyBfbnVtYmVycyhwYWdlLCBwYWdlcykgXTtcblx0XHR9LFxuXHRcblx0XHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdHJldHVybiBbICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnIF07XG5cdFx0fSxcblx0XG5cdFx0ZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCcsICdsYXN0JyBdO1xuXHRcdH0sXG5cdFx0XG5cdFx0Zmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcblx0IFx0XHRyZXR1cm4gWydmaXJzdCcsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ2xhc3QnXTtcblx0IFx0fSxcblx0XG5cdFx0Ly8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxuXHRcdF9udW1iZXJzOiBfbnVtYmVycyxcblx0XG5cdFx0Ly8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIChpbmNsdWRpbmcgZWxsaXBzaXMpIHRvIHNob3cuIF9NdXN0IGJlIG9kZCFfXG5cdFx0bnVtYmVyc19sZW5ndGg6IDdcblx0fSApO1xuXHRcblx0XG5cdCQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XG5cdFx0cGFnZUJ1dHRvbjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9zdCwgaWR4LCBidXR0b25zLCBwYWdlLCBwYWdlcyApIHtcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHRcdFx0dmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHRcdFx0XHR2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcblx0XHRcdFx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cdFxuXHRcdFx0XHR2YXIgYXR0YWNoID0gZnVuY3Rpb24oIGNvbnRhaW5lciwgYnV0dG9ucyApIHtcblx0XHRcdFx0XHR2YXIgaSwgaWVuLCBub2RlLCBidXR0b24sIHRhYkluZGV4O1xuXHRcdFx0XHRcdHZhciBkaXNhYmxlZENsYXNzID0gY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkO1xuXHRcdFx0XHRcdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRcdFx0XHRfZm5QYWdlQ2hhbmdlKCBzZXR0aW5ncywgZS5kYXRhLmFjdGlvbiwgdHJ1ZSApO1xuXHRcdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRidXR0b24gPSBidXR0b25zW2ldO1xuXHRcblx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggYnV0dG9uICkgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpbm5lciA9ICQoICc8JysoYnV0dG9uLkRUX2VsIHx8ICdkaXYnKSsnLz4nIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXHRcdFx0XHRcdFx0XHRhdHRhY2goIGlubmVyLCBidXR0b24gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b247XG5cdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gc2V0dGluZ3MuaVRhYkluZGV4O1xuXHRcblx0XHRcdFx0XHRcdFx0c3dpdGNoICggYnV0dG9uICkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2VsbGlwc2lzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj4mI3gyMDI2Ozwvc3Bhbj4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2UgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbmV4dCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTmV4dDtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTGFzdDtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlciggYnV0dG9uICsgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBwYWdlID09PSBidXR0b24gP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNQYWdlQnV0dG9uQWN0aXZlIDogJyc7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0aWYgKCBidG5EaXNwbGF5ICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSAkKCc8YT4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24rJyAnK2J0bkNsYXNzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1jb250cm9scyc6IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFbIGJ1dHRvbiBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnZGF0YS1kdC1pZHgnOiBjb3VudGVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQndGFiaW5kZXgnOiB0YWJJbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5zVGFibGVJZCArJ18nKyBidXR0b24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0Lmh0bWwoIGJ0bkRpc3BsYXkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0X2ZuQmluZEFjdGlvbihcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUsIHthY3Rpb246IGJ1dHRvbn0sIGNsaWNrSGFuZGxlclxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLiBUcnkgLyBjYXRjaCB0aGUgZXJyb3IuIE5vdCBnb29kIGZvclxuXHRcdFx0XHQvLyBhY2Nlc3NpYmlsaXR5LCBidXQgbmVpdGhlciBhcmUgZnJhbWVzLlxuXHRcdFx0XHR2YXIgYWN0aXZlRWw7XG5cdFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHRcdFx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0XHRcdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0XHRcdFx0Ly8gY29tcGxldGVkXG5cdFx0XHRcdFx0YWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHt9XG5cdFxuXHRcdFx0XHRhdHRhY2goICQoaG9zdCkuZW1wdHkoKSwgYnV0dG9ucyApO1xuXHRcblx0XHRcdFx0aWYgKCBhY3RpdmVFbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdCQoaG9zdCkuZmluZCggJ1tkYXRhLWR0LWlkeD0nK2FjdGl2ZUVsKyddJyApLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHRcblx0Ly8gQnVpbHQgaW4gdHlwZSBkZXRlY3Rpb24uIFNlZSBtb2RlbC5leHQuYVR5cGVzIGZvciBpbmZvcm1hdGlvbiBhYm91dFxuXHQvLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhpcyBtZXRob2RzLlxuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdCwgW1xuXHRcdC8vIFBsYWluIG51bWJlcnMgLSBmaXJzdCBzaW5jZSBWOCBkZXRlY3RzIHNvbWUgcGxhaW4gbnVtYmVycyBhcyBkYXRlc1xuXHRcdC8vIGUuZy4gRGF0ZS5wYXJzZSgnNTUnKSAoYnV0IG5vdCBhbGwsIGUuZy4gRGF0ZS5wYXJzZSgnMjInKS4uLikuXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsICkgPyAnbnVtJytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBEYXRlcyAob25seSB0aG9zZSByZWNvZ25pc2VkIGJ5IHRoZSBicm93c2VyJ3MgRGF0ZS5wYXJzZSlcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHQvLyBWOCB0cmllcyBfdmVyeV8gaGFyZCB0byBtYWtlIGEgc3RyaW5nIHBhc3NlZCBpbnRvIGBEYXRlLnBhcnNlKClgXG5cdFx0XHQvLyB2YWxpZCwgc28gd2UgbmVlZCB0byB1c2UgYSByZWdleCB0byByZXN0cmljdCBkYXRlIGZvcm1hdHMuIFVzZSBhXG5cdFx0XHQvLyBwbHVnLWluIGZvciBhbnl0aGluZyBvdGhlciB0aGFuIElTTzg2MDEgc3R5bGUgc3RyaW5nc1xuXHRcdFx0aWYgKCBkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICEgX3JlX2RhdGUudGVzdChkKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcblx0XHRcdHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCkgPyAnZGF0ZScgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEZvcm1hdHRlZCBudW1iZXJzXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnbnVtLWZtdCcrZGVjaW1hbCA6IG51bGw7XG5cdFx0fSxcblx0XG5cdFx0Ly8gSFRNTCBudW1lcmljXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsICkgPyAnaHRtbC1udW0nK2RlY2ltYWwgOiBudWxsO1xuXHRcdH0sXG5cdFxuXHRcdC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXG5cdFx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdFx0e1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnaHRtbC1udW0tZm10JytkZWNpbWFsIDogbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvLyBIVE1MICh0aGlzIGlzIHN0cmljdCBjaGVja2luZyAtIHRoZXJlIG11c3QgYmUgaHRtbClcblx0XHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgKHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTEpID9cblx0XHRcdFx0J2h0bWwnIDogbnVsbDtcblx0XHR9XG5cdF0gKTtcblx0XG5cdFxuXHRcblx0Ly8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcblx0Ly8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoZXNlIG1ldGhvZHMuXG5cdC8vIFxuXHQvLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXG5cdC8vIGh0bWwgZm9ybWF0dGVkIG51bWJlcnMgYnkgYF9hZGROdW1lcmljU29ydCgpYCB3aGVuIHdlIGtub3cgd2hhdCB0aGUgZGVjaW1hbFxuXHQvLyBwbGFjZSBpc1xuXHRcblx0XG5cdCQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoLCB7XG5cdFx0aHRtbDogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShkYXRhKSA/XG5cdFx0XHRcdGRhdGEgOlxuXHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGRhdGFcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApXG5cdFx0XHRcdFx0XHQucmVwbGFjZSggX3JlX2h0bWwsIFwiXCIgKSA6XG5cdFx0XHRcdFx0Jyc7XG5cdFx0fSxcblx0XG5cdFx0c3RyaW5nOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gX2VtcHR5KGRhdGEpID9cblx0XHRcdFx0ZGF0YSA6XG5cdFx0XHRcdHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XG5cdFx0XHRcdFx0ZGF0YS5yZXBsYWNlKCBfcmVfbmV3X2xpbmVzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdH1cblx0fSApO1xuXHRcblx0XG5cdFxuXHR2YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0XHRpZiAoIGQgIT09IDAgJiYgKCFkIHx8IGQgPT09ICctJykgKSB7XG5cdFx0XHRyZXR1cm4gLUluZmluaXR5O1xuXHRcdH1cblx0XG5cdFx0Ly8gSWYgYSBkZWNpbWFsIHBsYWNlIG90aGVyIHRoYW4gYC5gIGlzIHVzZWQsIGl0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZVxuXHRcdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHRcdC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cblx0XHRpZiAoIGRlY2ltYWxQbGFjZSApIHtcblx0XHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggZC5yZXBsYWNlICkge1xuXHRcdFx0aWYgKCByZTEgKSB7XG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMSwgJycgKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIHJlMiApIHtcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGQgKiAxO1xuXHR9O1xuXHRcblx0XG5cdC8vIEFkZCB0aGUgbnVtZXJpYyAnZGVmb3JtYXR0aW5nJyBmdW5jdGlvbnMgZm9yIHNvcnRpbmcgYW5kIHNlYXJjaC4gVGhpcyBpcyBkb25lXG5cdC8vIGluIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBhbiBlYXN5IGFiaWxpdHkgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb25zIHRvIGFkZFxuXHQvLyBhZGRpdGlvbmFsIG1ldGhvZHMgaWYgYSBub24tcGVyaW9kIGRlY2ltYWwgcGxhY2UgaXMgdXNlZC5cblx0ZnVuY3Rpb24gX2FkZE51bWVyaWNTb3J0ICggZGVjaW1hbFBsYWNlICkge1xuXHRcdCQuZWFjaChcblx0XHRcdHtcblx0XHRcdFx0Ly8gUGxhaW4gbnVtYmVyc1xuXHRcdFx0XHRcIm51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRlY2ltYWxQbGFjZSApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gRm9ybWF0dGVkIG51bWJlcnNcblx0XHRcdFx0XCJudW0tZm10XCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fSxcblx0XG5cdFx0XHRcdC8vIEhUTUwgbnVtZXJpY1xuXHRcdFx0XHRcImh0bWwtbnVtXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCApO1xuXHRcdFx0XHR9LFxuXHRcblx0XHRcdFx0Ly8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcblx0XHRcdFx0XCJodG1sLW51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uICgga2V5LCBmbiApIHtcblx0XHRcdFx0Ly8gQWRkIHRoZSBvcmRlcmluZyBtZXRob2Rcblx0XHRcdFx0X2V4dC50eXBlLm9yZGVyWyBrZXkrZGVjaW1hbFBsYWNlKyctcHJlJyBdID0gZm47XG5cdFxuXHRcdFx0XHQvLyBGb3IgSFRNTCB0eXBlcyBhZGQgYSBzZWFyY2ggZm9ybWF0dGVyIHRoYXQgd2lsbCBzdHJpcCB0aGUgSFRNTFxuXHRcdFx0XHRpZiAoIGtleS5tYXRjaCgvXmh0bWxcXC0vKSApIHtcblx0XHRcdFx0XHRfZXh0LnR5cGUuc2VhcmNoWyBrZXkrZGVjaW1hbFBsYWNlIF0gPSBfZXh0LnR5cGUuc2VhcmNoLmh0bWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cdFxuXHRcblx0Ly8gRGVmYXVsdCBzb3J0IG1ldGhvZHNcblx0JC5leHRlbmQoIF9leHQudHlwZS5vcmRlciwge1xuXHRcdC8vIERhdGVzXG5cdFx0XCJkYXRlLXByZVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHR2YXIgdHMgPSBEYXRlLnBhcnNlKCBkICk7XG5cdFx0XHRyZXR1cm4gaXNOYU4odHMpID8gLUluZmluaXR5IDogdHM7XG5cdFx0fSxcblx0XG5cdFx0Ly8gaHRtbFxuXHRcdFwiaHRtbC1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0YS5yZXBsYWNlID9cblx0XHRcdFx0XHRhLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICkudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0YSsnJztcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmdcblx0XHRcInN0cmluZy1wcmVcIjogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgZmFzdGVyIHRoYW4gYWx3YXlzIGNhbGxpbmcgdG9TdHJpbmcsXG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS90b3N0cmluZy12LWNoZWNrXG5cdFx0XHRyZXR1cm4gX2VtcHR5KGEpID9cblx0XHRcdFx0JycgOlxuXHRcdFx0XHR0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGEudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHRcdCcnIDpcblx0XHRcdFx0XHRcdGEudG9TdHJpbmcoKTtcblx0XHR9LFxuXHRcblx0XHQvLyBzdHJpbmctYXNjIGFuZCAtZGVzYyBhcmUgcmV0YWluZWQgb25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGRcblx0XHQvLyBzb3J0IG1ldGhvZHNcblx0XHRcInN0cmluZy1hc2NcIjogZnVuY3Rpb24gKCB4LCB5ICkge1xuXHRcdFx0cmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0fSxcblx0XG5cdFx0XCJzdHJpbmctZGVzY1wiOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cdFx0XHRyZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHR9XG5cdH0gKTtcblx0XG5cdFxuXHQvLyBOdW1lcmljIHNvcnRpbmcgdHlwZXMgLSBvcmRlciBkb2Vzbid0IG1hdHRlciBoZXJlXG5cdF9hZGROdW1lcmljU29ydCggJycgKTtcblx0XG5cdFxuXHQkLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRcdGhlYWRlcjoge1xuXHRcdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydCAtIG5vdGUgdGhhdCB1c2luZyB0aGVcblx0XHRcdFx0Ly8gYERUYCBuYW1lc3BhY2Ugd2lsbCBhbGxvdyB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHRcdC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcblx0XHRcdFx0Ly8gbGlzdGVuaW5nIGZvclxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRcdHJldHVybjsgICAgICAgICAgICAgICAvLyB0YWJsZSwgbm90IGEgbmVzdGVkIG9uZVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0dmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3MgKycgJytcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEFzYyArJyAnK1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzY1xuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnREZXNjIDpcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XG5cdFx0XHRqcXVlcnl1aTogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzICkge1xuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIgKVxuXHRcdFx0XHRcdC5hcHBlbmQoIGNlbGwuY29udGVudHMoKSApXG5cdFx0XHRcdFx0LmFwcGVuZCggJCgnPHNwYW4vPicpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRJY29uKycgJytjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSSApXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggY2VsbCApO1xuXHRcblx0XHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydFxuXHRcdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zICkge1xuXHRcdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXHRcblx0XHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzZXMuc1NvcnRBc2MgK1wiIFwiK2NsYXNzZXMuc1NvcnREZXNjIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFxuXHRcdFx0XHRcdGNlbGxcblx0XHRcdFx0XHRcdC5maW5kKCAnc3Bhbi4nK2NsYXNzZXMuc1NvcnRJY29uIClcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSSArXCIgXCIrXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkICtcIiBcIitcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2MgOlxuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzSlVJXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cdFxuXHQvKlxuXHQgKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxuXHQgKiBjYWxsZWQgYnkgYW55IG9mIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIERhdGFUYWJsZXMsIGJ1dCB0aGV5IGNhbiBiZSB1c2VkXG5cdCAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xuXHQgKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXG5cdCAqL1xuXHRcblx0dmFyIF9faHRtbEVzY2FwZUVudGl0aWVzID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdHJldHVybiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgP1xuXHRcdFx0ZFxuXHRcdFx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSA6XG5cdFx0XHRkO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEhlbHBlcnMgZm9yIGBjb2x1bW5zLnJlbmRlcmAuXG5cdCAqXG5cdCAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXG5cdCAqIG9wdGlvbiB0byBwcm92aWRlIGEgZGlzcGxheSByZW5kZXJlci4gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGRlZmluZWQ6XG5cdCAqXG5cdCAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxuXHQgKiAgIGRpc3BsYXksIHJldGFpbmluZyB0aGUgb3JpZ2luYWwgdW5mb3JtYXR0ZWQgZGF0YSBmb3Igc29ydGluZyBhbmQgZmlsdGVyaW5nLlxuXHQgKiAgIEl0IHRha2VzIDUgcGFyYW1ldGVyczpcblx0ICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxuXHQgKiAgICogYHN0cmluZ2AgLSBEZWNpbWFsIHBvaW50IGluZGljYXRvclxuXHQgKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcblx0ICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXG5cdCAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUG9zdGZpeCAoL3N1ZmZpeCkuXG5cdCAqICogYHRleHRgIC0gRXNjYXBlIEhUTUwgdG8gaGVscCBwcmV2ZW50IFhTUyBhdHRhY2tzLiBJdCBoYXMgbm8gb3B0aW9uYWxcblx0ICogICBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIENvbHVtbiBkZWZpbml0aW9uIHVzaW5nIHRoZSBudW1iZXIgcmVuZGVyZXJcblx0ICogICB7XG5cdCAqICAgICBkYXRhOiBcInNhbGFyeVwiLFxuXHQgKiAgICAgcmVuZGVyOiAkLmZuLmRhdGFUYWJsZS5yZW5kZXIubnVtYmVyKCAnXFwnJywgJy4nLCAwLCAnJCcgKVxuXHQgKiAgIH1cblx0ICpcblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0RGF0YVRhYmxlLnJlbmRlciA9IHtcblx0XHRudW1iZXI6IGZ1bmN0aW9uICggdGhvdXNhbmRzLCBkZWNpbWFsLCBwcmVjaXNpb24sIHByZWZpeCwgcG9zdGZpeCApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3BsYXk6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBkICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdHZhciBuZWdhdGl2ZSA9IGQgPCAwID8gJy0nIDogJyc7XG5cdFx0XHRcdFx0dmFyIGZsbyA9IHBhcnNlRmxvYXQoIGQgKTtcblx0XG5cdFx0XHRcdFx0Ly8gSWYgTmFOIHRoZW4gdGhlcmUgaXNuJ3QgbXVjaCBmb3JtYXR0aW5nIHRoYXQgd2UgY2FuIGRvIC0ganVzdFxuXHRcdFx0XHRcdC8vIHJldHVybiBpbW1lZGlhdGVseSwgZXNjYXBpbmcgYW55IEhUTUwgKHRoaXMgd2FzIHN1cHBvc2VkIHRvXG5cdFx0XHRcdFx0Ly8gYmUgYSBudW1iZXIgYWZ0ZXIgYWxsKVxuXHRcdFx0XHRcdGlmICggaXNOYU4oIGZsbyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9faHRtbEVzY2FwZUVudGl0aWVzKCBkICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRmbG8gPSBmbG8udG9GaXhlZCggcHJlY2lzaW9uICk7XG5cdFx0XHRcdFx0ZCA9IE1hdGguYWJzKCBmbG8gKTtcblx0XG5cdFx0XHRcdFx0dmFyIGludFBhcnQgPSBwYXJzZUludCggZCwgMTAgKTtcblx0XHRcdFx0XHR2YXIgZmxvYXRQYXJ0ID0gcHJlY2lzaW9uID9cblx0XHRcdFx0XHRcdGRlY2ltYWwrKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKCBwcmVjaXNpb24gKS5zdWJzdHJpbmcoIDIgKTpcblx0XHRcdFx0XHRcdCcnO1xuXHRcblx0XHRcdFx0XHRyZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4fHwnJykgK1xuXHRcdFx0XHRcdFx0aW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCB0aG91c2FuZHNcblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdFx0ZmxvYXRQYXJ0ICtcblx0XHRcdFx0XHRcdChwb3N0Zml4fHwnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0XG5cdFx0dGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGlzcGxheTogX19odG1sRXNjYXBlRW50aXRpZXMsXG5cdFx0XHRcdGZpbHRlcjogX19odG1sRXNjYXBlRW50aXRpZXNcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qXG5cdCAqIFRoaXMgaXMgcmVhbGx5IGEgZ29vZCBiaXQgcnViYmlzaCB0aGlzIG1ldGhvZCBvZiBleHBvc2luZyB0aGUgaW50ZXJuYWwgbWV0aG9kc1xuXHQgKiBwdWJsaWNseS4uLiAtIFRvIGJlIGZpeGVkIGluIDIuMCB1c2luZyBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGVcblx0ICovXG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGV4cG9ydGluZyBhbiBpbnRlcm5hbCBmdW5jdGlvbnMgdG8gYW4gZXh0ZXJuYWwgQVBJLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IGZuIEFQSSBmdW5jdGlvbiBuYW1lXG5cdCAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJvZiBEYXRhVGFibGUjaW50ZXJuYWxcblx0ICovXG5cdGZ1bmN0aW9uIF9mbkV4dGVybkFwaUZ1bmMgKGZuKVxuXHR7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBbX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0gKV0uY29uY2F0KFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIERhdGFUYWJsZS5leHQuaW50ZXJuYWxbZm5dLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0fTtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcblx0ICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXG5cdCAqIHByaXZhdGUuIElmIHlvdSB1c2UgdGhlc2UgbWV0aG9kcywgYmUgYXdhcmUgdGhhdCB0aGV5IGFyZSBsaWFibGUgdG8gY2hhbmdlXG5cdCAqIGJldHdlZW4gdmVyc2lvbnMuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqL1xuXHQkLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xuXHRcdF9mbkV4dGVybkFwaUZ1bmM6IF9mbkV4dGVybkFwaUZ1bmMsXG5cdFx0X2ZuQnVpbGRBamF4OiBfZm5CdWlsZEFqYXgsXG5cdFx0X2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcblx0XHRfZm5BamF4UGFyYW1ldGVyczogX2ZuQWpheFBhcmFtZXRlcnMsXG5cdFx0X2ZuQWpheFVwZGF0ZURyYXc6IF9mbkFqYXhVcGRhdGVEcmF3LFxuXHRcdF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcblx0XHRfZm5BZGRDb2x1bW46IF9mbkFkZENvbHVtbixcblx0XHRfZm5Db2x1bW5PcHRpb25zOiBfZm5Db2x1bW5PcHRpb25zLFxuXHRcdF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxuXHRcdF9mblZpc2libGVUb0NvbHVtbkluZGV4OiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsXG5cdFx0X2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcblx0XHRfZm5HZXRDb2x1bW5zOiBfZm5HZXRDb2x1bW5zLFxuXHRcdF9mbkNvbHVtblR5cGVzOiBfZm5Db2x1bW5UeXBlcyxcblx0XHRfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcblx0XHRfZm5IdW5nYXJpYW5NYXA6IF9mbkh1bmdhcmlhbk1hcCxcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuOiBfZm5DYW1lbFRvSHVuZ2FyaWFuLFxuXHRcdF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcblx0XHRfZm5Ccm93c2VyRGV0ZWN0OiBfZm5Ccm93c2VyRGV0ZWN0LFxuXHRcdF9mbkFkZERhdGE6IF9mbkFkZERhdGEsXG5cdFx0X2ZuQWRkVHI6IF9mbkFkZFRyLFxuXHRcdF9mbk5vZGVUb0RhdGFJbmRleDogX2ZuTm9kZVRvRGF0YUluZGV4LFxuXHRcdF9mbk5vZGVUb0NvbHVtbkluZGV4OiBfZm5Ob2RlVG9Db2x1bW5JbmRleCxcblx0XHRfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXG5cdFx0X2ZuU2V0Q2VsbERhdGE6IF9mblNldENlbGxEYXRhLFxuXHRcdF9mblNwbGl0T2JqTm90YXRpb246IF9mblNwbGl0T2JqTm90YXRpb24sXG5cdFx0X2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuU2V0T2JqZWN0RGF0YUZuOiBfZm5TZXRPYmplY3REYXRhRm4sXG5cdFx0X2ZuR2V0RGF0YU1hc3RlcjogX2ZuR2V0RGF0YU1hc3Rlcixcblx0XHRfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxuXHRcdF9mbkRlbGV0ZUluZGV4OiBfZm5EZWxldGVJbmRleCxcblx0XHRfZm5JbnZhbGlkYXRlOiBfZm5JbnZhbGlkYXRlLFxuXHRcdF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcblx0XHRfZm5DcmVhdGVUcjogX2ZuQ3JlYXRlVHIsXG5cdFx0X2ZuQnVpbGRIZWFkOiBfZm5CdWlsZEhlYWQsXG5cdFx0X2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxuXHRcdF9mbkRyYXc6IF9mbkRyYXcsXG5cdFx0X2ZuUmVEcmF3OiBfZm5SZURyYXcsXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxuXHRcdF9mbkRldGVjdEhlYWRlcjogX2ZuRGV0ZWN0SGVhZGVyLFxuXHRcdF9mbkdldFVuaXF1ZVRoczogX2ZuR2V0VW5pcXVlVGhzLFxuXHRcdF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcblx0XHRfZm5GaWx0ZXJDb21wbGV0ZTogX2ZuRmlsdGVyQ29tcGxldGUsXG5cdFx0X2ZuRmlsdGVyQ3VzdG9tOiBfZm5GaWx0ZXJDdXN0b20sXG5cdFx0X2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXG5cdFx0X2ZuRmlsdGVyOiBfZm5GaWx0ZXIsXG5cdFx0X2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsXG5cdFx0X2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxuXHRcdF9mbkZpbHRlckRhdGE6IF9mbkZpbHRlckRhdGEsXG5cdFx0X2ZuRmVhdHVyZUh0bWxJbmZvOiBfZm5GZWF0dXJlSHRtbEluZm8sXG5cdFx0X2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcblx0XHRfZm5JbmZvTWFjcm9zOiBfZm5JbmZvTWFjcm9zLFxuXHRcdF9mbkluaXRpYWxpc2U6IF9mbkluaXRpYWxpc2UsXG5cdFx0X2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXG5cdFx0X2ZuTGVuZ3RoQ2hhbmdlOiBfZm5MZW5ndGhDaGFuZ2UsXG5cdFx0X2ZuRmVhdHVyZUh0bWxMZW5ndGg6IF9mbkZlYXR1cmVIdG1sTGVuZ3RoLFxuXHRcdF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXG5cdFx0X2ZuUGFnZUNoYW5nZTogX2ZuUGFnZUNoYW5nZSxcblx0XHRfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXG5cdFx0X2ZuRmVhdHVyZUh0bWxUYWJsZTogX2ZuRmVhdHVyZUh0bWxUYWJsZSxcblx0XHRfZm5TY3JvbGxEcmF3OiBfZm5TY3JvbGxEcmF3LFxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxuXHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRoczogX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzLFxuXHRcdF9mblRocm90dGxlOiBfZm5UaHJvdHRsZSxcblx0XHRfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXG5cdFx0X2ZuR2V0V2lkZXN0Tm9kZTogX2ZuR2V0V2lkZXN0Tm9kZSxcblx0XHRfZm5HZXRNYXhMZW5TdHJpbmc6IF9mbkdldE1heExlblN0cmluZyxcblx0XHRfZm5TdHJpbmdUb0NzczogX2ZuU3RyaW5nVG9Dc3MsXG5cdFx0X2ZuU29ydEZsYXR0ZW46IF9mblNvcnRGbGF0dGVuLFxuXHRcdF9mblNvcnQ6IF9mblNvcnQsXG5cdFx0X2ZuU29ydEFyaWE6IF9mblNvcnRBcmlhLFxuXHRcdF9mblNvcnRMaXN0ZW5lcjogX2ZuU29ydExpc3RlbmVyLFxuXHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lcjogX2ZuU29ydEF0dGFjaExpc3RlbmVyLFxuXHRcdF9mblNvcnRpbmdDbGFzc2VzOiBfZm5Tb3J0aW5nQ2xhc3Nlcyxcblx0XHRfZm5Tb3J0RGF0YTogX2ZuU29ydERhdGEsXG5cdFx0X2ZuU2F2ZVN0YXRlOiBfZm5TYXZlU3RhdGUsXG5cdFx0X2ZuTG9hZFN0YXRlOiBfZm5Mb2FkU3RhdGUsXG5cdFx0X2ZuU2V0dGluZ3NGcm9tTm9kZTogX2ZuU2V0dGluZ3NGcm9tTm9kZSxcblx0XHRfZm5Mb2c6IF9mbkxvZyxcblx0XHRfZm5NYXA6IF9mbk1hcCxcblx0XHRfZm5CaW5kQWN0aW9uOiBfZm5CaW5kQWN0aW9uLFxuXHRcdF9mbkNhbGxiYWNrUmVnOiBfZm5DYWxsYmFja1JlZyxcblx0XHRfZm5DYWxsYmFja0ZpcmU6IF9mbkNhbGxiYWNrRmlyZSxcblx0XHRfZm5MZW5ndGhPdmVyZmxvdzogX2ZuTGVuZ3RoT3ZlcmZsb3csXG5cdFx0X2ZuUmVuZGVyZXI6IF9mblJlbmRlcmVyLFxuXHRcdF9mbkRhdGFTb3VyY2U6IF9mbkRhdGFTb3VyY2UsXG5cdFx0X2ZuUm93QXR0cmlidXRlczogX2ZuUm93QXR0cmlidXRlcyxcblx0XHRfZm5FeHRlbmQ6IF9mbkV4dGVuZCxcblx0XHRfZm5DYWxjdWxhdGVFbmQ6IGZ1bmN0aW9uICgpIHt9IC8vIFVzZWQgYnkgYSBsb3Qgb2YgcGx1Zy1pbnMsIGJ1dCByZWR1bmRhbnRcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIDEuMTAsIHNvIHRoaXMgZGVhZC1lbmQgZnVuY3Rpb24gaXNcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGVkIHRvIHByZXZlbnQgZXJyb3JzXG5cdH0gKTtcblx0XG5cblx0Ly8galF1ZXJ5IGFjY2Vzc1xuXHQkLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcblxuXHQvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG5cdERhdGFUYWJsZS4kID0gJDtcblxuXHQvLyBMZWdhY3kgYWxpYXNlc1xuXHQkLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHQkLmZuLmRhdGFUYWJsZUV4dCA9IERhdGFUYWJsZS5leHQ7XG5cblx0Ly8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcblx0Ly8galF1ZXJ5IG9iamVjdFxuXHQkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uICggb3B0cyApIHtcblx0XHRyZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUoIG9wdHMgKS5hcGkoKTtcblx0fTtcblxuXHQvLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcblx0Ly8gYXZhaWxhYmxlIG9uICQuZm4uRGF0YVRhYmxlXG5cdCQuZWFjaCggRGF0YVRhYmxlLCBmdW5jdGlvbiAoIHByb3AsIHZhbCApIHtcblx0XHQkLmZuLkRhdGFUYWJsZVsgcHJvcCBdID0gdmFsO1xuXHR9ICk7XG5cblxuXHQvLyBJbmZvcm1hdGlvbiBhYm91dCBldmVudHMgZmlyZWQgYnkgRGF0YVRhYmxlcyAtIGZvciBkb2N1bWVudGF0aW9uLlxuXHQvKipcblx0ICogRHJhdyBldmVudCwgZmlyZWQgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIHJlZHJhd24gb24gdGhlIHBhZ2UsIGF0IHRoZSBzYW1lXG5cdCAqIHBvaW50IGFzIGZuRHJhd0NhbGxiYWNrLiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIGJpbmRpbmcgZXZlbnRzIG9yXG5cdCAqIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zIHdoZW4gdGhlIHRhYmxlIGlzIGFsdGVyZWQgYXQgYWxsLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2RyYXcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHNlYXJjaGluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAodXNpbmcgdGhlXG5cdCAqIGJ1aWx0LWluIGdsb2JhbCBzZWFyY2gsIG9yIGNvbHVtbiBmaWx0ZXJzKSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3NlYXJjaC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFBhZ2UgY2hhbmdlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBwYWdpbmcgb2YgdGhlIHRhYmxlIGlzIGFsdGVyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjcGFnZS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIE9yZGVyIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBvcmRlcmluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI29yZGVyLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKi9cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiBjb21wbGV0ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgZnVsbHlcblx0ICogZHJhd24sIGluY2x1ZGluZyBBamF4IGRhdGEgbG9hZGVkLCBpZiBBamF4IGRhdGEgaXMgcmVxdWlyZWQuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjaW5pdC5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcblx0ICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkPC9saT48L29sPlxuXHQgKi9cblxuXHQvKipcblx0ICogU3RhdGUgc2F2ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZVxuXHQgKiBpcyByZXF1aXJlZC4gVGhpcyBldmVudCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0XG5cdCAqIHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Igb3RoZXIgc3RhdGVcblx0ICogcHJvcGVydGllcyAoZm9yIHBsdWctaW5zKSBvciBtb2RpZmljYXRpb24gb2YgYSBEYXRhVGFibGVzIGNvcmUgcHJvcGVydHkuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVTYXZlUGFyYW1zLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHN0YXRlIGluZm9ybWF0aW9uIHRvIGJlIHNhdmVkXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTdGF0ZSBsb2FkIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZFxuXHQgKiBkYXRhLCBidXQgcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGVcblx0ICogLSBhbGxvd2luZyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIGlzIHJlcXVpcmVkIG9yIGxvYWRpbmcgb2Zcblx0ICogc3RhdGUgZm9yIGEgcGx1Zy1pbi5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRQYXJhbXMuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIFN0YXRlIGxvYWRlZCBldmVudCwgZmlyZWQgd2hlbiBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSBzdG9yZWQgZGF0YSBhbmRcblx0ICogdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBieSB0aGUgbG9hZGVkIGRhdGEuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkZWQuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIFByb2Nlc3NpbmcgZXZlbnQsIGZpcmVkIHdoZW4gRGF0YVRhYmxlcyBpcyBkb2luZyBzb21lIGtpbmQgb2YgcHJvY2Vzc2luZ1xuXHQgKiAoYmUgaXQsIG9yZGVyLCBzZWFyY2ggb3IgYW55dGhpbmcgZWxzZSkuIEl0IGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRvXG5cdCAqIHRoZSBlbmQgdXNlciB0aGF0IHRoZXJlIGlzIHNvbWV0aGluZyBoYXBwZW5pbmcsIG9yIHRoYXQgc29tZXRoaW5nIGhhc1xuXHQgKiBmaW5pc2hlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNwcm9jZXNzaW5nLmR0XG5cdCAqICBAZXZlbnRcblx0ICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBiU2hvdyBGbGFnIGZvciBpZiBEYXRhVGFibGVzIGlzIGRvaW5nIHByb2Nlc3Npbmcgb3Igbm90XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBamF4IChYSFIpIGV2ZW50LCBmaXJlZCB3aGVuZXZlciBhbiBBamF4IHJlcXVlc3QgaXMgY29tcGxldGVkIGZyb20gYVxuXHQgKiByZXF1ZXN0IHRvIG1hZGUgdG8gdGhlIHNlcnZlciBmb3IgbmV3IGRhdGEuIFRoaXMgZXZlbnQgaXMgY2FsbGVkIGJlZm9yZVxuXHQgKiBEYXRhVGFibGVzIHByb2Nlc3NlZCB0aGUgcmV0dXJuZWQgZGF0YSwgc28gaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcmUtXG5cdCAqIHByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCBpZiBuZWVkZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHRyaWdnZXIgaXMgY2FsbGVkIGluIGBmblNlcnZlckRhdGFgLCBpZiB5b3Ugb3ZlcnJpZGVcblx0ICogYGZuU2VydmVyRGF0YWAgYW5kIHdoaWNoIHRvIHVzZSB0aGlzIGV2ZW50LCB5b3UgbmVlZCB0byB0cmlnZ2VyIGl0IGluIHlvdVxuXHQgKiBzdWNjZXNzIGZ1bmN0aW9uLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI3hoci5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAgLy8gVXNlIGEgY3VzdG9tIHByb3BlcnR5IHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiBhbm90aGVyIERPTSBlbGVtZW50XG5cdCAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XG5cdCAqICAgICAgICQoJyNzdGF0dXMnKS5odG1sKCBqc29uLnN0YXR1cyApO1xuXHQgKiAgICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgIC8vIFByZS1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuXHQgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuXHQgKiAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5hYURhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdCAqICAgICAgICAganNvbi5hYURhdGFbaV0uc3VtID0ganNvbi5hYURhdGFbaV0ub25lICsganNvbi5hYURhdGFbaV0udHdvO1xuXHQgKiAgICAgICB9XG5cdCAqICAgICAgIC8vIE5vdGUgbm8gcmV0dXJuIC0gbWFuaXB1bGF0ZSB0aGUgZGF0YSBkaXJlY3RseSBpbiB0aGUgSlNPTiBvYmplY3QuXG5cdCAqICAgICB9ICk7XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBEYXRhVGFibGUgaXMgZGVzdHJveWVkIGJ5IGNhbGxpbmcgZm5EZXN0cm95XG5cdCAqIG9yIHBhc3NpbmcgdGhlIGJEZXN0cm95OnRydWUgcGFyYW1ldGVyIGluIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QuIFRoaXNcblx0ICogY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGJvdW5kIGV2ZW50cywgYWRkZWQgRE9NIG5vZGVzLCBldGMuXG5cdCAqICBAbmFtZSBEYXRhVGFibGUjZGVzdHJveS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICovXG5cblx0LyoqXG5cdCAqIFBhZ2UgbGVuZ3RoIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiBudW1iZXIgb2YgcmVjb3JkcyB0byBzaG93IG9uIGVhY2hcblx0ICogcGFnZSAodGhlIGxlbmd0aCkgaXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNsZW5ndGguZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqICBAcGFyYW0ge2ludGVnZXJ9IGxlbiBOZXcgbGVuZ3RoXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb2x1bW4gc2l6aW5nIGhhcyBjaGFuZ2VkLlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi1zaXppbmcuZHRcblx0ICogIEBldmVudFxuXHQgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb2x1bW4gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZC5cblx0ICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tdmlzaWJpbGl0eS5kdFxuXHQgKiAgQGV2ZW50XG5cdCAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogIEBwYXJhbSB7aW50fSBjb2x1bW4gQ29sdW1uIGluZGV4XG5cdCAqICBAcGFyYW0ge2Jvb2x9IHZpcyBgZmFsc2VgIGlmIGNvbHVtbiBub3cgaGlkZGVuLCBvciBgdHJ1ZWAgaWYgdmlzaWJsZVxuXHQgKi9cblxuXHRyZXR1cm4gJC5mbi5kYXRhVGFibGU7XG59KSk7XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgZHQgZnJvbSAnZGF0YXRhYmxlcy5uZXQnO1xyXG5cclxuJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IHRhYmxlQ29sdW1ucyA9IFsnbmFtZScsICdyYWNlJywgJ2NsYXNzJywgJ3JvbGUnLCAnbGV2ZWwnLCAncmFuayddO1xyXG5cclxuICAgICQoJy53b3dwaS1yb3N0ZXInKS5lYWNoKCBmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgdGFibGVSYW5rcyA9ICQodGhpcykuZGF0YSgncmFua3MnKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh0YWJsZVJhbmtzKTtcclxuICAgICAgICBsZXQgZGF0YVRhYmxlT3B0cyA9IHtcclxuICAgICAgICAgICAgXCJwcm9jZXNzaW5nXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImFqYXhcIjogd293cGlSb3N0ZXJBamF4LmFqYXh1cmwsXHJcbiAgICAgICAgICAgIFwicGFnaW5nXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwicGFnZUxlbmd0aFwiOiBwYXJzZUludChyb3dzKSxcclxuICAgICAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICduYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICAnc29ydGFibGUnOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICdyYWNlJyxcclxuICAgICAgICAgICAgICAgICAgICAncmVuZGVyJzogZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJpY29uXCI+PGltZyBzcmM9XCIvd3AtY29udGVudC9wbHVnaW5zL3dvd3BpLWd1aWxkL2Fzc2V0cy9pY29uLycgKyBkYXRhLmljb24gKyAnXCIgYWx0PVwiJyArIGRhdGEubmFtZSArICdcIiAvPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAnc29ydGFibGUnOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAnY2xhc3MnLFxyXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXInOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImljb25cIj48aW1nIHNyYz1cIi93cC1jb250ZW50L3BsdWdpbnMvd293cGktZ3VpbGQvYXNzZXRzL2ljb24vJyArIGRhdGEuaWNvbiArICdcIiBhbHQ9XCInICsgZGF0YS5uYW1lICsgJ1wiIC8+PC9kaXY+JztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICdzb3J0YWJsZSc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICdyb2xlJyxcclxuICAgICAgICAgICAgICAgICAgICAncmVuZGVyJzogZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJpY29uXCI+PGltZyBzcmM9XCIvd3AtY29udGVudC9wbHVnaW5zL3dvd3BpLWd1aWxkL2Fzc2V0cy9pY29uL3JvbGVfJyArIGRhdGEudHlwZSArICcucG5nXCIgYWx0PVwiJyArIGRhdGEubmFtZSArICdcIiAvPjwvZGl2Pic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAnc29ydGFibGUnOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAnbGV2ZWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICdzb3J0YWJsZSc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogJ3JhbmsnLFxyXG4gICAgICAgICAgICAgICAgICAgICdzb3J0YWJsZSc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgJ3NlYXJjaENvbHMnIDogW1xyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICB7IFwic2VhcmNoXCI6IHRhYmxlUmFua3N9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByb3dzID0gJCh0aGlzKS5kYXRhKCdsZW5ndGgnKTtcclxuICAgICAgICBkYXRhVGFibGVPcHRzLnBhZ2VMZW5ndGggPSBwYXJzZUludChyb3dzKTtcclxuXHJcbiAgICAgICAgbGV0IG9yZGVyaW5nID0gW107XHJcbiAgICAgICAgbGV0IG9yZGVyQnkgPSAkKHRoaXMpLmRhdGEoJ29yZGVyYnknKTtcclxuICAgICAgICBsZXQgb3JkZXJCeUNvbHMgPSBvcmRlckJ5LnNwbGl0KCd8Jyk7XHJcblxyXG4gICAgICAgIGZvciggbGV0IGk9MDsgaTwgb3JkZXJCeUNvbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG9yZGVyQnlDb2xPcmRlcmluZyA9IG9yZGVyQnlDb2xzW2ldLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSB0YWJsZUNvbHVtbnMuaW5kZXhPZihvcmRlckJ5Q29sT3JkZXJpbmdbMF0pO1xyXG4gICAgICAgICAgICBsZXQgb3JkZXIgPSBvcmRlckJ5Q29sT3JkZXJpbmdbMV0gfHwgJ2FzYyc7XHJcbiAgICAgICAgICAgIGxldCBuZXdPcmRlcmluZyA9IFtjb2wsIG9yZGVyXTtcclxuICAgICAgICAgICAgb3JkZXJpbmcucHVzaChuZXdPcmRlcmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCBvcmRlcmluZy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICBkYXRhVGFibGVPcHRzLm9yZGVyID0gb3JkZXJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIGwgLSBsZW5ndGggY2hhbmdpbmcgaW5wdXQgY29udHJvbFxyXG4gICAgICAgIGYgLSBmaWx0ZXJpbmcgaW5wdXRcclxuICAgICAgICB0IC0gVGhlIHRhYmxlXHJcbiAgICAgICAgaSAtIFRhYmxlIGluZm9ybWF0aW9uIHN1bW1hcnlcclxuICAgICAgICBwIC0gcGFnaW5hdGlvbiBjb250cm9sXHJcbiAgICAgICAgciAtIHByb2Nlc3NpbmcgZGlzcGxheSBlbGVtZW50XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgbGV0IGRvbSA9ICcnO1xyXG5cclxuICAgICAgICBsZXQgc2hvd1NlbGVjdFBhZ2VMZW5ndGggPSBwYXJzZUludCgkKHRoaXMpLmRhdGEoJ3Nob3dzZWxlY3RsZW5ndGgnKSk7XHJcbiAgICAgICAgaWYoMSA9PT0gc2hvd1NlbGVjdFBhZ2VMZW5ndGgpIHtcclxuICAgICAgICAgICAgZG9tICs9ICdsJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzaG93U2VhcmNoID0gcGFyc2VJbnQoJCh0aGlzKS5kYXRhKCdzaG93c2VhcmNoJykpO1xyXG4gICAgICAgIGlmKDEgPT09IHNob3dTZWFyY2gpIHtcclxuICAgICAgICAgICAgZG9tICs9ICdmJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvbSArPSAncnRpcCc7XHJcblxyXG4gICAgICAgIGRhdGFUYWJsZU9wdHMuZG9tID0gZG9tO1xyXG5cclxuXHJcblxyXG4gICAgICAgICQodGhpcykuRGF0YVRhYmxlKCBkYXRhVGFibGVPcHRzICk7XHJcbiAgICB9KVxyXG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IGpRdWVyeTsiXSwic291cmNlUm9vdCI6IiJ9